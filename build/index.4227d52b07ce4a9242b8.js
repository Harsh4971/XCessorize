(()=>{var __webpack_modules__={786:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{$v:()=>I0,Vr:()=>SV,c9:()=>Sx,cK:()=>Sw,cX:()=>Sp,nj:()=>I2,qo:()=>Sa,rw:()=>I1,sf:()=>SM});function o(m,d){return d.forEach(function(p){p&&typeof p!="string"&&!Array.isArray(p)&&Object.keys(p).forEach(function(_){if(_!=="default"&&!(_ in m)){var E=Object.getOwnPropertyDescriptor(p,_);Object.defineProperty(m,_,E.get?E:{enumerable:!0,get:function(){return p[_]}})}})}),Object.freeze(m)}const G=1e-7,s=1e-4;class z{constructor(d,p){this.backend=d,this.dataMover=p,this.data=new WeakMap,this.dataIdsCount=0}get(d){return this.data.has(d)||this.dataMover.moveData(this.backend,d),this.data.get(d)}set(d,p){this.dataIdsCount++,this.data.set(d,p)}has(d){return this.data.has(d)}delete(d){return this.dataIdsCount--,this.data.delete(d)}numDataIds(){return this.dataIdsCount}}class C{refCount(d){return L("refCount")}incRef(d){return L("incRef")}timerAvailable(){return!0}time(d){return L("time")}read(d){return L("read")}readSync(d){return L("readSync")}readToGPU(d,p){return L("readToGPU")}numDataIds(){return L("numDataIds")}disposeData(d,p){return L("disposeData")}write(d,p,_){return L("write")}move(d,p,_,E,S){return L("move")}createTensorFromGPUData(d,p,_){return L("createTensorFromGPUData")}memory(){return L("memory")}floatPrecision(){return L("floatPrecision")}epsilon(){return this.floatPrecision()===32?G:s}dispose(){return L("dispose")}}function L(m){throw new Error("'"+m+"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen")}function K(m,d,p){return Math.max(m,Math.min(d,p))}function T(m){return m%2===0?m:m+1}function q(m,d,p){const _=m[d];m[d]=m[p],m[p]=_}function Q(m){let d=0;for(let p=0;p<m.length;p++)d+=m[p];return d}function A(m,d){if(!m)throw new Error(typeof d=="string"?d:d())}function N(m,d,p=""){A(i(m,d),()=>p+(" Shapes "+m+" and "+d+" must match"))}function O(m){A(m!=null,()=>"The input to the tensor constructor must be a non-null value.")}function n(m){if(m.length===0)return 1;let d=m[0];for(let p=1;p<m.length;p++)d*=m[p];return d}function i(m,d){if(m===d)return!0;if(m==null||d==null||m.length!==d.length)return!1;for(let p=0;p<m.length;p++)if(m[p]!==d[p])return!1;return!0}function e(m){return m%1===0}function P(m){const d=Math.ceil(Math.sqrt(m));return[d,Math.ceil(m/d)]}function j(m,d){return d<=m.length?m:m+" ".repeat(d-m.length)}function R(m,d=E=>0,p,_){return new Promise((E,S)=>{let I=0;const D=()=>{if(m()){E();return}I++;const k=d(I);if(p!=null&&I>=p){S();return}_!=null?_(D,k):setTimeout(D,k)};D()})}function H(m,d){let p=1,_=-1;for(let S=0;S<m.length;++S)if(m[S]>=0)p*=m[S];else if(m[S]===-1){if(_!==-1)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+_+" and dim "+S);_=S}else if(m[S]<0)throw Error("Shapes can not be < 0. Found "+m[S]+" at dim "+S);if(_===-1){if(d>0&&d!==p)throw Error("Size("+d+") must match the product of shape "+m);return m}if(p===0)throw Error("Cannot infer the missing size in ["+m+"] when there are 0 elements");if(d%p!==0)throw Error("The implicit shape can't be a fractional number. Got "+d+" / "+p);const E=m.slice();return E[_]=d/p,E}function X(m,d){const p=d.length;return m=m==null?d.map((_,E)=>E):[].concat(m),A(m.every(_=>_>=-p&&_<p),()=>"All values in axis param must be in range [-"+p+", "+p+") but got axis "+m),A(m.every(_=>e(_)),()=>"All values in axis param must be integers but got axis "+m),m.map(_=>_<0?p+_:_)}function f(m,d){const p=[],_=[],E=d!=null&&Array.isArray(d)&&d.length===0,S=d==null||E?null:X(d,m).sort();let I=0;for(let D=0;D<m.length;++D){if(S!=null){if(S[I]===D&&m[D]!==1)throw new Error("Can't squeeze axis "+D+" since its dim '"+m[D]+"' is not 1");(S[I]==null||S[I]>D)&&m[D]===1&&(p.push(m[D]),_.push(D)),S[I]<=D&&I++}m[D]!==1&&(p.push(m[D]),_.push(D))}return{newShape:p,keptDims:_}}function M(m,d){return U(m,d)}function U(m,d){let p=null;if(m==null||m==="float32")p=new Float32Array(d);else if(m==="int32")p=new Int32Array(d);else if(m==="bool")p=new Uint8Array(d);else if(m==="string")p=new Array(d);else throw new Error("Unknown data type "+m);return p}function J(m,d){for(let p=0;p<m.length;p++){const _=m[p];if(isNaN(_)||!isFinite(_))throw Error("A tensor of type "+d+" being uploaded contains "+_+".")}}function t(m){return m==="bool"||m==="complex64"||m==="float32"||m==="int32"||m==="string"}function h(m,d){return!(d==="complex64"||d==="float32"&&m!=="complex64"||d==="int32"&&m!=="float32"&&m!=="complex64"||d==="bool"&&m==="bool")}function Y(m){if(m==="float32"||m==="int32")return 4;if(m==="complex64")return 8;if(m==="bool")return 1;throw new Error("Unknown dtype "+m)}function l(m){if(m==null)return 0;let d=0;return m.forEach(p=>d+=p.length),d}function o0(m){return typeof m=="string"||m instanceof String}function o1(m){return typeof m=="boolean"}function o2(m){return typeof m=="number"}function o3(m){return Array.isArray(m)?o3(m[0]):m instanceof Float32Array?"float32":m instanceof Int32Array||m instanceof Uint8Array||m instanceof Uint8ClampedArray?"int32":o2(m)?"float32":o0(m)?"string":o1(m)?"bool":"float32"}function o4(m){return!!(m&&m.constructor&&m.call&&m.apply)}function o5(m,d){for(let p=d;p<m;++p)if(m%p===0)return p;return m}function o6(m){const d=m.length;if(d<2)return[];const p=new Array(d-1);p[d-2]=m[d-1];for(let _=d-3;_>=0;--_)p[_]=p[_+1]*m[_+1];return p}function o7(m,d,p,_=!1){const E=new Array;if(d.length===1){const S=d[0]*(_?2:1);for(let I=0;I<S;I++)E[I]=p[m+I]}else{const S=d[0],I=d.slice(1),D=I.reduce((k,V)=>k*V)*(_?2:1);for(let k=0;k<S;k++)E[k]=o7(m+k*D,I,p,_)}return E}function o8(m,d,p=!1){if(m.length===0)return d[0];const _=m.reduce((E,S)=>E*S)*(p?2:1);if(_===0)return[];if(_!==d.length)throw new Error("["+m+"] does not match the input size "+d.length+(p?" for a complex tensor":"")+".");return o7(0,m,d,p)}function o9(m,d){if(Array.isArray(m))return m;if(d==="float32")return m instanceof Float32Array?m:new Float32Array(m);if(d==="int32")return m instanceof Int32Array?m:new Int32Array(m);if(d==="bool"||d==="string")return Uint8Array.from(new Int32Array(m));throw new Error("Unknown dtype "+d)}function oo(m,d){const p=oc(m,d);for(let _=0;_<p.length;_++)p[_]=1;return p}function oc(m,d){if(d==null||d==="float32"||d==="complex64")return new Float32Array(m);if(d==="int32")return new Int32Array(m);if(d==="bool")return new Uint8Array(m);throw new Error("Unknown data type "+d)}function oG(m){m.forEach(d=>{A(Number.isInteger(d)&&d>=0,()=>"Tensor must have a shape comprised of positive integers but got shape ["+m+"].")})}function os(m,d,p){if(d===0)return 0;if(d===1)return m[0];let _=m[m.length-1];for(let E=0;E<m.length-1;++E)_+=p[E]*m[E];return _}function oz(m,d,p){if(d===0)return[];if(d===1)return[m];const _=new Array(d);for(let E=0;E<_.length-1;++E)_[E]=Math.floor(m/p[E]),m-=_[E]*p[E];return _[_.length-1]=m,_}function oC(m){return m&&m.then&&typeof m.then=="function"}const oL="tfjsflags";class oK{constructor(d){this.global=d,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=or,this.populateURLFlags()}setPlatform(d,p){this.platform!=null&&(oQ().getBool("IS_TEST")||oQ().getBool("PROD")||console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+d+".")),this.platformName=d,this.platform=p}registerFlag(d,p,_){if(this.flagRegistry[d]={evaluationFn:p,setHook:_},this.urlFlags[d]!=null){const E=this.urlFlags[d];oQ().getBool("IS_TEST")||oQ().getBool("PROD")||console.warn("Setting feature override from URL "+d+": "+E+"."),this.set(d,E)}}async getAsync(d){return d in this.flags?this.flags[d]:(this.flags[d]=await this.evaluateFlag(d),this.flags[d])}get(d){if(d in this.flags)return this.flags[d];const p=this.evaluateFlag(d);if(oC(p))throw new Error("Flag "+d+" cannot be synchronously evaluated. Please use getAsync() instead.");return this.flags[d]=p,this.flags[d]}getNumber(d){return this.get(d)}getBool(d){return this.get(d)}getString(d){return this.get(d)}getFlags(){return this.flags}get features(){return this.flags}set(d,p){if(this.flagRegistry[d]==null)throw new Error("Cannot set flag "+d+" as it has not been registered.");this.flags[d]=p,this.flagRegistry[d].setHook!=null&&this.flagRegistry[d].setHook(p)}evaluateFlag(d){if(this.flagRegistry[d]==null)throw new Error("Cannot evaluate flag '"+d+"': no evaluation function found.");return this.flagRegistry[d].evaluationFn()}setFlags(d){this.flags=Object.assign({},d)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const d=this.getQueryParams(this.global.location.search);oL in d&&d[oL].split(",").forEach(p=>{const[_,E]=p.split(":");this.urlFlags[_]=oq(_,E)})}}function or(m){const d={};return m.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(p,..._)=>(oT(d,_[0],_[1]),_.join("="))),d}function oT(m,d,p){m[decodeURIComponent(d)]=decodeURIComponent(p||"")}function oq(m,d){const p=d.toLowerCase();return p==="true"||p==="false"?p==="true":""+ +p===p?+p:d}function oQ(){return ok}let ok=null;function ow(m){ok=m}let oA;function oZ(){if(oA==null){let m;if(typeof window<"u")m=window;else if(typeof __webpack_require__.g<"u")m=__webpack_require__.g;else if(typeof process<"u")m=process;else if(typeof self<"u")m=self;else throw new Error("Could not find a global object");oA=m}return oA}function oF(){const m=oZ();return m._tfGlobals==null&&(m._tfGlobals=new Map),m._tfGlobals}function oN(m,d){const p=oF();if(p.has(m))return p.get(m);{const _=d();return p.set(m,_),p.get(m)}}const oO="Abs",oD="Add",on="AddN",oi="Atan2",oe="AvgPool",oP="BatchMatMul",oS="BatchToSpaceND",oI="Bincount",oB="Cast",oj="ClipByValue",oR="Complex",oH="ComplexAbs",ou="Concat",oX="Conv2D",of="Conv2DBackpropFilter",oy="Conv2DBackpropInput",oE="Cos",oW="CropAndResize",od="DepthToSpace",oM="DepthwiseConv2dNative",oU="DepthwiseConv2dNativeBackpropFilter",oJ="DepthwiseConv2dNativeBackpropInput",ot="RealDiv",ov="Einsum",oh="Elu",oY="ExpandDims",om="Fill",ox="FlipLeftRight",ol="Floor",ob="FloorDiv",oa="GatherV2",oV="Greater",og="GreaterEqual",c0="Identity",c1="Imag",c2="LeakyRelu",c3="Less",c4="LessEqual",c5="LogicalAnd",c6="LogicalOr",c7="Max",c8="Maximum",c9="MaxPool",co="Mean",cc="Min",cG="Minimum",cs="Multiply",cz="Neg",cC="NonMaxSuppressionV3",cL="NonMaxSuppressionV4",cK="NonMaxSuppressionV5",cr="Pack",cT="PadV2",cq="Pow",cQ="Prelu",ck="Range",cp="Real",cw="Relu",cA="Reshape",cZ="ResizeNearestNeighbor",cF="ResizeBilinear",cN="Relu6",cO="Round",cD="TensorScatterUpdate",cn="Select",ci="Slice",ce="Sin",cP="Sigmoid",cS="Sqrt",cI="Sum",cB="SpaceToBatchND",cj="SplitV",cR="Square",cH="StridedSlice",cu="Sub",cX="Tile",cf="Transform",cy="Transpose",cE="Unpack",cW="ZerosLike",cd="Step",cM="FromPixels",cU="RotateWithOffset",cJ="_FusedMatMul",ct="FusedConv2D",cv="FusedDepthwiseConv2D";function ch(...m){oQ().getBool("IS_TEST")||oQ().getBool("PROD")||console.warn(...m)}function cY(...m){oQ().getBool("IS_TEST")||oQ().getBool("PROD")||console.log(...m)}const cm=oN("kernelRegistry",()=>new Map),cx=oN("gradRegistry",()=>new Map);function cl(m,d){const p=cg(m,d);return cm.get(p)}function cb(m){return cx.get(m)}function ca(m){const d=cm.entries(),p=[];for(;;){const{done:_,value:E}=d.next();if(_)break;const[S,I]=E,[D]=S.split("_");D===m&&p.push(I)}return p}function cV(m){const{kernelName:d,backendName:p}=m,_=cg(d,p);cm.has(_)&&ch("The kernel '"+d+"' for backend '"+p+"' is already registered"),cm.set(_,m)}function cg(m,d){return d+"_"+m}function G0(m){return m instanceof Float32Array||m instanceof Int32Array||m instanceof Uint8Array||m instanceof Uint8ClampedArray}var G1=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof __webpack_require__.g<"u"?__webpack_require__.g:typeof self<"u"?self:{};function G2(m){return m&&m.__esModule&&Object.prototype.hasOwnProperty.call(m,"default")?m.default:m}var G3=G5,G4=null;try{G4=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(m){}function G5(m,d,p){this.low=m|0,this.high=d|0,this.unsigned=!!p}G5.prototype.__isLong__,Object.defineProperty(G5.prototype,"__isLong__",{value:!0});function G6(m){return(m&&m.__isLong__)===!0}G5.isLong=G6;var G7={},G8={};function G9(m,d){var p,_,E;return d?(m>>>=0,(E=0<=m&&m<256)&&(_=G8[m],_)?_:(p=Gc(m,(m|0)<0?-1:0,!0),E&&(G8[m]=p),p)):(m|=0,(E=-128<=m&&m<128)&&(_=G7[m],_)?_:(p=Gc(m,m<0?-1:0,!1),E&&(G7[m]=p),p))}G5.fromInt=G9;function Go(m,d){if(isNaN(m))return d?Gk:GQ;if(d){if(m<0)return Gk;if(m>=Gr)return GF}else{if(m<=-GT)return GN;if(m+1>=GT)return GZ}return m<0?Go(-m,d).neg():Gc(m%GK|0,m/GK|0,d)}G5.fromNumber=Go;function Gc(m,d,p){return new G5(m,d,p)}G5.fromBits=Gc;var GG=Math.pow;function Gs(m,d,p){if(m.length===0)throw Error("empty string");if(m==="NaN"||m==="Infinity"||m==="+Infinity"||m==="-Infinity")return GQ;if(typeof d=="number"?(p=d,d=!1):d=!!d,p=p||10,p<2||36<p)throw RangeError("radix");var _;if((_=m.indexOf("-"))>0)throw Error("interior hyphen");if(_===0)return Gs(m.substring(1),d,p).neg();for(var E=Go(GG(p,8)),S=GQ,I=0;I<m.length;I+=8){var D=Math.min(8,m.length-I),k=parseInt(m.substring(I,I+D),p);if(D<8){var V=Go(GG(p,D));S=S.mul(V).add(Go(k))}else S=S.mul(E),S=S.add(Go(k))}return S.unsigned=d,S}G5.fromString=Gs;function Gz(m,d){return typeof m=="number"?Go(m,d):typeof m=="string"?Gs(m,d):Gc(m.low,m.high,typeof d=="boolean"?d:m.unsigned)}G5.fromValue=Gz;var GC=65536,GL=1<<24,GK=GC*GC,Gr=GK*GK,GT=Gr/2,Gq=G9(GL),GQ=G9(0);G5.ZERO=GQ;var Gk=G9(0,!0);G5.UZERO=Gk;var Gp=G9(1);G5.ONE=Gp;var Gw=G9(1,!0);G5.UONE=Gw;var GA=G9(-1);G5.NEG_ONE=GA;var GZ=Gc(-1,2147483647,!1);G5.MAX_VALUE=GZ;var GF=Gc(-1,-1,!0);G5.MAX_UNSIGNED_VALUE=GF;var GN=Gc(0,-2147483648,!1);G5.MIN_VALUE=GN;var GO=G5.prototype;GO.toInt=function(){return this.unsigned?this.low>>>0:this.low},GO.toNumber=function(){return this.unsigned?(this.high>>>0)*GK+(this.low>>>0):this.high*GK+(this.low>>>0)},GO.toString=function(m){if(m=m||10,m<2||36<m)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(GN)){var d=Go(m),p=this.div(d),_=p.mul(d).sub(this);return p.toString(m)+_.toInt().toString(m)}else return"-"+this.neg().toString(m);for(var E=Go(GG(m,6),this.unsigned),S=this,I="";;){var D=S.div(E),k=S.sub(D.mul(E)).toInt()>>>0,V=k.toString(m);if(S=D,S.isZero())return V+I;for(;V.length<6;)V="0"+V;I=""+V+I}},GO.getHighBits=function(){return this.high},GO.getHighBitsUnsigned=function(){return this.high>>>0},GO.getLowBits=function(){return this.low},GO.getLowBitsUnsigned=function(){return this.low>>>0},GO.getNumBitsAbs=function(){if(this.isNegative())return this.eq(GN)?64:this.neg().getNumBitsAbs();for(var m=this.high!=0?this.high:this.low,d=31;d>0&&!(m&1<<d);d--);return this.high!=0?d+33:d+1},GO.isZero=function(){return this.high===0&&this.low===0},GO.eqz=GO.isZero,GO.isNegative=function(){return!this.unsigned&&this.high<0},GO.isPositive=function(){return this.unsigned||this.high>=0},GO.isOdd=function(){return(this.low&1)===1},GO.isEven=function(){return(this.low&1)===0},GO.equals=function(m){return G6(m)||(m=Gz(m)),this.unsigned!==m.unsigned&&this.high>>>31===1&&m.high>>>31===1?!1:this.high===m.high&&this.low===m.low},GO.eq=GO.equals,GO.notEquals=function(m){return!this.eq(m)},GO.neq=GO.notEquals,GO.ne=GO.notEquals,GO.lessThan=function(m){return this.comp(m)<0},GO.lt=GO.lessThan,GO.lessThanOrEqual=function(m){return this.comp(m)<=0},GO.lte=GO.lessThanOrEqual,GO.le=GO.lessThanOrEqual,GO.greaterThan=function(m){return this.comp(m)>0},GO.gt=GO.greaterThan,GO.greaterThanOrEqual=function(m){return this.comp(m)>=0},GO.gte=GO.greaterThanOrEqual,GO.ge=GO.greaterThanOrEqual,GO.compare=function(m){if(G6(m)||(m=Gz(m)),this.eq(m))return 0;var d=this.isNegative(),p=m.isNegative();return d&&!p?-1:!d&&p?1:this.unsigned?m.high>>>0>this.high>>>0||m.high===this.high&&m.low>>>0>this.low>>>0?-1:1:this.sub(m).isNegative()?-1:1},GO.comp=GO.compare,GO.negate=function(){return!this.unsigned&&this.eq(GN)?GN:this.not().add(Gp)},GO.neg=GO.negate,GO.add=function(m){G6(m)||(m=Gz(m));var d=this.high>>>16,p=this.high&65535,_=this.low>>>16,E=this.low&65535,S=m.high>>>16,I=m.high&65535,D=m.low>>>16,k=m.low&65535,V=0,$=0,Z=0,te=0;return te+=E+k,Z+=te>>>16,te&=65535,Z+=_+D,$+=Z>>>16,Z&=65535,$+=p+I,V+=$>>>16,$&=65535,V+=d+S,V&=65535,Gc(Z<<16|te,V<<16|$,this.unsigned)},GO.subtract=function(m){return G6(m)||(m=Gz(m)),this.add(m.neg())},GO.sub=GO.subtract,GO.multiply=function(m){if(this.isZero())return GQ;if(G6(m)||(m=Gz(m)),G4){var d=G4.mul(this.low,this.high,m.low,m.high);return Gc(d,G4.get_high(),this.unsigned)}if(m.isZero())return GQ;if(this.eq(GN))return m.isOdd()?GN:GQ;if(m.eq(GN))return this.isOdd()?GN:GQ;if(this.isNegative())return m.isNegative()?this.neg().mul(m.neg()):this.neg().mul(m).neg();if(m.isNegative())return this.mul(m.neg()).neg();if(this.lt(Gq)&&m.lt(Gq))return Go(this.toNumber()*m.toNumber(),this.unsigned);var p=this.high>>>16,_=this.high&65535,E=this.low>>>16,S=this.low&65535,I=m.high>>>16,D=m.high&65535,k=m.low>>>16,V=m.low&65535,$=0,Z=0,te=0,xe=0;return xe+=S*V,te+=xe>>>16,xe&=65535,te+=E*V,Z+=te>>>16,te&=65535,te+=S*k,Z+=te>>>16,te&=65535,Z+=_*V,$+=Z>>>16,Z&=65535,Z+=E*k,$+=Z>>>16,Z&=65535,Z+=S*D,$+=Z>>>16,Z&=65535,$+=p*V+_*k+E*D+S*I,$&=65535,Gc(te<<16|xe,$<<16|Z,this.unsigned)},GO.mul=GO.multiply,GO.divide=function(m){if(G6(m)||(m=Gz(m)),m.isZero())throw Error("division by zero");if(G4){if(!this.unsigned&&this.high===-2147483648&&m.low===-1&&m.high===-1)return this;var d=(this.unsigned?G4.div_u:G4.div_s)(this.low,this.high,m.low,m.high);return Gc(d,G4.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Gk:GQ;var p,_,E;if(this.unsigned){if(m.unsigned||(m=m.toUnsigned()),m.gt(this))return Gk;if(m.gt(this.shru(1)))return Gw;E=Gk}else{if(this.eq(GN)){if(m.eq(Gp)||m.eq(GA))return GN;if(m.eq(GN))return Gp;var S=this.shr(1);return p=S.div(m).shl(1),p.eq(GQ)?m.isNegative()?Gp:GA:(_=this.sub(m.mul(p)),E=p.add(_.div(m)),E)}else if(m.eq(GN))return this.unsigned?Gk:GQ;if(this.isNegative())return m.isNegative()?this.neg().div(m.neg()):this.neg().div(m).neg();if(m.isNegative())return this.div(m.neg()).neg();E=GQ}for(_=this;_.gte(m);){p=Math.max(1,Math.floor(_.toNumber()/m.toNumber()));for(var I=Math.ceil(Math.log(p)/Math.LN2),D=I<=48?1:GG(2,I-48),k=Go(p),V=k.mul(m);V.isNegative()||V.gt(_);)p-=D,k=Go(p,this.unsigned),V=k.mul(m);k.isZero()&&(k=Gp),E=E.add(k),_=_.sub(V)}return E},GO.div=GO.divide,GO.modulo=function(m){if(G6(m)||(m=Gz(m)),G4){var d=(this.unsigned?G4.rem_u:G4.rem_s)(this.low,this.high,m.low,m.high);return Gc(d,G4.get_high(),this.unsigned)}return this.sub(this.div(m).mul(m))},GO.mod=GO.modulo,GO.rem=GO.modulo,GO.not=function(){return Gc(~this.low,~this.high,this.unsigned)},GO.and=function(m){return G6(m)||(m=Gz(m)),Gc(this.low&m.low,this.high&m.high,this.unsigned)},GO.or=function(m){return G6(m)||(m=Gz(m)),Gc(this.low|m.low,this.high|m.high,this.unsigned)},GO.xor=function(m){return G6(m)||(m=Gz(m)),Gc(this.low^m.low,this.high^m.high,this.unsigned)},GO.shiftLeft=function(m){return G6(m)&&(m=m.toInt()),(m&=63)===0?this:m<32?Gc(this.low<<m,this.high<<m|this.low>>>32-m,this.unsigned):Gc(0,this.low<<m-32,this.unsigned)},GO.shl=GO.shiftLeft,GO.shiftRight=function(m){return G6(m)&&(m=m.toInt()),(m&=63)===0?this:m<32?Gc(this.low>>>m|this.high<<32-m,this.high>>m,this.unsigned):Gc(this.high>>m-32,this.high>=0?0:-1,this.unsigned)},GO.shr=GO.shiftRight,GO.shiftRightUnsigned=function(m){if(G6(m)&&(m=m.toInt()),m&=63,m===0)return this;var d=this.high;if(m<32){var p=this.low;return Gc(p>>>m|d<<32-m,d>>>m,this.unsigned)}else return m===32?Gc(d,0,this.unsigned):Gc(d>>>m-32,0,this.unsigned)},GO.shru=GO.shiftRightUnsigned,GO.shr_u=GO.shiftRightUnsigned,GO.toSigned=function(){return this.unsigned?Gc(this.low,this.high,!1):this},GO.toUnsigned=function(){return this.unsigned?this:Gc(this.low,this.high,!0)},GO.toBytes=function(m){return m?this.toBytesLE():this.toBytesBE()},GO.toBytesLE=function(){var m=this.high,d=this.low;return[d&255,d>>>8&255,d>>>16&255,d>>>24,m&255,m>>>8&255,m>>>16&255,m>>>24]},GO.toBytesBE=function(){var m=this.high,d=this.low;return[m>>>24,m>>>16&255,m>>>8&255,m&255,d>>>24,d>>>16&255,d>>>8&255,d&255]},G5.fromBytes=function(m,d,p){return p?G5.fromBytesLE(m,d):G5.fromBytesBE(m,d)},G5.fromBytesLE=function(m,d){return new G5(m[0]|m[1]<<8|m[2]<<16|m[3]<<24,m[4]|m[5]<<8|m[6]<<16|m[7]<<24,d)},G5.fromBytesBE=function(m,d){return new G5(m[4]<<24|m[5]<<16|m[6]<<8|m[7],m[0]<<24|m[1]<<16|m[2]<<8|m[3],d)};var GD=G2(G3),Gi=o({__proto__:null,default:GD},[G3]);const Ge=GD||Gi;function GP(m){return Ge.fromString(m,!0,16)}const GS=GP("c3a5c85c97cb3127"),GI=GP("b492b66fbe98f273"),GB=GP("9ae16a3b2f90404f");function Gj(m){return m.xor(m.shru(47))}function GR(m,d,p){const _=m.slice(d,d+p);return Ge.fromBytes(Array.from(_),!0,!0)}function GH(m,d){return GR(m,d,8)}function Gu(m,d){return GR(m,d,4)}function GX(m,d){return d===0?m:m.shru(d).or(m.shl(64-d))}function Gf(m,d,p=GP("9ddfea08eb382d69")){let _=m.xor(d).mul(p);_=_.xor(_.shru(47));let E=d.xor(_).mul(p);return E=E.xor(E.shru(47)),E=E.mul(p),E}function Gy(m,d,p,_,E,S){E=E.add(m),S=GX(S.add(E).add(_),21);const I=E;return E=E.add(d),E=E.add(p),S=S.add(GX(E,44)),[E.add(_),S.add(I)]}function GE(m,d,p,_){return Gy(GH(m,d),GH(m,d+8),GH(m,d+16),GH(m,d+24),p,_)}function GW(m,d=m.length){if(d>=8){const p=GB.add(d*2),_=GH(m,0).add(GB),E=GH(m,d-8),S=GX(E,37).mul(p).add(_),I=GX(_,25).add(E).mul(p);return Gf(S,I,p)}if(d>=4){const p=GB.add(d*2),_=Gu(m,0);return Gf(_.shl(3).add(d),Gu(m,d-4),p)}if(d>0){const p=m[0],_=m[d>>1],E=m[d-1],S=p+(_<<8),I=d+(E<<2);return Gj(GB.mul(S).xor(GS.mul(I))).mul(GB)}return GB}function Gd(m,d=m.length){const p=GB.add(d*2),_=GH(m,0).mul(GI),E=GH(m,8),S=GH(m,d-8).mul(p),I=GH(m,d-16).mul(GB);return Gf(GX(_.add(E),43).add(GX(S,30)).add(I),_.add(GX(E.add(GB),18)).add(S),p)}function GM(m,d=m.length){const p=GB.add(d*2),_=GH(m,0).mul(GB),E=GH(m,8),S=GH(m,d-8).mul(p),I=GH(m,d-16).mul(GB),D=GX(_.add(E),43).add(GX(S,30)).add(I),k=Gf(D,_.add(GX(E.add(GB),18)).add(S),p),V=GH(m,16).mul(p),$=GH(m,24),Z=D.add(GH(m,d-32)).mul(p),te=k.add(GH(m,d-24)).mul(p);return Gf(GX(V.add($),43).add(GX(Z,30)).add(te),V.add(GX($.add(_),18)).add(Z),p)}function GU(m,d=m.length){const p=Ge.fromNumber(81,!0);if(d<=32)return d<=16?GW(m,d):Gd(m,d);if(d<=64)return GM(m,d);let _=p,E=p.mul(GI).add(113),S=Gj(E.mul(GB).add(113)).mul(GB),I=[Ge.UZERO,Ge.UZERO],D=[Ge.UZERO,Ge.UZERO];_=_.mul(GB).add(GH(m,0));let k=0;const V=(d-1>>6)*64,$=V+(d-1&63)-63;do _=GX(_.add(E).add(I[0]).add(GH(m,k+8)),37).mul(GI),E=GX(E.add(I[1]).add(GH(m,k+48)),42).mul(GI),_=_.xor(D[1]),E=E.add(I[0]).add(GH(m,k+40)),S=GX(S.add(D[0]),33).mul(GI),I=GE(m,k,I[1].mul(GI),_.add(D[0])),D=GE(m,k+32,S.add(D[1]),E.add(GH(m,k+16))),[S,_]=[_,S],k+=64;while(k!==V);const Z=GI.add(S.and(255).shl(1));return k=$,D[0]=D[0].add(d-1&63),I[0]=I[0].add(D[0]),D[0]=D[0].add(I[0]),_=GX(_.add(E).add(I[0]).add(GH(m,k+8)),37).mul(Z),E=GX(E.add(I[1]).add(GH(m,k+48)),42).mul(Z),_=_.xor(D[1].mul(9)),E=E.add(I[0].mul(9).add(GH(m,k+40))),S=GX(S.add(D[0]),33).mul(Z),I=GE(m,k,I[1].mul(Z),_.add(D[0])),D=GE(m,k+32,S.add(D[1]),E.add(GH(m,k+16))),[S,_]=[_,S],Gf(Gf(I[0],D[0],Z).add(Gj(E).mul(GS)).add(S),Gf(I[1],D[1],Z).add(_),Z)}function GJ(m,d){return d==="string"?GY(m):Gv([m],d)}function Gt(m,d){return m instanceof Float32Array&&d==="float32"||m instanceof Int32Array&&d==="int32"||m instanceof Uint8Array&&d==="bool"}function Gv(m,d){if(d==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(m)&&(m=Gl(m)),oQ().getBool("DEBUG")&&J(m,d),Gt(m,d))return m;if(d==null||d==="float32"||d==="complex64")return new Float32Array(m);if(d==="int32")return new Int32Array(m);if(d==="bool"){const p=new Uint8Array(m.length);for(let _=0;_<p.length;++_)Math.round(m[_])!==0&&(p[_]=1);return p}else throw new Error("Unknown data type "+d)}function Gh(){return oQ().platform.now()}function GY(m,d="utf-8"){return d=d||"utf-8",oQ().platform.encode(m,d)}function Gm(m,d="utf-8"){return d=d||"utf-8",oQ().platform.decode(m,d)}function Gx(m){return oQ().platform.isTypedArray!=null?oQ().platform.isTypedArray(m):G0(m)}function Gl(m,d=[],p=!1){if(d==null&&(d=[]),typeof m=="boolean"||typeof m=="number"||typeof m=="string"||oC(m)||m==null||Gx(m)&&p)d.push(m);else if(Array.isArray(m)||Gx(m))for(let _=0;_<m.length;++_)Gl(m[_],d,p);else{let _=-1;for(const E of Object.keys(m))/^([1-9]+[0-9]*|0)$/.test(E)&&(_=Math.max(_,Number(E)));for(let E=0;E<=_;E++)Gl(m[E],d,p)}return d}class Gb{constructor(d,p){this.backendTimer=d,this.logger=p,p==null&&(this.logger=new GV)}profileKernel(d,p,_){let E;const S=()=>{E=_()};let I;const D=Gh();if(this.backendTimer.timerAvailable())I=this.backendTimer.time(S);else{S();for(const k of E)k.dataSync();I=Promise.resolve({kernelMs:Gh()-D})}if(oQ().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let k=0;k<E.length;k++){const V=E[k];V.data().then($=>{Ga($,V.dtype,d)})}return{kernelName:d,outputs:E,inputs:p,timeMs:I.then(k=>k.kernelMs),extraInfo:I.then(k=>k.getExtraProfileInfo!=null?k.getExtraProfileInfo():"")}}logKernelProfile(d){const{kernelName:p,outputs:_,timeMs:E,inputs:S,extraInfo:I}=d;_.forEach(D=>{Promise.all([D.data(),E,I]).then(k=>{this.logger.logKernelProfile(p,D,k[0],k[1],S,k[2])})})}}function Ga(m,d,p){if(d!=="float32")return!1;for(let _=0;_<m.length;_++){const E=m[_];if(isNaN(E)||!isFinite(E))return console.warn("Found "+E+" in the result of '"+p+"'"),!0}return!1}class GV{logKernelProfile(d,p,_,E,S,I){const D=typeof E=="number"?j(E+"ms",9):E.error,k=j(d,25),V=p.rank,$=p.size,Z=j(p.shape.toString(),14);let te="";for(const xe in S){const le=S[xe];if(le!=null){const he=le.shape||p.shape,de=he.length;te+=xe+": "+de+"D "+(de>0?he:"")+" "}}console.log("%c"+k+"	%c"+D+"	%c"+V+"D "+Z+"	%c"+$+"	%c"+te+"	%c"+I,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Gg(m,d,p){const _={},E={};for(let k=0;k<d.length;k++)_[d[k].id]=!0;for(let k=0;k<m.length;k++){const V=m[k],$=V.inputs;for(const Z in $){const te=$[Z];let xe=!1;for(let le=0;le<d.length;le++)if(_[te.id]){V.outputs.forEach(he=>_[he.id]=!0),xe=!0,E[V.id]=!0;break}if(xe)break}}const S={};S[p.id]=!0;const I={};for(let k=m.length-1;k>=0;k--){const V=m[k],$=V.inputs;for(let Z=0;Z<V.outputs.length;Z++)if(S[V.outputs[Z].id]){for(const te in $)S[$[te].id]=!0,I[V.id]=!0;break}}const D=[];for(let k=0;k<m.length;k++){const V=m[k];if(E[V.id]&&I[V.id]){const $={};for(const te in V.inputs){const xe=V.inputs[te];_[xe.id]&&($[te]=xe)}const Z=Object.assign({},V);Z.inputs=$,Z.outputs=V.outputs,D.push(Z)}}return D}function s0(m,d,p,_){for(let E=d.length-1;E>=0;E--){const S=d[E],I=[];if(S.outputs.forEach(k=>{const V=m[k.id];V!=null?I.push(V):I.push(null)}),S.gradient==null)throw new Error("Cannot compute gradient: gradient function not found for "+S.kernelName+".");const D=S.gradient(I);for(const k in S.inputs){if(!(k in D))throw new Error("Cannot backprop through input "+k+". Available gradients found: "+Object.keys(D)+".");const V=p(()=>D[k]());if(V.dtype!=="float32")throw new Error("Error in gradient for op "+S.kernelName+". The gradient of input "+k+" must have 'float32' dtype, but has '"+V.dtype+"'");const $=S.inputs[k];if(!i(V.shape,$.shape))throw new Error("Error in gradient for op "+S.kernelName+". The gradient of input '"+k+"' has shape '"+V.shape+"', which does not match the shape of the input '"+$.shape+"'");if(m[$.id]==null)m[$.id]=V;else{const Z=m[$.id];m[$.id]=_(Z,V),Z.dispose()}}}}const s1=20,s2=3,s3=7;function s4(m,d,p,_){const E=o6(d),S=s5(m,d,p,E),I=d.length,D=s8(m,d,p,E,S),k=["Tensor"];return _&&(k.push("  dtype: "+p),k.push("  rank: "+I),k.push("  shape: ["+d+"]"),k.push("  values:")),k.push(D.map(V=>"    "+V).join(`
`)),k.join(`
`)}function s5(m,d,p,_){const E=n(d),S=_[_.length-1],I=new Array(S).fill(0),D=d.length,k=p==="complex64"?s9(m):m;if(D>1)for(let V=0;V<E/S;V++){const $=V*S;for(let Z=0;Z<S;Z++)I[Z]=Math.max(I[Z],s6(k[$+Z],0,p).length)}return I}function s6(m,d,p){let _;return Array.isArray(m)?_=parseFloat(m[0].toFixed(s3))+" + "+parseFloat(m[1].toFixed(s3))+"j":o0(m)?_="'"+m+"'":p==="bool"?_=s7(m):_=parseFloat(m.toFixed(s3)).toString(),j(_,d)}function s7(m){return m===0?"false":"true"}function s8(m,d,p,_,E,S=!0){const I=p==="complex64"?2:1,D=d[0],k=d.length;if(k===0){if(p==="complex64"){const he=s9(m);return[s6(he[0],0,p)]}return p==="bool"?[s7(m[0])]:[m[0].toString()]}if(k===1){if(D>s1){const he=s2*I;let de=Array.from(m.slice(0,he)),me=Array.from(m.slice((D-s2)*I,D*I));return p==="complex64"&&(de=s9(de),me=s9(me)),["["+de.map((ge,be)=>s6(ge,E[be],p)).join(", ")+", ..., "+me.map((ge,be)=>s6(ge,E[D-s2+be],p)).join(", ")+"]"]}return["["+(p==="complex64"?s9(m):Array.from(m)).map((he,de)=>s6(he,E[de],p)).join(", ")+"]"]}const V=d.slice(1),$=_.slice(1),Z=_[0]*I,te=[];if(D>s1){for(let he=0;he<s2;he++){const de=he*Z,me=de+Z;te.push(...s8(m.slice(de,me),V,p,$,E,!1))}te.push("...");for(let he=D-s2;he<D;he++){const de=he*Z,me=de+Z;te.push(...s8(m.slice(de,me),V,p,$,E,he===D-1))}}else for(let he=0;he<D;he++){const de=he*Z,me=de+Z;te.push(...s8(m.slice(de,me),V,p,$,E,he===D-1))}const xe=k===2?",":"";te[0]="["+(D>0?te[0]+xe:"");for(let he=1;he<te.length-1;he++)te[he]=" "+te[he]+xe;let le=`,
`;for(let he=2;he<k;he++)le+=`
`;return te[te.length-1]=" "+te[te.length-1]+"]"+(S?"":le),te}function s9(m){const d=[];for(let p=0;p<m.length;p+=2)d.push([m[p],m[p+1]]);return d}class so{constructor(d,p,_){if(this.dtype=p,this.shape=d.slice(),this.size=n(d),_!=null){const E=_.length;A(E===this.size,()=>"Length of values '"+E+"' does not match the size inferred by the shape '"+this.size+"'.")}if(p==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=_||U(p,this.size),this.strides=o6(d)}set(d,...p){p.length===0&&(p=[0]),A(p.length===this.rank,()=>"The number of provided coordinates ("+p.length+") must match the rank ("+this.rank+")");const _=this.locToIndex(p);this.values[_]=d}get(...d){d.length===0&&(d=[0]);let p=0;for(const E of d){if(E<0||E>=this.shape[p]){const S="Requested out of range element at "+d+".   Buffer shape="+this.shape;throw new Error(S)}p++}let _=d[d.length-1];for(let E=0;E<d.length-1;++E)_+=this.strides[E]*d[E];return this.values[_]}locToIndex(d){if(this.rank===0)return 0;if(this.rank===1)return d[0];let p=d[d.length-1];for(let _=0;_<d.length-1;++_)p+=this.strides[_]*d[_];return p}indexToLoc(d){if(this.rank===0)return[];if(this.rank===1)return[d];const p=new Array(this.shape.length);for(let _=0;_<p.length-1;++_)p[_]=Math.floor(d/this.strides[_]),d-=p[_]*this.strides[_];return p[p.length-1]=d,p}get rank(){return this.shape.length}toTensor(){return sc().makeTensor(this.values,this.shape,this.dtype)}}let sc=null,sG=null;function ss(m){sc=m}function sz(m){sG=m}class sC{constructor(d,p,_,E){this.kept=!1,this.isDisposedInternal=!1,this.shape=d.slice(),this.dtype=p||"float32",this.size=n(d),this.strides=o6(d),this.dataId=_,this.id=E,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const d=await this.data();return sG.buffer(this.shape,this.dtype,d)}bufferSync(){return sG.buffer(this.shape,this.dtype,this.dataSync())}async array(){const d=await this.data();return o8(this.shape,d,this.dtype==="complex64")}arraySync(){return o8(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const d=sc().read(this.dataId);if(this.dtype==="string"){const p=await d;try{return p.map(_=>Gm(_))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return d}dataToGPU(d){return this.throwIfDisposed(),sc().readToGPU(this.dataId,d)}dataSync(){this.throwIfDisposed();const d=sc().readSync(this.dataId);if(this.dtype==="string")try{return d.map(p=>Gm(p))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return d}async bytes(){this.throwIfDisposed();const d=await sc().read(this.dataId);return this.dtype==="string"?d:new Uint8Array(d.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),sc().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(d=!1){return sG.print(this,d)}clone(){return this.throwIfDisposed(),sG.clone(this)}toString(d=!1){const p=this.dataSync();return s4(p,this.shape,this.dtype,d)}cast(d){return this.throwIfDisposed(),sG.cast(this,d)}variable(d=!0,p,_){return this.throwIfDisposed(),sc().makeVariable(this,d,p,_)}}Object.defineProperty(sC,Symbol.hasInstance,{value:m=>!!m&&m.data!=null&&m.dataSync!=null&&m.throwIfDisposed!=null});function sL(){return oN("Tensor",()=>sC)}sL();class sK extends sC{constructor(d,p,_,E){super(d.shape,d.dtype,d.dataId,E),this.trainable=p,this.name=_}assign(d){if(d.dtype!==this.dtype)throw new Error("dtype of the new value ("+d.dtype+") and previous value ("+this.dtype+") must match");if(!i(d.shape,this.shape))throw new Error("shape of the new value ("+d.shape+") and previous value ("+this.shape+") must match");sc().disposeTensor(this),this.dataId=d.dataId,sc().incRef(this,null)}dispose(){sc().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(sK,Symbol.hasInstance,{value:m=>m instanceof sC&&m.assign!=null&&m.assign instanceof Function});var sT;(function(m){m.R0="R0",m.R1="R1",m.R2="R2",m.R3="R3",m.R4="R4",m.R5="R5",m.R6="R6"})(sT||(sT={}));var sq;(function(m){m.float32="float32",m.int32="int32",m.bool="int32",m.complex64="complex64"})(sq||(sq={}));var sQ;(function(m){m.float32="float32",m.int32="int32",m.bool="bool",m.complex64="complex64"})(sQ||(sQ={}));var sk;(function(m){m.float32="float32",m.int32="float32",m.bool="float32",m.complex64="complex64"})(sk||(sk={}));var sp;(function(m){m.float32="complex64",m.int32="complex64",m.bool="complex64",m.complex64="complex64"})(sp||(sp={}));const sw={float32:sk,int32:sq,bool:sQ,complex64:sp};function sA(m,d){if(m==="string"||d==="string"){if(m==="string"&&d==="string")return"string";throw new Error("Can not upcast "+m+" with "+d)}return sw[m][d]}function sZ(m){return sA(m,"int32")}function sF(m){return m!=null&&typeof m=="object"&&"texture"in m&&m.texture instanceof WebGLTexture}function sN(m){return typeof GPUBuffer<"u"&&m!=null&&typeof m=="object"&&"buffer"in m&&m.buffer instanceof GPUBuffer}function sO(m,d){if(m.dtype===d.dtype)return[m,d];const p=sA(m.dtype,d.dtype);return[m.cast(p),d.cast(p)]}function sD(m){const d=[];return sn(m,d,new Set),d}function sn(m,d,p){if(m==null)return;if(m instanceof sC){d.push(m);return}if(!si(m))return;const _=m;for(const E in _){const S=_[E];p.has(S)||(p.add(S),sn(S,d,p))}}function si(m){return Array.isArray(m)||typeof m=="object"}function se(m){return m.kernelName!=null}class sP{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(d=>d.name)))}}}dispose(){for(const d in this.registeredVariables)this.registeredVariables[d].dispose()}}class sS{constructor(d){this.ENV=d,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new sP}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const d=this.getSortedBackends();for(let p=0;p<d.length;p++){const _=d[p];if(await this.initializeBackend(_).success){await this.setBackend(_);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(this.backendInstance==null){const{name:d,asyncInit:p}=this.initializeBackendsAndReturnBest();if(p)throw new Error("The highest priority backend '"+d+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(d)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(d){if(!(d in this.registry))if(d in this.registryFactory){const{asyncInit:p}=this.initializeBackend(d);if(p)return null}else return null;return this.registry[d]}findBackendFactory(d){return d in this.registryFactory?this.registryFactory[d].factory:null}registerBackend(d,p,_=1){return d in this.registryFactory?(ch(d+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[d]={factory:p,priority:_},!0)}async setBackend(d){if(this.registryFactory[d]==null)throw new Error("Backend name '"+d+"' not found in registry");if(this.backendName=d,this.registry[d]==null){this.backendInstance=null;const{success:p,asyncInit:_}=this.initializeBackend(d);if(!(_?await p:p))return!1}return this.backendInstance=this.registry[d],this.setupRegisteredKernels(),this.profiler=new Gb(this.backendInstance),!0}setupRegisteredKernels(){ca(this.backendName).forEach(d=>{d.setupFunc!=null&&d.setupFunc(this.backendInstance)})}disposeRegisteredKernels(d){ca(d).forEach(p=>{p.disposeFunc!=null&&p.disposeFunc(this.registry[d])})}initializeBackend(d){const p=this.registryFactory[d];if(p==null)throw new Error("Cannot initialize backend "+d+", no registration found.");try{const _=p.factory();if(_&&!(_ instanceof C)&&typeof _.then=="function"){const E=++this.pendingBackendInitId,S=_.then(I=>E<this.pendingBackendInitId?!1:(this.registry[d]=I,this.pendingBackendInit=null,!0)).catch(I=>(E<this.pendingBackendInitId||(this.pendingBackendInit=null,ch("Initialization of backend "+d+" failed"),ch(I.stack||I.message)),!1));return this.pendingBackendInit=S,{success:S,asyncInit:!0}}else return this.registry[d]=_,{success:!0,asyncInit:!1}}catch(_){return ch("Initialization of backend "+d+" failed"),ch(_.stack||_.message),{success:!1,asyncInit:!1}}}removeBackend(d){if(!(d in this.registryFactory))throw new Error(d+" backend not found in registry");this.backendName===d&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,d in this.registry&&(this.disposeRegisteredKernels(d),this.registry[d].dispose(),delete this.registry[d]),delete this.registryFactory[d],this.backendName===d&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((d,p)=>this.registryFactory[p].priority-this.registryFactory[d].priority)}initializeBackendsAndReturnBest(){const d=this.getSortedBackends();for(let p=0;p<d.length;p++){const _=d[p],{success:E,asyncInit:S}=this.initializeBackend(_);if(S||E)return{name:_,asyncInit:S}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(d,p){const _=this.state.tensorInfo.get(p),E=_.backend,S=this.readSync(p),I=E.refCount(p);E.disposeData(p,!0),_.backend=d,d.move(p,S,_.shape,_.dtype,I),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(d,p){let _=null;if(p==null){if(typeof d!="function")throw new Error("Please provide a function to tidy()");p=d}else{if(typeof d!="string"&&!(d instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof p!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");_=d}let E;return this.scopedRun(()=>this.startScope(_),()=>this.endScope(E),()=>(E=p(),E instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),E))}scopedRun(d,p,_){d();try{const E=_();return p(),E}catch(E){throw p(),E}}nextTensorId(){return sS.nextTensorId++}nextVariableId(){return sS.nextVariableId++}clone(d){const p=sj.runKernel(c0,{x:d}),_={x:d},E=I=>({x:()=>{const D="float32",k={x:I},V={dtype:D};return sj.runKernel(oB,k,V)}}),S=[];return this.addTapeNode(this.state.activeScope.name,_,[p],E,S,{}),p}runKernel(d,p,_){if(this.backendName==null&&this.backend,cl(d,this.backendName)==null)throw new Error("Kernel '"+d+"' not registered for backend '"+this.backendName+"'");return this.runKernelFunc({kernelName:d,inputs:p,attrs:_})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(d,p,_){const E=this.backend.numDataIds();let S=0;_.forEach(k=>{S+=k.dtype==="complex64"?3:1});const I=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],D=E-p-S-I;if(D>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+D+" data ids) after running '"+d+"'")}runKernelFunc(d){let p,_=[];const E=this.isTapeOn(),S=this.state.numBytes,I=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let D;this.backendName==null&&this.backend;let k;const V=se(d)?d.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(se(d)){const{kernelName:le,inputs:he,attrs:de}=d;this.backendName==null&&this.backend;const me=cl(le,this.backendName);A(me!=null,()=>"Cannot find registered kernel '"+le+"' for backend '"+this.backendName+"'"),D=()=>{const ge=this.backend.numDataIds();k=me.kernelFunc({inputs:he,attrs:de,backend:this.backend});const be=Array.isArray(k)?k:[k];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(le,ge,be);const ye=be.map(ve=>ve.rank!=null?ve:this.makeTensorFromTensorInfo(ve));if(E){const ve=this.getTensorsForGradient(le,he,ye);_=this.saveTensorsForBackwardMode(ve)}return ye}}else{const{forwardFunc:le}=d,he=de=>{E&&(_=de.map(me=>this.keep(this.clone(me))))};D=()=>{const de=this.backend.numDataIds();k=this.tidy(()=>le(this.backend,he));const me=Array.isArray(k)?k:[k];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(V,de,me),me}}const{inputs:$,attrs:Z}=d,te=se(d)?null:d.backwardsFunc;let xe;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?p=D():(xe=this.profiler.profileKernel(V,$,()=>D()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(xe),p=xe.outputs)}),E&&this.addTapeNode(V,$,p,te,_,Z),this.state.profiling&&this.state.activeProfile.kernels.push({name:V,bytesAdded:this.state.numBytes-S,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-I,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys($).map(le=>$[le]!=null?$[le].shape:null),outputShapes:p.map(le=>le.shape),kernelTimeMs:xe.timeMs,extraInfo:xe.extraInfo}),Array.isArray(k)?p:p[0]}saveTensorsForBackwardMode(d){return d.map(p=>this.keep(this.clone(p)))}getTensorsForGradient(d,p,_){const E=cb(d);if(E!=null){const S=E.inputsToSave||[],I=E.outputsToSave||[];let D;E.saveAllInputs?(A(Array.isArray(p),()=>"saveAllInputs is true, expected inputs to be an array."),D=Object.keys(p).map(V=>p[V])):D=S.map(V=>p[V]);const k=_.filter((V,$)=>I[$]);return D.concat(k)}return[]}makeTensor(d,p,_,E){if(d==null)throw new Error("Values passed to engine.makeTensor() are null");_=_||"float32",E=E||this.backend;let S=d;_==="string"&&o0(d[0])&&(S=d.map(k=>GY(k)));const I=E.write(S,p,_),D=new sC(p,_,I,this.nextTensorId());if(this.trackTensor(D,E),_==="string"){const k=this.state.tensorInfo.get(I),V=l(S);this.state.numBytes+=V-k.bytes,k.bytes=V}return D}makeTensorFromDataId(d,p,_,E){_=_||"float32";const S={dataId:d,shape:p,dtype:_};return this.makeTensorFromTensorInfo(S,E)}makeTensorFromTensorInfo(d,p){const{dataId:_,shape:E,dtype:S}=d,I=new sC(E,S,_,this.nextTensorId());return this.trackTensor(I,p),I}makeVariable(d,p=!0,_,E){_=_||this.nextVariableId().toString(),E!=null&&E!==d.dtype&&(d=d.cast(E));const S=new sK(d,p,_,this.nextTensorId());if(this.state.registeredVariables[S.name]!=null)throw new Error("Variable with name "+S.name+" was already registered");return this.state.registeredVariables[S.name]=S,this.incRef(S,this.backend),S}trackTensor(d,p){this.state.numTensors++,d.dtype==="string"&&this.state.numStringTensors++;let _=0;d.dtype!=="complex64"&&d.dtype!=="string"&&(_=d.size*Y(d.dtype)),this.state.numBytes+=_,this.state.tensorInfo.has(d.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(d.dataId,{backend:p||this.backend,dtype:d.dtype,shape:d.shape,bytes:_})),d instanceof sK||this.track(d)}incRef(d,p){this.trackTensor(d,p),this.backend.incRef(d.dataId)}removeDataId(d,p){this.state.tensorInfo.has(d)&&this.state.tensorInfo.get(d).backend===p&&(this.state.tensorInfo.delete(d),this.state.numDataBuffers--)}disposeTensor(d){if(!this.state.tensorInfo.has(d.dataId))return;const p=this.state.tensorInfo.get(d.dataId);if(this.state.numTensors--,d.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=p.bytes),d.dtype!=="complex64"&&d.dtype!=="string"){const _=d.size*Y(d.dtype);this.state.numBytes-=_}p.backend.disposeData(d.dataId)&&this.removeDataId(d.dataId,p.backend)}disposeVariables(){for(const d in this.state.registeredVariables){const p=this.state.registeredVariables[d];this.disposeVariable(p)}}disposeVariable(d){this.disposeTensor(d),this.state.registeredVariables[d.name]!=null&&delete this.state.registeredVariables[d.name]}memory(){const d=this.backend.memory();return d.numTensors=this.state.numTensors,d.numDataBuffers=this.state.numDataBuffers,d.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(d.unreliable=!0,d.reasons==null&&(d.reasons=[]),d.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),d}async profile(d){this.state.profiling=!0;const p=this.state.numBytes,_=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await d(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(E=>E.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-p,this.state.activeProfile.newTensors=this.state.numTensors-_;for(const E of this.state.activeProfile.kernels)E.kernelTimeMs=await E.kernelTimeMs,E.extraInfo=await E.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(d,p,_,E,S,I){const D={id:this.state.nextTapeNodeId++,kernelName:d,inputs:p,outputs:_,saved:S},k=cb(d);k!=null&&(E=k.gradFunc),E!=null&&(D.gradient=V=>(V=V.map(($,Z)=>{if($==null){const te=_[Z],xe=oc(te.size,te.dtype);return this.makeTensor(xe,te.shape,te.dtype)}return $}),E(V.length>1?V:V[0],S,I))),this.state.activeTape.push(D)}keep(d){return d.kept=!0,d}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(d){const p={track:[],name:"unnamed scope",id:this.state.nextScopeId++};d&&(p.name=d),this.state.scopeStack.push(p),this.state.activeScope=p}endScope(d){const p=sD(d),_=new Set(p.map(S=>S.id));for(let S=0;S<this.state.activeScope.track.length;S++){const I=this.state.activeScope.track[S];!I.kept&&!_.has(I.id)&&I.dispose()}const E=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],p.forEach(S=>{!S.kept&&S.scopeId===E.id&&this.track(S)})}gradients(d,p,_,E=!1){if(A(p.length>0,()=>"gradients() received an empty list of xs."),_!=null&&_.dtype!=="float32")throw new Error("dy must have 'float32' dtype, but has '"+_.dtype+"'");const S=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",d));A(S instanceof sC,()=>"The result y returned by f() must be a tensor.");const I=Gg(this.state.activeTape,p,S);if(!E&&I.length===0&&p.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const D={};D[S.id]=_??sI(S.shape),s0(D,I,V=>this.tidy(V),sR);const k=p.map(V=>D[V.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(V=>{for(const $ of V.saved)$.dispose()}),this.state.activeTape=null),{value:S,grads:k}})}customGrad(d){return A(o4(d),()=>"The f passed in customGrad(f) must be a function."),(...p)=>{A(p.every(D=>D instanceof sC),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let _;const E={};p.forEach((D,k)=>{E[k]=D});const S=(D,k)=>(_=d(...p,k),A(_.value instanceof sC,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),A(o4(_.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),_.value),I=(D,k)=>{const V=_.gradFunc(D,k),$=Array.isArray(V)?V:[V];A($.length===p.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),A($.every(te=>te instanceof sC),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const Z={};return $.forEach((te,xe)=>{Z[xe]=()=>te}),Z};return this.runKernelFunc({forwardFunc:S,backwardsFunc:I,inputs:E})}}readSync(d){return this.state.tensorInfo.get(d).backend.readSync(d)}read(d){return this.state.tensorInfo.get(d).backend.read(d)}readToGPU(d,p){return this.state.tensorInfo.get(d).backend.readToGPU(d,p)}async time(d){const p=Gh(),_=await this.backend.time(d);return _.wallMs=Gh()-p,_}track(d){return this.state.activeScope!=null&&(d.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(d)),d}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new sP;for(const d in this.registry)this.disposeRegisteredKernels(d),this.registry[d].dispose(),delete this.registry[d];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}sS.nextTensorId=0,sS.nextVariableId=0;function sI(m){const d=oo(n(m),"float32");return sj.makeTensor(d,m,"float32")}function sB(){const m=oZ();if(m._tfengine==null){const d=new oK(m);m._tfengine=new sS(d)}return ow(m._tfengine.ENV),ss(()=>m._tfengine),m._tfengine}const sj=sB();function sR(m,d){const p={a:m,b:d};return sj.runKernel(oD,p)}function sH(){return typeof navigator<"u"&&navigator!=null}function su(m){if(m||sH()){if(m||(m=navigator),m.product==="ReactNative")return!0;const d=m.userAgent||m.vendor||(typeof window<"u"?window.opera:"");if(!d){const p=m;return p.userAgentData&&p.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(d)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(d.substr(0,4))}return!1}function sX(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const sf=oQ();sf.registerFlag("DEBUG",()=>!1,m=>{m&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),sf.registerFlag("IS_BROWSER",()=>sX()),sf.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),sf.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),sf.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),sf.registerFlag("PROD",()=>!1),sf.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>sf.getBool("DEBUG")),sf.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),sf.registerFlag("IS_TEST",()=>!1),sf.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>sf.getBool("DEBUG")),sf.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),sf.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),sf.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function sy(m,d){let p=m;if(Gx(m))return d==="string"?[]:[m.length];if(sF(m)){const E=m.channels||"RGBA";return[m.height,m.width*E.length]}else if(sN(m))return[m.buffer.size/(d==null?4:Y(d))];if(!Array.isArray(m))return[];const _=[];for(;Array.isArray(p)||Gx(p)&&d!=="string";)_.push(p.length),p=p[0];return Array.isArray(m)&&oQ().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&sE(m,_,[]),_}function sE(m,d,p){if(p=p||[],!Array.isArray(m)&&!Gx(m)){A(d.length===0,()=>"Element arr["+p.join("][")+"] is a primitive, but should be an array/TypedArray of "+d[0]+" elements");return}A(d.length>0,()=>"Element arr["+p.join("][")+"] should be a primitive, but is an array of "+m.length+" elements"),A(m.length===d[0],()=>"Element arr["+p.join("][")+"] should have "+d[0]+" elements, but has "+m.length+" elements");const _=d.slice(1);for(let E=0;E<m.length;++E)sE(m[E],_,p.concat(E))}function sW(m,d,p,_){if(m!=="string_or_numeric"){if(m==null)throw new Error("Expected dtype cannot be null.");if(m!=="numeric"&&m!==d||m==="numeric"&&d==="string")throw new Error("Argument '"+p+"' passed to '"+_+"' must be "+m+" tensor, but got "+d+" tensor")}}function sd(m,d,p,_="numeric"){if(m instanceof sL())return sW(_,m.dtype,d,p),m;let E=o3(m);if(E!=="string"&&["bool","int32","float32"].indexOf(_)>=0&&(E=_),sW(_,E,d,p),m==null||!Gx(m)&&!Array.isArray(m)&&typeof m!="number"&&typeof m!="boolean"&&typeof m!="string"){const D=m==null?"null":m.constructor.name;throw new Error("Argument '"+d+"' passed to '"+p+"' must be a Tensor or TensorLike, but got '"+D+"'")}const S=sy(m,E);!Gx(m)&&!Array.isArray(m)&&(m=[m]);const I=E!=="string"?Gv(m,E):Gl(m,[],!0);return sj.makeTensor(I,S,E)}function sM(m,d,p,_="numeric"){if(!Array.isArray(m))throw new Error("Argument "+d+" passed to "+p+" must be a `Tensor[]` or `TensorLike[]`");return m.map((E,S)=>sd(E,d+"["+S+"]",p,_))}const sU="__op";function sJ(m){const d=Object.keys(m);if(d.length!==1)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+d.length+" keys.");let p=d[0];const _=m[p];p.endsWith("_")&&(p=p.substring(0,p.length-1)),p=p+sU;const E=(...S)=>{sj.startScope(p);try{const I=_(...S);return oC(I)&&console.error("Cannot return a Promise inside of tidy."),sj.endScope(I),I}catch(I){throw sj.endScope(null),I}};return Object.defineProperty(E,"name",{value:p,configurable:!0}),E}function st(m,d){const p=sd(m,"real","complex"),_=sd(d,"imag","complex");N(p.shape,_.shape,"real and imag shapes, "+p.shape+" and "+_.shape+", must match in call to tf.complex().");const E={real:p,imag:_};return sj.runKernel(oR,E)}const sv=sJ({complex_:st});function sh(m,d,p,_){if(_==null)_=o3(m);else if(_==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(sN(m)||sF(m)){if(_!=="float32"&&_!=="int32")throw new Error("Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is "+_+".");return sj.backend.createTensorFromGPUData(m,d||p,_)}if(!Gx(m)&&!Array.isArray(m)&&typeof m!="number"&&typeof m!="boolean"&&typeof m!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(d!=null){oG(d);const E=n(d),S=n(p);A(E===S,()=>"Based on the provided shape, ["+d+"], the tensor should have "+E+" values but has "+S);for(let I=0;I<p.length;++I){const D=p[I],k=I===p.length-1?D!==n(d.slice(I)):!0;A(p[I]===d[I]||!k,()=>"Error creating a new Tensor. Inferred shape ("+p+") does not match the provided shape ("+d+"). ")}}return!Gx(m)&&!Array.isArray(m)&&(m=[m]),d=d||p,m=_!=="string"?Gv(m,_):Gl(m,[],!0),sj.makeTensor(m,d,_)}function sY(m,d,p){const _=sy(m,p);return sh(m,d,_,p)}const sm={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class sx{static join(d){return new sx(d).slice()}constructor(d){if(this.shards=[],this.previousShardIndex=0,d==null||(d instanceof Array||(d=[d]),d=d.map(_=>Gx(_)?_.buffer:_),d.length===0))return;this.bufferUniformSize=d[0].byteLength;let p=0;for(let _=0;_<d.length;_++){const E=d[_];_!==d.length-1&&E.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const S=p+E.byteLength;this.shards.push({buffer:E,start:p,end:S}),p=S}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(d=0,p=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(d=isNaN(Number(d))?0:d,p=isNaN(Number(p))?0:p,d=Math.max(0,d),p=Math.min(this.byteLength,p),p<=d)return new ArrayBuffer(0);const _=this.findShardForByte(d);if(_===-1)throw new Error("Could not find start shard for byte "+d);const E=p-d,S=new ArrayBuffer(E),I=new Uint8Array(S);let D=0;for(let k=_;k<this.shards.length;k++){const V=this.shards[k],$=d+D-V.start,Z=D,te=Math.min(p,V.end)-V.start,xe=new Uint8Array(V.buffer,$,te-$);if(I.set(xe,Z),D+=xe.length,p<V.end)break}return S}findShardForByte(d){if(this.shards.length===0||d<0||d>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(d/this.bufferUniformSize),this.previousShardIndex;function p(E){return d<E.start?-1:d>=E.end?1:0}if(p(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const _=sl(this.shards,p);return _===-1?-1:(this.previousShardIndex=_,this.previousShardIndex)}}function sl(m,d){let p=0,_=m.length;for(;p<=_;){const E=Math.floor((_-p)/2)+p,S=d(m[E]);if(S===0)return E;S<0?_=E:p=E+1}return-1}function sb(){oQ().set("PROD",!0)}function sa(){return sj}function sV(m,d){return sj.tidy(m,d)}function sg(m){sD(m).forEach(d=>d.dispose())}function z0(m){return sj.keep(m)}function z1(m){return sj.setBackend(m)}function z2(){return sj.backendName}function z3(m,d,p=1){return sj.registerBackend(m,d,p)}function z4(){return sj.backend}const z5=4;async function z6(m,d){const p=[],_=[],E=Array.isArray(m)?m.map(I=>I.name):Object.keys(m);for(let I=0;I<E.length;++I){const D=E[I],k=Array.isArray(m)?m[I].tensor:m[D];if(k.dtype!=="float32"&&k.dtype!=="int32"&&k.dtype!=="bool"&&k.dtype!=="string"&&k.dtype!=="complex64")throw new Error("Unsupported dtype in weight '"+D+"': "+k.dtype);const V={name:D,shape:k.shape,dtype:k.dtype};if(k.dtype==="string"){const $=new Promise(async Z=>{const te=await k.bytes(),xe=te.reduce((de,me)=>de+me.length,0)+z5*te.length,le=new Uint8Array(xe);let he=0;for(let de=0;de<te.length;de++){const me=te[de],ge=new Uint8Array(new Uint32Array([me.length]).buffer);le.set(ge,he),he+=z5,le.set(me,he),he+=me.length}Z(le)});_.push($)}else _.push(k.data());d!=null&&(V.group=d),p.push(V)}const S=await Promise.all(_);return{data:zs(S),specs:p}}function z7(m,d){const p=new sx(m),_={};let E=0;for(const S of d){const I=z8(S,(D,k)=>p.slice(E+D,E+k));_[S.name]=zo(S,p.slice(E,E+I)),E+=I}return _}function z8(m,d){const p=n(m.shape);let _;if("quantization"in m){const E=m.quantization;_=sm[E.dtype]}else if(m.dtype==="string"){let E=0;for(let S=0;S<p;S++)E+=z5+new Uint32Array(d(E,E+z5))[0];return E}else _=sm[m.dtype];return p*_}async function z9(m,d){const p=n(m.shape);let _;if("quantization"in m){const E=m.quantization;_=sm[E.dtype]}else if(m.dtype==="string"){let E=0;for(let S=0;S<p;S++)E+=z5+new Uint32Array(await d(E,E+z5))[0];return E}else _=sm[m.dtype];return p*_}function zo(m,d){const p=m.name,_=m.dtype,E=m.shape,S=n(E);let I,D=0;if("quantization"in m){const k=m.quantization;if(k.dtype==="uint8"||k.dtype==="uint16"){if(!("min"in k&&"scale"in k))throw new Error("Weight "+m.name+" with quantization "+k.dtype+" doesn't have corresponding metadata min and scale.")}else if(k.dtype==="float16"){if(_!=="float32")throw new Error("Weight "+m.name+" is quantized with "+k.dtype+" which only supports weights of type float32 not "+_+".")}else throw new Error("Weight "+m.name+" has unknown quantization dtype "+k.dtype+". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");const V=sm[k.dtype],$=k.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(_==="float32")if(k.dtype==="uint8"||k.dtype==="uint16"){I=new Float32Array($.length);for(let Z=0;Z<$.length;Z++){const te=$[Z];I[Z]=te*k.scale+k.min}}else if(k.dtype==="float16")I=zN()($);else throw new Error("Unsupported quantization type "+k.dtype+" for weight type float32.");else if(_==="int32"){if(k.dtype!=="uint8"&&k.dtype!=="uint16")throw new Error("Unsupported quantization type "+k.dtype+" for weight type int32.");I=new Int32Array($.length);for(let Z=0;Z<$.length;Z++){const te=$[Z];I[Z]=Math.round(te*k.scale+k.min)}}else throw new Error("Unsupported dtype in weight '"+p+"': "+_);D+=S*V}else if(_==="string"){const k=n(m.shape);I=[];for(let V=0;V<k;V++){const $=new Uint32Array(d.slice(D,D+z5))[0];D+=z5;const Z=new Uint8Array(d.slice(D,D+$));I.push(Z),D+=$}}else{const k=sm[_];if(_==="float32")I=new Float32Array(d);else if(_==="int32")I=new Int32Array(d);else if(_==="bool")I=new Uint8Array(d);else if(_==="complex64"){I=new Float32Array(d);const V=new Float32Array(I.length/2),$=new Float32Array(I.length/2);for(let le=0;le<V.length;le++)V[le]=I[le*2],$[le]=I[le*2+1];const Z=sY(V,E,"float32"),te=sY($,E,"float32"),xe=sv(Z,te);return Z.dispose(),te.dispose(),xe}else throw new Error("Unsupported dtype in weight '"+p+"': "+_);D+=S*k}return sY(I,E,_)}async function zc(m,d,p){let _=new Uint8Array(d);for(;_.byteLength<p;){const{done:E,value:S}=await m.read();if(E&&S==null){const D=p-_.byteLength;throw new Error("Reader is done but "+D+" bytes are still expected")}const I=new Uint8Array(_.length+S.byteLength);I.set(_,0),I.set(new Uint8Array(S),_.length),_=I}return _.buffer}async function zG(m,d){const p={},_=m.getReader();let E=new ArrayBuffer(0);for(const S of d){const I=await z9(S,async(V,$)=>(E=await zc(_,E,$),E.slice(V,$)));E=await zc(_,E,I);const D=E.slice(0,I);E=E.slice(I);const k=zo(S,D);if(p[S.name]=k,z2()==="webgpu"){const V=z4();"uploadToGPU"in V&&n(k.shape)>=oQ().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&V.uploadToGPU(k.dataId)}}return p}function zs(m){if(m===null)throw new Error("Invalid input value: "+JSON.stringify(m));let d=0;const p=[];m.forEach(S=>{if(d+=S.byteLength,p.push(S.byteLength===S.buffer.byteLength?S:new S.constructor(S)),!(S instanceof Float32Array||S instanceof Int32Array||S instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+S.constructor.name)});const _=new Uint8Array(d);let E=0;return p.forEach(S=>{_.set(new Uint8Array(S.buffer),E),E+=S.byteLength}),_.buffer}const zz=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function zC(m){return zz?Buffer.byteLength(m,"utf8"):new Blob([m]).size}function zL(m){if(zz)return Buffer.from(m).toString("base64");const d=new Uint8Array(m);let p="";for(let _=0,E=d.length;_<E;_++)p+=String.fromCharCode(d[_]);return btoa(p)}function zK(m){if(zz){const _=Buffer.from(m,"base64");return _.buffer.slice(_.byteOffset,_.byteOffset+_.byteLength)}const d=atob(m),p=new Uint8Array(d.length);for(let _=0;_<d.length;++_)p.set([d.charCodeAt(_)],_);return p.buffer}function zr(m){return sx.join(m)}function zT(m){const d="/";for(m=m.trim();m.endsWith(d);)m=m.slice(0,m.length-1);const p=m.split(d);return p[p.length-1]}function zq(m,d){const p={modelTopology:m.modelTopology,format:m.format,generatedBy:m.generatedBy,convertedBy:m.convertedBy,weightsManifest:d};return m.signature!=null&&(p.signature=m.signature),m.userDefinedMetadata!=null&&(p.userDefinedMetadata=m.userDefinedMetadata),m.modelInitializer!=null&&(p.modelInitializer=m.modelInitializer),m.initializerSignature!=null&&(p.initializerSignature=m.initializerSignature),m.trainingConfig!=null&&(p.trainingConfig=m.trainingConfig),p}function zQ(m,d,p){const _={modelTopology:m.modelTopology,format:m.format,generatedBy:m.generatedBy,convertedBy:m.convertedBy};if(m.trainingConfig!=null&&(_.trainingConfig=m.trainingConfig),m.weightsManifest!=null){if(!d)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!p)throw new Error("modelJSON has weightsManifest but weightData is null");_.weightSpecs=d,_.weightData=p}return m.signature!=null&&(_.signature=m.signature),m.userDefinedMetadata!=null&&(_.userDefinedMetadata=m.userDefinedMetadata),m.modelInitializer!=null&&(_.modelInitializer=m.modelInitializer),m.initializerSignature!=null&&(_.initializerSignature=m.initializerSignature),_}async function zk(m,d){let p,_;return m.weightsManifest!=null&&([p,_]=await d(m.weightsManifest)),zQ(m,p,_)}function zp(m){if(m.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:m.modelTopology==null?0:zC(JSON.stringify(m.modelTopology)),weightSpecsBytes:m.weightSpecs==null?0:zC(JSON.stringify(m.weightSpecs)),weightDataBytes:m.weightData==null?0:new sx(m.weightData).byteLength}}function zw(m){const d=[];for(const p of m)d.push(...p.weights);return d}function zA(){const m=p=>{let _=p<<13,E=0;for(;!(_&8388608);)E-=8388608,_<<=1;return _&=-8388609,E+=947912704,_|E},d=new Uint32Array(2048);d[0]=0;for(let p=1;p<1024;p++)d[p]=m(p);for(let p=1024;p<2048;p++)d[p]=939524096+(p-1024<<13);return d}function zZ(){const m=new Uint32Array(64);m[0]=0,m[31]=1199570944,m[32]=2147483648,m[63]=3347054592;for(let d=1;d<31;d++)m[d]=d<<23;for(let d=33;d<63;d++)m[d]=2147483648+(d-32<<23);return m}function zF(){const m=new Uint32Array(64);for(let d=0;d<64;d++)m[d]=1024;return m[0]=m[32]=0,m}function zN(){const m=zA(),d=zZ(),p=zF();return _=>{const E=new ArrayBuffer(4*_.length),S=new Uint32Array(E);for(let I=0;I<_.length;I++){const D=_[I],k=m[p[D>>10]+(D&1023)]+d[D>>10];S[I]=k}return new Float32Array(E)}}class zO{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return zO.instance==null&&(zO.instance=new zO),zO.instance}static registerSaveRouter(d){zO.getInstance().saveRouters.push(d)}static registerLoadRouter(d){zO.getInstance().loadRouters.push(d)}static getSaveHandlers(d){return zO.getHandlers(d,"save")}static getLoadHandlers(d,p){return zO.getHandlers(d,"load",p)}static getHandlers(d,p,_){const E=[];return(p==="load"?zO.getInstance().loadRouters:zO.getInstance().saveRouters).forEach(S=>{const I=S(d,_);I!==null&&E.push(I)}),E}}const zD=m=>zO.registerSaveRouter(m),zn=m=>zO.registerLoadRouter(m),zi=m=>zO.getSaveHandlers(m),ze=(m,d)=>zO.getLoadHandlers(m,d),zP="tensorflowjs",zS=1,zI="models_store",zB="model_info_store";function zj(){if(!oQ().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const m=typeof window>"u"?self:window,d=m.indexedDB||m.mozIndexedDB||m.webkitIndexedDB||m.msIndexedDB||m.shimIndexedDB;if(d==null)throw new Error("The current browser does not appear to support IndexedDB.");return d}function zR(m){const d=m.result;d.createObjectStore(zI,{keyPath:"modelPath"}),d.createObjectStore(zB,{keyPath:"modelPath"})}class zH{constructor(d){if(this.indexedDB=zj(),d==null||!d)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=d}async save(d){if(d.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,d)}async load(){return this.databaseAction(this.modelPath)}databaseAction(d,p){return new Promise((_,E)=>{const S=this.indexedDB.open(zP,zS);S.onupgradeneeded=()=>zR(S),S.onsuccess=()=>{const I=S.result;if(p==null){const D=I.transaction(zI,"readonly"),k=D.objectStore(zI).get(this.modelPath);k.onsuccess=()=>{if(k.result==null)return I.close(),E(new Error("Cannot find model with path '"+this.modelPath+"' in IndexedDB."));_(k.result.modelArtifacts)},k.onerror=V=>(I.close(),E(k.error)),D.oncomplete=()=>I.close()}else{p.weightData=sx.join(p.weightData);const D=zp(p),k=I.transaction(zB,"readwrite");let V=k.objectStore(zB),$;try{$=V.put({modelPath:this.modelPath,modelArtifactsInfo:D})}catch(te){return E(te)}let Z;$.onsuccess=()=>{Z=I.transaction(zI,"readwrite");const te=Z.objectStore(zI);let xe;try{xe=te.put({modelPath:this.modelPath,modelArtifacts:p,modelArtifactsInfo:D})}catch(le){return E(le)}xe.onsuccess=()=>_({modelArtifactsInfo:D}),xe.onerror=le=>{V=k.objectStore(zB);const he=V.delete(this.modelPath);he.onsuccess=()=>(I.close(),E(xe.error)),he.onerror=de=>(I.close(),E(xe.error))}},$.onerror=te=>(I.close(),E($.error)),k.oncomplete=()=>{Z==null?I.close():Z.oncomplete=()=>I.close()}}},S.onerror=I=>E(S.error)})}}zH.URL_SCHEME="indexeddb://";const zu=m=>oQ().getBool("IS_BROWSER")&&!Array.isArray(m)&&m.startsWith(zH.URL_SCHEME)?zX(m.slice(zH.URL_SCHEME.length)):null;zO.registerSaveRouter(zu),zO.registerLoadRouter(zu);function zX(m){return new zH(m)}function zf(m){return m.startsWith(zH.URL_SCHEME)?m.slice(zH.URL_SCHEME.length):m}class zy{constructor(){this.indexedDB=zj()}async listModels(){return new Promise((d,p)=>{const _=this.indexedDB.open(zP,zS);_.onupgradeneeded=()=>zR(_),_.onsuccess=()=>{const E=_.result,S=E.transaction(zB,"readonly"),I=S.objectStore(zB).getAll();I.onsuccess=()=>{const D={};for(const k of I.result)D[k.modelPath]=k.modelArtifactsInfo;d(D)},I.onerror=D=>(E.close(),p(I.error)),S.oncomplete=()=>E.close()},_.onerror=E=>p(_.error)})}async removeModel(d){return d=zf(d),new Promise((p,_)=>{const E=this.indexedDB.open(zP,zS);E.onupgradeneeded=()=>zR(E),E.onsuccess=()=>{const S=E.result,I=S.transaction(zB,"readwrite"),D=I.objectStore(zB),k=D.get(d);let V;k.onsuccess=()=>{if(k.result==null)return S.close(),_(new Error("Cannot find model with path '"+d+"' in IndexedDB."));{const $=D.delete(d),Z=()=>{V=S.transaction(zI,"readwrite");const te=V.objectStore(zI).delete(d);te.onsuccess=()=>p(k.result.modelArtifactsInfo),te.onerror=xe=>_(k.error)};$.onsuccess=Z,$.onerror=te=>(Z(),S.close(),_(k.error))}},k.onerror=$=>(S.close(),_(k.error)),I.oncomplete=()=>{V==null?S.close():V.oncomplete=()=>S.close()}},E.onerror=S=>_(E.error)})}}const zE="/",zW="tensorflowjs_models",zd="info",zM="model_topology",zU="weight_specs",zJ="weight_data",zt="model_metadata";function zv(m){return{info:[zW,m,zd].join(zE),topology:[zW,m,zM].join(zE),weightSpecs:[zW,m,zU].join(zE),weightData:[zW,m,zJ].join(zE),modelMetadata:[zW,m,zt].join(zE)}}function zh(m){for(const d of Object.values(m))window.localStorage.removeItem(d)}function zY(m){const d=m.split(zE);if(d.length<3)throw new Error("Invalid key format: "+m);return d.slice(1,d.length-1).join(zE)}function zm(m){return m.startsWith(zx.URL_SCHEME)?m.slice(zx.URL_SCHEME.length):m}class zx{constructor(d){if(!oQ().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,d==null||!d)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=d,this.keys=zv(this.modelPath)}async save(d){if(d.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const p=JSON.stringify(d.modelTopology),_=JSON.stringify(d.weightSpecs),E=zp(d),S=sx.join(d.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(E)),this.LS.setItem(this.keys.topology,p),this.LS.setItem(this.keys.weightSpecs,_),this.LS.setItem(this.keys.weightData,zL(S));const I={format:d.format,generatedBy:d.generatedBy,convertedBy:d.convertedBy,signature:d.signature!=null?d.signature:void 0,userDefinedMetadata:d.userDefinedMetadata!=null?d.userDefinedMetadata:void 0,modelInitializer:d.modelInitializer!=null?d.modelInitializer:void 0,initializerSignature:d.initializerSignature!=null?d.initializerSignature:void 0,trainingConfig:d.trainingConfig!=null?d.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(I)),{modelArtifactsInfo:E}}catch{throw zh(this.keys),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+E.modelTopologyBytes+", weightSpecsBytes="+E.weightSpecsBytes+", weightDataBytes="+E.weightDataBytes+".")}}}async load(){const d=JSON.parse(this.LS.getItem(this.keys.info));if(d==null)throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if(d.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const p={},_=JSON.parse(this.LS.getItem(this.keys.topology));if(_==null)throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");p.modelTopology=_;const E=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(E==null)throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");p.weightSpecs=E;const S=this.LS.getItem(this.keys.modelMetadata);if(S!=null){const D=JSON.parse(S);p.format=D.format,p.generatedBy=D.generatedBy,p.convertedBy=D.convertedBy,D.signature!=null&&(p.signature=D.signature),D.userDefinedMetadata!=null&&(p.userDefinedMetadata=D.userDefinedMetadata),D.modelInitializer!=null&&(p.modelInitializer=D.modelInitializer),D.initializerSignature!=null&&(p.initializerSignature=D.initializerSignature),D.trainingConfig!=null&&(p.trainingConfig=D.trainingConfig)}const I=this.LS.getItem(this.keys.weightData);if(I==null)throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return p.weightData=zK(I),p}}zx.URL_SCHEME="localstorage://";const zl=m=>oQ().getBool("IS_BROWSER")&&!Array.isArray(m)&&m.startsWith(zx.URL_SCHEME)?zb(m.slice(zx.URL_SCHEME.length)):null;zO.registerSaveRouter(zl),zO.registerLoadRouter(zl);function zb(m){return new zx(m)}class za{constructor(){A(oQ().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),A(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const d={},p=zW+zE,_=zE+zd;for(let E=0;E<this.LS.length;++E){const S=this.LS.key(E);if(S.startsWith(p)&&S.endsWith(_)){const I=zY(S);d[I]=JSON.parse(this.LS.getItem(S))}}return d}async removeModel(d){d=zm(d);const p=zv(d);if(this.LS.getItem(p.info)==null)throw new Error("Cannot find model at path '"+d+"'");const _=JSON.parse(this.LS.getItem(p.info));return zh(p),_}}const zV="model",zg=".json",C0=".weights.bin";function C1(m){return new Promise(d=>setTimeout(d)).then(m)}class C2{constructor(d){if(!oQ().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");d.startsWith(C2.URL_SCHEME)&&(d=d.slice(C2.URL_SCHEME.length)),(d==null||d.length===0)&&(d=zV),this.modelJsonFileName=d+zg,this.weightDataFileName=d+C0}async save(d){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const p=sx.join(d.weightData),_=window.URL.createObjectURL(new Blob([p],{type:"application/octet-stream"}));if(d.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const E=[{paths:["./"+this.weightDataFileName],weights:d.weightSpecs}],S=zq(d,E),I=window.URL.createObjectURL(new Blob([JSON.stringify(S)],{type:"application/json"})),D=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(D.download=this.modelJsonFileName,D.href=I,await C1(()=>D.dispatchEvent(new MouseEvent("click"))),d.weightData!=null){const k=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;k.download=this.weightDataFileName,k.href=_,await C1(()=>k.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:zp(d)}}}}C2.URL_SCHEME="downloads://";class C3{constructor(d){if(d==null||d.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+d);this.jsonFile=d[0],this.weightsFiles=d.slice(1)}async load(){return new Promise((d,p)=>{const _=new FileReader;_.onload=E=>{const S=JSON.parse(E.target.result),I=S.modelTopology;if(I==null){p(new Error("modelTopology field is missing from file "+this.jsonFile.name));return}if(S.weightsManifest==null){p(new Error("weightManifest field is missing from file "+this.jsonFile.name));return}if(this.weightsFiles.length===0){d({modelTopology:I});return}const D=zk(S,k=>this.loadWeights(k));d(D)},_.onerror=E=>p("Failed to read model topology and weights manifest JSON from file '"+this.jsonFile.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only."),_.readAsText(this.jsonFile)})}loadWeights(d){const p=[],_=[];for(const I of d)p.push(...I.weights),_.push(...I.paths);const E=this.checkManifestAndWeightFiles(d),S=_.map(I=>this.loadWeightsFile(I,E[I]));return Promise.all(S).then(I=>[p,I])}loadWeightsFile(d,p){return new Promise((_,E)=>{const S=new FileReader;S.onload=I=>{const D=I.target.result;_(D)},S.onerror=I=>E("Failed to weights data from file of path '"+d+"'."),S.readAsArrayBuffer(p)})}checkManifestAndWeightFiles(d){const p=[],_=this.weightsFiles.map(S=>zT(S.name)),E={};for(const S of d)S.paths.forEach(I=>{const D=zT(I);if(p.indexOf(D)!==-1)throw new Error("Duplicate file basename found in weights manifest: '"+D+"'");if(p.push(D),_.indexOf(D)===-1)throw new Error("Weight file with basename '"+D+"' is not provided.");E[I]=this.weightsFiles[_.indexOf(D)]});if(p.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest ("+p.length+") and the number of weight files provided ("+this.weightsFiles.length+").");return E}}const C4=m=>oQ().getBool("IS_BROWSER")&&!Array.isArray(m)&&m.startsWith(C2.URL_SCHEME)?C5(m.slice(C2.URL_SCHEME.length)):null;zO.registerSaveRouter(C4);function C5(m="model"){return new C2(m)}function C6(m){return new C3(m)}function C7(m,d,p,_){I(m),p=p??0,_=_??1,D(p,_);let E=0;const S=k=>(k.then(V=>{const $=p+ ++E/m.length*(_-p);return d($),V}),k);function I(k){A(k!=null&&Array.isArray(k)&&k.length>0,()=>"promises must be a none empty array")}function D(k,V){A(k>=0&&k<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction "+k),A(V>=0&&V<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction "+V),A(V>=k,()=>"startFraction must be no more than endFraction, but got startFraction "+k+" and endFraction "+V)}return Promise.all(m.map(S))}async function C8(m,d){d==null&&(d={});const p=d.fetchFunc==null?oQ().platform.fetch:d.fetchFunc,_=m.map(V=>p(V,d.requestInit,{isBinary:!0})),E=0,S=.5,I=(d.onProgress==null?await Promise.all(_):await C7(_,d.onProgress,E,S)).map(V=>V.arrayBuffer());return d.onProgress==null?await Promise.all(I):await C7(I,d.onProgress,.5,1)}function C9(m,d){var p;const _=d.fetchFunc==null?oQ().platform.fetch:d.fetchFunc;let E=0,S;return(p=d.onProgress)===null||p===void 0||p.call(d,0),new ReadableStream({pull:async I=>{for(var D;E<m.length;){S||(S=(await _(m[E],d.requestInit,{isBinary:!0})).body.getReader());const{done:k,value:V}=await S.read();if(k){E++,S=void 0,(D=d.onProgress)===null||D===void 0||D.call(d,E/m.length);continue}I.enqueue(V);return}I.close()}})}async function Co(m,d="",p,_){return Cc(E=>C8(E,{requestInit:_}))(m,d,p)}function Cc(m){return async(d,p="",_)=>{const E=d.map(()=>!1),S={},I=_!=null?_.map(()=>!1):[],D=[];if(d.forEach((xe,le)=>{let he=0;xe.weights.forEach(de=>{const me="quantization"in de?de.quantization.dtype:de.dtype,ge=sm[me]*n(de.shape),be=()=>{E[le]=!0,S[le]==null&&(S[le]=[]),S[le].push({manifestEntry:de,groupOffset:he,sizeBytes:ge})};_!=null?_.forEach((ye,ve)=>{ye===de.name&&(be(),I[ve]=!0)}):be(),D.push(de.name),he+=ge})}),!I.every(xe=>xe)){const xe=_.filter((le,he)=>!I[he]);throw new Error("Could not find weights in manifest with names: "+xe.join(", ")+`. 
Manifest JSON has weights with names: `+D.join(", ")+".")}const k=E.reduce((xe,le,he)=>(le&&xe.push(he),xe),[]),V=[];k.forEach(xe=>{d[xe].paths.forEach(le=>{const he=p+(p.endsWith("/")?"":"/")+le;V.push(he)})});const $=await m(V),Z={};let te=0;return k.forEach(xe=>{const le=d[xe].paths.length,he=new sx($.slice(te,te+le));S[xe].forEach(de=>{const me=he.slice(de.groupOffset,de.groupOffset+de.sizeBytes),ge=z7(me,[de.manifestEntry]);for(const be in ge)Z[be]=ge[be]}),te+=le}),Z}}const CG="application/octet-stream",Cs="application/json";class Cz{constructor(d,p){if(this.DEFAULT_METHOD="POST",p==null&&(p={}),this.weightPathPrefix=p.weightPathPrefix,this.weightUrlConverter=p.weightUrlConverter,p.fetchFunc!=null?(A(typeof p.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=p.fetchFunc):this.fetch=oQ().platform.fetch,A(d!=null&&d.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(d)&&A(d.length===2,()=>"URL paths for http must have a length of 2, (actual length is "+d.length+")."),this.path=d,p.requestInit!=null&&p.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=p.requestInit||{},this.loadOptions=p}async save(d){if(d.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const p=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);p.body=new FormData;const _=[{paths:["./model.weights.bin"],weights:d.weightSpecs}],E=zq(d,_);if(p.body.append("model.json",new Blob([JSON.stringify(E)],{type:Cs}),"model.json"),d.weightData!=null){const I=sx.join(d.weightData);p.body.append("model.weights.bin",new Blob([I],{type:CG}),"model.weights.bin")}const S=await this.fetch(this.path,p);if(S.ok)return{modelArtifactsInfo:zp(d),responses:[S]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+S.status+".")}async loadModelJSON(){const d=await this.fetch(this.path,this.requestInit);if(!d.ok)throw new Error("Request to "+this.path+" failed with status code "+d.status+". Please verify this URL points to the model JSON of the model to load.");let p;try{p=await d.json()}catch{let I="Failed to parse model JSON of response from "+this.path+".";throw this.path.endsWith(".pb")?I+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":I+=" Please make sure the server is serving valid JSON for this request.",new Error(I)}const _=p.modelTopology,E=p.weightsManifest;if(_==null&&E==null)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return p}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const d=await this.loadModelJSON();return zk(d,p=>this.loadWeights(p))}async loadStream(){const d=await this.loadModelJSON(),p=await this.getWeightUrls(d.weightsManifest),_=zw(d.weightsManifest),E=()=>C9(p,this.loadOptions);return Object.assign(Object.assign({},d),{weightSpecs:_,getWeightStream:E})}async getWeightUrls(d){const p=Array.isArray(this.path)?this.path[1]:this.path,[_,E]=CC(p),S=this.weightPathPrefix||_,I=[],D=[];for(const k of d)for(const V of k.paths)this.weightUrlConverter!=null?D.push(this.weightUrlConverter(V)):I.push(S+V+E);return this.weightUrlConverter&&I.push(...await Promise.all(D)),I}async loadWeights(d){const p=await this.getWeightUrls(d),_=zw(d),E=await C8(p,this.loadOptions);return[_,E]}}Cz.URL_SCHEME_REGEX=/^https?:\/\//;function CC(m){const d=m.lastIndexOf("/"),p=m.lastIndexOf("?"),_=m.substring(0,d),E=p>d?m.substring(p):"";return[_+"/",E]}function CL(m){return m.match(Cz.URL_SCHEME_REGEX)!=null}const CK=(m,d)=>{if(typeof fetch>"u"&&(d==null||d.fetchFunc==null))return null;{let p=!0;if(Array.isArray(m)?p=m.every(_=>CL(_)):p=CL(m),p)return Cr(m,d)}return null};zO.registerSaveRouter(CK),zO.registerLoadRouter(CK);function Cr(m,d){return new Cz(m,d)}function CT(m,d){return Cr(m,d)}class Cq{constructor(d){this.modelArtifacts=d}load(){return this.modelArtifacts}}class CQ{constructor(d){this.saveHandler=d}save(d){return this.saveHandler(d)}}class Ck{constructor(d){d.load&&(this.load=()=>Promise.resolve(d.load())),d.save&&(this.save=p=>Promise.resolve(d.save(p)))}}function Cp(m,d,p,_){const E=arguments;return new Ck(Cw(...E))}function Cw(m,d,p,_){return arguments.length===1?m.modelTopology!=null||m.weightSpecs!=null?new Cq(m):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Cq({modelTopology:m})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Cq({modelTopology:m,weightSpecs:d,weightData:p,trainingConfig:_}))}function CA(m){return new CQ(m)}function CZ(m){return new CQ(m)}const CF="://";class CN{constructor(){this.managers={}}static getInstance(){return CN.instance==null&&(CN.instance=new CN),CN.instance}static registerManager(d,p){A(d!=null,()=>"scheme must not be undefined or null."),d.endsWith(CF)&&(d=d.slice(0,d.indexOf(CF))),A(d.length>0,()=>"scheme must not be an empty string.");const _=CN.getInstance();A(_.managers[d]==null,()=>"A model store manager is already registered for scheme '"+d+"'."),_.managers[d]=p}static getManager(d){const p=CN.getInstance().managers[d];if(p==null)throw new Error("Cannot find model manager for scheme '"+d+"'");return p}static getSchemes(){return Object.keys(CN.getInstance().managers)}}function CO(m){if(m.indexOf(CF)===-1)throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+CN.getSchemes().join(","));return{scheme:m.split(CF)[0],path:m.split(CF)[1]}}async function CD(m,d,p=!1){A(m!==d,()=>"Old path and new path are the same: '"+m+"'");const _=zO.getLoadHandlers(m);A(_.length>0,()=>"Copying failed because no load handler is found for source URL "+m+"."),A(_.length<2,()=>"Copying failed because more than one ("+_.length+") load handlers for source URL "+m+".");const E=_[0],S=zO.getSaveHandlers(d);A(S.length>0,()=>"Copying failed because no save handler is found for destination URL "+d+"."),A(S.length<2,()=>"Copying failed because more than one ("+_.length+") save handlers for destination URL "+d+".");const I=S[0],D=CO(m).scheme,k=CO(m).path,V=D===CO(m).scheme,$=await E.load();p&&V&&await CN.getManager(D).removeModel(k);const Z=await I.save($);return p&&!V&&await CN.getManager(D).removeModel(k),Z.modelArtifactsInfo}async function Cn(){const m=CN.getSchemes(),d={};for(const p of m){const _=await CN.getManager(p).listModels();for(const E in _){const S=p+CF+E;d[S]=_[E]}}return d}async function Ci(m){const d=CO(m);return CN.getManager(d.scheme).removeModel(d.path)}async function Ce(m,d){return CD(m,d,!1)}async function CP(m,d){return CD(m,d,!0)}var CS=Object.freeze({__proto__:null,CompositeArrayBuffer:sx,browserFiles:C6,browserHTTPRequest:CT,concatenateArrayBuffers:zr,copyModel:Ce,decodeWeights:z7,decodeWeightsStream:zG,encodeWeights:z6,fromMemory:Cp,fromMemorySync:Cw,getLoadHandlers:ze,getModelArtifactsForJSON:zk,getModelArtifactsForJSONSync:zQ,getModelArtifactsInfoForJSON:zp,getSaveHandlers:zi,getWeightSpecs:zw,http:Cr,isHTTPScheme:CL,listModels:Cn,loadWeights:Co,moveModel:CP,registerLoadRouter:zn,registerSaveRouter:zD,removeModel:Ci,weightsLoaderFactory:Cc,withSaveHandler:CA,withSaveHandlerSync:CZ});function CI(m,d){const p=sd(m,"x","cast");if(!t(d))throw new Error("Failed to cast to unknown dtype "+d);if(d==="string"&&p.dtype!=="string"||d!=="string"&&p.dtype==="string")throw new Error("Only strings can be casted to strings");const _={x:p},E={dtype:d};return sj.runKernel(oB,_,E)}const CB=sJ({cast_:CI});function Cj(m,d,p=!1,_=!1){let E=sd(m,"a","matMul"),S=sd(d,"b","matMul");[E,S]=sO(E,S);const I={a:E,b:S},D={transposeA:p,transposeB:_};return sj.runKernel(oP,I,D)}const CR=sJ({matMul_:Cj});function CH(m){const d={input:sd(m,"input","imag")};return sj.runKernel(c1,d)}const Cu=sJ({imag_:CH});function CX(m){const d={x:sd(m,"x","neg")};return sj.runKernel(cz,d)}const Cf=sJ({neg_:CX});function Cy(m){const d={input:sd(m,"input","real")};return sj.runKernel(cp,d)}const CE=sJ({real_:Cy});function CW(m,d,p){const _=sd(m,"x","transpose");if(d==null&&(d=_.shape.map((I,D)=>D).reverse()),A(_.rank===d.length,()=>"Error in transpose: rank of input "+_.rank+" must match length of perm "+d+"."),d.forEach(I=>{A(I>=0&&I<_.rank,()=>"All entries in 'perm' must be between 0 and "+(_.rank-1)+" but got "+d)}),_.rank<=1)return _.clone();const E={x:_},S={perm:d};return _.dtype==="complex64"?sV(()=>{let I=CE(_),D=Cu(_);return I=sj.runKernel(cy,{x:I},S),D=sj.runKernel(cy,{x:D},S),p&&(D=Cf(D)),sv(I,D)}):sj.runKernel(cy,E,S)}const Cd=sJ({transpose_:CW});function CM(m,d){const p=m.length,_=[];for(let E=0;E<p;E++){const S=p-1-E,I=m[S]||1;(d[d.length-1-E]||1)>1&&I===1&&_.unshift(S)}return _}function CU(m,d){const p=[];for(let _=0;_<d.length;_++){const E=m[m.length-_-1],S=d.length-_-1,I=d[S];(E==null||E===1&&I>1)&&p.unshift(S)}return p}function CJ(m,d){const p=Math.max(m.length,d.length),_=new Array(p);for(let E=0;E<p;E++){let S=m[m.length-E-1];S==null&&(S=1);let I=d[d.length-E-1];if(I==null&&(I=1),S===1)_[p-E-1]=I;else if(I===1)_[p-E-1]=S;else if(S!==I){const D="Operands could not be broadcast together with shapes "+m+" and "+d+".";throw Error(D)}else _[p-E-1]=S}return _}function Ct(m,d,p){if(O(m),d!=null&&d.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const _=sy(m,p);if(_.length!==3&&_.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(_.length===1&&d==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return sh(m,d,_,p)}let Cv;function Ch(m,d=3){if(d>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(m==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let p=!1,_=!1,E=!1,S=!1,I=!1,D=!1;if(m.data instanceof Uint8Array)p=!0;else if(typeof ImageData<"u"&&m instanceof ImageData)_=!0;else if(typeof HTMLVideoElement<"u"&&m instanceof HTMLVideoElement)E=!0;else if(typeof HTMLImageElement<"u"&&m instanceof HTMLImageElement)S=!0;else if(m.getContext!=null)I=!0;else if(typeof ImageBitmap<"u"&&m instanceof ImageBitmap)D=!0;else throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+m.constructor.name);if(cl(cM,sj.backendName)!=null){const te={pixels:m},xe={numChannels:d};return sj.runKernel(cM,te,xe)}const[k,V]=E?[m.videoWidth,m.videoHeight]:[m.width,m.height];let $;if(I)$=m.getContext("2d").getImageData(0,0,k,V).data;else if(_||p)$=m.data;else if(S||E||D){if(Cv==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Cv=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Cv=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Cv.canvas.width=k,Cv.canvas.height=V,Cv.drawImage(m,0,0,k,V),$=Cv.getImageData(0,0,k,V).data}let Z;if(d===4)Z=new Int32Array($);else{const te=k*V;Z=new Int32Array(te*d);for(let xe=0;xe<te;xe++)for(let le=0;le<d;++le)Z[xe*d+le]=$[xe*4+le]}return Ct(Z,[V,k,d],"int32")}const CY=sJ({fromPixels_:Ch});function Cm(m,d){const p=m.shape.length,_=d.shape.length;if(p<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+p+".");if(_<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+_+".");if(d.dtype!=="int32")throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+d.dtype+".");if(d.shape[_-1]>p)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+d.shape[_-1]+" vs. "+p);if(n(m.shape)===0)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+m.shape+".");const E=d.shape,S=E[E.length-1];let I=1;for(let Z=0;Z<E.length-1;++Z)I*=E[Z];const D=m.shape,k=E.slice();k.pop();let V=1;for(let Z=S;Z<p;++Z)V*=D[Z],k.push(D[Z]);const $=[...o6(m.shape).map(Z=>Z/V),1].slice(0,S);return[k,I,V,$]}function Cx(m,d,p){const _=d.rank>1?d.shape[d.rank-1]:1,E=d.rank>1?d.rank-1:1,S="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+p.shape+", indices.shape: "+d.shape+", shape: "+m+", sliceDim: "+_+", and batchDim: "+E+".";if(p.rank<E)throw new Error(S+(" update.rank < "+E+". "));if(m.length<_+(p.rank-E))throw new Error(S+(" Output shape length < "+(_+(p.rank-E))));if(p.rank!==E+m.length-_)throw new Error(S+(" update.rank != "+(E+m.length-_)));for(let I=0;I<E;++I)if(p.shape[I]!==d.shape[I])throw new Error(S+(" updates.shape["+I+"] ("+p.shape[I]+") != indices.shape["+I+"] ("+d.shape[I]+")."));for(let I=0;I<p.rank-E;++I)if(p.shape[I+E]!==m[I+_])throw new Error(S+(" updates.shape["+(I+E)+"] ("+p.shape[I+E]+") != shape["+(I+E)+"] ("+m[I+E]+")"))}function Cl(m,d,p){if(d.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+d.rank+".");if(m.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+m.rank+".");if(d.dtype!=="int32")throw new Error("The dtype of 'indices' should be int32, but got dtype: "+d.dtype);if(p.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+p);if(p.length===0){if(d.size===0)throw new Error("Indices specified for empty output. indices shape: "+d.shape);if(m.size===0)throw new Error("Updates specified for empty output. updates shape: "+m.shape)}Cx(p,d,m)}function Cb(m,d,p){const _=d.shape.length,E=_>1?d.shape[_-1]:1,S=p.length;let I=1;for(let Z=E;Z<S;++Z)I*=p[Z];const D=E<1?1:E,k=n(d.shape)/D,V=[...o6(p.slice(0,E)),1],$=n(p);return{sliceRank:E,numUpdates:k,sliceSize:I,strides:V,outputSize:$}}const Ca=-2,CV=-1;function Cg(m,d,p){const _=m.shape.length;A(_===d.length,()=>"Error in slice"+_+"D: Length of begin "+d+" must match the rank of the array ("+_+")."),A(_===p.length,()=>"Error in slice"+_+"D: Length of size "+p+" must match the rank of the array ("+_+").");for(let E=0;E<_;++E)A(d[E]+p[E]<=m.shape[E],()=>"Error in slice"+_+"D: begin["+E+"] + size["+E+"] ("+(d[E]+p[E])+") would overflow input.shape["+E+"] ("+m.shape[E]+")")}function L0(m){const d=[];let p=0;for(;m>0;)m&1&&d.push(p),m/=2,p++;return d}function L1(m,d,p){const _=[];for(let E=0;E<m.length;E++)_[E]=Math.ceil((d[E]-m[E])/p[E]);return _}function L2(m,d,p,_){const E=[...m];for(let S=E.length;S<_.length;S++)E.push(1);for(let S=0;S<p;S++)S===0?E[d]=1:(E.splice(d,0,1),E.pop());return E}function L3(m,d,p){return p<=m?p:p-(d-1)}function L4(m,d){const p=[];for(let _=0;_<m;_++)p.push(d+_);return p}function L5(m,d,p,_,E,S,I,D,k){const V=m.length;let $=new Array(V),Z=new Array(V),te=new Array(V);if(d.length&&p>0){const xe=d[0],le=p+1;$=L6(I,xe,le,_,m),Z=L7(D,xe,le,E,m),te=L2(S,xe,le,m)}else for(let xe=0;xe<V;xe++)$[xe]=L9(I,_,S,m,xe,k),Z[xe]=Lo(D,E,S,m,xe,k),te[xe]=L8(S,xe,k);return{begin:$,end:Z,strides:te}}function L6(m,d,p,_,E){const S=[...E],I=L4(p,d);for(let D=0;D<S.length;D++)if(I.indexOf(D)>-1)S[D]=0;else{const k=L3(d,p,D);let V=_[k];m&1<<k&&(V=0),S[D]=V}return S}function L7(m,d,p,_,E){const S=[...E],I=L4(p,d);for(let D=0;D<S.length;D++)if(I.indexOf(D)>-1)S[D]=Number.MAX_SAFE_INTEGER;else{const k=L3(d,p,D);let V=_[k];m&1<<k&&(V=Number.MAX_SAFE_INTEGER),S[D]=V}for(let D=0;D<S.length;D++){const k=E[D];S[D]<0&&(S[D]+=k),S[D]=K(0,S[D],E[D])}return S}function L8(m,d,p){let _=m[d];return(p&1<<d||_==null)&&(_=1),_}function L9(m,d,p,_,E,S){let I=d[E];const D=p[E]||1;(m&1<<E||S&1<<E||I==null)&&(D>0?I=Number.MIN_SAFE_INTEGER:I=Number.MAX_SAFE_INTEGER);const k=_[E];return I<0&&(I+=k),I=K(0,I,k-1),I}function Lo(m,d,p,_,E,S){let I=d[E];const D=p[E]||1;(m&1<<E||S&1<<E||I==null)&&(D>0?I=Number.MAX_SAFE_INTEGER:I=Number.MIN_SAFE_INTEGER);const k=_[E];return I<0&&(I+=k),D>0?I=K(0,I,k):I=K(-1,I,k-1),I}function Lc(m,d,p){let _=p.length;for(let E=0;E<p.length;E++)if(p[E]>1){_=E;break}for(let E=_+1;E<p.length;E++)if(d[E]>0||p[E]!==m[E])return!1;return!0}function LG(m,d){let p=m.length>0?m[m.length-1]:1;for(let _=0;_<m.length-1;_++)p+=m[_]*d[_];return p}function Ls(m,d,p){let _;const E=m.shape.length;typeof d=="number"?_=[d,...new Array(E-1).fill(0)]:d.length<E?_=d.concat(new Array(E-d.length).fill(0)):_=d.slice(),_.forEach(I=>{A(I!==-1,()=>"slice() does not support negative begin indexing.")});let S;return p==null?S=new Array(E).fill(-1):typeof p=="number"?S=[p,...new Array(E-1).fill(-1)]:p.length<E?S=p.concat(new Array(E-p.length).fill(-1)):S=p,S=S.map((I,D)=>I>=0?I:(A(I===-1,()=>"Negative size values should be exactly -1 but got "+I+" for the slice() size at index "+D+"."),m.shape[D]-_[D])),[_,S]}function Lz(m,d,p,_,E,S,I,D,k){let V;if(_==null?(V=new Array(d.length),V.fill(1)):V=_,I!=null&&I&I-1)throw new Error("Multiple ellipses in slice is not allowed.");let $=!1;const Z={dims:V.length,numAddAxisAfterEllipsis:0,begin:d.slice(),end:p.slice(),strides:V.slice(),beginMask:E,endMask:S,ellipsisMask:I,newAxisMask:D,shrinkAxisMask:k};for(let ge=0;ge<Z.dims;ge++)$&&1<<ge&D&&Z.numAddAxisAfterEllipsis++,1<<ge&I&&($=!0);$||(Z.ellipsisMask|=1<<Z.dims,Z.dims++);const te={dims:m.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};LC(Z,te);let xe=!0,le=!0,he=!0;const de=[],me=[];for(let ge=0;ge<m.length;++ge){if(te.strides[ge]===0)throw Error("strides["+ge+"] must be non-zero");const be=!!(te.shrinkAxisMask&1<<ge),ye=m[ge];if(ye===-1){de.push(be?1:-1);continue}const ve=[te.beginMask&1<<ge,te.endMask&1<<ge],Ie=[te.strides[ge]>0?0:-1,te.strides[ge]>0?ye:ye-1];if(be&&te.strides[ge]<=0)throw Error("only stride 1 allowed on non-range indexing.");he=he&&te.strides[ge]===1;const je=!!(te.beginMask&1<<ge&&te.endMask&1<<ge);if(te.beginValid&&te.endValid){if(be){const gt=te.begin[ge]<0?ye+te.begin[ge]:te.begin[ge];if(te.begin[ge]=gt,te.end[ge]=te.begin[ge]+1,gt<0||gt>=ye)throw Error("slice index "+te.begin[ge]+" of dimension "+ge+" out of bounds.")}else te.begin[ge]=LL(te.begin[ge],0,te.strides[ge],ye,ve,Ie),te.end[ge]=LL(te.end[ge],1,te.strides[ge],ye,ve,Ie);const bt=te.strides[ge]===1&&te.begin[ge]===0&&te.end[ge]===ye;xe=xe&&bt,le=le&&(ge===0&&te.strides[ge]===1||bt)}else xe=xe&&te.strides[ge]===1&&je,le=le&&(ge===0&&te.strides[ge]===1||je);let Me,xt=!1;if(te.beginValid&&te.endValid?(Me=te.end[ge]-te.begin[ge],xt=!0):be?(Me=1,xt=!0):je&&ye>=0&&(te.strides[ge]<0?Me=-ye:Me=ye,xt=!0),xt){let bt;Me===0||Me<0!=te.strides[ge]<0?bt=0:bt=Math.trunc(Me/te.strides[ge])+(Me%te.strides[ge]!==0?1:0),de.push(bt)}else de.push(-1)}for(let ge=0;ge<te.finalShapeGatherIndices.length;++ge){const be=te.finalShapeGatherIndices[ge];be>=0?me.push(de[be]):be===Ca&&me.push(1)}return{finalShapeSparse:me.filter((ge,be)=>te.finalShapeGatherIndices[be]!==Ca),finalShape:me,isIdentity:xe,sliceDim0:le,isSimpleSlice:he,begin:te.begin,end:te.end,strides:te.strides}}function LC(m,d){d.beginMask=0,d.endMask=0,d.shrinkAxisMask=0;let p=0;d.beginValid=m.begin!=null,d.endValid=m.end!=null,d.begin=new Array(d.dims),d.end=new Array(d.dims),d.strides=new Array(d.dims),d.finalShapeGatherIndices=[],d.finalShapeGatherIndicesSparse=[],d.inputShapeGatherIndicesSparse=new Array(d.dims);for(let _=0;_<m.dims;_++)if(1<<_&m.ellipsisMask){const E=Math.min(d.dims-(m.dims-_)+1+m.numAddAxisAfterEllipsis,d.dims);for(;p<E;p++)d.begin[p]=0,d.end[p]=0,d.strides[p]=1,d.beginMask|=1<<p,d.endMask|=1<<p,d.finalShapeGatherIndices.push(p),d.finalShapeGatherIndicesSparse.push(-1),d.inputShapeGatherIndicesSparse[p]=_}else if(1<<_&m.newAxisMask)d.finalShapeGatherIndices.push(Ca),d.finalShapeGatherIndicesSparse.push(-1);else{if(p===d.begin.length)throw Error("Index out of range using input dim "+p+"; input has only "+d.dims+" dims, "+d.begin.length+".");m.begin!=null&&(d.begin[p]=m.begin[_]),m.end!=null&&(d.end[p]=m.end[_]),d.strides[p]=m.strides[_],m.beginMask&1<<_&&(d.beginMask|=1<<p),m.endMask&1<<_&&(d.endMask|=1<<p),m.shrinkAxisMask&1<<_?(d.finalShapeGatherIndices.push(CV),d.finalShapeGatherIndicesSparse.push(-1),d.shrinkAxisMask|=1<<p):(d.finalShapeGatherIndices.push(p),d.finalShapeGatherIndicesSparse.push(_)),d.inputShapeGatherIndicesSparse[p]=_,p++}}function LL(m,d,p,_,E,S){if(E[d])return p>0?S[d]:S[d+1&1];{const I=m<0?_+m:m;return I<S[0]?S[0]:I>S[1]?S[1]:I}}var LK=Object.freeze({__proto__:null,assertParamsValid:Cg,computeFlatOffset:LG,computeOutShape:L1,getNormalizedAxes:L5,isSliceContinous:Lc,maskToAxes:L0,parseSliceParams:Ls,sliceInfo:Lz,startForAxis:L9,startIndicesWithElidedDims:L6,stopForAxis:Lo,stopIndicesWithElidedDims:L7,stridesForAxis:L8,stridesWithElidedDims:L2});function Lr(m,d){let p=sd(m,"a","add"),_=sd(d,"b","add");[p,_]=sO(p,_);const E={a:p,b:_};return sj.runKernel(oD,E)}const LT=sJ({add_:Lr});function Lq(m,d){let p=sd(m,"a","floorDiv"),_=sd(d,"b","floorDiv");[p,_]=sO(p,_);const E={a:p,b:_};return sj.runKernel(ob,E)}const LQ=sJ({floorDiv_:Lq});function Lk(m,d){let p=sd(m,"a","div"),_=sd(d,"b","div");if([p,_]=sO(p,_),p.dtype==="int32"&&_.dtype==="int32")return LQ(p,_);const E={a:p,b:_},S={};return sj.runKernel(ot,E,S)}const Lp=sJ({div_:Lk});function Lw(m,d){let p=sd(m,"a","mul"),_=sd(d,"b","mul");[p,_]=sO(p,_);const E={a:p,b:_};return sj.runKernel(cs,E)}const LA=sJ({mul_:Lw});function LZ(m){const d=sd(m,"x","abs");if(d.dtype==="complex64"){const p={x:d};return sj.runKernel(oH,p)}else{const p={x:d};return sj.runKernel(oO,p)}}const LF=sJ({abs_:LZ});function LN(m){A(Array.isArray(m),()=>"The argument passed to tf.addN() must be a list of tensors"),A(m.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+m.length);const d=m.map((E,S)=>sd(E,"tensors"+S,"addN")),p=d[0];d.forEach(E=>{if(E.dtype!==p.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),d.forEach(E=>{if(!i(E.shape,p.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const _=d;return sj.runKernel(on,_)}const LO=sJ({addN_:LN});function LD(m,d){let p=sd(m,"a","atan2"),_=sd(d,"b","atan2");[p,_]=sO(p,_);const E={a:p,b:_};return sj.runKernel(oi,E)}const Ln=sJ({atan2_:LD});function Li(m,d,p,_,E="NHWC",S){const I=m[3],D=[...d,I],k=LU(E);return LS(m,D,p,S,_,null,null,k)}function Le(m,d,p,_,E,S,I="channelsLast"){const[D,k]=LH(d);let V;if(I==="channelsLast")V=[D,k,m[3],m[3]];else if(I==="channelsFirst")V=[D,k,m[1],m[1]];else throw new Error("Unknown dataFormat "+I);return LS(m,V,p,_,E,S,!1,I)}function LP(m,d,p,_,E,S,I="NDHWC"){const[D,k,V]=Lu(d);let $,Z;if(I==="NDHWC")Z="channelsLast",$=[D,k,V,m[4],m[4]];else if(I==="NCDHW")Z="channelsFirst",$=[D,k,V,m[1],m[1]];else throw new Error("Unknown dataFormat "+I);return LI(m,$,p,_,E,!1,Z,S)}function LS(m,d,p,_,E,S,I=!1,D="channelsLast"){let[k,V,$,Z]=[-1,-1,-1,-1];if(D==="channelsLast")[k,V,$,Z]=m;else if(D==="channelsFirst")[k,Z,V,$]=m;else throw new Error("Unknown dataFormat "+D);const[te,xe,,le]=d,[he,de]=LH(p),[me,ge]=LH(_),be=LX(te,me),ye=LX(xe,ge),{padInfo:ve,outHeight:Ie,outWidth:je}=Lf(E,V,$,he,de,be,ye,S,D),Me=I?le*Z:le;let xt;return D==="channelsFirst"?xt=[k,Me,Ie,je]:D==="channelsLast"&&(xt=[k,Ie,je,Me]),{batchSize:k,dataFormat:D,inHeight:V,inWidth:$,inChannels:Z,outHeight:Ie,outWidth:je,outChannels:Me,padInfo:ve,strideHeight:he,strideWidth:de,filterHeight:te,filterWidth:xe,effectiveFilterHeight:be,effectiveFilterWidth:ye,dilationHeight:me,dilationWidth:ge,inShape:m,outShape:xt,filterShape:d}}function LI(m,d,p,_,E,S=!1,I="channelsLast",D){let[k,V,$,Z,te]=[-1,-1,-1,-1,-1];if(I==="channelsLast")[k,V,$,Z,te]=m;else if(I==="channelsFirst")[k,te,V,$,Z]=m;else throw new Error("Unknown dataFormat "+I);const[xe,le,he,,de]=d,[me,ge,be]=Lu(p),[ye,ve,Ie]=Lu(_),je=LX(xe,ye),Me=LX(le,ve),xt=LX(he,Ie),{padInfo:bt,outDepth:gt,outHeight:Xt,outWidth:Ut}=Ly(E,V,$,Z,me,ge,be,je,Me,xt,D),Ht=S?de*te:de;let mi;return I==="channelsFirst"?mi=[k,Ht,gt,Xt,Ut]:I==="channelsLast"&&(mi=[k,gt,Xt,Ut,Ht]),{batchSize:k,dataFormat:I,inDepth:V,inHeight:$,inWidth:Z,inChannels:te,outDepth:gt,outHeight:Xt,outWidth:Ut,outChannels:Ht,padInfo:bt,strideDepth:me,strideHeight:ge,strideWidth:be,filterDepth:xe,filterHeight:le,filterWidth:he,effectiveFilterDepth:je,effectiveFilterHeight:Me,effectiveFilterWidth:xt,dilationDepth:ye,dilationHeight:ve,dilationWidth:Ie,inShape:m,outShape:mi,filterShape:d}}function LB(m,d,p,_,E){_==null&&(_=LR(m,d,p));const S=m[0],I=m[1],D=LE((S-d+2*_)/p+1,E),k=LE((I-d+2*_)/p+1,E);return[D,k]}function Lj(m,d,p,_,E,S){E==null&&(E=LR(m,d[0],_[0]));const I=[0,0,0,p];for(let D=0;D<3;D++)m[D]+2*E>=d[D]&&(I[D]=LE((m[D]-d[D]+2*E)/_[D]+1,S));return I}function LR(m,d,p,_=1){const E=LX(d,_);return Math.floor((m[0]*(p-1)-p+E)/2)}function LH(m){return typeof m=="number"?[m,m,m]:m.length===2?[m[0],m[1],1]:m}function Lu(m){return typeof m=="number"?[m,m,m]:m}function LX(m,d){return d<=1?m:m+(m-1)*(d-1)}function Lf(m,d,p,_,E,S,I,D,k){let V,$,Z;if(typeof m=="number"){V={top:m,bottom:m,left:m,right:m,type:m===0?"VALID":"NUMBER"};const te=LB([d,p],S,_,m,D);$=te[0],Z=te[1]}else if(m==="same"){$=Math.ceil(d/_),Z=Math.ceil(p/E);const te=Math.max(0,($-1)*_+S-d),xe=Math.max(0,(Z-1)*E+I-p),le=Math.floor(te/2),he=te-le,de=Math.floor(xe/2),me=xe-de;V={top:le,bottom:he,left:de,right:me,type:"SAME"}}else if(m==="valid")V={top:0,bottom:0,left:0,right:0,type:"VALID"},$=Math.ceil((d-S+1)/_),Z=Math.ceil((p-I+1)/E);else if(typeof m=="object"){const te=k==="channelsLast"?m[1][0]:m[2][0],xe=k==="channelsLast"?m[1][1]:m[2][1],le=k==="channelsLast"?m[2][0]:m[3][0],he=k==="channelsLast"?m[2][1]:m[3][1];V={top:te,bottom:xe,left:le,right:he,type:te===0&&xe===0&&le===0&&he===0?"VALID":"EXPLICIT"},$=LE((d-S+te+xe)/_+1,D),Z=LE((p-I+le+he)/E+1,D)}else throw Error("Unknown padding parameter: "+m);return{padInfo:V,outHeight:$,outWidth:Z}}function Ly(m,d,p,_,E,S,I,D,k,V,$){let Z,te,xe,le;if(m==="valid"&&(m=0),typeof m=="number"){Z={top:m,bottom:m,left:m,right:m,front:m,back:m,type:m===0?"VALID":"NUMBER"};const he=Lj([d,p,_,1],[D,k,V],1,[E,S,I],m,$);te=he[0],xe=he[1],le=he[2]}else if(m==="same"){te=Math.ceil(d/E),xe=Math.ceil(p/S),le=Math.ceil(_/I);const he=(te-1)*E+D-d,de=(xe-1)*S+k-p,me=(le-1)*I+V-_,ge=Math.floor(he/2),be=he-ge,ye=Math.floor(de/2),ve=de-ye,Ie=Math.floor(me/2),je=me-Ie;Z={top:ye,bottom:ve,left:Ie,right:je,front:ge,back:be,type:"SAME"}}else throw Error("Unknown padding parameter: "+m);return{padInfo:Z,outDepth:te,outHeight:xe,outWidth:le}}function LE(m,d){if(!d)return Math.trunc(m);switch(d){case"round":return Math.round(m);case"ceil":return Math.ceil(m);case"floor":return Math.floor(m);default:throw new Error("Unknown roundingMode "+d)}}function LW(m){const[d,p,_]=LH(m);return d===1&&p===1&&_===1}function Ld(m,d){return LW(m)||LW(d)}function LM(m){return LH(m).every(d=>d>0)}function LU(m){if(m==="NHWC")return"channelsLast";if(m==="NCHW")return"channelsFirst";throw new Error("Unknown dataFormat "+m)}function LJ(m,d,p){if(p!=null){if(typeof d=="string")throw Error("Error in "+m+": pad must be an integer when using dimRoundingMode "+p+" but got pad "+d+".");if(typeof d=="number")A(e(d),()=>"Error in "+m+": pad must be an integer when using dimRoundingMode "+p+" but got pad "+d+".");else if(typeof d=="object")d.forEach(_=>{_.forEach(E=>{A(e(E),()=>"Error in "+m+": pad must be an integer when using dimRoundingMode "+p+" but got pad "+E+".")})});else throw Error("Error in "+m+": Unknown padding parameter: "+d)}}function Lt(m,d){const p={x:sd(m,"x","reshape","string_or_numeric")},_={shape:d};return sj.runKernel(cA,p,_)}const Lv=sJ({reshape_:Lt});function Lh(m,d,p,_,E){const S=sd(m,"x","avgPool","float32"),I=1;A(Ld(p,I),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+p+" and dilations '"+I+"'");let D=S,k=!1;S.rank===3&&(k=!0,D=Lv(S,[1,S.shape[0],S.shape[1],S.shape[2]])),A(D.rank===4,()=>"Error in avgPool: x must be rank 4 but got rank "+D.rank+"."),LJ("avgPool",_,E);const V={x:D},$={filterSize:d,strides:p,pad:_,dimRoundingMode:E};let Z=sj.runKernel(oe,V,$);return Z=CB(Z,S.dtype),k?Lv(Z,[Z.shape[1],Z.shape[2],Z.shape[3]]):Z}const LY=sJ({avgPool_:Lh});function Lm(m){const d={x:sd(m,"x","clone","string_or_numeric")};return sj.runKernel(c0,d)}const Lx=sJ({clone_:Lm});function Ll(m,d=0){A(m.length>=1,()=>"Pass at least one tensor to concat");const p=sM(m,"tensors","concat","string_or_numeric");if(p[0].dtype==="complex64"&&p.forEach(S=>{if(S.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype `+S.dtype+". ")}),p.length===1)return Lx(p[0]);const _=p,E={axis:d};return sj.runKernel(ou,_,E)}const Lb=sJ({concat_:Ll});function La(m){const d={x:sd(m,"x","sigmoid","float32")};return sj.runKernel(cP,d)}const LV=sJ({sigmoid_:La});function Lg(m,d,p){const _=sd(m,"x","slice","string_or_numeric");if(_.rank===0)throw new Error("Slicing scalar is not possible");const E={x:_},S={begin:d,size:p};return sj.runKernel(ci,E,S)}const K0=sJ({slice_:Lg});function K1(m,d,p){const _=sd(m,"x","batchToSpaceND"),E=d.reduce((D,k)=>D*k);A(_.rank>=1+d.length,()=>"input rank is "+_.rank+" but should be > than blockShape.length "+d.length),A(p.length===d.length,()=>"crops.length is "+p.length+" but should be equal to blockShape.length  "+d.length),A(_.shape[0]%E===0,()=>"input tensor batch is "+_.shape[0]+" but is not divisible by the product of the elements of blockShape "+d.join(" * ")+" === "+E);const S={x:_},I={blockShape:d,crops:p};return sj.runKernel(oS,S,I)}const K2=sJ({batchToSpaceND_:K1});function K3(m,d,p){const _=sd(m,"x","bincount"),E=sd(d,"weights","bincount");A(_.dtype==="int32",()=>"Error in bincount: input dtype must be int32, but got "+_.dtype),A(p>=0,()=>"size must be non-negative, but got "+p+"."),A(E.size===_.size||E.size===0,()=>"Error in bincount: weights must have the same size as input or0-length, but got input shape: "+_.shape+", weights shape: "+E.shape+".");const S={x:_,weights:E},I={size:p};return sj.runKernel(oI,S,I)}const K4=sJ({bincount_:K3});function K5(m,d){let p=sd(m,"broadcastTo","x");const _=p.shape;if(oG(d),d.length<p.rank)throw new Error("broadcastTo(): shape.length="+d.length+" < input.rank="+p.rank+".");if(d.length>p.rank){const k=p.shape.slice();for(;k.length<d.length;)k.unshift(1);p=Lv(p,k)}const E=p.shape,S=Array.from(d);for(let k=d.length-1;k>=0;k--)if(E[k]===d[k])S[k]=1;else if(p.shape[k]!==1)throw new Error("broadcastTo(): ["+_+"] cannot be broadcast to ["+d+"].");if(S.map((k,V)=>k>1?V:-1).filter(k=>k>=0).length===0)return Lx(p);const I={x:p},D={reps:S};return sj.runKernel(cX,I,D)}const K6=sJ({broadcastTo_:K5});function K7(m,d="float32",p){return d=d||"float32",oG(m),new so(m,d,p)}function K8(m,d,p){oG(m),p=p||o3(d);const _={shape:m,value:d,dtype:p};return sj.runKernel(om,{},_)}function K9(m,d,p){const _=sd(m,"x","clipByValue");if(A(d<=p,()=>"Error in clip: min ("+d+") must be less than or equal to max ("+p+")."),d===p)return K8(_.shape,d,_.dtype);const E={x:_},S={clipValueMin:d,clipValueMax:p};return sj.runKernel(oj,E,S)}const Ko=sJ({clipByValue_:K9});function Kc(m,d){return Lb(m,d)}const KG=sJ({concat2d_:Kc});function Ks(m,d){return Lb(m,d)}const Kz=sJ({concat3d_:Ks});function KC(m,d,p,_,E="NHWC",S=[1,1],I){const D=sd(m,"x","conv2d","float32"),k=sd(d,"filter","conv2d","float32");let V=D,$=!1;D.rank===3&&($=!0,V=Lv(D,[1,D.shape[0],D.shape[1],D.shape[2]])),A(V.rank===4,()=>"Error in conv2d: input must be rank 4, but got rank "+V.rank+"."),A(k.rank===4,()=>"Error in conv2d: filter must be rank 4, but got rank "+k.rank+"."),LJ("conv2d",_,I);const Z=E==="NHWC"?V.shape[3]:V.shape[1];A(Z===k.shape[2],()=>"Error in conv2d: depth of input ("+Z+") must match input depth for filter "+k.shape[2]+"."),A(Ld(p,S),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+p+" and dilations '"+S+"'"),A(LM(S),()=>"Error in conv2D: Dilated rates should be larger than 0."),A(LM(p),()=>"Error in conv2D: Strides should be larger than 0.");const te={x:V,filter:k},xe={strides:p,pad:_,dataFormat:E,dilations:S,dimRoundingMode:I},le=sj.runKernel(oX,te,xe);return $?Lv(le,[le.shape[1],le.shape[2],le.shape[3]]):le}const KL=sJ({conv2d_:KC});function KK(m,d,p,_,E,S="NHWC",I){A(m.length===d.rank,()=>"Length of inShape ("+m.length+") and rank of dy ("+d.rank+") must match");let D=m,k=d,V=!1;d.rank===3&&(V=!0,k=Lv(d,[1,d.shape[0],d.shape[1],d.shape[2]]),D=[1,m[0],m[1],m[2]]),A(D.length===4,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+D.length+"."),A(k.rank===4,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+k.rank),A(p.rank===4,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+p.rank);const $=S==="NHWC"?D[3]:D[1],Z=S==="NHWC"?k.shape[3]:k.shape[1];A($===p.shape[2],()=>"Error in conv2dDerInput: depth of input ("+$+") must match input depth for filter "+p.shape[2]+"."),A(Z===p.shape[3],()=>"Error in conv2dDerInput: depth of output ("+Z+") must match output depth for filter "+p.shape[3]+"."),LJ("conv2dDerInput",E,I);const te={dy:k,filter:p},xe={strides:_,pad:E,dataFormat:S,dimRoundingMode:I,inputShape:D},le=sj.runKernel(oy,te,xe);return V?Lv(le,[le.shape[1],le.shape[2],le.shape[3]]):le}const Kr=sJ({conv2DBackpropInput_:KK});function KT(m,d,p,_,E,S){const I=sd(m,"x","conv2dTranspose"),D=sd(d,"filter","conv2dTranspose");return Kr(p,I,D,_,E,"NHWC",S)}const Kq=sJ({conv2dTranspose_:KT});function KQ(m){const d={x:sd(m,"x","cos","float32")};return sj.runKernel(oE,d)}const Kk=sJ({cos_:KQ});function Kp(m,d,p="NHWC"){const _=sd(m,"x","depthToSpace","float32"),E=p==="NHWC"?_.shape[1]:_.shape[2],S=p==="NHWC"?_.shape[2]:_.shape[3],I=p==="NHWC"?_.shape[3]:_.shape[1];A(d>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+d),A(E*d>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+E+" and "+d+`  for depthToSpace with input shape
    `+_.shape),A(S*d>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+S+" and "+d+` for depthToSpace with input shape
        `+_.shape),A(I%(d*d)===0,()=>"Dimension size must be evenly divisible by "+d*d+" but is "+I+" for depthToSpace with input shape "+_.shape);const D={x:_},k={blockSize:d,dataFormat:p};return sj.runKernel(od,D,k)}const Kw=sJ({depthToSpace_:Kp});function KA(m,d,p,_,E="NHWC",S=[1,1],I){const D=sd(m,"x","depthwiseConv2d","float32"),k=sd(d,"filter","depthwiseConv2d","float32");let V=D,$=!1;D.rank===3&&($=!0,V=Lv(D,[1,D.shape[0],D.shape[1],D.shape[2]])),A(V.rank===4,()=>"Error in depthwiseConv2d: input must be rank 4, but got rank "+V.rank+"."),A(k.rank===4,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+k.rank+".");const Z=E==="NHWC"?V.shape[3]:V.shape[1];A(Z===k.shape[2],()=>"Error in depthwiseConv2d: number of input channels ("+Z+") must match the inChannels dimension in filter "+k.shape[2]+"."),LJ("depthwiseConv2d",_,I);const te={x:V,filter:k},xe={strides:p,pad:_,dataFormat:E,dilations:S,dimRoundingMode:I},le=sj.runKernel(oM,te,xe);return $?Lv(le,[le.shape[1],le.shape[2],le.shape[3]]):le}const KZ=sJ({depthwiseConv2d_:KA});function KF(m,d,p){const _=sd(d,"a","where"),E=sd(p,"b","where"),S=sd(m,"condition","where","bool"),I=CJ(CJ(S.shape,_.shape),E.shape),D=K6(S,I),k=K6(_,I),V=K6(E,I),$={condition:D,t:k,e:V};return sj.runKernel(cn,$)}const KN=sJ({where_:KF});function KO(m){const d={x:sd(m,"x","zerosLike")};return sj.runKernel(cW,d)}const KD=sJ({zerosLike_:KO});function Kn(m,...d){const p=d.map((E,S)=>sd(E,"tensors"+S,"einsum")),_={equation:m};return sj.runKernel(ov,p,_)}const Ki=sJ({einsum_:Kn});function Ke(m){const d={x:sd(m,"x","elu","float32")};return sj.runKernel(oh,d)}const KP=sJ({elu_:Ke});function KS(m,d){for(let p=0;p<m.length;++p)if(m[m.length-p-1]!==d-1-p)return!1;return!0}function KI(m,d,p){const _=m.length+d.length,E=[];let S=0,I=0;for(let D=0;D<_;D++)p.indexOf(D)===-1?E.push(m[S++]):E.push(d[I++]);return E}function KB(m,d){const p=[],_=m.length;for(let S=0;S<_;S++)d.indexOf(S)===-1&&p.push(m[S]);const E=d.map(S=>m[S]);return[p,E]}function Kj(m,d){const p=d.map(_=>1);return KI(m,p,d)}function KR(m,d,p){A(KS(d,p),()=>m+" supports only inner-most axes for now. Got axes "+d+" and rank-"+p+" input.")}function KH(m,d){if(KS(m,d))return null;const p=[];for(let _=0;_<d;++_)m.indexOf(_)===-1&&p.push(_);return m.forEach(_=>p.push(_)),p}function Ku(m){return m.map((d,p)=>[p,d]).sort((d,p)=>d[1]-p[1]).map(d=>d[0])}function KX(m,d){const p=[];for(let _=d-m;_<d;++_)p.push(_);return p}function Kf(m,d=null,p=!1){const _={x:sd(m,"x","max")},E={reductionIndices:d,keepDims:p};return sj.runKernel(c7,_,E)}const Ky=sJ({max_:Kf});function KE(m,d=null,p=!1){const _={x:sd(m,"x","min")},E={axis:d,keepDims:p};return sj.runKernel(cc,_,E)}const KW=sJ({min_:KE});function Kd(m,d){let p=sd(m,"base","pow"),_=sd(d,"exp","pow");[p,_]=sO(p,_);const E={a:p,b:_};return sj.runKernel(cq,E)}const KM=sJ({pow_:Kd});function KU(m,d){if((Gx(m)&&d!=="string"||Array.isArray(m))&&d!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(d==="string"&&Gx(m)&&!(m instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return sh(m,[],[],d)}function KJ(m){const d={x:sd(m,"x","sqrt","float32")};return sj.runKernel(cS,d)}const Kt=sJ({sqrt_:KJ});function Kv(m){const d=sd(m,"x","square"),p={};return sj.runKernel("Square",{x:d},p)}const Kh=sJ({square_:Kv});function KY(m,d=null,p=!1){let _=sd(m,"x","sum");_.dtype==="bool"&&(_=CB(_,"int32"));const E={x:_},S={axis:d,keepDims:p};return sj.runKernel(cI,E,S)}const Km=sJ({sum_:KY});function Kx(m,d="euclidean",p=null,_=!1){m=sd(m,"x","norm");const E=Kl(m,d,p);let S=E.shape;if(_){const I=X(p,m.shape);S=Kj(E.shape,I)}return Lv(E,S)}function Kl(m,d,p=null){if(m.rank===0)return LF(m);if(m.rank!==1&&p===null)return Kl(Lv(m,[-1]),d,p);if(m.rank===1||typeof p=="number"||Array.isArray(p)&&p.length===1){if(d===1)return Km(LF(m),p);if(d===1/0)return Ky(LF(m),p);if(d===-1/0)return KW(LF(m),p);if(d==="euclidean"||d===2)return Kt(Km(KM(LF(m),KU(2,"int32")),p));throw new Error("Error in norm: invalid ord value: "+d)}if(Array.isArray(p)&&p.length===2){if(d===1)return Ky(Km(LF(m),p[0]),p[1]-1);if(d===1/0)return Ky(Km(LF(m),p[1]),p[0]);if(d===-1/0)return KW(Km(LF(m),p[1]),p[0]);if(d==="fro"||d==="euclidean")return Kt(Km(Kh(m),p));throw new Error("Error in norm: invalid ord value: "+d)}throw new Error("Error in norm: invalid axis: "+p)}const Kb=sJ({norm_:Kx});function Ka(m,d=null,p=!1){return Kb(m,"euclidean",d,p)}const KV=sJ({euclideanNorm_:Ka});function Kg(m,d=0){const p=sd(m,"x","expandDims","string_or_numeric");A(d<=p.rank,()=>"Axis must be <= rank of the tensor");const _={input:p},E={dim:d};return sj.runKernel(oY,_,E)}const r0=sJ({expandDims_:Kg});function r1(m,d){const p=sd(m,"x","tile","string_or_numeric");A(p.rank===d.length,()=>"Error in transpose: rank of input "+p.rank+" must match length of reps "+d+".");const _={x:p},E={reps:d};return sj.runKernel(cX,_,E)}const r2=sJ({tile_:r1});function r3(m){const d={x:sd(m,"x","floor","float32")};return sj.runKernel(ol,d)}const r4=sJ({floor_:r3});function r5(m,d,p=0,_=0){const E=sd(m,"x","gather"),S=sd(d,"indices","gather","int32"),I={x:E,indices:S},D={axis:p,batchDims:_};return sj.runKernel(oa,I,D)}const r6=sJ({gather_:r5});function r7(m,d){let p=sd(m,"a","greater","string_or_numeric"),_=sd(d,"b","greater","string_or_numeric");[p,_]=sO(p,_),CJ(p.shape,_.shape);const E={a:p,b:_};return sj.runKernel(oV,E)}const r8=sJ({greater_:r7});function r9(m,d){let p=sd(m,"a","greaterEqual","string_or_numeric"),_=sd(d,"b","greaterEqual","string_or_numeric");[p,_]=sO(p,_),CJ(p.shape,_.shape);const E={a:p,b:_};return sj.runKernel(og,E)}const ro=sJ({greaterEqual_:r9});function rc(m,d=.2){const p={x:sd(m,"x","leakyRelu")},_={alpha:d};return sj.runKernel(c2,p,_)}const rG=sJ({leakyRelu_:rc});function rs(m,d){let p=sd(m,"a","less","string_or_numeric"),_=sd(d,"b","less","string_or_numeric");[p,_]=sO(p,_),CJ(p.shape,_.shape);const E={a:p,b:_};return sj.runKernel(c3,E)}const rz=sJ({less_:rs});function rC(m,d){let p=sd(m,"a","lessEqual","string_or_numeric"),_=sd(d,"b","lessEqual","string_or_numeric");[p,_]=sO(p,_),CJ(p.shape,_.shape);const E={a:p,b:_};return sj.runKernel(c4,E)}const rL=sJ({lessEqual_:rC});function rK(m){return sj.customGrad(m)}function rr(m,d){let p=sd(m,"a","sub"),_=sd(d,"b","sub");[p,_]=sO(p,_);const E={a:p,b:_};return sj.runKernel(cu,E)}const rT=sJ({sub_:rr});function rq(m,d){const p=sd(m,"a","logicalAnd","bool"),_=sd(d,"b","logicalAnd","bool");CJ(p.shape,_.shape);const E={a:p,b:_};return sj.runKernel(c5,E)}const rQ=sJ({logicalAnd_:rq});function rk(m,d){const p=sd(m,"a","logicalOr","bool"),_=sd(d,"b","logicalOr","bool");CJ(p.shape,_.shape);const E={a:p,b:_};return sj.runKernel(c6,E)}const rp=sJ({logicalOr_:rk});function rw(m,d,p,_,E){const S=sd(m,"x","maxPool"),I=1;let D=S,k=!1;S.rank===3&&(k=!0,D=Lv(S,[1,S.shape[0],S.shape[1],S.shape[2]])),A(D.rank===4,()=>"Error in maxPool: input must be rank 4 but got rank "+D.rank+"."),A(Ld(p,I),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+p+" and dilations '"+I+"'"),LJ("maxPool",_,E);const V={x:D},$={filterSize:d,strides:p,pad:_,dimRoundingMode:E},Z=sj.runKernel(c9,V,$);return k?Lv(Z,[Z.shape[1],Z.shape[2],Z.shape[3]]):Z}const rA=sJ({maxPool_:rw});function rZ(m,d){let p=sd(m,"a","maximum"),_=sd(d,"b","maximum");[p,_]=sO(p,_),p.dtype==="bool"&&(p=CB(p,"int32"),_=CB(_,"int32")),CJ(p.shape,_.shape);const E={a:p,b:_};return sj.runKernel(c8,E)}const rF=sJ({maximum_:rZ});function rN(m,d=null,p=!1){const _={x:sd(m,"x","mean")},E={axis:d,keepDims:p};return sj.runKernel(co,_,E)}const rO=sJ({mean_:rN});function rD(m,d="float32"){if(oG(m),d==="complex64"){const _=rD(m,"float32"),E=rD(m,"float32");return sv(_,E)}const p=oc(n(m),d);return sj.makeTensor(p,m,d)}function rn(m,d="float32"){if(oG(m),d==="complex64"){const _=rn(m,"float32"),E=rD(m,"float32");return sv(_,E)}const p=oo(n(m),d);return sj.makeTensor(p,m,d)}function ri(m,d){let p=sd(m,"a","minimum"),_=sd(d,"b","minimum");[p,_]=sO(p,_),p.dtype==="bool"&&(p=CB(p,"int32"),_=CB(_,"int32")),CJ(p.shape,_.shape);const E={a:p,b:_};return sj.runKernel(cG,E)}const re=sJ({minimum_:ri});function rP(m,d,p=0){const _=sd(m,"x","pad");if(_.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const E={paddings:d,constantValue:p},S={x:_};return sj.runKernel(cT,S,E)}const rS=sJ({pad_:rP});function rI(m,d,p){const _=sd(m,"x","spaceToBatchND");A(_.rank>=1+d.length,()=>"input rank "+_.rank+" should be > than [blockShape] "+d.length),A(p.length===d.length,()=>"paddings.shape[0] "+p.length+" must be equal to [blockShape] "+d.length),A(_.shape.reduce((I,D,k)=>k>0&&k<=d.length?I&&(D+p[k-1][0]+p[k-1][1])%d[k-1]===0:I,!0),()=>"input spatial dimensions "+_.shape.slice(1)+" with paddings "+p.toString()+" must be divisible by blockShapes "+d.toString());const E={x:_},S={blockShape:d,paddings:p};return sj.runKernel(cB,E,S)}const rB=sJ({spaceToBatchND_:rI});function rj(m,d,p,_,E,S,I){E==null&&(E=[1,1]),S==null&&(S=1),_===0&&(_="valid");const D=sd(m,"x","maxPool");let k=D,V=!1;D.rank===3&&(V=!0,k=Lv(D,[1,D.shape[0],D.shape[1],D.shape[2]])),A(Ld(S,E),()=>"Error in pool: Either strides or dilations must be 1. Got strides "+S+" and dilations '"+E+"'");const $=Le(k.shape,d,S,E,_),Z=[$.dilationHeight,$.dilationWidth];let te;_==="same"?te=rH([$.filterHeight,$.filterWidth],Z):te=[[0,0],[0,0]];const xe=Z[0]===1&&Z[1]===1,[le,he]=rR([$.inHeight,$.inWidth],Z,te),de=xe?_:"valid",me=xe?k:rB(k,Z,le),ge=(p==="avg"?()=>LY(me,d,S,de,I):()=>rA(me,d,S,de,I))(),be=xe?ge:K2(ge,Z,he);return V?Lv(be,[be.shape[1],be.shape[2],be.shape[3]]):be}function rR(m,d,p){const _=p.map($=>$[0]),E=p.map($=>$[1]),S=m.concat(_,E),I=d.map(($,Z)=>($-S[Z]%$)%$),D=E.map(($,Z)=>$+I[Z]),k=d.map(($,Z)=>[_[Z],D[Z]]),V=d.map(($,Z)=>[0,I[Z]]);return[k,V]}function rH(m,d){const p=m.map((S,I)=>S+(S-1)*(d[I]-1)).map(S=>S-1),_=p.map(S=>Math.floor(S/2)),E=p.map((S,I)=>S-_[I]);return p.map((S,I)=>[_[I],E[I]])}const ru=sJ({pool_:rj});function rX(m,d){const p=sd(m,"x","prelu"),_=sd(d,"alpha","prelu"),E={x:p,alpha:_};return sj.runKernel(cQ,E)}const rf=sJ({prelu_:rX});function ry(m,d=!1){console.log(m.toString(d))}var rE={exports:{}};rE.exports,function(m){(function(d,p,_){function E(k){var V=this,$=D();V.next=function(){var Z=2091639*V.s0+V.c*23283064365386963e-26;return V.s0=V.s1,V.s1=V.s2,V.s2=Z-(V.c=Z|0)},V.c=1,V.s0=$(" "),V.s1=$(" "),V.s2=$(" "),V.s0-=$(k),V.s0<0&&(V.s0+=1),V.s1-=$(k),V.s1<0&&(V.s1+=1),V.s2-=$(k),V.s2<0&&(V.s2+=1),$=null}function S(k,V){return V.c=k.c,V.s0=k.s0,V.s1=k.s1,V.s2=k.s2,V}function I(k,V){var $=new E(k),Z=V&&V.state,te=$.next;return te.int32=function(){return $.next()*4294967296|0},te.double=function(){return te()+(te()*2097152|0)*11102230246251565e-32},te.quick=te,Z&&(typeof Z=="object"&&S(Z,$),te.state=function(){return S($,{})}),te}function D(){var k=4022871197,V=function($){$=String($);for(var Z=0;Z<$.length;Z++){k+=$.charCodeAt(Z);var te=.02519603282416938*k;k=te>>>0,te-=k,te*=k,k=te>>>0,te-=k,k+=te*4294967296}return(k>>>0)*23283064365386963e-26};return V}p&&p.exports?p.exports=I:_&&_.amd?_(function(){return I}):this.alea=I})(G1,m,!1)}(rE);var rW=rE.exports,rd={exports:{}};rd.exports,function(m){(function(d,p,_){function E(D){var k=this,V="";k.x=0,k.y=0,k.z=0,k.w=0,k.next=function(){var Z=k.x^k.x<<11;return k.x=k.y,k.y=k.z,k.z=k.w,k.w^=k.w>>>19^Z^Z>>>8},D===(D|0)?k.x=D:V+=D;for(var $=0;$<V.length+64;$++)k.x^=V.charCodeAt($)|0,k.next()}function S(D,k){return k.x=D.x,k.y=D.y,k.z=D.z,k.w=D.w,k}function I(D,k){var V=new E(D),$=k&&k.state,Z=function(){return(V.next()>>>0)/4294967296};return Z.double=function(){do var te=V.next()>>>11,xe=(V.next()>>>0)/4294967296,le=(te+xe)/(1<<21);while(le===0);return le},Z.int32=V.next,Z.quick=Z,$&&(typeof $=="object"&&S($,V),Z.state=function(){return S(V,{})}),Z}p&&p.exports?p.exports=I:_&&_.amd?_(function(){return I}):this.xor128=I})(G1,m,!1)}(rd);var rM=rd.exports,rU={exports:{}};rU.exports,function(m){(function(d,p,_){function E(D){var k=this,V="";k.next=function(){var Z=k.x^k.x>>>2;return k.x=k.y,k.y=k.z,k.z=k.w,k.w=k.v,(k.d=k.d+362437|0)+(k.v=k.v^k.v<<4^(Z^Z<<1))|0},k.x=0,k.y=0,k.z=0,k.w=0,k.v=0,D===(D|0)?k.x=D:V+=D;for(var $=0;$<V.length+64;$++)k.x^=V.charCodeAt($)|0,$==V.length&&(k.d=k.x<<10^k.x>>>4),k.next()}function S(D,k){return k.x=D.x,k.y=D.y,k.z=D.z,k.w=D.w,k.v=D.v,k.d=D.d,k}function I(D,k){var V=new E(D),$=k&&k.state,Z=function(){return(V.next()>>>0)/4294967296};return Z.double=function(){do var te=V.next()>>>11,xe=(V.next()>>>0)/4294967296,le=(te+xe)/(1<<21);while(le===0);return le},Z.int32=V.next,Z.quick=Z,$&&(typeof $=="object"&&S($,V),Z.state=function(){return S(V,{})}),Z}p&&p.exports?p.exports=I:_&&_.amd?_(function(){return I}):this.xorwow=I})(G1,m,!1)}(rU);var rJ=rU.exports,rt={exports:{}};rt.exports,function(m){(function(d,p,_){function E(D){var k=this;k.next=function(){var $=k.x,Z=k.i,te,xe;return te=$[Z],te^=te>>>7,xe=te^te<<24,te=$[Z+1&7],xe^=te^te>>>10,te=$[Z+3&7],xe^=te^te>>>3,te=$[Z+4&7],xe^=te^te<<7,te=$[Z+7&7],te=te^te<<13,xe^=te^te<<9,$[Z]=xe,k.i=Z+1&7,xe};function V($,Z){var te,xe=[];if(Z===(Z|0))xe[0]=Z;else for(Z=""+Z,te=0;te<Z.length;++te)xe[te&7]=xe[te&7]<<15^Z.charCodeAt(te)+xe[te+1&7]<<13;for(;xe.length<8;)xe.push(0);for(te=0;te<8&&xe[te]===0;++te);for(te==8?xe[7]=-1:xe[te],$.x=xe,$.i=0,te=256;te>0;--te)$.next()}V(k,D)}function S(D,k){return k.x=D.x.slice(),k.i=D.i,k}function I(D,k){D==null&&(D=+new Date);var V=new E(D),$=k&&k.state,Z=function(){return(V.next()>>>0)/4294967296};return Z.double=function(){do var te=V.next()>>>11,xe=(V.next()>>>0)/4294967296,le=(te+xe)/(1<<21);while(le===0);return le},Z.int32=V.next,Z.quick=Z,$&&($.x&&S($,V),Z.state=function(){return S(V,{})}),Z}p&&p.exports?p.exports=I:_&&_.amd?_(function(){return I}):this.xorshift7=I})(G1,m,!1)}(rt);var rv=rt.exports,rh={exports:{}};rh.exports,function(m){(function(d,p,_){function E(D){var k=this;k.next=function(){var $=k.w,Z=k.X,te=k.i,xe,le;return k.w=$=$+1640531527|0,le=Z[te+34&127],xe=Z[te=te+1&127],le^=le<<13,xe^=xe<<17,le^=le>>>15,xe^=xe>>>12,le=Z[te]=le^xe,k.i=te,le+($^$>>>16)|0};function V($,Z){var te,xe,le,he,de,me=[],ge=128;for(Z===(Z|0)?(xe=Z,Z=null):(Z=Z+"\0",xe=0,ge=Math.max(ge,Z.length)),le=0,he=-32;he<ge;++he)Z&&(xe^=Z.charCodeAt((he+32)%Z.length)),he===0&&(de=xe),xe^=xe<<10,xe^=xe>>>15,xe^=xe<<4,xe^=xe>>>13,he>=0&&(de=de+1640531527|0,te=me[he&127]^=xe+de,le=te==0?le+1:0);for(le>=128&&(me[(Z&&Z.length||0)&127]=-1),le=127,he=512;he>0;--he)xe=me[le+34&127],te=me[le=le+1&127],xe^=xe<<13,te^=te<<17,xe^=xe>>>15,te^=te>>>12,me[le]=xe^te;$.w=de,$.X=me,$.i=le}V(k,D)}function S(D,k){return k.i=D.i,k.w=D.w,k.X=D.X.slice(),k}function I(D,k){D==null&&(D=+new Date);var V=new E(D),$=k&&k.state,Z=function(){return(V.next()>>>0)/4294967296};return Z.double=function(){do var te=V.next()>>>11,xe=(V.next()>>>0)/4294967296,le=(te+xe)/(1<<21);while(le===0);return le},Z.int32=V.next,Z.quick=Z,$&&($.X&&S($,V),Z.state=function(){return S(V,{})}),Z}p&&p.exports?p.exports=I:_&&_.amd?_(function(){return I}):this.xor4096=I})(G1,m,!1)}(rh);var rY=rh.exports,rm={exports:{}};rm.exports,function(m){(function(d,p,_){function E(D){var k=this,V="";k.next=function(){var Z=k.b,te=k.c,xe=k.d,le=k.a;return Z=Z<<25^Z>>>7^te,te=te-xe|0,xe=xe<<24^xe>>>8^le,le=le-Z|0,k.b=Z=Z<<20^Z>>>12^te,k.c=te=te-xe|0,k.d=xe<<16^te>>>16^le,k.a=le-Z|0},k.a=0,k.b=0,k.c=-1640531527,k.d=1367130551,D===Math.floor(D)?(k.a=D/4294967296|0,k.b=D|0):V+=D;for(var $=0;$<V.length+20;$++)k.b^=V.charCodeAt($)|0,k.next()}function S(D,k){return k.a=D.a,k.b=D.b,k.c=D.c,k.d=D.d,k}function I(D,k){var V=new E(D),$=k&&k.state,Z=function(){return(V.next()>>>0)/4294967296};return Z.double=function(){do var te=V.next()>>>11,xe=(V.next()>>>0)/4294967296,le=(te+xe)/(1<<21);while(le===0);return le},Z.int32=V.next,Z.quick=Z,$&&(typeof $=="object"&&S($,V),Z.state=function(){return S(V,{})}),Z}p&&p.exports?p.exports=I:_&&_.amd?_(function(){return I}):this.tychei=I})(G1,m,!1)}(rm);var rx=rm.exports,rl={exports:{}};(function(m){(function(d,p,_){var E=256,S=6,I=52,D="random",k=_.pow(E,S),V=_.pow(2,I),$=V*2,Z=E-1,te;function xe(ye,ve,Ie){var je=[];ve=ve==!0?{entropy:!0}:ve||{};var Me=me(de(ve.entropy?[ye,be(p)]:ye??ge(),3),je),xt=new le(je),bt=function(){for(var gt=xt.g(S),Xt=k,Ut=0;gt<V;)gt=(gt+Ut)*E,Xt*=E,Ut=xt.g(1);for(;gt>=$;)gt/=2,Xt/=2,Ut>>>=1;return(gt+Ut)/Xt};return bt.int32=function(){return xt.g(4)|0},bt.quick=function(){return xt.g(4)/4294967296},bt.double=bt,me(be(xt.S),p),(ve.pass||Ie||function(gt,Xt,Ut,Ht){return Ht&&(Ht.S&&he(Ht,xt),gt.state=function(){return he(xt,{})}),Ut?(_[D]=gt,Xt):gt})(bt,Me,"global"in ve?ve.global:this==_,ve.state)}function le(ye){var ve,Ie=ye.length,je=this,Me=0,xt=je.i=je.j=0,bt=je.S=[];for(Ie||(ye=[Ie++]);Me<E;)bt[Me]=Me++;for(Me=0;Me<E;Me++)bt[Me]=bt[xt=Z&xt+ye[Me%Ie]+(ve=bt[Me])],bt[xt]=ve;(je.g=function(gt){for(var Xt,Ut=0,Ht=je.i,mi=je.j,gi=je.S;gt--;)Xt=gi[Ht=Z&Ht+1],Ut=Ut*E+gi[Z&(gi[Ht]=gi[mi=Z&mi+Xt])+(gi[mi]=Xt)];return je.i=Ht,je.j=mi,Ut})(E)}function he(ye,ve){return ve.i=ye.i,ve.j=ye.j,ve.S=ye.S.slice(),ve}function de(ye,ve){var Ie=[],je=typeof ye,Me;if(ve&&je=="object")for(Me in ye)try{Ie.push(de(ye[Me],ve-1))}catch{}return Ie.length?Ie:je=="string"?ye:ye+"\0"}function me(ye,ve){for(var Ie=ye+"",je,Me=0;Me<Ie.length;)ve[Z&Me]=Z&(je^=ve[Z&Me]*19)+Ie.charCodeAt(Me++);return be(ve)}function ge(){try{var ye;return te&&(ye=te.randomBytes)?ye=ye(E):(ye=new Uint8Array(E),(d.crypto||d.msCrypto).getRandomValues(ye)),be(ye)}catch{var ve=d.navigator,Ie=ve&&ve.plugins;return[+new Date,d,Ie,d.screen,be(p)]}}function be(ye){return String.fromCharCode.apply(0,ye)}if(me(_.random(),p),m.exports){m.exports=xe;try{te=__webpack_require__(742)}catch{}}else _["seed"+D]=xe})(typeof self<"u"?self:G1,[],Math)})(rl);var rb=rl.exports,ra=rW,rV=rM,rg=rJ,T0=rv,T1=rY,T2=rx,T3=rb;T3.alea=ra,T3.xor128=rV,T3.xorwow=rg,T3.xorshift7=T0,T3.xor4096=T1,T3.tychei=T2;function T4(m,d,p=1,_="float32"){if(p===0)throw new Error("Cannot have a step of zero");const E={start:m,stop:d,step:p,dtype:_};return sj.runKernel(ck,{},E)}function T5(m){const d={x:sd(m,"x","relu")};return sj.runKernel(cw,d)}const T6=sJ({relu_:T5});function T7(m){const d={x:sd(m,"x","relu6")};return sj.runKernel(cN,d)}const T8=sJ({relu6_:T7});function T9(m){const d={x:sd(m,"x","round")};return sj.runKernel(cO,d)}const To=sJ({round_:T9});function Tc(m){const d={x:sd(m,"x","sin","float32")};return sj.runKernel(ce,d)}const TG=sJ({sin_:Tc});function Ts(m,d,p){const _=sd(m,"x","slice3d");return A(_.rank===3,()=>"slice3d expects a rank-3 tensor, but got a rank-"+_.rank+" tensor"),K0(_,d,p)}const Tz=sJ({slice3d_:Ts});function TC(m,d,p=0){const _={x:sd(m,"x","split")},E={numOrSizeSplits:d,axis:p};return sj.runKernel(cj,_,E)}const TL=sJ({split_:TC});function TK(m,d){const p=sd(m,"x","squeeze","string_or_numeric");return Lv(p,f(p.shape,d).newShape)}const Tr=sJ({squeeze_:TK});function TT(m,d=0){const p=sM(m,"tensors","stack","string_or_numeric");A(p.length>=1,()=>"Pass at least one tensor to tf.stack"),p.length>0&&A(d<=p[0].rank,()=>"Axis must be <= rank of the tensor");const _=p,E={axis:d};return sj.runKernel(cr,_,E)}const Tq=sJ({stack_:TT});function TQ(m,d=0){const p={x:sd(m,"x","step")},_={alpha:d};return sj.runKernel(cd,p,_)}const Tk=sJ({step_:TQ});function Tp(m,d,p,_,E=0,S=0,I=0,D=0,k=0){const V={x:sd(m,"x","stridedSlice","string_or_numeric")},$={begin:d,end:p,strides:_,beginMask:E,endMask:S,ellipsisMask:I,newAxisMask:D,shrinkAxisMask:k};return sj.runKernel(cH,V,$)}const Tw=sJ({stridedSlice_:Tp});function TA(m,d){O(m);const p=sy(m,d);if(p.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return sh(m,null,p,d)}function TZ(m,d,p){if(O(m),d!=null&&d.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const _=sy(m,p);if(_.length!==2&&_.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(_.length===1&&d==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return sh(m,d,_,p)}function TF(m,d,p){const _=sd(m,"tensor","tensorScatterupdate"),E=sd(d,"indices","tensorScatterupdate","int32"),S=sd(p,"updates","tensorScatterupdate");if(Cl(S,E,_.shape),_.dtype!==S.dtype)throw new Error("tensor and updates must have the same dtype, instead they are "+_.dtype+" and "+S.dtype+".");const I={tensor:_,indices:E,updates:S},D={};return sj.runKernel(cD,I,D)}sJ({tensorScatterUpdate_:TF});function TN(m,d=0){const p=sd(m,"x","unstack","string_or_numeric");A(d>=-p.shape.length&&d<p.shape.length,()=>"Axis = "+d+" is not in [-"+p.shape.length+", "+p.shape.length+")");const _={value:p},E={axis:d};return sj.runKernel(cE,_,E)}const TO=sJ({unstack_:TN});function TD(m,d){const p=[];for(let S=0;S<d.length;S++)d[S]&&p.push(S);const _=K7(m,"int32"),E=K7([p.length,m.length],"int32");for(let S=0;S<p.length;S++){const I=_.indexToLoc(p[S]),D=S*m.length;E.values.set(I,D)}return E.toTensor()}function Tn(m,d,p,_,E,S="NHWC",I){let D=m;m.rank===3&&(D=Lv(m,[1,m.shape[0],m.shape[1],m.shape[2]]));let k=d;k.rank===3&&(k=Lv(d,[1,d.shape[0],d.shape[1],d.shape[2]])),A(D.rank===4,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+D.shape+"."),A(k.rank===4,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+k.shape+"."),A(p.length===4,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+p+".");const V=S==="NHWC"?D.shape[3]:D.shape[1],$=S==="NHWC"?k.shape[3]:k.shape[1];A(V===p[2],()=>"Error in conv2dDerFilter: depth of input "+V+") must match input depth in filter ("+p[2]+"."),A($===p[3],()=>"Error in conv2dDerFilter: depth of dy ("+$+") must match output depth for filter ("+p[3]+")."),LJ("conv2dDerFilter",E,I);const Z={x:D,dy:k},te={strides:_,pad:E,dataFormat:S,dimRoundingMode:I,filterShape:p};return sj.runKernel(of,Z,te)}const Ti=sJ({conv2DBackpropFilter_:Tn});function Te(m,d,p){if(p==null||p==="linear")return m;if(p==="relu")return LA(m,Tk(d));throw new Error("Cannot compute gradient for fused activation "+p+".")}function TP(m,d){let p=d;const _=CU(m.shape,d.shape);return _.length>0&&(p=Km(p,_)),Lv(p,m.shape)}function TS(m,d,p,_){if(d==="linear")return m;if(d==="relu")return T6(m);if(d==="elu")return KP(m);if(d==="relu6")return T8(m);if(d==="prelu")return rf(m,p);if(d==="leakyrelu")return rG(m,_);if(d==="sigmoid")return LV(m);throw new Error("Unknown fused activation "+d+".")}const TI=(m,d)=>!(m>0)||d==="linear";function TB({x:m,filter:d,strides:p,pad:_,dataFormat:E="NHWC",dilations:S=[1,1],dimRoundingMode:I,bias:D,activation:k="linear",preluActivationWeights:V,leakyreluAlpha:$}){if(k=k||"linear",TI(sj.state.gradientDepth,k)===!1){A(E==="NHWC",()=>"Error in fused conv2d: got dataFormat of "+E+" but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let Ie=KL(m,d,p,_,E,S,I);return D!=null&&(Ie=LT(Ie,D)),TS(Ie,k,V,$)}const Z=sd(m,"x","conv2d","float32"),te=sd(d,"filter","conv2d","float32");let xe=Z,le=!1;Z.rank===3&&(le=!0,xe=Lv(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2]])),A(xe.rank===4,()=>"Error in fused conv2d: input must be rank 4, but got rank "+xe.rank+"."),A(te.rank===4,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+te.rank+"."),LJ("fused conv2d",_,I);const he=E==="NHWC"?xe.shape[3]:xe.shape[1];A(te.shape[2]===he,()=>"Error in conv2d: depth of input ("+he+") must match input depth for filter "+te.shape[2]+"."),A(Ld(p,S),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+p+" and dilations '"+S+"'");const de=LS(xe.shape,te.shape,p,S,_,I);let me;D!=null&&(me=sd(D,"bias","fused conv2d"),[me]=sO(me,Z),E==="NHWC"?CJ(de.outShape,me.shape):(A(me.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-"+me.shape.length+"."),A(me.shape.length===0||me.shape[0]===de.outChannels||me.shape[0]===1,()=>"Error in fused conv2d: bias shape ("+me.shape+") is not compatible with the number of output channels ("+de.outChannels+")")));let ge;if(V!=null){const Ie=V.shape;if(A(Ie.length<=1||Ie.length===3,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-"+Ie.length+"."),Ie.length===1)A(Ie[0]===1||Ie[0]===de.outChannels,()=>"Error in fused conv2d: PReLU activation weights ("+Ie+") is not compatible with the number of output channels ("+de.outChannels+").");else if(Ie.length===3)try{CJ(Ie,de.outShape)}catch{const Me="Error in fused conv2d: PReLU activation weights ("+Ie+") is not compatible with the output shape of the conv2d ("+de.outShape+").";throw Error(Me)}ge=sd(V,"prelu weights","fused conv2d")}const be=(Ie,je)=>{A(E==="NHWC",()=>"Error in gradient of fused conv2D: got dataFormat of "+E+" but only NHWC is currently supported.");const[Me,xt,bt,gt]=je,Xt=Te(Ie,bt,k);A(LW(S),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+S+"'");const Ut=Kr(xt.shape,Xt,Me,p,_),Ht=Ti(xt,Xt,Me.shape,p,_),mi=[Ut,Ht];if(gt!=null){const gi=TP(gt,Xt);mi.push(gi)}return mi},ye={x:xe,filter:te,bias:me,preluActivationWeights:ge},ve={strides:p,pad:_,dataFormat:E,dilations:S,dimRoundingMode:I,activation:k,leakyreluAlpha:$};return D==null?rK((Ie,je,Me)=>{let xt=sj.runKernel(ct,ye,ve);return Me([je,Ie,xt]),le&&(xt=Lv(xt,[xt.shape[1],xt.shape[2],xt.shape[3]])),{value:xt,gradFunc:be}})(xe,te):rK((Ie,je,Me,xt)=>{let bt=sj.runKernel(ct,ye,ve);return xt([je,Ie,bt,Me]),le&&(bt=Lv(bt,[bt.shape[1],bt.shape[2],bt.shape[3]])),{value:bt,gradFunc:be}})(xe,te,me)}const Tj=sJ({fusedConv2d_:TB});function TR(m,d,p,_,E,S=[1,1],I){let D=m;m.rank===3&&(D=Lv(m,[1,m.shape[0],m.shape[1],m.shape[2]]));let k=d;k.rank===3&&(k=Lv(d,[1,d.shape[0],d.shape[1],d.shape[2]]));const V={x:D,dy:k},$={strides:_,pad:E,dimRoundingMode:I,dilations:S,filterShape:p};return sj.runKernel(oU,V,$)}const TH=sJ({depthwiseConv2dNativeBackpropFilter_:TR});function Tu(m,d,p,_,E,S=[1,1],I){let D=d,k=!1;d.rank===3&&(k=!0,D=Lv(d,[1,d.shape[0],d.shape[1],d.shape[2]]));const V={dy:D,filter:p},$={strides:_,pad:E,dimRoundingMode:I,dilations:S,inputShape:m},Z=sj.runKernel(oJ,V,$);return k?Lv(Z,[Z.shape[1],Z.shape[2],Z.shape[3]]):Z}const TX=sJ({depthwiseConv2dNativeBackpropInput_:Tu});function Tf({x:m,filter:d,strides:p,pad:_,dataFormat:E="NHWC",dilations:S=[1,1],dimRoundingMode:I,bias:D,activation:k="linear",preluActivationWeights:V,leakyreluAlpha:$}){if(TI(sj.state.gradientDepth,k)===!1){let ve=KZ(m,d,p,_,E,S,I);return D!=null&&(ve=LT(ve,D)),TS(ve,k,V,$)}const Z=sd(m,"x","depthwiseConv2d","float32"),te=sd(d,"filter","depthwiseConv2d","float32");let xe=Z,le=!1;Z.rank===3&&(le=!0,xe=Lv(Z,[1,Z.shape[0],Z.shape[1],Z.shape[2]])),A(xe.rank===4,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+xe.rank+"."),A(te.rank===4,()=>"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+te.rank+"."),A(xe.shape[3]===te.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels ("+xe.shape[3]+") must match the inChannels dimension in filter "+te.shape[2]+"."),S==null&&(S=[1,1]),A(Ld(p,S),()=>"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+p+" and dilations '"+S+"'"),LJ("fused depthwiseConv2d",_,I);const he=LS(xe.shape,te.shape,p,S,_,I,!0);let de;D!=null&&(de=sd(D,"bias","fused conv2d"),[de]=sO(de,Z),CJ(he.outShape,de.shape));let me;V!=null&&(me=sd(V,"prelu weights","fused depthwiseConv2d"));const ge=(ve,Ie)=>{A(LW(S),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+S+"'");const[je,Me,xt,bt]=Ie,gt=Te(ve,xt,k),Xt=TX(Me.shape,gt,je,p,_,S,I),Ut=TH(Me,gt,je.shape,p,_,S,I);if(bt!=null){const Ht=TP(de,gt);return[Xt,Ut,Ht]}return[Xt,Ut]},be={x:xe,filter:te,bias:de,preluActivationWeights:me},ye={strides:p,pad:_,dataFormat:E,dilations:S,dimRoundingMode:I,activation:k,leakyreluAlpha:$};return D==null?rK((ve,Ie,je)=>{let Me=sj.runKernel(cv,be,ye);return je([Ie,ve,Me]),le&&(Me=Lv(Me,[Me.shape[1],Me.shape[2],Me.shape[3]])),{value:Me,gradFunc:ge}})(xe,te):rK((ve,Ie,je,Me)=>{let xt=sj.runKernel(cv,be,ye);return Me([Ie,ve,xt,je]),le&&(xt=Lv(xt,[xt.shape[1],xt.shape[2],xt.shape[3]])),{value:xt,gradFunc:ge}})(xe,te,de)}const Ty=sJ({fusedDepthwiseConv2d_:Tf});function TE({a:m,b:d,transposeA:p=!1,transposeB:_=!1,bias:E,activation:S="linear",preluActivationWeights:I,leakyreluAlpha:D=.2}){if(TI(sj.state.gradientDepth,S)===!1){let bt=CR(m,d,p,_);return E!=null&&(bt=LT(bt,E)),TS(bt,S,I,D)}let k=sd(m,"a","fused matMul"),V=sd(d,"b","fused matMul");[k,V]=sO(k,V);const $=p?k.shape[k.rank-2]:k.shape[k.rank-1],Z=_?V.shape[V.rank-1]:V.shape[V.rank-2],te=p?k.shape[k.rank-1]:k.shape[k.rank-2],xe=_?V.shape[V.rank-2]:V.shape[V.rank-1],le=k.shape.slice(0,-2),he=V.shape.slice(0,-2),de=n(le),me=n(he);A($===Z,()=>"Error in fused matMul: inner shapes ("+$+") and ("+Z+") of Tensors with shapes "+k.shape+" and "+V.shape+" and transposeA="+p+" and transposeB="+_+" must match.");const ge=CJ(k.shape.slice(0,-2),V.shape.slice(0,-2)).concat([te,xe]),be=p?Lv(k,[de,$,te]):Lv(k,[de,te,$]),ye=_?Lv(V,[me,xe,Z]):Lv(V,[me,Z,xe]);let ve;E!=null&&(ve=sd(E,"bias","fused matMul"),[ve]=sO(ve,k),CJ(ge,ve.shape));let Ie;I!=null&&(Ie=sd(I,"prelu weights","fused matMul"));const je=(bt,gt)=>{const[Xt,Ut,Ht,mi]=gt,gi=Te(Lv(bt,Ht.shape),Ht,S);let Ui,yi;if(!p&&!_?(Ui=CR(gi,Ut,!1,!0),yi=CR(Xt,gi,!0,!1)):!p&&_?(Ui=CR(gi,Ut,!1,!1),yi=CR(gi,Xt,!0,!1)):p&&!_?(Ui=CR(Ut,gi,!1,!0),yi=CR(Xt,gi,!1,!1)):(Ui=CR(Ut,gi,!0,!0),yi=CR(gi,Xt,!0,!0)),E!=null){const vi=TP(mi,gi);return[Ui,yi,vi]}else return[Ui,yi]},Me={a:be,b:ye,bias:ve,preluActivationWeights:Ie},xt={transposeA:p,transposeB:_,activation:S,leakyreluAlpha:D};return E==null?rK((bt,gt,Xt)=>{const Ut=sj.runKernel(cJ,Me,xt);return Xt([bt,gt,Ut]),{value:Lv(Ut,ge),gradFunc:je}})(be,ye):rK((bt,gt,Xt,Ut)=>{const Ht=sj.runKernel(cJ,Me,xt);return Ut([bt,gt,Ht,Xt]),{value:Lv(Ht,ge),gradFunc:je}})(be,ye,ve)}const TW=sJ({fusedMatMul_:TE});function Td(m,d,p,_,E="bilinear",S=0){const I=sd(m,"image","cropAndResize"),D=sd(d,"boxes","cropAndResize","float32"),k=sd(p,"boxInd","cropAndResize","int32"),V=D.shape[0];A(I.rank===4,()=>"Error in cropAndResize: image must be rank 4,but got rank "+I.rank+"."),A(D.rank===2&&D.shape[1]===4,()=>"Error in cropAndResize: boxes must be have size ["+V+",4] but had shape "+D.shape+"."),A(k.rank===1&&k.shape[0]===V,()=>"Error in cropAndResize: boxInd must be have size ["+V+"] but had shape "+D.shape+"."),A(_.length===2,()=>"Error in cropAndResize: cropSize must be of length 2, but got length "+_.length+"."),A(_[0]>=1&&_[1]>=1,()=>"cropSize must be atleast [1,1], but was "+_),A(E==="bilinear"||E==="nearest",()=>"method must be bilinear or nearest, but was "+E);const $={image:I,boxes:D,boxInd:k},Z={method:E,extrapolationValue:S,cropSize:_};return sj.runKernel(oW,$,Z)}const TM=sJ({cropAndResize_:Td});function TU(m){const d=sd(m,"image","flipLeftRight","float32");A(d.rank===4,()=>"Error in flipLeftRight: image must be rank 4,but got rank "+d.rank+".");const p={image:d};return sj.runKernel(ox,p,{})}const TJ=sJ({flipLeftRight_:TU});function Tt(m){const d=sd(m,"image","grayscaleToRGB"),p=d.rank-1,_=d.shape[p];A(d.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, but got rank "+d.rank+"."),A(_===1,()=>"Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size "+_+".");const E=new Array(d.rank);return E.fill(1,0,p),E[p]=3,r2(d,E)}const Tv=sJ({grayscaleToRGB_:Tt});function Th(m){const d=sd(m,"image","RGBToGrayscale"),p=d.rank-1,_=d.shape[p];A(d.rank>=2,()=>"Error in RGBToGrayscale: images must be at least rank 2, but got rank "+d.rank+"."),A(_===3,()=>"Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size "+_+".");const E=d.dtype,S=CB(d,"float32"),I=TA([.2989,.587,.114]);let D;switch(d.rank){case 2:D=Ki("ij,j->i",S,I);break;case 3:D=Ki("ijk,k->ij",S,I);break;case 4:D=Ki("ijkl,l->ijk",S,I);break;case 5:D=Ki("ijklm,m->ijkl",S,I);break;case 6:D=Ki("ijklmn,n->ijklm",S,I);break;default:throw new Error("Not a valid tensor rank.")}return D=r0(D,-1),CB(D,E)}const TY=sJ({rgbToGrayscale_:Th});function Tm(m,d,p=0,_=.5){const E=sd(m,"image","rotateWithOffset","float32");A(E.rank===4,()=>"Error in rotateWithOffset: image must be rank 4,but got rank "+E.rank+".");const S={image:E},I={radians:d,fillValue:p,center:_};return sj.runKernel(cU,S,I)}const Tx=sJ({rotateWithOffset_:Tm});function Tl(m,d,p,_,E,S){_==null&&(_=.5),E==null&&(E=Number.NEGATIVE_INFINITY),S==null&&(S=0);const I=m.shape[0];return p=Math.min(p,I),A(0<=_&&_<=1,()=>"iouThreshold must be in [0, 1], but was '"+_+"'"),A(m.rank===2,()=>"boxes must be a 2D tensor, but was of rank '"+m.rank+"'"),A(m.shape[1]===4,()=>"boxes must have 4 columns, but 2nd dimension was "+m.shape[1]),A(d.rank===1,()=>"scores must be a 1D tensor"),A(d.shape[0]===I,()=>"scores has incompatible shape with boxes. Expected "+I+", but was "+d.shape[0]),A(0<=S&&S<=1,()=>"softNmsSigma must be in [0, 1], but was '"+S+"'"),{maxOutputSize:p,iouThreshold:_,scoreThreshold:E,softNmsSigma:S}}function Tb(m,d,p,_=.5,E=Number.NEGATIVE_INFINITY){const S=sd(m,"boxes","nonMaxSuppression","float32"),I=sd(d,"scores","nonMaxSuppression","float32"),D=Tl(S,I,p,_,E);p=D.maxOutputSize,_=D.iouThreshold,E=D.scoreThreshold;const k={maxOutputSize:p,iouThreshold:_,scoreThreshold:E};return sj.runKernel(cC,{boxes:S,scores:I},k)}const Ta=sJ({nonMaxSuppression_:Tb});function TV(m,d,p){const _=Tg(m,d,p),E=_<0?-(_+1):_;m.splice(E,0,d)}function Tg(m,d,p){return q1(m,d,p||q0)}function q0(m,d){return m>d?1:m<d?-1:0}function q1(m,d,p){let _=0,E=m.length,S=0,I=!1;for(;_<E;){S=_+(E-_>>>1);const D=p(d,m[S]);D>0?_=S+1:(E=S,I=!D)}return I?_:-_-1}function q2(m,d,p,_,E){return q5(m,d,p,_,E,0)}function q3(m,d,p,_,E,S){return q5(m,d,p,_,E,0,!1,S,!0)}function q4(m,d,p,_,E,S){return q5(m,d,p,_,E,S,!0)}function q5(m,d,p,_,E,S,I=!1,D=!1,k=!1){const V=[];for(let de=0;de<d.length;de++)d[de]>E&&V.push({score:d[de],boxIndex:de,suppressBeginIndex:0});V.sort(q8);const $=S>0?-.5/S:0,Z=[],te=[];for(;Z.length<p&&V.length>0;){const de=V.pop(),{score:me,boxIndex:ge,suppressBeginIndex:be}=de;if(me<E)break;let ye=!1;for(let ve=Z.length-1;ve>=be;--ve){const Ie=q6(m,ge,Z[ve]);if(Ie>=_){ye=!0;break}if(de.score=de.score*q7(_,$,Ie),de.score<=E)break}de.suppressBeginIndex=Z.length,ye||(de.score===me?(Z.push(ge),te.push(de.score)):de.score>E&&TV(V,de,q8))}const xe=Z.length,le=p-xe;D&&le>0&&(Z.push(...new Array(le).fill(0)),te.push(...new Array(le).fill(0)));const he={selectedIndices:Z};return I&&(he.selectedScores=te),k&&(he.validOutputs=xe),he}function q6(m,d,p){const _=m.subarray(d*4,d*4+4),E=m.subarray(p*4,p*4+4),S=Math.min(_[0],_[2]),I=Math.min(_[1],_[3]),D=Math.max(_[0],_[2]),k=Math.max(_[1],_[3]),V=Math.min(E[0],E[2]),$=Math.min(E[1],E[3]),Z=Math.max(E[0],E[2]),te=Math.max(E[1],E[3]),xe=(D-S)*(k-I),le=(Z-V)*(te-$);if(xe<=0||le<=0)return 0;const he=Math.max(S,V),de=Math.max(I,$),me=Math.min(D,Z),ge=Math.min(k,te),be=Math.max(me-he,0)*Math.max(ge-de,0);return be/(xe+le-be)}function q7(m,d,p){const _=Math.exp(d*p*p);return p<=m?_:0}function q8(m,d){return m.score-d.score||m.score===d.score&&d.boxIndex-m.boxIndex}async function q9(m,d,p,_=.5,E=Number.NEGATIVE_INFINITY){const S=sd(m,"boxes","nonMaxSuppressionAsync"),I=sd(d,"scores","nonMaxSuppressionAsync"),D=Tl(S,I,p,_,E);p=D.maxOutputSize,_=D.iouThreshold,E=D.scoreThreshold;const k=await Promise.all([S.data(),I.data()]),V=k[0],$=k[1],{selectedIndices:Z}=q2(V,$,p,_,E);return S!==m&&S.dispose(),I!==d&&I.dispose(),TA(Z,"int32")}const qo=q9;function qc(m,d,p,_=.5,E=Number.NEGATIVE_INFINITY,S=0){const I=sd(m,"boxes","nonMaxSuppression"),D=sd(d,"scores","nonMaxSuppression"),k=Tl(I,D,p,_,E,S);p=k.maxOutputSize,_=k.iouThreshold,E=k.scoreThreshold,S=k.softNmsSigma;const V={boxes:I,scores:D},$={maxOutputSize:p,iouThreshold:_,scoreThreshold:E,softNmsSigma:S},Z=sj.runKernel(cK,V,$);return{selectedIndices:Z[0],selectedScores:Z[1]}}const qG=sJ({nonMaxSuppressionWithScore_:qc});async function qs(m,d,p,_=.5,E=Number.NEGATIVE_INFINITY,S=0){const I=sd(m,"boxes","nonMaxSuppressionAsync"),D=sd(d,"scores","nonMaxSuppressionAsync"),k=Tl(I,D,p,_,E,S);p=k.maxOutputSize,_=k.iouThreshold,E=k.scoreThreshold,S=k.softNmsSigma;const V=await Promise.all([I.data(),D.data()]),$=V[0],Z=V[1],{selectedIndices:te,selectedScores:xe}=q4($,Z,p,_,E,S);return I!==m&&I.dispose(),D!==d&&D.dispose(),{selectedIndices:TA(te,"int32"),selectedScores:TA(xe)}}const qz=qs;function qC(m,d,p,_=.5,E=Number.NEGATIVE_INFINITY,S=!1){const I=sd(m,"boxes","nonMaxSuppression"),D=sd(d,"scores","nonMaxSuppression"),k=Tl(I,D,p,_,E,null),V=k.maxOutputSize,$=k.iouThreshold,Z=k.scoreThreshold,te={boxes:I,scores:D},xe={maxOutputSize:V,iouThreshold:$,scoreThreshold:Z,padToMaxOutputSize:S},le=sj.runKernel(cL,te,xe);return{selectedIndices:le[0],validOutputs:le[1]}}const qL=sJ({nonMaxSuppressionPadded_:qC});async function qK(m,d,p,_=.5,E=Number.NEGATIVE_INFINITY,S=!1){const I=sd(m,"boxes","nonMaxSuppressionAsync"),D=sd(d,"scores","nonMaxSuppressionAsync"),k=Tl(I,D,p,_,E,null),V=k.maxOutputSize,$=k.iouThreshold,Z=k.scoreThreshold,[te,xe]=await Promise.all([I.data(),D.data()]),{selectedIndices:le,validOutputs:he}=q3(te,xe,V,$,Z,S);return I!==m&&I.dispose(),D!==d&&D.dispose(),{selectedIndices:TA(le,"int32"),validOutputs:KU(he,"int32")}}const qr=qK;function qT(m,d,p=!1,_=!1){const E=sd(m,"images","resizeBilinear");A(E.rank===3||E.rank===4,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+E.rank+"."),A(d.length===2,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+d+"."),A(_===!1||p===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let S=E,I=!1;E.rank===3&&(I=!0,S=Lv(E,[1,E.shape[0],E.shape[1],E.shape[2]]));const D={images:S},k={alignCorners:p,halfPixelCenters:_,size:d},V=sj.runKernel(cF,D,k);return I?Lv(V,[V.shape[1],V.shape[2],V.shape[3]]):V}const qq=sJ({resizeBilinear_:qT});function qQ(m,d,p=!1,_=!1){const E=sd(m,"images","resizeNearestNeighbor");A(E.rank===3||E.rank===4,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+E.rank+"."),A(d.length===2,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+d+"."),A(E.dtype==="float32"||E.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),A(_===!1||p===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let S=E,I=!1;E.rank===3&&(I=!0,S=Lv(E,[1,E.shape[0],E.shape[1],E.shape[2]]));const D={images:S},k={alignCorners:p,halfPixelCenters:_,size:d},V=sj.runKernel(cZ,D,k);return I?Lv(V,[V.shape[1],V.shape[2],V.shape[3]]):V}const qk=sJ({resizeNearestNeighbor_:qQ});function qp(m,d="binary",p=!1,_=.5){const E=sd(m,"image","threshold"),S=.2989,I=.587,D=.114,k=E.shape[0]*E.shape[1];let V=LA(TA([_]),255),$,Z,te,xe;if(A(E.rank===3,()=>"Error in threshold: image must be rank 3,but got rank "+E.rank+"."),A(E.shape[2]===3||E.shape[2]===1,()=>"Error in threshold: image color channel must be equal to 3 or 1but got "+E.shape[2]+"."),A(E.dtype==="int32"||E.dtype==="float32",()=>"Error in dtype: image dtype must be int32 or float32,but got dtype "+E.dtype+"."),A(d==="otsu"||d==="binary",()=>"Method must be binary or otsu, but was "+d),E.shape[2]===3){[$,Z,te]=TL(E,[1,1,1],-1);const he=LA($,S),de=LA(Z,I),me=LA(te,D);xe=LT(LT(he,de),me)}else xe=m;if(d==="otsu"){const he=K4(CB(To(xe),"int32"),sY([]),256);V=qw(he,k)}const le=p?rL(xe,V):r8(xe,V);return CB(LA(le,255),"int32")}function qw(m,d){let p=TA([-1]),_=TA([0]),E=TA([0]),S,I,D,k,V,$;for(let Z=0;Z<m.size-1;Z++){S=K0(m,0,Z+1),I=K0(m,Z+1),V=Lp(Km(S),d),$=Lp(Km(I),d);const te=Km(LA(S,T4(0,S.size)));D=Lp(te,Km(S));const xe=K8(I.shape,S.size),le=LT(T4(0,I.size),xe),he=LA(I,le);k=Lp(Km(he),Km(I));const de=rT(D,k),me=rT(D,k),ge=LA(V,$);E=LA(LA(ge,de),me);const be=r8(E,_);_=KN(be,E,_),p=KN(be,TA([Z]),p)}return p}const qA=sJ({threshold_:qp});function qZ(m,d,p="nearest",_="constant",E=0,S){const I=sd(m,"image","transform","float32"),D=sd(d,"transforms","transform","float32");A(I.rank===4,()=>"Error in transform: image must be rank 4,but got rank "+I.rank+"."),A(D.rank===2&&(D.shape[0]===I.shape[0]||D.shape[0]===1)&&D.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),A(S==null||S.length===2,()=>"Error in transform: outputShape must be [height, width] or null, but got "+S+".");const k={image:I,transforms:D},V={interpolation:p,fillMode:_,fillValue:E,outputShape:S};return sj.runKernel(cf,k,V)}const qF=sJ({transform_:qZ});var qN;(function(m){m[m.NONE=0]="NONE",m[m.MEAN=1]="MEAN",m[m.SUM=2]="SUM",m[m.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(qN||(qN={}));const qO={flipLeftRight:TJ,grayscaleToRGB:Tv,resizeNearestNeighbor:qk,resizeBilinear:qq,rgbToGrayscale:TY,rotateWithOffset:Tx,cropAndResize:TM,nonMaxSuppression:Ta,nonMaxSuppressionAsync:qo,nonMaxSuppressionWithScore:qG,nonMaxSuppressionWithScoreAsync:qz,nonMaxSuppressionPadded:qL,nonMaxSuppressionPaddedAsync:qr,threshold:qA,transform:qF},qD=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:m=>m();function qn(){return new Promise(m=>qD(()=>m()))}function qi(m,d){const p=m[0].length;m.forEach((E,S)=>{A(E.length===p,()=>"Error in concat"+p+"D: rank of tensors["+S+"] must be the same as the rank of the rest ("+p+")")}),A(d>=0&&d<p,()=>"Error in concat"+p+"D: axis must be between 0 and "+(p-1)+".");const _=m[0];m.forEach((E,S)=>{for(let I=0;I<p;I++)A(I===d||E[I]===_[I],()=>"Error in concat"+p+"D: Shape of tensors["+S+"] ("+E+") does not match the shape of the rest ("+_+") along the non-concatenated axis "+S+".")})}function qe(m,d){const p=m[0].slice();for(let _=1;_<m.length;_++)p[d]+=m[_][d];return p}var qP;(function(m){m[m.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",m[m.VALUE_ROWIDS=1]="VALUE_ROWIDS",m[m.ROW_LENGTHS=2]="ROW_LENGTHS",m[m.ROW_SPLITS=3]="ROW_SPLITS",m[m.ROW_LIMITS=4]="ROW_LIMITS",m[m.ROW_STARTS=5]="ROW_STARTS"})(qP||(qP={}));function qS(m,d,p){let _=new Array;if(p==null&&d==null)return _;if(d==null)for(;_.length<m+p.length;)_.push(-1);else _=d.slice();if(p==null)return _;if(m+p.length!==_.length)throw new Error("rt input.shape and shape="+d+" are incompatible: rt input.rank = "+(m+p.length)+", but shape.rank = "+_.length);for(let E=1;E<p.length;++E){const S=p[E],I=_[_.length-p.length+E],D=_[I];if(S>=0)if(D>=0){if(D!==S)throw new Error("rt input.shape and shape="+d+" are incompatible: rt input.shape["+(E+m)+"] = "+S+" but shape["+(E+m)+"] = "+D)}else _[I]=S}return _}function qI(m){const d={FIRST_DIM_SIZE:qP.FIRST_DIM_SIZE,VALUE_ROWIDS:qP.VALUE_ROWIDS,ROW_LENGTHS:qP.ROW_LENGTHS,ROW_SPLITS:qP.ROW_SPLITS,ROW_LIMITS:qP.ROW_LIMITS,ROW_STARTS:qP.ROW_STARTS},p=[];for(const _ of m)if(_ in d)p.push(d[_]);else break;return p}function qB(m){return m.length===0?0:m[0]===qP.FIRST_DIM_SIZE?m.length-1:m.length}function qj(m,d){if(m==null||d==null)return;const p=m.length,_=d.length;if(p>=_)throw new Error("defaultValue.shape="+m+" and ragged tensor flatValues.shape="+d+", are incompatible: defaultValue.rank = "+p+" must be less than ragged tensor input flatValues.rank = "+_+")");for(let E=0;E<Math.min(p,_-1);++E){const S=m[E],I=d[E+1];if(S>=0&&I>=0&&S!==1&&S!==I)throw new Error("defaultValue.shape="+m+", and ragged tensor input flatValues.shape="+d+" are incompatible: defaultValue.shape["+(E-m.length)+"] = "+S+" but ragged tensor input.flatValues.shape["+(E-m.length)+"] = "+I)}}const qR=30;function qH(m){return m<=qR?m:o5(m,Math.floor(Math.sqrt(m)))}function qu(m,d,p){const _=p*(typeof m=="number"?m:m[0]),E=d*(typeof m=="number"?m:m[1]);return[_,E]}function qX(m,d,p,_=!0){let E=[];if(_)E=E.concat(d.slice(0)),E.push(m[0]/p),E=E.concat(m.slice(1));else{E=E.concat(m[0]);const S=d.length;for(let I=0;I<S;++I)E=E.concat([m[I+1]/d[I],d[I]]);E=E.concat(m.slice(S+1))}return E}function qf(m,d,p=!0){const _=[];if(p){_.push(d);for(let E=d+1;E<m;++E)E<=2*d?(_.push(E),_.push(E-(d+1))):_.push(E)}else{const E=[],S=[];for(let I=1;I<m;++I)I>=d*2+1||I%2===1?S.push(I):E.push(I);_.push(...E),_.push(0),_.push(...S)}return _}function qy(m,d,p,_=!0){const E=[];_?E.push(m[0]/p):E.push(m[0]*p);for(let S=1;S<m.length;++S)S<=d.length?_?E.push(d[S-1]*m[S]):E.push(m[S]/d[S-1]):E.push(m[S]);return E}function qE(m,d){const p=[0];for(let _=0;_<d;++_)p.push(m[_][0]);return p}function qW(m,d,p){const _=m.slice(0,1);for(let E=0;E<p;++E)_.push(m[E+1]-d[E][0]-d[E][1]);return _}const qd=1.7580993408473768,qM=1.0507009873554805,qU=.3275911,qJ=.254829592,qt=-.284496736,qv=1.421413741,qh=-1.453152027,qY=1.061405429;function qm(m,d){if(m.length!==d.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+m.length+", imag: "+d.length+".");const p=new Float32Array(m.length*2);for(let _=0;_<p.length;_+=2)p[_]=m[_/2],p[_+1]=d[_/2];return p}function qx(m){const d=new Float32Array(m.length/2),p=new Float32Array(m.length/2);for(let _=0;_<m.length;_+=2)d[_/2]=m[_],p[_/2]=m[_+1];return{real:d,imag:p}}function ql(m){const d=Math.ceil(m.length/4),p=new Float32Array(d),_=new Float32Array(d);for(let E=0;E<m.length;E+=4)p[Math.floor(E/4)]=m[E],_[Math.floor(E/4)]=m[E+1];return{real:p,imag:_}}function qb(m){const d=Math.floor(m.length/4),p=new Float32Array(d),_=new Float32Array(d);for(let E=2;E<m.length;E+=4)p[Math.floor(E/4)]=m[E],_[Math.floor(E/4)]=m[E+1];return{real:p,imag:_}}function qa(m,d){const p=m[d*2],_=m[d*2+1];return{real:p,imag:_}}function qV(m,d,p,_){m[_*2]=d,m[_*2+1]=p}function qg(m,d){const p=new Float32Array(m/2),_=new Float32Array(m/2);for(let E=0;E<Math.ceil(m/2);E++){const S=(d?2:-2)*Math.PI*(E/m);p[E]=Math.cos(S),_[E]=Math.sin(S)}return{real:p,imag:_}}function Q0(m,d,p){const _=(p?2:-2)*Math.PI*(m/d),E=Math.cos(_),S=Math.sin(_);return{real:E,imag:S}}const Q1="->",Q2=/->/g,Q3=",",Q4="...";function Q5(m,d){m=m.replace(/\s/g,"");const p=(m.length-m.replace(Q2,"").length)/Q1.length;if(p<1)throw new Error("Equations without an arrow are not supported.");if(p>1)throw new Error('Equation must contain exactly one arrow ("'+Q1+'").');const[_,E]=m.split(Q1);A(_.indexOf(Q4)===-1,()=>'The ellipsis notation ("'+Q4+'") is not supported yet.');const S=_.split(Q3),I=S.length;if(d!==I)throw new Error("Expected "+I+" input tensors, received "+d);if(I>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const D=[];for(let te=0;te<E.length;++te){const xe=E[te];if(!S.some(le=>le.indexOf(xe)!==-1))throw new Error("Output subscripts contain the label "+xe+" not present in the input subscripts.");D.indexOf(xe)===-1&&D.push(xe)}for(let te=0;te<_.length;++te){const xe=_[te];D.indexOf(xe)===-1&&xe!==Q3&&D.push(xe)}const k=new Array(S.length);for(let te=0;te<I;++te){if(new Set(S[te].split("")).size!==S[te].length)throw new Error("Found duplicate axes in input component "+S[te]+". Support for duplicate axes in input is not implemented yet.");k[te]=[];for(let xe=0;xe<S[te].length;++xe)k[te].push(D.indexOf(S[te][xe]))}const V=D.length,$=E.length,Z=[];for(let te=$;te<V;++te)Z.push(te);return{allDims:D,summedDims:Z,idDims:k}}function Q6(m,d){let p=new Array(m);p.fill(-1);for(let E=0;E<d.length;++E)p[d[E]]=E;const _=[];for(let E=0;E<m;++E)p[E]===-1&&_.push(E);return p=p.filter(E=>E!==-1),{permutationIndices:p,expandDims:_}}function Q7(m,d,p){const _=new Array(m);for(let E=0;E<p.length;++E){const S=p[E].shape;for(let I=0;I<d[E].length;++I)_[d[E][I]]===void 0?_[d[E][I]]=S[I]:A(_[d[E][I]]===S[I],()=>"Expected dimension "+_[d[E][I]]+" at axis "+I+" of input shaped "+JSON.stringify(S)+", but got dimension "+S[I])}}function Q8(m,d){const p=m,_=[];let E=0;m.length===0&&p.push(-1),E=m.length+1;for(let I=0;I<E;++I)_.push([]);const S=[];for(let I=0;I<p.length;++I){const D=p[I],k=Qo(d,D);for(const V of k)S.indexOf(V)===-1&&(_[I].push(V),S.push(V))}return{path:p,steps:_}}function Q9(m){return m.every((d,p)=>d===p)}function Qo(m,d){const p=[];for(let _=0;_<m.length;++_)(m[_].length===0||m[_].indexOf(d)!==-1||d===-1)&&p.push(_);return p}function Qc(m,d,p=0){let _=[];if(typeof d=="number")A(m.shape[p]%d===0,()=>"Number of splits must evenly divide the axis."),_=new Array(d).fill(m.shape[p]/d);else{const E=d.reduce((I,D)=>(D===-1&&(I+=1),I),0);A(E<=1,()=>"There should be only one negative value in split array.");const S=d.indexOf(-1);if(S!==-1){const I=d.reduce((D,k)=>k>0?D+k:D);d[S]=m.shape[p]-I}A(m.shape[p]===d.reduce((I,D)=>I+D),()=>"The sum of sizes must match the size of the axis dimension."),_=d}return _}function QG(m){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = `+m}function Qs(m,d){return"indices("+m+", 0) is invalid: "+d+" < 0"}function Qz(m,d,p){return"indices("+m+", 0) is invalid: "+d+" >= "+p}function QC(m,d){return"only one output dimension may be -1, not both "+m+" and "+d}function QL(m,d){return"size "+m+" must be non-negative, not "+d}function QK(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Qr(m,d){const p=n(m),_=n(d);return"Input to reshape is a SparseTensor with "+p+`
  dense values, but the requested shape requires a multiple of `+_+". inputShape="+m+" outputShape= "+d}function QT(m,d){const p=n(m),_=n(d);return"Input to reshape is a tensor with "+p+" dense values, but the requested shape has "+_+". inputShape="+m+" outputShape="+d}function Qq(){return"segment ids must be >= 0"}function QQ(){return"segment ids are not increasing"}function Qk(m,d){return"Segment id "+m+" out of range [0, "+d+"), possibly because segmentIds input is not sorted."}function Qp(m,d,p){return"Bad: indices["+m+"] == "+d+" out of range [0, "+p+")"}function Qw(m,d){let p=!1,_;for(m<=qR?(_=m,p=!0):_=o5(m,Math.floor(Math.sqrt(m)));!p;)_>d||_===m?p=!0:_=o5(m,_+1);return _}function QA(m,d,p){const _=[],E=m.length;for(let S=0;S<E;S++)S!==d?_.push(m[S]):_.push(p);return _}function QZ(m,d,p,_){const E=d.shape.length,S=m.shape.length;if(_!==0&&(_<-E||_>E))throw new Error("Expect batchDims in the range of [-"+E+", "+E+"], but got "+_);if(_<0&&(_+=E),_>S)throw new Error("batchDims ("+_+`) must be less than rank(x) (
    `+S+").");if(p<_)throw new Error("batchDims ("+_+") must be less than or equal to axis ("+p+").");for(let Z=0;Z<_;++Z)if(m.shape[Z]!==d.shape[Z])throw new Error("x.shape["+Z+"]: "+m.shape[Z]+" should be equal to indices.shape["+Z+"]: "+d.shape[Z]+".");const I=m.shape[p],D=[];let k=1,V=1,$=1;for(let Z=0;Z<_;++Z)D.push(m.shape[Z]),k*=m.shape[Z];for(let Z=_;Z<p;Z++)D.push(m.shape[Z]),V*=m.shape[Z];for(let Z=_;Z<E;Z++)D.push(d.shape[Z]);for(let Z=p+1;Z<S;Z++)D.push(m.shape[Z]),$*=m.shape[Z];return{batchSize:k,sliceSize:$,outerSize:V,dimSize:I,outputShape:D}}var QF=Object.freeze({__proto__:null,collectGatherOpShapeInfo:QZ,computeOutShape:QA,segOpComputeOptimalWindowSize:Qw});function QN(m){try{return m.map(d=>Gm(d))}catch(d){throw new Error("Failed to decode encoded string bytes into utf-8, error: "+d)}}function QO(m){return m.map(d=>GY(d))}var QD=Object.freeze({__proto__:null,ERF_A1:qJ,ERF_A2:qt,ERF_A3:qv,ERF_A4:qh,ERF_A5:qY,ERF_P:qU,PARALLELIZE_THRESHOLD:qR,get RowPartitionType(){return qP},SELU_SCALE:qM,SELU_SCALEALPHA:qd,applyActivation:TS,assertAndGetBroadcastShape:CJ,assertAxesAreInnerMostDims:KR,assertParamsConsistent:qi,assignToTypedArray:qV,axesAreInnerMostDims:KS,calculateShapes:Cb,checkEinsumDimSizes:Q7,checkPadOnDimRoundingMode:LJ,combineLocations:KI,combineRaggedTensorToTensorShapes:qS,complexWithEvenIndex:ql,complexWithOddIndex:qb,computeConv2DInfo:LS,computeConv3DInfo:LI,computeDefaultPad:LR,computeDilation2DInfo:Li,computeOptimalWindowSize:qH,computeOutAndReduceShapes:KB,computeOutShape:qe,computePool2DInfo:Le,computePool3DInfo:LP,convertConv2DDataFormat:LU,decodeEinsumEquation:Q5,eitherStridesOrDilationsAreOne:Ld,expandShapeToKeepDim:Kj,exponent:Q0,exponents:qg,fromStringArrayToUint8:QO,fromUint8ToStringArray:QN,getAxesPermutation:KH,getBroadcastDims:CM,getComplexWithIndex:qa,getEinsumComputePath:Q8,getEinsumPermutation:Q6,getFusedBiasGradient:TP,getFusedDyActivation:Te,getImageCenter:qu,getInnerMostAxes:KX,getPermuted:qf,getRaggedRank:qB,getReductionAxes:CU,getReshaped:qX,getReshapedPermuted:qy,getRowPartitionTypesHelper:qI,getSliceBeginCoords:qE,getSliceSize:qW,getSparseFillEmptyRowsIndicesDenseShapeMismatch:QG,getSparseFillEmptyRowsNegativeIndexErrorMessage:Qs,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Qz,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:QK,getSparseReshapeInputOutputMismatchErrorMessage:QT,getSparseReshapeInputOutputMultipleErrorMessage:Qr,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:QC,getSparseReshapeNegativeOutputDimErrorMessage:QL,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Qp,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Qq,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:QQ,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Qk,getUndoAxesPermutation:Ku,isIdentityPermutation:Q9,log:cY,mergeRealAndImagArrays:qm,prepareAndValidate:Cm,prepareSplitSize:Qc,segment_util:QF,shouldFuse:TI,slice_util:LK,splitRealAndImagArrays:qx,stridesOrDilationsArePositive:LM,tupleValuesAreOne:LW,upcastType:sA,validateDefaultValueShape:qj,validateInput:Cl,validateUpdateShape:Cx,warn:ch});class Qn{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(d,p){return fetch(d,p)}now(){return performance.now()}encode(d,p){if(p!=="utf-8"&&p!=="utf8")throw new Error("Browser's encoder only supports utf-8, but got "+p);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(d)}decode(d,p){return new TextDecoder(p).decode(d)}setTimeoutCustom(d,p){if(typeof window>"u"||!oQ().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(d,p);return}this.functionRefs.push(d),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},p),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",_=>{if(_.source===window&&_.data.name===this.messageName){_.stopPropagation();const E=this.functionRefs[_.data.index];E(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(d){return G0(d)}}if(oQ().get("IS_BROWSER")){oQ().setPlatform("browser",new Qn);try{CN.registerManager(zx.URL_SCHEME,new za)}catch{}try{CN.registerManager(zH.URL_SCHEME,new zy)}catch{}}const Qi={importFetch:()=>__webpack_require__(92)};let Qe;class QP{constructor(){this.util=__webpack_require__(537),this.textEncoder=new this.util.TextEncoder}fetch(d,p){return oQ().global.fetch!=null?oQ().global.fetch(d,p):(Qe==null&&(Qe=Qi.importFetch()),Qe(d,p))}now(){const d=process.hrtime();return d[0]*1e3+d[1]/1e6}encode(d,p){if(p!=="utf-8"&&p!=="utf8")throw new Error("Node built-in encoder only supports utf-8, but got "+p);return this.textEncoder.encode(d)}decode(d,p){return d.length===0?"":new this.util.TextDecoder(p).decode(d)}isTypedArray(d){return this.util.types.isFloat32Array(d)||this.util.types.isInt32Array(d)||this.util.types.isUint8Array(d)||this.util.types.isUint8ClampedArray(d)}}oQ().get("IS_NODE")&&!oQ().get("IS_BROWSER")&&oQ().setPlatform("node",new QP),sB();const QS={buffer:K7,cast:CB,clone:Lx,print:ry};sz(QS);var QI=Object.defineProperty,QB=Object.getOwnPropertySymbols,Qj=Object.prototype.hasOwnProperty,QR=Object.prototype.propertyIsEnumerable,QH=(m,d,p)=>d in m?QI(m,d,{enumerable:!0,configurable:!0,writable:!0,value:p}):m[d]=p,Qu=(m,d)=>{for(var p in d||(d={}))Qj.call(d,p)&&QH(m,p,d[p]);if(QB)for(var p of QB(d))QR.call(d,p)&&QH(m,p,d[p]);return m};class QX{constructor(d){this.model=d,this.posesMax=1,this.iouThresh=.3,this.scoreThresh=.5,this.model=d,this.modelSize=d.inputs[0].shape?{width:d.inputs[0].shape[2],height:d.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=TA(this.anchorsData.map(p=>p.x)),this.anchorsY=TA(this.anchorsData.map(p=>p.y))}async process(d){let p={x:0,y:0};const[_,E]=sV(()=>{const V={width:d.shape[2],height:d.shape[1]},$=V.width/V.height;let Z=Qu({},V),te={x:0,y:0};$>this.modelRatio?(Z.height=d.shape[2]/this.modelRatio,te.y=Math.floor((Z.height-d.shape[1])*.5),p.y=te.y/Z.height):$<this.modelRatio&&(Z.width=d.shape[1]*this.modelRatio,te.x=Math.floor((Z.width-d.shape[2])*.5),p.x=te.x/Z.width);const xe=rS(d,[[0,0],[te.y,te.y],[te.x,te.x],[0,0]],0),le=qO.resizeBilinear(xe,[this.modelSize.height,this.modelSize.width]),he=this.model.execute(le,"person"),de=Tr(K0(he,[0,0,1],[1,-1,-1])),me=Tr(K0(he,[0,0,0],[1,-1,1])),ge=LV(Ko(me,-100,100));return[this.decodeBoxes(de,[this.anchorsX,this.anchorsY],this.modelSize),ge]}),S=await _.data(),I=await E.data();let D=[];for(let V=0;V<I.length;V++){if(I[V]<this.scoreThresh)continue;const $=S[V*12+2]-S[V*12+0],Z=S[V*12+3]-S[V*12+1];$<0||Z<0||D.push({box:[[S[V*12+0],S[V*12+1]],[S[V*12+2],S[V*12+3]]],points:[[S[V*12+4],S[V*12+5]],[S[V*12+6],S[V*12+7]],[S[V*12+8],S[V*12+9]],[S[V*12+10],S[V*12+11]]],score:I[V]})}if(_.dispose(),E.dispose(),D.length<1)return[];if(D.length>1){const V=TZ(D.map(le=>[le.box[0][1],le.box[0][0],le.box[1][1],le.box[1][0]])),$=TA(D.map(le=>le.score)),Z=await qO.nonMaxSuppressionAsync(V,$,this.posesMax,this.iouThresh,this.scoreThresh),te=await Z.data();Z.dispose();const xe=[];for(let le=0;le<te.length;le++)xe.push(D[te[le]]);D=xe}if(D.length<1)return[];const k={width:1-2*p.x,height:1-2*p.y};return D.map(V=>({box:V.box.map($=>[($[0]-p.x)/k.width,($[1]-p.y)/k.height]),points:V.points.map($=>[($[0]-p.x)/k.width,($[1]-p.y)/k.height]),score:V.score}))}decodeBoxes(d,p,_){let E=Tr(K0(d,[0,0],[-1,1])),S=Tr(K0(d,[0,1],[-1,1])),I=Tr(K0(d,[0,2],[-1,1])),D=Tr(K0(d,[0,3],[-1,1]));E=LT(Lp(E,_.width),p[0]),S=LT(Lp(S,_.height),p[1]),I=Lp(I,_.width*2),D=Lp(D,_.height*2);const k=Lv(rT(E,I),[2254,1]),V=Lv(rT(S,D),[2254,1]),$=Lv(LT(E,I),[2254,1]),Z=Lv(LT(S,D),[2254,1]);let te=KG([k,V,$,Z],1);for(let xe=0;xe<4;xe++){let le=Tr(K0(d,[0,4+xe*2],[-1,1])),he=Tr(K0(d,[0,4+xe*2+1],[-1,1]));le=Lv(LT(Lp(le,_.width),p[0]),[2254,1]),he=Lv(LT(Lp(he,_.height),p[1]),[2254,1]),te=KG([te,le,he],1)}return te}buildAnchors(d){const p=[8,16,32,32,32],_=[];let E=0;for(;E<5;){let S=0,I=E;for(;I<p.length&&p[I]===p[E];)S+=2,I++;const D=p[E],k=Math.ceil(d.height/D),V=Math.ceil(d.width/D);for(let $=0;$<k;++$)for(let Z=0;Z<V;++Z)for(let te=0;te<S;++te)_.push({x:(Z+.5)/V,y:($+.5)/k});E=I}return _}async prepare(){const{width:d,height:p}=this.modelSize,_=rD([1,p,d,3]),E=this.model.execute(_,"person");await E.data(),_.dispose(),E.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}class Qf{constructor(d){if(this.size=d,z2()!=="webgl")return;const{width:p,height:_}=d;this.backend=z4(),this.prog={variableNames:["maskT","prevT"],outputShape:[_,p],userCode:`
                void main() {
                    ivec2 c = getOutputCoords();
                    float mask = getMaskT(c[0], c[1]);
                    float prev = getPrevT(c[0], c[1]);
                    float t = mask - 0.5;
                    float x = t * t;
                    float alpha = 1.0 - min(
                        x * (5.74062006 + x * (-2.90180189 + x * (-30.34594285 +
                        x * (153.83657925 + x * (-387.53530186))))), 1.0);
                    float smoothed = mask + (prev - mask) * (alpha * 0.9);
                    setOutput(smoothed);
                }
        `}}process(d){var p;if(!this.backend||!this.prog)return;const _=this.backend.compileAndRun(this.prog,[d,this.prev||d]),E=sa().makeTensorFromTensorInfo(_);return(p=this.prev)==null||p.dispose(),this.prev=E,E}reset(){var d;(d=this.prev)==null||d.dispose(),delete this.prev}async prepare(){if(!this.backend||!this.prog)return;const{width:d,height:p}=this.size,_=rD([p,d]),E=rn([p,d]),S=this.backend.compileAndRun(this.prog,[_,E]),I=sa().makeTensorFromTensorInfo(S);await I.data(),_.dispose(),E.dispose(),I.dispose()}dispose(){this.reset(),delete this.prog,delete this.backend}}class Qy{constructor(d,p=!1){this.model=d,this.mask=p,this.sizeFactor=1.2,this.model=d,this.modelSize=d.inputs[0].shape?{width:d.inputs[0].shape[2],height:d.inputs[0].shape[1]}:{width:256,height:256},typeof p=="object"&&p.smooth&&(this.maskFilter=new Qf(this.modelSize))}process(d,p){const[_,E]=[d.shape[1],d.shape[2]],{modelSize:S}=this;return p.map(I=>{var D;const k=[I.center[0]*E,I.center[1]*_],V=[I.top[0]*E,I.top[1]*_],$=[V[0]-k[0],V[1]-k[1]],Z=Math.sqrt($[0]*$[0]+$[1]*$[1])*this.sizeFactor,te=Math.atan2($[0],-$[1]),xe=[k[1]-Z,k[0]-Z,k[1]+Z,k[0]+Z],le=sV(()=>{const bt=this.rotatedRect(d,xe,te,S);return LT(LA(bt,.5),.5)}),he=["ld_3d","world_3d","output_poseflag","activation_heatmap"];this.mask&&he.push("activation_segmentation");const[de,me,ge,be,ye]=this.model.execute(le,he),ve=de.dataSync(),Ie=me.dataSync(),je=ge.dataSync()[0];let Me=[];for(let bt=0;bt<39;bt++)Me.push([ve[bt*5+0]/S.width,ve[bt*5+1]/S.height,ve[bt*5+2]/S.width]);let xt;if(ye){const bt=qO.rotateWithOffset(ye,-te),gt=Tr(bt),Xt=((D=this.maskFilter)==null?void 0:D.process(gt))||gt,Ut=LA(Xt,255);xt=new Uint8Array(Ut.dataSync()),ye.dispose(),bt.dispose(),gt.dispose(),Ut.dispose()}return le.dispose(),de.dispose(),me.dispose(),ge.dispose(),Me=this.refinePoints(Me,be),be.dispose(),{points:Me,pointsData:ve,metricData:Ie,maskData:xt,score:je,center:k,top:V,radius:Z,angle:te}}).map(I=>{const{points:D,pointsData:k,metricData:V,maskData:$,score:Z,center:te,top:xe,radius:le,angle:he}=I;let de=D.map((je,Me)=>({pixel:je,metric:[V[Me*3+0],V[Me*3+1],V[Me*3+2]],norm:[V[Me*3+0],V[Me*3+1],V[Me*3+2]],score:1/(1+Math.exp(-k[Me*5+3])),visibility:1/(1+Math.exp(-k[Me*5+4]))}));de.forEach(je=>{je.pixel[0]=(je.pixel[0]-.5)*2*le,je.pixel[1]=(je.pixel[1]-.5)*2*le,je.pixel[2]*=2*le});const me=Math.sin(he),ge=Math.cos(he);de.forEach(je=>{const Me=je.pixel[0],xt=je.pixel[1];je.pixel[0]=(Me*ge-xt*me+te[0])/E,je.pixel[1]=(Me*me+xt*ge+te[1])/_,je.pixel[2]/=E;const bt=je.metric[0],gt=je.metric[1];je.metric[0]=bt*ge-gt*me,je.metric[1]=bt*me+gt*ge});const be=de.map(je=>je.pixel[0]),ye=de.map(je=>je.pixel[1]),ve=[[Math.min(...be),Math.min(...ye)],[Math.max(...be),Math.max(...ye)]],Ie=$&&{buffer:$,size:{width:256,height:256},box:[[(te[0]-le)/E,(te[1]-le)/_],[(te[0]+le)/E,(te[1]+le)/_]]};return{keypoints:de,score:Z,mask:Ie,center:[de[33].pixel[0],de[33].pixel[1]],top:[de[34].pixel[0],de[34].pixel[1]],debug:{center:te,top:xe,box:ve,radius:le,angle:he}}})}refinePoints(d,p){const _=Tr(p,[0]),E=_.bufferSync(),[S,I,D]=_.shape;return d.map((k,V)=>{const $=k,Z=Math.trunc($[0]*I),te=Math.trunc($[1]*S);if(Z<0||Z>=I||te<0||te>=S)return k;const xe=Math.trunc(6/2),le=Math.max(Z-xe,0),he=Math.min(Z+xe+1,I),de=Math.max(te-xe,0),me=Math.min(te+xe+1,S);let ge=0,be=0,ye=0,ve=0;for(let Ie=de;Ie<me;Ie++)for(let je=le;je<he;je++){const Me=E.get(Ie,je,V);ge+=Me,be=Math.max(Me,be),ye+=je*Me,ve+=Ie*Me}return _.dispose(),be>=.5&&ge>0?[ye/ge/I,ve/ge/S,$[2]]:k})}rotatedRect(d,p,_,E){const[S,I]=[p[2]-p[0],p[3]-p[1]],[D,k]=[(p[2]+p[0])*.5,(p[3]+p[1])*.5],[V,$]=[S/E.height,I/E.width],[Z,te]=[Math.cos(_),Math.sin(_)],xe=[Z*$,-te*V,(-Z*I+te*S)*.5+k,te*$,Z*V,(-te*I-Z*S)*.5+D,0,0];return qO.transform(d,[xe],"bilinear","constant",0,[E.height,E.width])}reset(){var d;(d=this.maskFilter)==null||d.reset()}async prepare(){var d;const{width:p,height:_}=this.modelSize,E=rD([1,_,p,3]),S=this.model.execute(E);await Promise.all(S.map(async I=>{await I.data(),I.dispose()})),await((d=this.maskFilter)==null?void 0:d.prepare()),E.dispose()}async dispose(){var d,p;(d=this.model)==null||d.dispose(),(p=this.maskFilter)==null||p.dispose(),delete this.maskFilter}}var QE=Object.defineProperty,QW=Object.getOwnPropertySymbols,Qd=Object.prototype.hasOwnProperty,QM=Object.prototype.propertyIsEnumerable,QU=(m,d,p)=>d in m?QE(m,d,{enumerable:!0,configurable:!0,writable:!0,value:p}):m[d]=p,QJ=(m,d)=>{for(var p in d||(d={}))Qd.call(d,p)&&QU(m,p,d[p]);if(QW)for(var p of QW(d))QM.call(d,p)&&QU(m,p,d[p]);return m};class Qv{constructor(){this.freq=30,this.pixelParams={minCutOff:1,minCutOffD:1,beta:50},this.metricParams={minCutOff:.5,minCutOffD:1,beta:30},this.boxParams={minCutOff:1,minCutOffD:1,beta:50},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(d,p,_=1){return this.time>=p?d:(this.time!==0&&(this.freq=1/(p-this.time)),this.time=p,!this.raw||!this.smooth||!this.der?(this.raw=this.clonePose(d),this.smooth=this.clonePose(d),this.der={keypoints:d.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0],norm:[0,0,0],score:0,visibility:0})),score:0,center:[0,0],top:[0,0],debug:{box:[[0,0],[0,0]],center:[0,0],top:[0,0],radius:0,angle:0}},this.clonePose(this.smooth)):(this.filterKeypoints(d.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,_),this.filterCoord2D(d.center,this.raw.center,this.der.center,this.smooth.center,_,this.boxParams),this.filterCoord2D(d.top,this.raw.top,this.der.top,this.smooth.top,_,this.boxParams),this.smooth.score=d.score,this.smooth.mask=d.mask&&{buffer:d.mask.buffer,size:QJ({},d.mask.size),box:[[...d.mask.box[0]],[...d.mask.box[1]]]},this.smooth.debug=d.debug&&{center:[...d.debug.center],top:[...d.debug.top],box:[[...d.debug.box[0]],[...d.debug.box[1]]],radius:d.debug.radius,angle:d.debug.angle},this.clonePose(this.smooth)))}filterKeypoints(d,p,_,E,S){const I=this.alpha(this.visibilityCutOff),D=this.alpha(this.scoreCutOff);for(let k=0;k<d.length;k++)this.filterCoord3D(d[k].pixel,p[k].pixel,_[k].pixel,E[k].pixel,S,this.pixelParams),this.filterCoord3D(d[k].metric,p[k].metric,_[k].metric,E[k].metric,S,this.metricParams),this.filterCoord3D(d[k].norm,p[k].norm,_[k].norm,E[k].norm,S,this.metricParams),E[k].score=E[k].score+D*(d[k].score-E[k].score),E[k].visibility=E[k].visibility+I*(d[k].visibility-E[k].visibility)}filterCoord3D(d,p,_,E,S,I){const D=[(d[0]-E[0])*S*this.freq,(d[1]-E[1])*S*this.freq,(d[2]-E[2])*S*this.freq],k=this.alpha(I.minCutOffD);_[0]=_[0]+k*(D[0]-_[0]),_[1]=_[1]+k*(D[1]-_[1]),_[2]=_[2]+k*(D[2]-_[2]);const V=[this.alpha(I.minCutOff+I.beta*Math.abs(_[0])),this.alpha(I.minCutOff+I.beta*Math.abs(_[1])),this.alpha(I.minCutOff+I.beta*Math.abs(_[2]))];E[0]=E[0]+V[0]*(d[0]-E[0]),E[1]=E[1]+V[1]*(d[1]-E[1]),E[2]=E[2]+V[2]*(d[2]-E[2]),p[0]=d[0],p[1]=d[1],p[2]=d[2]}filterCoord2D(d,p,_,E,S,I){const D=[(d[0]-E[0])*S*this.freq,(d[1]-E[1])*S*this.freq],k=this.alpha(I.minCutOffD);_[0]=_[0]+k*(D[0]-_[0]),_[1]=_[1]+k*(D[1]-_[1]);const V=[this.alpha(I.minCutOff+I.beta*Math.abs(_[0])),this.alpha(I.minCutOff+I.beta*Math.abs(_[1]))];E[0]=E[0]+V[0]*(d[0]-E[0]),E[1]=E[1]+V[1]*(d[1]-E[1]),p[0]=d[0],p[1]=d[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(d){return 1/(1+this.freq/(2*Math.PI*d))}clonePose(d){return{keypoints:d.keypoints.map(p=>({pixel:[...p.pixel],metric:[...p.metric],norm:[...p.norm],score:p.score,visibility:p.visibility})),score:d.score,center:[...d.center],top:[...d.top],mask:d.mask&&{buffer:d.mask.buffer,size:QJ({},d.mask.size),box:[[...d.mask.box[0]],[...d.mask.box[1]]]},debug:d.debug&&{box:[[...d.debug.box[0]],[...d.debug.box[1]]],center:[...d.debug.center],top:[...d.debug.top],radius:d.debug.radius,angle:d.debug.angle}}}}function Qh(m,d){const p=[Math.max(m.xy.x,d.xy.x),Math.max(m.xy.y,d.xy.y)],_=[Math.min(m.xy.x+m.size.width,m.xy.x+m.size.width),Math.min(m.xy.y+m.size.height,m.xy.y+m.size.height)],E=(_[0]-p[0])*(_[1]-p[1]);return E/(m.size.width*m.size.height+d.size.width*d.size.height-E)}function QY(m,d){const p=[[Math.max(m[0][0],d[0][0]),Math.max(m[0][1],d[0][1])],[Math.min(m[1][0],d[1][0]),Math.min(m[1][1],d[1][1])]],_=(p[1][0]-p[0][0])*(p[1][1]-p[0][1]);return _/((m[1][0]-m[0][0])*(m[1][1]-m[0][1])+(d[1][0]-d[0][0])*(d[1][1]-d[0][1])-_)}function Qm(m){return{xy:{x:m[0][0],y:m[0][1]},size:{width:m[1][0]-m[0][0],height:m[1][1]-m[0][1]}}}function Qx(m){return[[m.xy.x,m.xy.y],[m.xy.x+m.size.width,m.xy.y+m.size.height]]}var Ql=(()=>{var m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(d={}){var p=d,_,E;p.ready=new Promise((at,Je)=>{_=at,E=Je});var S=Object.assign({},p),I=!0,D="";function k(at){return p.locateFile?p.locateFile(at,D):D+at}typeof document<"u"&&document.currentScript&&(D=document.currentScript.src),m&&(D=m),D.startsWith("blob:")?D="":D=D.substr(0,D.replace(/[?#].*/,"").lastIndexOf("/")+1),p.print||console.log.bind(console);var V=p.printErr||console.error.bind(console);Object.assign(p,S),S=null,p.arguments&&p.arguments,p.thisProgram&&p.thisProgram,p.quit&&p.quit;var $;p.wasmBinary&&($=p.wasmBinary);var Z,te=!1,xe,le,he,de,me,ge,be,ye;function ve(){var at=Z.buffer;p.HEAP8=xe=new Int8Array(at),p.HEAP16=he=new Int16Array(at),p.HEAPU8=le=new Uint8Array(at),p.HEAPU16=de=new Uint16Array(at),p.HEAP32=me=new Int32Array(at),p.HEAPU32=ge=new Uint32Array(at),p.HEAPF32=be=new Float32Array(at),p.HEAPF64=ye=new Float64Array(at)}var Ie=[],je=[],Me=[];function xt(){if(p.preRun)for(typeof p.preRun=="function"&&(p.preRun=[p.preRun]);p.preRun.length;)Xt(p.preRun.shift());xs(Ie)}function bt(){xs(je)}function gt(){if(p.postRun)for(typeof p.postRun=="function"&&(p.postRun=[p.postRun]);p.postRun.length;)Ht(p.postRun.shift());xs(Me)}function Xt(at){Ie.unshift(at)}function Ut(at){je.unshift(at)}function Ht(at){Me.unshift(at)}var mi=0,gi=null;function Ui(at){var Je;mi++,(Je=p.monitorRunDependencies)==null||Je.call(p,mi)}function yi(at){var Je;if(mi--,(Je=p.monitorRunDependencies)==null||Je.call(p,mi),mi==0&&gi){var Rt=gi;gi=null,Rt()}}function vi(at){var Je;(Je=p.onAbort)==null||Je.call(p,at),at="Aborted("+at+")",V(at),te=!0,at+=". Build with -sASSERTIONS for more info.";var Rt=new WebAssembly.RuntimeError(at);throw E(Rt),Rt}var ts="data:application/octet-stream;base64,",us=at=>at.startsWith(ts),bi;bi="poseutils.wasm",us(bi)||(bi=k(bi));function Ri(at){if(at==bi&&$)return new Uint8Array($);throw"both async and sync fetching of the wasm failed"}function Nt(at){return!$&&I&&typeof fetch=="function"?fetch(at,{credentials:"same-origin"}).then(Je=>{if(!Je.ok)throw"failed to load wasm binary file at '"+at+"'";return Je.arrayBuffer()}).catch(()=>Ri(at)):Promise.resolve().then(()=>Ri(at))}function $t(at,Je,Rt){return Nt(at).then(_t=>WebAssembly.instantiate(_t,Je)).then(Rt,_t=>{V("failed to asynchronously prepare wasm: "+_t),vi(_t)})}function li(at,Je,Rt,_t){return!at&&typeof WebAssembly.instantiateStreaming=="function"&&!us(Je)&&typeof fetch=="function"?fetch(Je,{credentials:"same-origin"}).then(He=>{var Xe=WebAssembly.instantiateStreaming(He,Rt);return Xe.then(_t,function(lt){return V("wasm streaming compile failed: "+lt),V("falling back to ArrayBuffer instantiation"),$t(Je,Rt,_t)})}):$t(Je,Rt,_t)}function Ei(){var at={a:Uh};function Je(_t,He){return J0=_t.exports,Z=J0.v,ve(),Yn=J0.z,Ut(J0.w),yi(),J0}Ui();function Rt(_t){Je(_t.instance)}if(p.instantiateWasm)try{return p.instantiateWasm(at,Je)}catch(_t){V("Module.instantiateWasm callback failed with error: "+_t),E(_t)}return li($,bi,at,Rt).catch(E),{}}var xs=at=>{for(;at.length>0;)at.shift()(p)};p.noExitRuntime;class Vs{constructor(Je){this.excPtr=Je,this.ptr=Je-24}set_type(Je){ge[this.ptr+4>>2]=Je}get_type(){return ge[this.ptr+4>>2]}set_destructor(Je){ge[this.ptr+8>>2]=Je}get_destructor(){return ge[this.ptr+8>>2]}set_caught(Je){Je=Je?1:0,xe[this.ptr+12]=Je}get_caught(){return xe[this.ptr+12]!=0}set_rethrown(Je){Je=Je?1:0,xe[this.ptr+13]=Je}get_rethrown(){return xe[this.ptr+13]!=0}init(Je,Rt){this.set_adjusted_ptr(0),this.set_type(Je),this.set_destructor(Rt)}set_adjusted_ptr(Je){ge[this.ptr+16>>2]=Je}get_adjusted_ptr(){return ge[this.ptr+16>>2]}get_exception_ptr(){var Je=Ua(this.get_type());if(Je)return ge[this.excPtr>>2];var Rt=this.get_adjusted_ptr();return Rt!==0?Rt:this.excPtr}}var ms=0,bs=(at,Je,Rt)=>{var _t=new Vs(at);throw _t.init(Je,Rt),ms=at,ms},Us={},Mr=at=>{for(;at.length;){var Je=at.pop(),Rt=at.pop();Rt(Je)}};function ar(at){return this.fromWireType(ge[at>>2])}var yr={},jr={},xn={},dn,Rn=at=>{throw new dn(at)},Vn=(at,Je,Rt)=>{at.forEach(function(yt){xn[yt]=Je});function _t(yt){var jt=Rt(yt);jt.length!==at.length&&Rn("Mismatched type converter count");for(var ti=0;ti<at.length;++ti)vr(at[ti],jt[ti])}var He=new Array(Je.length),Xe=[],lt=0;Je.forEach((yt,jt)=>{jr.hasOwnProperty(yt)?He[jt]=jr[yt]:(Xe.push(yt),yr.hasOwnProperty(yt)||(yr[yt]=[]),yr[yt].push(()=>{He[jt]=jr[yt],++lt,lt===Xe.length&&_t(He)}))}),Xe.length===0&&_t(He)},Hi=at=>{var Je=Us[at];delete Us[at];var Rt=Je.rawConstructor,_t=Je.rawDestructor,He=Je.fields,Xe=He.map(lt=>lt.getterReturnType).concat(He.map(lt=>lt.setterArgumentType));Vn([at],Xe,lt=>{var yt={};return He.forEach((jt,ti)=>{var Vt=jt.fieldName,di=lt[ti],Xi=jt.getter,hs=jt.getterContext,Mi=lt[ti+He.length],Ws=jt.setter,Br=jt.setterContext;yt[Vt]={read:Jr=>di.fromWireType(Xi(hs,Jr)),write:(Jr,Mn)=>{var $n=[];Ws(Br,Jr,Mi.toWireType($n,Mn)),Mr($n)}}}),[{name:Je.name,fromWireType:jt=>{var ti={};for(var Vt in yt)ti[Vt]=yt[Vt].read(jt);return _t(jt),ti},toWireType:(jt,ti)=>{for(var Vt in yt)if(!(Vt in ti))throw new TypeError('Missing field: "'+Vt+'"');var di=Rt();for(Vt in yt)yt[Vt].write(di,ti[Vt]);return jt!==null&&jt.push(_t,di),di},argPackAdvance:Io,readValueFromPointer:ar,destructorFunction:_t}]})},Ya=(at,Je,Rt,_t,He)=>{},_o=()=>{for(var at=new Array(256),Je=0;Je<256;++Je)at[Je]=String.fromCharCode(Je);jo=at},jo,aa=at=>{for(var Je="",Rt=at;le[Rt];)Je+=jo[le[Rt++]];return Je},Ur,ur=at=>{throw new Ur(at)};function Y0(at,Je,Rt={}){var _t=Je.name;if(at||ur('type "'+_t+'" must have a positive integer typeid pointer'),jr.hasOwnProperty(at)){if(Rt.ignoreDuplicateRegistrations)return;ur("Cannot register type '"+_t+"' twice")}if(jr[at]=Je,delete xn[at],yr.hasOwnProperty(at)){var He=yr[at];delete yr[at],He.forEach(Xe=>Xe())}}function vr(at,Je,Rt={}){if(!("argPackAdvance"in Je))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Y0(at,Je,Rt)}var Io=8,t0=(at,Je,Rt,_t)=>{Je=aa(Je),vr(at,{name:Je,fromWireType:function(He){return!!He},toWireType:function(He,Xe){return Xe?Rt:_t},argPackAdvance:Io,readValueFromPointer:function(He){return this.fromWireType(le[He])},destructorFunction:null})},y0=at=>({count:at.count,deleteScheduled:at.deleteScheduled,preservePointerOnDelete:at.preservePointerOnDelete,ptr:at.ptr,ptrType:at.ptrType,smartPtr:at.smartPtr,smartPtrType:at.smartPtrType}),v2=at=>{function Je(Rt){return Rt.$$.ptrType.registeredClass.name}ur(Je(at)+" instance already deleted")},bc=!1,Xx=at=>{},dl=at=>{at.smartPtr?at.smartPtrType.rawDestructor(at.smartPtr):at.ptrType.registeredClass.rawDestructor(at.ptr)},Jt=at=>{at.count.value-=1;var Je=at.count.value===0;Je&&dl(at)},Ec=(at,Je,Rt)=>{if(Je===Rt)return at;if(Rt.baseClass===void 0)return null;var _t=Ec(at,Je,Rt.baseClass);return _t===null?null:Rt.downcast(_t)},hn={},a0=()=>Object.keys(jx).length,xa=()=>{var at=[];for(var Je in jx)jx.hasOwnProperty(Je)&&at.push(jx[Je]);return at},Uo=[],ux=()=>{for(;Uo.length;){var at=Uo.pop();at.$$.deleteScheduled=!1,at.delete()}},U0,Yl=at=>{U0=at,Uo.length&&U0&&U0(ux)},tr=()=>{p.getInheritedInstanceCount=a0,p.getLiveInheritedInstances=xa,p.flushPendingDeletes=ux,p.setDelayFunction=Yl},jx={},js=(at,Je)=>{for(Je===void 0&&ur("ptr should not be undefined");at.baseClass;)Je=at.upcast(Je),at=at.baseClass;return Je},Qt=(at,Je)=>(Je=js(at,Je),jx[Je]),$l=(at,Je)=>{(!Je.ptrType||!Je.ptr)&&Rn("makeClassHandle requires ptr and ptrType");var Rt=!!Je.smartPtrType,_t=!!Je.smartPtr;return Rt!==_t&&Rn("Both smartPtrType and smartPtr must be specified"),Je.count={value:1},V0(Object.create(at,{$$:{value:Je,writable:!0}}))};function fh(at){var Je=this.getPointee(at);if(!Je)return this.destructor(at),null;var Rt=Qt(this.registeredClass,Je);if(Rt!==void 0){if(Rt.$$.count.value===0)return Rt.$$.ptr=Je,Rt.$$.smartPtr=at,Rt.clone();var _t=Rt.clone();return this.destructor(at),_t}function He(){return this.isSmartPointer?$l(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:Je,smartPtrType:this,smartPtr:at}):$l(this.registeredClass.instancePrototype,{ptrType:this,ptr:at})}var Xe=this.registeredClass.getActualType(Je),lt=hn[Xe];if(!lt)return He.call(this);var yt;this.isConst?yt=lt.constPointerType:yt=lt.pointerType;var jt=Ec(Je,this.registeredClass,yt.registeredClass);return jt===null?He.call(this):this.isSmartPointer?$l(yt.registeredClass.instancePrototype,{ptrType:yt,ptr:jt,smartPtrType:this,smartPtr:at}):$l(yt.registeredClass.instancePrototype,{ptrType:yt,ptr:jt})}var V0=at=>typeof FinalizationRegistry>"u"?(V0=Je=>Je,at):(bc=new FinalizationRegistry(Je=>{Jt(Je.$$)}),V0=Je=>{var Rt=Je.$$,_t=!!Rt.smartPtr;if(_t){var He={$$:Rt};bc.register(Je,He,Je)}return Je},Xx=Je=>bc.unregister(Je),V0(at)),mh=()=>{Object.assign($0.prototype,{isAliasOf(at){if(!(this instanceof $0)||!(at instanceof $0))return!1;var Je=this.$$.ptrType.registeredClass,Rt=this.$$.ptr;at.$$=at.$$;for(var _t=at.$$.ptrType.registeredClass,He=at.$$.ptr;Je.baseClass;)Rt=Je.upcast(Rt),Je=Je.baseClass;for(;_t.baseClass;)He=_t.upcast(He),_t=_t.baseClass;return Je===_t&&Rt===He},clone(){if(this.$$.ptr||v2(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var at=V0(Object.create(Object.getPrototypeOf(this),{$$:{value:y0(this.$$)}}));return at.$$.count.value+=1,at.$$.deleteScheduled=!1,at},delete(){this.$$.ptr||v2(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&ur("Object already scheduled for deletion"),Xx(this),Jt(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||v2(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&ur("Object already scheduled for deletion"),Uo.push(this),Uo.length===1&&U0&&U0(ux),this.$$.deleteScheduled=!0,this}})};function $0(){}var R2=(at,Je)=>Object.defineProperty(Je,"name",{value:at}),fn=(at,Je,Rt)=>{if(at[Je].overloadTable===void 0){var _t=at[Je];at[Je]=function(...He){return at[Je].overloadTable.hasOwnProperty(He.length)||ur("Function '"+Rt+"' called with an invalid number of arguments ("+He.length+") - expects one of ("+at[Je].overloadTable+")!"),at[Je].overloadTable[He.length].apply(this,He)},at[Je].overloadTable=[],at[Je].overloadTable[_t.argCount]=_t}},dx=(at,Je,Rt)=>{p.hasOwnProperty(at)?((Rt===void 0||p[at].overloadTable!==void 0&&p[at].overloadTable[Rt]!==void 0)&&ur("Cannot register public name '"+at+"' twice"),fn(p,at,at),p.hasOwnProperty(Rt)&&ur("Cannot register multiple overloads of a function with the same number of arguments ("+Rt+")!"),p[at].overloadTable[Rt]=Je):(p[at]=Je,Rt!==void 0&&(p[at].numArguments=Rt))},M2=48,gh=57,_h=at=>{if(at===void 0)return"_unknown";at=at.replace(/[^a-zA-Z0-9_]/g,"$");var Je=at.charCodeAt(0);return Je>=M2&&Je<=gh?"_"+at:at};function _a(at,Je,Rt,_t,He,Xe,lt,yt){this.name=at,this.constructor=Je,this.instancePrototype=Rt,this.rawDestructor=_t,this.baseClass=He,this.getActualType=Xe,this.upcast=lt,this.downcast=yt,this.pureVirtualFunctions=[]}var Jl=(at,Je,Rt)=>{for(;Je!==Rt;)Je.upcast||ur("Expected null or instance of "+Rt.name+", got an instance of "+Je.name),at=Je.upcast(at),Je=Je.baseClass;return at};function k2(at,Je){if(Je===null)return this.isReference&&ur("null is not a valid "+this.name),0;Je.$$||ur('Cannot pass "'+da(Je)+'" as a '+this.name),Je.$$.ptr||ur("Cannot pass deleted object as a pointer of type "+this.name);var Rt=Je.$$.ptrType.registeredClass,_t=Jl(Je.$$.ptr,Rt,this.registeredClass);return _t}function vx(at,Je){var Rt;if(Je===null)return this.isReference&&ur("null is not a valid "+this.name),this.isSmartPointer?(Rt=this.rawConstructor(),at!==null&&at.push(this.rawDestructor,Rt),Rt):0;(!Je||!Je.$$)&&ur('Cannot pass "'+da(Je)+'" as a '+this.name),Je.$$.ptr||ur("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&Je.$$.ptrType.isConst&&ur("Cannot convert argument of type "+(Je.$$.smartPtrType?Je.$$.smartPtrType.name:Je.$$.ptrType.name)+" to parameter type "+this.name);var _t=Je.$$.ptrType.registeredClass;if(Rt=Jl(Je.$$.ptr,_t,this.registeredClass),this.isSmartPointer)switch(Je.$$.smartPtr===void 0&&ur("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:Je.$$.smartPtrType===this?Rt=Je.$$.smartPtr:ur("Cannot convert argument of type "+(Je.$$.smartPtrType?Je.$$.smartPtrType.name:Je.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:Rt=Je.$$.smartPtr;break;case 2:if(Je.$$.smartPtrType===this)Rt=Je.$$.smartPtr;else{var He=Je.clone();Rt=this.rawShare(Rt,Ro.toHandle(()=>He.delete())),at!==null&&at.push(this.rawDestructor,Rt)}break;default:ur("Unsupporting sharing policy")}return Rt}function yh(at,Je){if(Je===null)return this.isReference&&ur("null is not a valid "+this.name),0;Je.$$||ur('Cannot pass "'+da(Je)+'" as a '+this.name),Je.$$.ptr||ur("Cannot pass deleted object as a pointer of type "+this.name),Je.$$.ptrType.isConst&&ur("Cannot convert argument of type "+Je.$$.ptrType.name+" to parameter type "+this.name);var Rt=Je.$$.ptrType.registeredClass,_t=Jl(Je.$$.ptr,Rt,this.registeredClass);return _t}var vc=()=>{Object.assign(fl.prototype,{getPointee(at){return this.rawGetPointee&&(at=this.rawGetPointee(at)),at},destructor(at){var Je;(Je=this.rawDestructor)==null||Je.call(this,at)},argPackAdvance:Io,readValueFromPointer:ar,fromWireType:fh})};function fl(at,Je,Rt,_t,He,Xe,lt,yt,jt,ti,Vt){this.name=at,this.registeredClass=Je,this.isReference=Rt,this.isConst=_t,this.isSmartPointer=He,this.pointeeType=Xe,this.sharingPolicy=lt,this.rawGetPointee=yt,this.rawConstructor=jt,this.rawShare=ti,this.rawDestructor=Vt,!He&&Je.baseClass===void 0?_t?(this.toWireType=k2,this.destructorFunction=null):(this.toWireType=yh,this.destructorFunction=null):this.toWireType=vx}var Ix=(at,Je,Rt)=>{p.hasOwnProperty(at)||Rn("Replacing nonexistent public symbol"),p[at].overloadTable!==void 0&&Rt!==void 0?p[at].overloadTable[Rt]=Je:(p[at]=Je,p[at].argCount=Rt)},ho=(at,Je,Rt)=>{var _t=p["dynCall_"+at];return _t(Je,...Rt)},hi=[],Yn,ml=at=>{var Je=hi[at];return Je||(at>=hi.length&&(hi.length=at+1),hi[at]=Je=Yn.get(at)),Je},uo=(at,Je,Rt=[])=>{if(at.includes("j"))return ho(at,Je,Rt);var _t=ml(Je)(...Rt);return _t},B2=(at,Je)=>(...Rt)=>uo(at,Je,Rt),Ba=(at,Je)=>{at=aa(at);function Rt(){return at.includes("j")?B2(at,Je):ml(Je)}var _t=Rt();return typeof _t!="function"&&ur("unknown function pointer with signature "+at+": "+Je),_t},bh=(at,Je)=>{var Rt=R2(Je,function(_t){this.name=Je,this.message=_t;var He=new Error(_t).stack;He!==void 0&&(this.stack=this.toString()+`
`+He.replace(/^Error(:[^\n]*)?\n/,""))});return Rt.prototype=Object.create(at.prototype),Rt.prototype.constructor=Rt,Rt.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},Rt},x0,fo=at=>{var Je=as(at),Rt=aa(Je);return mx(Je),Rt},Vo=(at,Je)=>{var Rt=[],_t={};function He(Xe){if(!_t[Xe]&&!jr[Xe]){if(xn[Xe]){xn[Xe].forEach(He);return}Rt.push(Xe),_t[Xe]=!0}}throw Je.forEach(He),new x0(at+": "+Rt.map(fo).join([", "]))},U2=(at,Je,Rt,_t,He,Xe,lt,yt,jt,ti,Vt,di,Xi)=>{Vt=aa(Vt),Xe=Ba(He,Xe),yt&&(yt=Ba(lt,yt)),ti&&(ti=Ba(jt,ti)),Xi=Ba(di,Xi);var hs=_h(Vt);dx(hs,function(){Vo("Cannot construct "+Vt+" due to unbound types",[_t])}),Vn([at,Je,Rt],_t?[_t]:[],Mi=>{var Ws;Mi=Mi[0];var Br,Jr;_t?(Br=Mi.registeredClass,Jr=Br.instancePrototype):Jr=$0.prototype;var Mn=R2(Vt,function(...W0){if(Object.getPrototypeOf(this)!==$n)throw new Ur("Use 'new' to construct "+Vt);if(Hr.constructor_body===void 0)throw new Ur(Vt+" has no accessible constructor");var Va=Hr.constructor_body[W0.length];if(Va===void 0)throw new Ur("Tried to invoke ctor of "+Vt+" with invalid number of parameters ("+W0.length+") - expected ("+Object.keys(Hr.constructor_body).toString()+") parameters instead!");return Va.apply(this,W0)}),$n=Object.create(Jr,{constructor:{value:Mn}});Mn.prototype=$n;var Hr=new _a(Vt,Mn,$n,Xi,Br,Xe,yt,ti);Hr.baseClass&&((Ws=Hr.baseClass).__derivedClasses!=null||(Ws.__derivedClasses=[]),Hr.baseClass.__derivedClasses.push(Hr));var Ir=new fl(Vt,Hr,!0,!1,!1),u0=new fl(Vt+"*",Hr,!1,!1,!1),tn=new fl(Vt+" const*",Hr,!1,!0,!1);return hn[at]={pointerType:u0,constPointerType:tn},Ix(hs,Mn),[Ir,u0,tn]})},Wn=(at,Je)=>{for(var Rt=[],_t=0;_t<at;_t++)Rt.push(ge[Je+_t*4>>2]);return Rt};function Yx(at){for(var Je=1;Je<at.length;++Je)if(at[Je]!==null&&at[Je].destructorFunction===void 0)return!0;return!1}function Yo(at,Je,Rt,_t,He,Xe){var lt=Je.length;lt<2&&ur("argTypes array size mismatch! Must at least get return value and 'this' types!");var yt=Je[1]!==null&&Rt!==null,jt=Yx(Je),ti=Je[0].name!=="void",Vt=lt-2,di=new Array(Vt),Xi=[],hs=[],Mi=function(...Ws){Ws.length!==Vt&&ur("function "+at+" called with "+Ws.length+" arguments, expected "+Vt),hs.length=0;var Br;Xi.length=yt?2:1,Xi[0]=He,yt&&(Br=Je[1].toWireType(hs,this),Xi[1]=Br);for(var Jr=0;Jr<Vt;++Jr)di[Jr]=Je[Jr+2].toWireType(hs,Ws[Jr]),Xi.push(di[Jr]);var Mn=_t(...Xi);function $n(Hr){if(jt)Mr(hs);else for(var Ir=yt?1:2;Ir<Je.length;Ir++){var u0=Ir===1?Br:di[Ir-2];Je[Ir].destructorFunction!==null&&Je[Ir].destructorFunction(u0)}if(ti)return Je[0].fromWireType(Hr)}return $n(Mn)};return R2(at,Mi)}var Ic=(at,Je,Rt,_t,He,Xe)=>{var lt=Wn(Je,Rt);He=Ba(_t,He),Vn([],[at],yt=>{yt=yt[0];var jt="constructor "+yt.name;if(yt.registeredClass.constructor_body===void 0&&(yt.registeredClass.constructor_body=[]),yt.registeredClass.constructor_body[Je-1]!==void 0)throw new Ur("Cannot register multiple constructors with identical number of parameters ("+(Je-1)+") for class '"+yt.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return yt.registeredClass.constructor_body[Je-1]=()=>{Vo("Cannot construct "+yt.name+" due to unbound types",lt)},Vn([],lt,ti=>(ti.splice(1,0,null),yt.registeredClass.constructor_body[Je-1]=Yo(jt,ti,null,He,Xe),[])),[]})},Wo=at=>{at=at.trim();const Je=at.indexOf("(");return Je!==-1?at.substr(0,Je):at},Eh=(at,Je,Rt,_t,He,Xe,lt,yt,jt)=>{var ti=Wn(Rt,_t);Je=aa(Je),Je=Wo(Je),Xe=Ba(He,Xe),Vn([],[at],Vt=>{Vt=Vt[0];var di=Vt.name+"."+Je;Je.startsWith("@@")&&(Je=Symbol[Je.substring(2)]),yt&&Vt.registeredClass.pureVirtualFunctions.push(Je);function Xi(){Vo("Cannot call "+di+" due to unbound types",ti)}var hs=Vt.registeredClass.instancePrototype,Mi=hs[Je];return Mi===void 0||Mi.overloadTable===void 0&&Mi.className!==Vt.name&&Mi.argCount===Rt-2?(Xi.argCount=Rt-2,Xi.className=Vt.name,hs[Je]=Xi):(fn(hs,Je,di),hs[Je].overloadTable[Rt-2]=Xi),Vn([],ti,Ws=>{var Br=Yo(di,Ws,Vt,Xe,lt);return hs[Je].overloadTable===void 0?(Br.argCount=Rt-2,hs[Je]=Br):hs[Je].overloadTable[Rt-2]=Br,[]}),[]})},Es=(at,Je,Rt)=>(at instanceof Object||ur(Rt+' with invalid "this": '+at),at instanceof Je.registeredClass.constructor||ur(Rt+' incompatible with "this" of type '+at.constructor.name),at.$$.ptr||ur("cannot call emscripten binding method "+Rt+" on deleted object"),Jl(at.$$.ptr,at.$$.ptrType.registeredClass,Je.registeredClass)),vh=(at,Je,Rt,_t,He,Xe,lt,yt,jt,ti)=>{Je=aa(Je),He=Ba(_t,He),Vn([],[at],Vt=>{Vt=Vt[0];var di=Vt.name+"."+Je,Xi={get(){Vo("Cannot access "+di+" due to unbound types",[Rt,lt])},enumerable:!0,configurable:!0};return jt?Xi.set=()=>Vo("Cannot access "+di+" due to unbound types",[Rt,lt]):Xi.set=hs=>ur(di+" is a read-only property"),Object.defineProperty(Vt.registeredClass.instancePrototype,Je,Xi),Vn([],jt?[Rt,lt]:[Rt],hs=>{var Mi=hs[0],Ws={get(){var Jr=Es(this,Vt,di+" getter");return Mi.fromWireType(He(Xe,Jr))},enumerable:!0};if(jt){jt=Ba(yt,jt);var Br=hs[1];Ws.set=function(Jr){var Mn=Es(this,Vt,di+" setter"),$n=[];jt(ti,Mn,Br.toWireType($n,Jr)),Mr($n)}}return Object.defineProperty(Vt.registeredClass.instancePrototype,Je,Ws),[]}),[]})},t2=[],l0=[],a2=at=>{at>9&&--l0[at+1]===0&&(l0[at]=void 0,t2.push(at))},Bt=()=>l0.length/2-5-t2.length,x2=()=>{l0.push(0,1,void 0,1,null,1,!0,1,!1,1),p.count_emval_handles=Bt},Ro={toValue:at=>(at||ur("Cannot use deleted val. handle = "+at),l0[at]),toHandle:at=>{switch(at){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const Je=t2.pop()||l0.length;return l0[Je]=at,l0[Je+1]=1,Je}}}},$x={name:"emscripten::val",fromWireType:at=>{var Je=Ro.toValue(at);return a2(at),Je},toWireType:(at,Je)=>Ro.toHandle(Je),argPackAdvance:Io,readValueFromPointer:ar,destructorFunction:null},l2=at=>vr(at,$x),da=at=>{if(at===null)return"null";var Je=typeof at;return Je==="object"||Je==="array"||Je==="function"?at.toString():""+at},h0=(at,Je)=>{switch(Je){case 4:return function(Rt){return this.fromWireType(be[Rt>>2])};case 8:return function(Rt){return this.fromWireType(ye[Rt>>3])};default:throw new TypeError("invalid float width ("+Je+"): "+at)}},V2=(at,Je,Rt)=>{Je=aa(Je),vr(at,{name:Je,fromWireType:_t=>_t,toWireType:(_t,He)=>He,argPackAdvance:Io,readValueFromPointer:h0(Je,Rt),destructorFunction:null})},Jx=(at,Je,Rt)=>{switch(Je){case 1:return Rt?_t=>xe[_t]:_t=>le[_t];case 2:return Rt?_t=>he[_t>>1]:_t=>de[_t>>1];case 4:return Rt?_t=>me[_t>>2]:_t=>ge[_t>>2];default:throw new TypeError("invalid integer width ("+Je+"): "+at)}},Ho=(at,Je,Rt,_t,He)=>{Je=aa(Je);var Xe=Vt=>Vt;if(_t===0){var lt=32-8*Rt;Xe=Vt=>Vt<<lt>>>lt}var yt=Je.includes("unsigned"),jt=(Vt,di)=>{},ti;yt?ti=function(Vt,di){return jt(di,this.name),di>>>0}:ti=function(Vt,di){return jt(di,this.name),di},vr(at,{name:Je,fromWireType:Xe,toWireType:ti,argPackAdvance:Io,readValueFromPointer:Jx(Je,Rt,_t!==0),destructorFunction:null})},Xo=(at,Je,Rt)=>{var _t=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],He=_t[Je];function Xe(lt){var yt=ge[lt>>2],jt=ge[lt+4>>2];return new He(xe.buffer,jt,yt)}Rt=aa(Rt),vr(at,{name:Rt,fromWireType:Xe,argPackAdvance:Io,readValueFromPointer:Xe},{ignoreDuplicateRegistrations:!0})},Ih=(at,Je,Rt,_t)=>{if(!(_t>0))return 0;for(var He=Rt,Xe=Rt+_t-1,lt=0;lt<at.length;++lt){var yt=at.charCodeAt(lt);if(yt>=55296&&yt<=57343){var jt=at.charCodeAt(++lt);yt=65536+((yt&1023)<<10)|jt&1023}if(yt<=127){if(Rt>=Xe)break;Je[Rt++]=yt}else if(yt<=2047){if(Rt+1>=Xe)break;Je[Rt++]=192|yt>>6,Je[Rt++]=128|yt&63}else if(yt<=65535){if(Rt+2>=Xe)break;Je[Rt++]=224|yt>>12,Je[Rt++]=128|yt>>6&63,Je[Rt++]=128|yt&63}else{if(Rt+3>=Xe)break;Je[Rt++]=240|yt>>18,Je[Rt++]=128|yt>>12&63,Je[Rt++]=128|yt>>6&63,Je[Rt++]=128|yt&63}}return Je[Rt]=0,Rt-He},Rh=(at,Je,Rt)=>Ih(at,le,Je,Rt),Rc=at=>{for(var Je=0,Rt=0;Rt<at.length;++Rt){var _t=at.charCodeAt(Rt);_t<=127?Je++:_t<=2047?Je+=2:_t>=55296&&_t<=57343?(Je+=4,++Rt):Je+=3}return Je},h2=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,u2=(at,Je,Rt)=>{for(var _t=Je+Rt,He=Je;at[He]&&!(He>=_t);)++He;if(He-Je>16&&at.buffer&&h2)return h2.decode(at.subarray(Je,He));for(var Xe="";Je<He;){var lt=at[Je++];if(!(lt&128)){Xe+=String.fromCharCode(lt);continue}var yt=at[Je++]&63;if((lt&224)==192){Xe+=String.fromCharCode((lt&31)<<6|yt);continue}var jt=at[Je++]&63;if((lt&240)==224?lt=(lt&15)<<12|yt<<6|jt:lt=(lt&7)<<18|yt<<12|jt<<6|at[Je++]&63,lt<65536)Xe+=String.fromCharCode(lt);else{var ti=lt-65536;Xe+=String.fromCharCode(55296|ti>>10,56320|ti&1023)}}return Xe},yo=(at,Je)=>at?u2(le,at,Je):"",Mh=(at,Je)=>{Je=aa(Je);var Rt=Je==="std::string";vr(at,{name:Je,fromWireType(_t){var He=ge[_t>>2],Xe=_t+4,lt;if(Rt)for(var yt=Xe,jt=0;jt<=He;++jt){var ti=Xe+jt;if(jt==He||le[ti]==0){var Vt=ti-yt,di=yo(yt,Vt);lt===void 0?lt=di:(lt+="\0",lt+=di),yt=ti+1}}else{for(var Xi=new Array(He),jt=0;jt<He;++jt)Xi[jt]=String.fromCharCode(le[Xe+jt]);lt=Xi.join("")}return mx(_t),lt},toWireType(_t,He){He instanceof ArrayBuffer&&(He=new Uint8Array(He));var Xe,lt=typeof He=="string";lt||He instanceof Uint8Array||He instanceof Uint8ClampedArray||He instanceof Int8Array||ur("Cannot pass non-string to std::string"),Rt&&lt?Xe=Rc(He):Xe=He.length;var yt=m2(4+Xe+1),jt=yt+4;if(ge[yt>>2]=Xe,Rt&&lt)Rh(He,jt,Xe+1);else if(lt)for(var ti=0;ti<Xe;++ti){var Vt=He.charCodeAt(ti);Vt>255&&(mx(jt),ur("String has UTF-16 code units that do not fit in 8 bits")),le[jt+ti]=Vt}else for(var ti=0;ti<Xe;++ti)le[jt+ti]=He[ti];return _t!==null&&_t.push(mx,yt),yt},argPackAdvance:Io,readValueFromPointer:ar,destructorFunction(_t){mx(_t)}})},Mc=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,d2=(at,Je)=>{for(var Rt=at,_t=Rt>>1,He=_t+Je/2;!(_t>=He)&&de[_t];)++_t;if(Rt=_t<<1,Rt-at>32&&Mc)return Mc.decode(le.subarray(at,Rt));for(var Xe="",lt=0;!(lt>=Je/2);++lt){var yt=he[at+lt*2>>1];if(yt==0)break;Xe+=String.fromCharCode(yt)}return Xe},b0=(at,Je,Rt)=>{if(Rt!=null||(Rt=2147483647),Rt<2)return 0;Rt-=2;for(var _t=Je,He=Rt<at.length*2?Rt/2:at.length,Xe=0;Xe<He;++Xe){var lt=at.charCodeAt(Xe);he[Je>>1]=lt,Je+=2}return he[Je>>1]=0,Je-_t},gl=at=>at.length*2,_l=(at,Je)=>{for(var Rt=0,_t="";!(Rt>=Je/4);){var He=me[at+Rt*4>>2];if(He==0)break;if(++Rt,He>=65536){var Xe=He-65536;_t+=String.fromCharCode(55296|Xe>>10,56320|Xe&1023)}else _t+=String.fromCharCode(He)}return _t},W2=(at,Je,Rt)=>{if(Rt!=null||(Rt=2147483647),Rt<4)return 0;for(var _t=Je,He=_t+Rt-4,Xe=0;Xe<at.length;++Xe){var lt=at.charCodeAt(Xe);if(lt>=55296&&lt<=57343){var yt=at.charCodeAt(++Xe);lt=65536+((lt&1023)<<10)|yt&1023}if(me[Je>>2]=lt,Je+=4,Je+4>He)break}return me[Je>>2]=0,Je-_t},la=at=>{for(var Je=0,Rt=0;Rt<at.length;++Rt){var _t=at.charCodeAt(Rt);_t>=55296&&_t<=57343&&++Rt,Je+=4}return Je},Bc=(at,Je,Rt)=>{Rt=aa(Rt);var _t,He,Xe,lt;Je===2?(_t=d2,He=b0,lt=gl,Xe=yt=>de[yt>>1]):Je===4&&(_t=_l,He=W2,lt=la,Xe=yt=>ge[yt>>2]),vr(at,{name:Rt,fromWireType:yt=>{for(var jt=ge[yt>>2],ti,Vt=yt+4,di=0;di<=jt;++di){var Xi=yt+4+di*Je;if(di==jt||Xe(Xi)==0){var hs=Xi-Vt,Mi=_t(Vt,hs);ti===void 0?ti=Mi:(ti+="\0",ti+=Mi),Vt=Xi+Je}}return mx(yt),ti},toWireType:(yt,jt)=>{typeof jt!="string"&&ur("Cannot pass non-string to C++ string type "+Rt);var ti=lt(jt),Vt=m2(4+ti+Je);return ge[Vt>>2]=ti/Je,He(jt,Vt+4,ti+Je),yt!==null&&yt.push(mx,Vt),Vt},argPackAdvance:Io,readValueFromPointer:ar,destructorFunction(yt){mx(yt)}})},H2=(at,Je,Rt,_t,He,Xe)=>{Us[at]={name:aa(Je),rawConstructor:Ba(Rt,_t),rawDestructor:Ba(He,Xe),fields:[]}},f2=(at,Je,Rt,_t,He,Xe,lt,yt,jt,ti)=>{Us[at].fields.push({fieldName:aa(Je),getterReturnType:Rt,getter:Ba(_t,He),getterContext:Xe,setterArgumentType:lt,setter:Ba(yt,jt),setterContext:ti})},yl=(at,Je)=>{Je=aa(Je),vr(at,{isVoid:!0,name:Je,argPackAdvance:0,fromWireType:()=>{},toWireType:(Rt,_t)=>{}})},fx=(at,Je)=>{var Rt=jr[at];return Rt===void 0&&ur(Je+" has unknown type "+fo(at)),Rt},X2=(at,Je)=>{at=fx(at,"_emval_take_value");var Rt=at.readValueFromPointer(Je);return Ro.toHandle(Rt)},Uc=()=>{vi("")},bl=(at,Je,Rt)=>le.copyWithin(at,Je,Je+Rt),Bh=()=>2147483648,El=at=>{var Je=Z.buffer,Rt=(at-Je.byteLength+65535)/65536;try{return Z.grow(Rt),ve(),1}catch{}},Vc=at=>{var Je=le.length;at>>>=0;var Rt=Bh();if(at>Rt)return!1;for(var _t=(jt,ti)=>jt+(ti-jt%ti)%ti,He=1;He<=4;He*=2){var Xe=Je*(1+.2/He);Xe=Math.min(Xe,at+100663296);var lt=Math.min(Rt,_t(Math.max(at,Xe),65536)),yt=El(lt);if(yt)return!0}return!1};dn=p.InternalError=class extends Error{constructor(at){super(at),this.name="InternalError"}},_o(),Ur=p.BindingError=class extends Error{constructor(at){super(at),this.name="BindingError"}},mh(),tr(),vc(),x0=p.UnboundTypeError=bh(Error,"UnboundTypeError"),x2();var Uh={c:bs,m:Hi,p:Ya,u:t0,i:U2,h:Ic,b:Eh,e:vh,t:l2,k:V2,d:Ho,a:Xo,j:Mh,g:Bc,n:H2,f:f2,l:yl,o:X2,q:Uc,s:bl,r:Vc},J0=Ei(),mx=at=>(mx=J0.x)(at),m2=at=>(m2=J0.y)(at),as=at=>(as=J0.A)(at),Ua=at=>(Ua=J0.B)(at),E0;gi=function at(){E0||v0(),E0||(gi=at)};function v0(){if(mi>0||(xt(),mi>0))return;function at(){E0||(E0=!0,p.calledRun=!0,!te&&(bt(),_(p),p.onRuntimeInitialized&&p.onRuntimeInitialized(),gt()))}p.setStatus?(p.setStatus("Running..."),setTimeout(function(){setTimeout(function(){p.setStatus("")},1),at()},1)):at()}if(p.preInit)for(typeof p.preInit=="function"&&(p.preInit=[p.preInit]);p.preInit.length>0;)p.preInit.pop()();return v0(),d.ready}})(),Qb=(()=>{var m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(d={}){var p=d,_,E;p.ready=new Promise((We,Ue)=>{_=We,E=Ue});var S=Object.assign({},p),I="./this.program",D=(We,Ue)=>{throw Ue},k=!0,V=!1,$="";function Z(We){return p.locateFile?p.locateFile(We,$):$+We}typeof document<"u"&&document.currentScript&&($=document.currentScript.src),m&&($=m),$.startsWith("blob:")?$="":$=$.substr(0,$.replace(/[?#].*/,"").lastIndexOf("/")+1),p.print||console.log.bind(console);var te=p.printErr||console.error.bind(console);Object.assign(p,S),S=null,p.arguments&&p.arguments,p.thisProgram&&(I=p.thisProgram),p.quit&&(D=p.quit);var xe;p.wasmBinary&&(xe=p.wasmBinary);var le,he=!1,de,me,ge,be,ye,ve,Ie,je,Me;function xt(){var We=le.buffer;p.HEAP8=me=new Int8Array(We),p.HEAP16=be=new Int16Array(We),p.HEAPU8=ge=new Uint8Array(We),p.HEAPU16=ye=new Uint16Array(We),p.HEAP32=ve=new Int32Array(We),p.HEAPU32=Ie=new Uint32Array(We),p.HEAPF32=je=new Float32Array(We),p.HEAPF64=Me=new Float64Array(We)}var bt=[],gt=[],Xt=[];function Ut(){if(p.preRun)for(typeof p.preRun=="function"&&(p.preRun=[p.preRun]);p.preRun.length;)gi(p.preRun.shift());Mr(bt)}function Ht(){Mr(gt)}function mi(){if(p.postRun)for(typeof p.postRun=="function"&&(p.postRun=[p.postRun]);p.postRun.length;)yi(p.postRun.shift());Mr(Xt)}function gi(We){bt.unshift(We)}function Ui(We){gt.unshift(We)}function yi(We){Xt.unshift(We)}var vi=0,ts=null;function us(We){var Ue;vi++,(Ue=p.monitorRunDependencies)==null||Ue.call(p,vi)}function bi(We){var Ue;if(vi--,(Ue=p.monitorRunDependencies)==null||Ue.call(p,vi),vi==0&&ts){var mt=ts;ts=null,mt()}}function Ri(We){var Ue;(Ue=p.onAbort)==null||Ue.call(p,We),We="Aborted("+We+")",te(We),he=!0,de=1,We+=". Build with -sASSERTIONS for more info.";var mt=new WebAssembly.RuntimeError(We);throw E(mt),mt}var Nt="data:application/octet-stream;base64,",$t=We=>We.startsWith(Nt),li;li="bodyutils.wasm",$t(li)||(li=Z(li));function Ei(We){if(We==li&&xe)return new Uint8Array(xe);throw"both async and sync fetching of the wasm failed"}function xs(We){return!xe&&k&&typeof fetch=="function"?fetch(We,{credentials:"same-origin"}).then(Ue=>{if(!Ue.ok)throw"failed to load wasm binary file at '"+We+"'";return Ue.arrayBuffer()}).catch(()=>Ei(We)):Promise.resolve().then(()=>Ei(We))}function Vs(We,Ue,mt){return xs(We).then(Wt=>WebAssembly.instantiate(Wt,Ue)).then(mt,Wt=>{te("failed to asynchronously prepare wasm: "+Wt),Ri(Wt)})}function ms(We,Ue,mt,Wt){return!We&&typeof WebAssembly.instantiateStreaming=="function"&&!$t(Ue)&&typeof fetch=="function"?fetch(Ue,{credentials:"same-origin"}).then(_i=>{var Ii=WebAssembly.instantiateStreaming(_i,mt);return Ii.then(Wt,function(ji){return te("wasm streaming compile failed: "+ji),te("falling back to ArrayBuffer instantiation"),Vs(Ue,mt,Wt)})}):Vs(Ue,mt,Wt)}function bs(){var We={a:Jp};function Ue(Wt,_i){return gx=Wt.exports,le=gx.E,xt(),B2=gx.H,Ui(gx.F),bi(),gx}us();function mt(Wt){Ue(Wt.instance)}if(p.instantiateWasm)try{return p.instantiateWasm(We,Ue)}catch(Wt){te("Module.instantiateWasm callback failed with error: "+Wt),E(Wt)}return ms(xe,li,We,mt).catch(E),{}}function Us(We){this.name="ExitStatus",this.message="Program terminated with exit("+We+")",this.status=We}var Mr=We=>{for(;We.length>0;)We.shift()(p)},ar=p.noExitRuntime||!0;class yr{constructor(Ue){this.excPtr=Ue,this.ptr=Ue-24}set_type(Ue){Ie[this.ptr+4>>2]=Ue}get_type(){return Ie[this.ptr+4>>2]}set_destructor(Ue){Ie[this.ptr+8>>2]=Ue}get_destructor(){return Ie[this.ptr+8>>2]}set_caught(Ue){Ue=Ue?1:0,me[this.ptr+12]=Ue}get_caught(){return me[this.ptr+12]!=0}set_rethrown(Ue){Ue=Ue?1:0,me[this.ptr+13]=Ue}get_rethrown(){return me[this.ptr+13]!=0}init(Ue,mt){this.set_adjusted_ptr(0),this.set_type(Ue),this.set_destructor(mt)}set_adjusted_ptr(Ue){Ie[this.ptr+16>>2]=Ue}get_adjusted_ptr(){return Ie[this.ptr+16>>2]}get_exception_ptr(){var Ue=r_(this.get_type());if(Ue)return Ie[this.excPtr>>2];var mt=this.get_adjusted_ptr();return mt!==0?mt:this.excPtr}}var jr=0,xn=(We,Ue,mt)=>{var Wt=new yr(We);throw Wt.init(Ue,mt),jr=We,jr},dn=(We,Ue,mt,Wt,_i)=>{},Rn=()=>{for(var We=new Array(256),Ue=0;Ue<256;++Ue)We[Ue]=String.fromCharCode(Ue);Vn=We},Vn,Hi=We=>{for(var Ue="",mt=We;ge[mt];)Ue+=Vn[ge[mt++]];return Ue},Ya={},_o={},jo={},aa,Ur=We=>{throw new aa(We)},ur,Y0=We=>{throw new ur(We)},vr=(We,Ue,mt)=>{We.forEach(function(Bi){jo[Bi]=Ue});function Wt(Bi){var vs=mt(Bi);vs.length!==We.length&&Y0("Mismatched type converter count");for(var Ys=0;Ys<We.length;++Ys)t0(We[Ys],vs[Ys])}var _i=new Array(Ue.length),Ii=[],ji=0;Ue.forEach((Bi,vs)=>{_o.hasOwnProperty(Bi)?_i[vs]=_o[Bi]:(Ii.push(Bi),Ya.hasOwnProperty(Bi)||(Ya[Bi]=[]),Ya[Bi].push(()=>{_i[vs]=_o[Bi],++ji,ji===Ii.length&&Wt(_i)}))}),Ii.length===0&&Wt(_i)};function Io(We,Ue,mt={}){var Wt=Ue.name;if(We||Ur('type "'+Wt+'" must have a positive integer typeid pointer'),_o.hasOwnProperty(We)){if(mt.ignoreDuplicateRegistrations)return;Ur("Cannot register type '"+Wt+"' twice")}if(_o[We]=Ue,delete jo[We],Ya.hasOwnProperty(We)){var _i=Ya[We];delete Ya[We],_i.forEach(Ii=>Ii())}}function t0(We,Ue,mt={}){if(!("argPackAdvance"in Ue))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Io(We,Ue,mt)}var y0=8,v2=(We,Ue,mt,Wt)=>{Ue=Hi(Ue),t0(We,{name:Ue,fromWireType:function(_i){return!!_i},toWireType:function(_i,Ii){return Ii?mt:Wt},argPackAdvance:y0,readValueFromPointer:function(_i){return this.fromWireType(ge[_i])},destructorFunction:null})},bc=We=>({count:We.count,deleteScheduled:We.deleteScheduled,preservePointerOnDelete:We.preservePointerOnDelete,ptr:We.ptr,ptrType:We.ptrType,smartPtr:We.smartPtr,smartPtrType:We.smartPtrType}),Xx=We=>{function Ue(mt){return mt.$$.ptrType.registeredClass.name}Ur(Ue(We)+" instance already deleted")},dl=!1,Jt=We=>{},Ec=We=>{We.smartPtr?We.smartPtrType.rawDestructor(We.smartPtr):We.ptrType.registeredClass.rawDestructor(We.ptr)},hn=We=>{We.count.value-=1;var Ue=We.count.value===0;Ue&&Ec(We)},a0=(We,Ue,mt)=>{if(Ue===mt)return We;if(mt.baseClass===void 0)return null;var Wt=a0(We,Ue,mt.baseClass);return Wt===null?null:mt.downcast(Wt)},xa={},Uo=()=>Object.keys(Qt).length,ux=()=>{var We=[];for(var Ue in Qt)Qt.hasOwnProperty(Ue)&&We.push(Qt[Ue]);return We},U0=[],Yl=()=>{for(;U0.length;){var We=U0.pop();We.$$.deleteScheduled=!1,We.delete()}},tr,jx=We=>{tr=We,U0.length&&tr&&tr(Yl)},js=()=>{p.getInheritedInstanceCount=Uo,p.getLiveInheritedInstances=ux,p.flushPendingDeletes=Yl,p.setDelayFunction=jx},Qt={},$l=(We,Ue)=>{for(Ue===void 0&&Ur("ptr should not be undefined");We.baseClass;)Ue=We.upcast(Ue),We=We.baseClass;return Ue},fh=(We,Ue)=>(Ue=$l(We,Ue),Qt[Ue]),V0=(We,Ue)=>{(!Ue.ptrType||!Ue.ptr)&&Y0("makeClassHandle requires ptr and ptrType");var mt=!!Ue.smartPtrType,Wt=!!Ue.smartPtr;return mt!==Wt&&Y0("Both smartPtrType and smartPtr must be specified"),Ue.count={value:1},$0(Object.create(We,{$$:{value:Ue,writable:!0}}))};function mh(We){var Ue=this.getPointee(We);if(!Ue)return this.destructor(We),null;var mt=fh(this.registeredClass,Ue);if(mt!==void 0){if(mt.$$.count.value===0)return mt.$$.ptr=Ue,mt.$$.smartPtr=We,mt.clone();var Wt=mt.clone();return this.destructor(We),Wt}function _i(){return this.isSmartPointer?V0(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:Ue,smartPtrType:this,smartPtr:We}):V0(this.registeredClass.instancePrototype,{ptrType:this,ptr:We})}var Ii=this.registeredClass.getActualType(Ue),ji=xa[Ii];if(!ji)return _i.call(this);var Bi;this.isConst?Bi=ji.constPointerType:Bi=ji.pointerType;var vs=a0(Ue,this.registeredClass,Bi.registeredClass);return vs===null?_i.call(this):this.isSmartPointer?V0(Bi.registeredClass.instancePrototype,{ptrType:Bi,ptr:vs,smartPtrType:this,smartPtr:We}):V0(Bi.registeredClass.instancePrototype,{ptrType:Bi,ptr:vs})}var $0=We=>typeof FinalizationRegistry>"u"?($0=Ue=>Ue,We):(dl=new FinalizationRegistry(Ue=>{hn(Ue.$$)}),$0=Ue=>{var mt=Ue.$$,Wt=!!mt.smartPtr;if(Wt){var _i={$$:mt};dl.register(Ue,_i,Ue)}return Ue},Jt=Ue=>dl.unregister(Ue),$0(We)),R2=()=>{Object.assign(fn.prototype,{isAliasOf(We){if(!(this instanceof fn)||!(We instanceof fn))return!1;var Ue=this.$$.ptrType.registeredClass,mt=this.$$.ptr;We.$$=We.$$;for(var Wt=We.$$.ptrType.registeredClass,_i=We.$$.ptr;Ue.baseClass;)mt=Ue.upcast(mt),Ue=Ue.baseClass;for(;Wt.baseClass;)_i=Wt.upcast(_i),Wt=Wt.baseClass;return Ue===Wt&&mt===_i},clone(){if(this.$$.ptr||Xx(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var We=$0(Object.create(Object.getPrototypeOf(this),{$$:{value:bc(this.$$)}}));return We.$$.count.value+=1,We.$$.deleteScheduled=!1,We},delete(){this.$$.ptr||Xx(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Ur("Object already scheduled for deletion"),Jt(this),hn(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||Xx(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Ur("Object already scheduled for deletion"),U0.push(this),U0.length===1&&tr&&tr(Yl),this.$$.deleteScheduled=!0,this}})};function fn(){}var dx=(We,Ue)=>Object.defineProperty(Ue,"name",{value:We}),M2=(We,Ue,mt)=>{if(We[Ue].overloadTable===void 0){var Wt=We[Ue];We[Ue]=function(..._i){return We[Ue].overloadTable.hasOwnProperty(_i.length)||Ur("Function '"+mt+"' called with an invalid number of arguments ("+_i.length+") - expects one of ("+We[Ue].overloadTable+")!"),We[Ue].overloadTable[_i.length].apply(this,_i)},We[Ue].overloadTable=[],We[Ue].overloadTable[Wt.argCount]=Wt}},gh=(We,Ue,mt)=>{p.hasOwnProperty(We)?((mt===void 0||p[We].overloadTable!==void 0&&p[We].overloadTable[mt]!==void 0)&&Ur("Cannot register public name '"+We+"' twice"),M2(p,We,We),p.hasOwnProperty(mt)&&Ur("Cannot register multiple overloads of a function with the same number of arguments ("+mt+")!"),p[We].overloadTable[mt]=Ue):(p[We]=Ue,mt!==void 0&&(p[We].numArguments=mt))},_h=48,_a=57,Jl=We=>{if(We===void 0)return"_unknown";We=We.replace(/[^a-zA-Z0-9_]/g,"$");var Ue=We.charCodeAt(0);return Ue>=_h&&Ue<=_a?"_"+We:We};function k2(We,Ue,mt,Wt,_i,Ii,ji,Bi){this.name=We,this.constructor=Ue,this.instancePrototype=mt,this.rawDestructor=Wt,this.baseClass=_i,this.getActualType=Ii,this.upcast=ji,this.downcast=Bi,this.pureVirtualFunctions=[]}var vx=(We,Ue,mt)=>{for(;Ue!==mt;)Ue.upcast||Ur("Expected null or instance of "+mt.name+", got an instance of "+Ue.name),We=Ue.upcast(We),Ue=Ue.baseClass;return We};function yh(We,Ue){if(Ue===null)return this.isReference&&Ur("null is not a valid "+this.name),0;Ue.$$||Ur('Cannot pass "'+Ho(Ue)+'" as a '+this.name),Ue.$$.ptr||Ur("Cannot pass deleted object as a pointer of type "+this.name);var mt=Ue.$$.ptrType.registeredClass,Wt=vx(Ue.$$.ptr,mt,this.registeredClass);return Wt}function vc(We,Ue){var mt;if(Ue===null)return this.isReference&&Ur("null is not a valid "+this.name),this.isSmartPointer?(mt=this.rawConstructor(),We!==null&&We.push(this.rawDestructor,mt),mt):0;(!Ue||!Ue.$$)&&Ur('Cannot pass "'+Ho(Ue)+'" as a '+this.name),Ue.$$.ptr||Ur("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&Ue.$$.ptrType.isConst&&Ur("Cannot convert argument of type "+(Ue.$$.smartPtrType?Ue.$$.smartPtrType.name:Ue.$$.ptrType.name)+" to parameter type "+this.name);var Wt=Ue.$$.ptrType.registeredClass;if(mt=vx(Ue.$$.ptr,Wt,this.registeredClass),this.isSmartPointer)switch(Ue.$$.smartPtr===void 0&&Ur("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:Ue.$$.smartPtrType===this?mt=Ue.$$.smartPtr:Ur("Cannot convert argument of type "+(Ue.$$.smartPtrType?Ue.$$.smartPtrType.name:Ue.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:mt=Ue.$$.smartPtr;break;case 2:if(Ue.$$.smartPtrType===this)mt=Ue.$$.smartPtr;else{var _i=Ue.clone();mt=this.rawShare(mt,h0.toHandle(()=>_i.delete())),We!==null&&We.push(this.rawDestructor,mt)}break;default:Ur("Unsupporting sharing policy")}return mt}function fl(We,Ue){if(Ue===null)return this.isReference&&Ur("null is not a valid "+this.name),0;Ue.$$||Ur('Cannot pass "'+Ho(Ue)+'" as a '+this.name),Ue.$$.ptr||Ur("Cannot pass deleted object as a pointer of type "+this.name),Ue.$$.ptrType.isConst&&Ur("Cannot convert argument of type "+Ue.$$.ptrType.name+" to parameter type "+this.name);var mt=Ue.$$.ptrType.registeredClass,Wt=vx(Ue.$$.ptr,mt,this.registeredClass);return Wt}function Ix(We){return this.fromWireType(Ie[We>>2])}var ho=()=>{Object.assign(hi.prototype,{getPointee(We){return this.rawGetPointee&&(We=this.rawGetPointee(We)),We},destructor(We){var Ue;(Ue=this.rawDestructor)==null||Ue.call(this,We)},argPackAdvance:y0,readValueFromPointer:Ix,fromWireType:mh})};function hi(We,Ue,mt,Wt,_i,Ii,ji,Bi,vs,Ys,Ms){this.name=We,this.registeredClass=Ue,this.isReference=mt,this.isConst=Wt,this.isSmartPointer=_i,this.pointeeType=Ii,this.sharingPolicy=ji,this.rawGetPointee=Bi,this.rawConstructor=vs,this.rawShare=Ys,this.rawDestructor=Ms,!_i&&Ue.baseClass===void 0?Wt?(this.toWireType=yh,this.destructorFunction=null):(this.toWireType=fl,this.destructorFunction=null):this.toWireType=vc}var Yn=(We,Ue,mt)=>{p.hasOwnProperty(We)||Y0("Replacing nonexistent public symbol"),p[We].overloadTable!==void 0&&mt!==void 0?p[We].overloadTable[mt]=Ue:(p[We]=Ue,p[We].argCount=mt)},ml=(We,Ue,mt)=>{var Wt=p["dynCall_"+We];return Wt(Ue,...mt)},uo=[],B2,Ba=We=>{var Ue=uo[We];return Ue||(We>=uo.length&&(uo.length=We+1),uo[We]=Ue=B2.get(We)),Ue},bh=(We,Ue,mt=[])=>{if(We.includes("j"))return ml(We,Ue,mt);var Wt=Ba(Ue)(...mt);return Wt},x0=(We,Ue)=>(...mt)=>bh(We,Ue,mt),fo=(We,Ue)=>{We=Hi(We);function mt(){return We.includes("j")?x0(We,Ue):Ba(Ue)}var Wt=mt();return typeof Wt!="function"&&Ur("unknown function pointer with signature "+We+": "+Ue),Wt},Vo=(We,Ue)=>{var mt=dx(Ue,function(Wt){this.name=Ue,this.message=Wt;var _i=new Error(Wt).stack;_i!==void 0&&(this.stack=this.toString()+`
`+_i.replace(/^Error(:[^\n]*)?\n/,""))});return mt.prototype=Object.create(We.prototype),mt.prototype.constructor=mt,mt.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},mt},U2,Wn=We=>{var Ue=Ye(We),mt=Hi(Ue);return vl(Ue),mt},Yx=(We,Ue)=>{var mt=[],Wt={};function _i(Ii){if(!Wt[Ii]&&!_o[Ii]){if(jo[Ii]){jo[Ii].forEach(_i);return}mt.push(Ii),Wt[Ii]=!0}}throw Ue.forEach(_i),new U2(We+": "+mt.map(Wn).join([", "]))},Yo=(We,Ue,mt,Wt,_i,Ii,ji,Bi,vs,Ys,Ms,$r,Xr)=>{Ms=Hi(Ms),Ii=fo(_i,Ii),Bi&&(Bi=fo(ji,Bi)),Ys&&(Ys=fo(vs,Ys)),Xr=fo($r,Xr);var bn=Jl(Ms);gh(bn,function(){Yx("Cannot construct "+Ms+" due to unbound types",[Wt])}),vr([We,Ue,mt],Wt?[Wt]:[],ya=>{var Wa;ya=ya[0];var Ha,Xa;Wt?(Ha=ya.registeredClass,Xa=Ha.instancePrototype):Xa=fn.prototype;var ds=dx(Ms,function(...Il){if(Object.getPrototypeOf(this)!==br)throw new aa("Use 'new' to construct "+Ms);if(Bn.constructor_body===void 0)throw new aa(Ms+" has no accessible constructor");var Ji=Bn.constructor_body[Il.length];if(Ji===void 0)throw new aa("Tried to invoke ctor of "+Ms+" with invalid number of parameters ("+Il.length+") - expected ("+Object.keys(Bn.constructor_body).toString()+") parameters instead!");return Ji.apply(this,Il)}),br=Object.create(Xa,{constructor:{value:ds}});ds.prototype=br;var Bn=new k2(Ms,ds,br,Xr,Ha,Ii,Bi,Ys);Bn.baseClass&&((Wa=Bn.baseClass).__derivedClasses!=null||(Wa.__derivedClasses=[]),Bn.baseClass.__derivedClasses.push(Bn));var ha=new hi(Ms,Bn,!0,!1,!1),Er=new hi(Ms+"*",Bn,!1,!1,!1),d0=new hi(Ms+" const*",Bn,!1,!0,!1);return xa[We]={pointerType:Er,constPointerType:d0},Yn(bn,ds),[ha,Er,d0]})},Ic=(We,Ue)=>{for(var mt=[],Wt=0;Wt<We;Wt++)mt.push(Ie[Ue+Wt*4>>2]);return mt},Wo=We=>{for(;We.length;){var Ue=We.pop(),mt=We.pop();mt(Ue)}};function Eh(We){for(var Ue=1;Ue<We.length;++Ue)if(We[Ue]!==null&&We[Ue].destructorFunction===void 0)return!0;return!1}function Es(We,Ue,mt,Wt,_i,Ii){var ji=Ue.length;ji<2&&Ur("argTypes array size mismatch! Must at least get return value and 'this' types!");var Bi=Ue[1]!==null&&mt!==null,vs=Eh(Ue),Ys=Ue[0].name!=="void",Ms=ji-2,$r=new Array(Ms),Xr=[],bn=[],ya=function(...Wa){Wa.length!==Ms&&Ur("function "+We+" called with "+Wa.length+" arguments, expected "+Ms),bn.length=0;var Ha;Xr.length=Bi?2:1,Xr[0]=_i,Bi&&(Ha=Ue[1].toWireType(bn,this),Xr[1]=Ha);for(var Xa=0;Xa<Ms;++Xa)$r[Xa]=Ue[Xa+2].toWireType(bn,Wa[Xa]),Xr.push($r[Xa]);var ds=Wt(...Xr);function br(Bn){if(vs)Wo(bn);else for(var ha=Bi?1:2;ha<Ue.length;ha++){var Er=ha===1?Ha:$r[ha-2];Ue[ha].destructorFunction!==null&&Ue[ha].destructorFunction(Er)}if(Ys)return Ue[0].fromWireType(Bn)}return br(ds)};return dx(We,ya)}var vh=(We,Ue,mt,Wt,_i,Ii)=>{var ji=Ic(Ue,mt);_i=fo(Wt,_i),vr([],[We],Bi=>{Bi=Bi[0];var vs="constructor "+Bi.name;if(Bi.registeredClass.constructor_body===void 0&&(Bi.registeredClass.constructor_body=[]),Bi.registeredClass.constructor_body[Ue-1]!==void 0)throw new aa("Cannot register multiple constructors with identical number of parameters ("+(Ue-1)+") for class '"+Bi.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return Bi.registeredClass.constructor_body[Ue-1]=()=>{Yx("Cannot construct "+Bi.name+" due to unbound types",ji)},vr([],ji,Ys=>(Ys.splice(1,0,null),Bi.registeredClass.constructor_body[Ue-1]=Es(vs,Ys,null,_i,Ii),[])),[]})},t2=We=>{We=We.trim();const Ue=We.indexOf("(");return Ue!==-1?We.substr(0,Ue):We},l0=(We,Ue,mt,Wt,_i,Ii,ji,Bi,vs)=>{var Ys=Ic(mt,Wt);Ue=Hi(Ue),Ue=t2(Ue),Ii=fo(_i,Ii),vr([],[We],Ms=>{Ms=Ms[0];var $r=Ms.name+"."+Ue;Ue.startsWith("@@")&&(Ue=Symbol[Ue.substring(2)]),Bi&&Ms.registeredClass.pureVirtualFunctions.push(Ue);function Xr(){Yx("Cannot call "+$r+" due to unbound types",Ys)}var bn=Ms.registeredClass.instancePrototype,ya=bn[Ue];return ya===void 0||ya.overloadTable===void 0&&ya.className!==Ms.name&&ya.argCount===mt-2?(Xr.argCount=mt-2,Xr.className=Ms.name,bn[Ue]=Xr):(M2(bn,Ue,$r),bn[Ue].overloadTable[mt-2]=Xr),vr([],Ys,Wa=>{var Ha=Es($r,Wa,Ms,Ii,ji);return bn[Ue].overloadTable===void 0?(Ha.argCount=mt-2,bn[Ue]=Ha):bn[Ue].overloadTable[mt-2]=Ha,[]}),[]})},a2=(We,Ue,mt)=>(We instanceof Object||Ur(mt+' with invalid "this": '+We),We instanceof Ue.registeredClass.constructor||Ur(mt+' incompatible with "this" of type '+We.constructor.name),We.$$.ptr||Ur("cannot call emscripten binding method "+mt+" on deleted object"),vx(We.$$.ptr,We.$$.ptrType.registeredClass,Ue.registeredClass)),Bt=(We,Ue,mt,Wt,_i,Ii,ji,Bi,vs,Ys)=>{Ue=Hi(Ue),_i=fo(Wt,_i),vr([],[We],Ms=>{Ms=Ms[0];var $r=Ms.name+"."+Ue,Xr={get(){Yx("Cannot access "+$r+" due to unbound types",[mt,ji])},enumerable:!0,configurable:!0};return vs?Xr.set=()=>Yx("Cannot access "+$r+" due to unbound types",[mt,ji]):Xr.set=bn=>Ur($r+" is a read-only property"),Object.defineProperty(Ms.registeredClass.instancePrototype,Ue,Xr),vr([],vs?[mt,ji]:[mt],bn=>{var ya=bn[0],Wa={get(){var Xa=a2(this,Ms,$r+" getter");return ya.fromWireType(_i(Ii,Xa))},enumerable:!0};if(vs){vs=fo(Bi,vs);var Ha=bn[1];Wa.set=function(Xa){var ds=a2(this,Ms,$r+" setter"),br=[];vs(Ys,ds,Ha.toWireType(br,Xa)),Wo(br)}}return Object.defineProperty(Ms.registeredClass.instancePrototype,Ue,Wa),[]}),[]})},x2=[],Ro=[],$x=We=>{We>9&&--Ro[We+1]===0&&(Ro[We]=void 0,x2.push(We))},l2=()=>Ro.length/2-5-x2.length,da=()=>{Ro.push(0,1,void 0,1,null,1,!0,1,!1,1),p.count_emval_handles=l2},h0={toValue:We=>(We||Ur("Cannot use deleted val. handle = "+We),Ro[We]),toHandle:We=>{switch(We){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const Ue=x2.pop()||Ro.length;return Ro[Ue]=We,Ro[Ue+1]=1,Ue}}}},V2={name:"emscripten::val",fromWireType:We=>{var Ue=h0.toValue(We);return $x(We),Ue},toWireType:(We,Ue)=>h0.toHandle(Ue),argPackAdvance:y0,readValueFromPointer:Ix,destructorFunction:null},Jx=We=>t0(We,V2),Ho=We=>{if(We===null)return"null";var Ue=typeof We;return Ue==="object"||Ue==="array"||Ue==="function"?We.toString():""+We},Xo=(We,Ue)=>{switch(Ue){case 4:return function(mt){return this.fromWireType(je[mt>>2])};case 8:return function(mt){return this.fromWireType(Me[mt>>3])};default:throw new TypeError("invalid float width ("+Ue+"): "+We)}},Ih=(We,Ue,mt)=>{Ue=Hi(Ue),t0(We,{name:Ue,fromWireType:Wt=>Wt,toWireType:(Wt,_i)=>_i,argPackAdvance:y0,readValueFromPointer:Xo(Ue,mt),destructorFunction:null})},Rh=(We,Ue,mt)=>{switch(Ue){case 1:return mt?Wt=>me[Wt]:Wt=>ge[Wt];case 2:return mt?Wt=>be[Wt>>1]:Wt=>ye[Wt>>1];case 4:return mt?Wt=>ve[Wt>>2]:Wt=>Ie[Wt>>2];default:throw new TypeError("invalid integer width ("+Ue+"): "+We)}},Rc=(We,Ue,mt,Wt,_i)=>{Ue=Hi(Ue);var Ii=Ms=>Ms;if(Wt===0){var ji=32-8*mt;Ii=Ms=>Ms<<ji>>>ji}var Bi=Ue.includes("unsigned"),vs=(Ms,$r)=>{},Ys;Bi?Ys=function(Ms,$r){return vs($r,this.name),$r>>>0}:Ys=function(Ms,$r){return vs($r,this.name),$r},t0(We,{name:Ue,fromWireType:Ii,toWireType:Ys,argPackAdvance:y0,readValueFromPointer:Rh(Ue,mt,Wt!==0),destructorFunction:null})},h2=(We,Ue,mt)=>{var Wt=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],_i=Wt[Ue];function Ii(ji){var Bi=Ie[ji>>2],vs=Ie[ji+4>>2];return new _i(me.buffer,vs,Bi)}mt=Hi(mt),t0(We,{name:mt,fromWireType:Ii,argPackAdvance:y0,readValueFromPointer:Ii},{ignoreDuplicateRegistrations:!0})},u2=(We,Ue,mt,Wt)=>{if(!(Wt>0))return 0;for(var _i=mt,Ii=mt+Wt-1,ji=0;ji<We.length;++ji){var Bi=We.charCodeAt(ji);if(Bi>=55296&&Bi<=57343){var vs=We.charCodeAt(++ji);Bi=65536+((Bi&1023)<<10)|vs&1023}if(Bi<=127){if(mt>=Ii)break;Ue[mt++]=Bi}else if(Bi<=2047){if(mt+1>=Ii)break;Ue[mt++]=192|Bi>>6,Ue[mt++]=128|Bi&63}else if(Bi<=65535){if(mt+2>=Ii)break;Ue[mt++]=224|Bi>>12,Ue[mt++]=128|Bi>>6&63,Ue[mt++]=128|Bi&63}else{if(mt+3>=Ii)break;Ue[mt++]=240|Bi>>18,Ue[mt++]=128|Bi>>12&63,Ue[mt++]=128|Bi>>6&63,Ue[mt++]=128|Bi&63}}return Ue[mt]=0,mt-_i},yo=(We,Ue,mt)=>u2(We,ge,Ue,mt),Mh=We=>{for(var Ue=0,mt=0;mt<We.length;++mt){var Wt=We.charCodeAt(mt);Wt<=127?Ue++:Wt<=2047?Ue+=2:Wt>=55296&&Wt<=57343?(Ue+=4,++mt):Ue+=3}return Ue},Mc=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,d2=(We,Ue,mt)=>{for(var Wt=Ue+mt,_i=Ue;We[_i]&&!(_i>=Wt);)++_i;if(_i-Ue>16&&We.buffer&&Mc)return Mc.decode(We.subarray(Ue,_i));for(var Ii="";Ue<_i;){var ji=We[Ue++];if(!(ji&128)){Ii+=String.fromCharCode(ji);continue}var Bi=We[Ue++]&63;if((ji&224)==192){Ii+=String.fromCharCode((ji&31)<<6|Bi);continue}var vs=We[Ue++]&63;if((ji&240)==224?ji=(ji&15)<<12|Bi<<6|vs:ji=(ji&7)<<18|Bi<<12|vs<<6|We[Ue++]&63,ji<65536)Ii+=String.fromCharCode(ji);else{var Ys=ji-65536;Ii+=String.fromCharCode(55296|Ys>>10,56320|Ys&1023)}}return Ii},b0=(We,Ue)=>We?d2(ge,We,Ue):"",gl=(We,Ue)=>{Ue=Hi(Ue);var mt=Ue==="std::string";t0(We,{name:Ue,fromWireType(Wt){var _i=Ie[Wt>>2],Ii=Wt+4,ji;if(mt)for(var Bi=Ii,vs=0;vs<=_i;++vs){var Ys=Ii+vs;if(vs==_i||ge[Ys]==0){var Ms=Ys-Bi,$r=b0(Bi,Ms);ji===void 0?ji=$r:(ji+="\0",ji+=$r),Bi=Ys+1}}else{for(var Xr=new Array(_i),vs=0;vs<_i;++vs)Xr[vs]=String.fromCharCode(ge[Ii+vs]);ji=Xr.join("")}return vl(Wt),ji},toWireType(Wt,_i){_i instanceof ArrayBuffer&&(_i=new Uint8Array(_i));var Ii,ji=typeof _i=="string";ji||_i instanceof Uint8Array||_i instanceof Uint8ClampedArray||_i instanceof Int8Array||Ur("Cannot pass non-string to std::string"),mt&&ji?Ii=Mh(_i):Ii=_i.length;var Bi=Y2(4+Ii+1),vs=Bi+4;if(Ie[Bi>>2]=Ii,mt&&ji)yo(_i,vs,Ii+1);else if(ji)for(var Ys=0;Ys<Ii;++Ys){var Ms=_i.charCodeAt(Ys);Ms>255&&(vl(vs),Ur("String has UTF-16 code units that do not fit in 8 bits")),ge[vs+Ys]=Ms}else for(var Ys=0;Ys<Ii;++Ys)ge[vs+Ys]=_i[Ys];return Wt!==null&&Wt.push(vl,Bi),Bi},argPackAdvance:y0,readValueFromPointer:Ix,destructorFunction(Wt){vl(Wt)}})},_l=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,W2=(We,Ue)=>{for(var mt=We,Wt=mt>>1,_i=Wt+Ue/2;!(Wt>=_i)&&ye[Wt];)++Wt;if(mt=Wt<<1,mt-We>32&&_l)return _l.decode(ge.subarray(We,mt));for(var Ii="",ji=0;!(ji>=Ue/2);++ji){var Bi=be[We+ji*2>>1];if(Bi==0)break;Ii+=String.fromCharCode(Bi)}return Ii},la=(We,Ue,mt)=>{if(mt!=null||(mt=2147483647),mt<2)return 0;mt-=2;for(var Wt=Ue,_i=mt<We.length*2?mt/2:We.length,Ii=0;Ii<_i;++Ii){var ji=We.charCodeAt(Ii);be[Ue>>1]=ji,Ue+=2}return be[Ue>>1]=0,Ue-Wt},Bc=We=>We.length*2,H2=(We,Ue)=>{for(var mt=0,Wt="";!(mt>=Ue/4);){var _i=ve[We+mt*4>>2];if(_i==0)break;if(++mt,_i>=65536){var Ii=_i-65536;Wt+=String.fromCharCode(55296|Ii>>10,56320|Ii&1023)}else Wt+=String.fromCharCode(_i)}return Wt},f2=(We,Ue,mt)=>{if(mt!=null||(mt=2147483647),mt<4)return 0;for(var Wt=Ue,_i=Wt+mt-4,Ii=0;Ii<We.length;++Ii){var ji=We.charCodeAt(Ii);if(ji>=55296&&ji<=57343){var Bi=We.charCodeAt(++Ii);ji=65536+((ji&1023)<<10)|Bi&1023}if(ve[Ue>>2]=ji,Ue+=4,Ue+4>_i)break}return ve[Ue>>2]=0,Ue-Wt},yl=We=>{for(var Ue=0,mt=0;mt<We.length;++mt){var Wt=We.charCodeAt(mt);Wt>=55296&&Wt<=57343&&++mt,Ue+=4}return Ue},fx=(We,Ue,mt)=>{mt=Hi(mt);var Wt,_i,Ii,ji;Ue===2?(Wt=W2,_i=la,ji=Bc,Ii=Bi=>ye[Bi>>1]):Ue===4&&(Wt=H2,_i=f2,ji=yl,Ii=Bi=>Ie[Bi>>2]),t0(We,{name:mt,fromWireType:Bi=>{for(var vs=Ie[Bi>>2],Ys,Ms=Bi+4,$r=0;$r<=vs;++$r){var Xr=Bi+4+$r*Ue;if($r==vs||Ii(Xr)==0){var bn=Xr-Ms,ya=Wt(Ms,bn);Ys===void 0?Ys=ya:(Ys+="\0",Ys+=ya),Ms=Xr+Ue}}return vl(Bi),Ys},toWireType:(Bi,vs)=>{typeof vs!="string"&&Ur("Cannot pass non-string to C++ string type "+mt);var Ys=ji(vs),Ms=Y2(4+Ys+Ue);return Ie[Ms>>2]=Ys/Ue,_i(vs,Ms+4,Ys+Ue),Bi!==null&&Bi.push(vl,Ms),Ms},argPackAdvance:y0,readValueFromPointer:Ix,destructorFunction(Bi){vl(Bi)}})},X2=(We,Ue)=>{Ue=Hi(Ue),t0(We,{isVoid:!0,name:Ue,argPackAdvance:0,fromWireType:()=>{},toWireType:(mt,Wt)=>{}})};function Uc(We){if(lt.xhrs.has(We)){var Ue=lt.xhrs.get(We);lt.xhrs.free(We),Ue.readyState>0&&Ue.readyState<4&&Ue.abort()}}var bl=(We,Ue)=>{var mt=_o[We];return mt===void 0&&Ur(Ue+" has unknown type "+Wn(We)),mt},Bh=(We,Ue,mt)=>{var Wt=[],_i=We.toWireType(Wt,mt);return Wt.length&&(Ie[Ue>>2]=h0.toHandle(Wt)),_i},El=(We,Ue,mt)=>(We=h0.toValue(We),Ue=bl(Ue,"emval::as"),Bh(Ue,mt,We)),Vc={},Uh=We=>{var Ue=Vc[We];return Ue===void 0?Hi(We):Ue},J0=()=>{if(typeof globalThis=="object")return globalThis;function We(Ue){Ue.$$$embind_global$$$=Ue;var mt=typeof $$$embind_global$$$=="object"&&Ue.$$$embind_global$$$==Ue;return mt||delete Ue.$$$embind_global$$$,mt}if(typeof $$$embind_global$$$=="object"||(typeof __webpack_require__.g=="object"&&We(__webpack_require__.g)?$$$embind_global$$$=__webpack_require__.g:typeof self=="object"&&We(self)&&($$$embind_global$$$=self),typeof $$$embind_global$$$=="object"))return $$$embind_global$$$;throw Error("unable to get global object.")},mx=We=>We===0?h0.toHandle(J0()):(We=Uh(We),h0.toHandle(J0()[We])),m2=(We,Ue)=>(We=h0.toValue(We),Ue=h0.toValue(Ue),h0.toHandle(We[Ue])),as=We=>h0.toHandle(Uh(We)),Ua=We=>{var Ue=h0.toValue(We);Wo(Ue),$x(We)},E0=(We,Ue)=>{We=bl(We,"_emval_take_value");var mt=We.readValueFromPointer(Ue);return h0.toHandle(mt)},v0=()=>{Ri("")},at=()=>!V,Je=(We,Ue,mt)=>ge.copyWithin(We,Ue,Ue+mt),Rt=()=>2147483648,_t=We=>{var Ue=le.buffer,mt=(We-Ue.byteLength+65535)/65536;try{return le.grow(mt),xt(),1}catch{}},He=We=>{var Ue=ge.length;We>>>=0;var mt=Rt();if(We>mt)return!1;for(var Wt=(vs,Ys)=>vs+(Ys-vs%Ys)%Ys,_i=1;_i<=4;_i*=2){var Ii=Ue*(1+.2/_i);Ii=Math.min(Ii,We+100663296);var ji=Math.min(mt,Wt(Math.max(We,Ii),65536)),Bi=_t(ji);if(Bi)return!0}return!1};class Xe{constructor(){this.allocated=[void 0],this.freelist=[]}get(Ue){return this.allocated[Ue]}has(Ue){return this.allocated[Ue]!==void 0}allocate(Ue){var mt=this.freelist.pop()||this.allocated.length;return this.allocated[mt]=Ue,mt}free(Ue){this.allocated[Ue]=void 0,this.freelist.push(Ue)}}var lt={openDatabase(We,Ue,mt,Wt){try{var _i=indexedDB.open(We,Ue)}catch(Ii){return Wt(Ii)}_i.onupgradeneeded=Ii=>{var ji=Ii.target.result;ji.objectStoreNames.contains("FILES")&&ji.deleteObjectStore("FILES"),ji.createObjectStore("FILES")},_i.onsuccess=Ii=>mt(Ii.target.result),_i.onerror=Wt},init(){lt.xhrs=new Xe;var We=mt=>{lt.dbInstance=mt,bi()},Ue=()=>{lt.dbInstance=!1,bi()};us(),lt.openDatabase("emscripten_filesystem",1,We,Ue)}};function yt(We,Ue,mt,Wt,_i){var Ii=Ie[We+8>>2];if(!Ii){mt(We,0,"no url specified!");return}var ji=b0(Ii),Bi=We+112,vs=b0(Bi+0);vs||(vs="GET");var Ys=Ie[Bi+56>>2],Ms=Ie[Bi+68>>2],$r=Ie[Bi+72>>2],Xr=Ie[Bi+76>>2],bn=Ie[Bi+80>>2],ya=Ie[Bi+84>>2],Wa=Ie[Bi+88>>2],Ha=Ie[Bi+52>>2],Xa=!!(Ha&1),ds=!!(Ha&2),br=!!(Ha&64),Bn=Ms?b0(Ms):void 0,ha=$r?b0($r):void 0,Er=new XMLHttpRequest;if(Er.withCredentials=!!ge[Bi+60],Er.open(vs,ji,!br,Bn,ha),br||(Er.timeout=Ys),Er.url_=ji,Er.responseType="arraybuffer",bn){var d0=b0(bn);Er.overrideMimeType(d0)}if(Xr)for(;;){var Il=Ie[Xr>>2];if(!Il)break;var Ji=Ie[Xr+4>>2];if(!Ji)break;Xr+=8;var ht=b0(Il),gn=b0(Ji);Er.setRequestHeader(ht,gn)}var va=lt.xhrs.allocate(Er);Ie[We>>2]=va;var jm=ya&&Wa?ge.slice(ya,ya+Wa):null;function Vh(){var En=0,Rx=0;Er.response&&Xa&&Ie[We+12>>2]===0&&(Rx=Er.response.byteLength),Rx>0&&(En=Y2(Rx),ge.set(new Uint8Array(Er.response),En)),Ie[We+12>>2]=En,Br(We+16,Rx),Br(We+24,0);var tl=Er.response?Er.response.byteLength:0;tl&&Br(We+32,tl),be[We+40>>1]=Er.readyState,be[We+42>>1]=Er.status,Er.statusText&&yo(Er.statusText,We+44,64)}Er.onload=En=>{lt.xhrs.has(va)&&(Vh(),Er.status>=200&&Er.status<300?Ue?.(We,Er,En):mt?.(We,Er,En))},Er.onerror=En=>{lt.xhrs.has(va)&&(Vh(),mt?.(We,Er,En))},Er.ontimeout=En=>{lt.xhrs.has(va)&&mt?.(We,Er,En)},Er.onprogress=En=>{if(lt.xhrs.has(va)){var Rx=Xa&&ds&&Er.response?Er.response.byteLength:0,tl=0;Rx>0&&Xa&&ds&&(tl=Y2(Rx),ge.set(new Uint8Array(Er.response),tl)),Ie[We+12>>2]=tl,Br(We+16,Rx),Br(We+24,En.loaded-Rx),Br(We+32,En.total),be[We+40>>1]=Er.readyState,Er.readyState>=3&&Er.status===0&&En.loaded>0&&(Er.status=200),be[We+42>>1]=Er.status,Er.statusText&&yo(Er.statusText,We+44,64),Wt?.(We,Er,En),tl&&vl(tl)}},Er.onreadystatechange=En=>{lt.xhrs.has(va)&&(be[We+40>>1]=Er.readyState,Er.readyState>=2&&(be[We+42>>1]=Er.status),_i?.(We,Er,En))};try{Er.send(jm)}catch(En){mt?.(We,Er,En)}}var jt=We=>{if(We instanceof Us||We=="unwind")return de;D(1,We)},ti=0,Vt=()=>ar||ti>0,di=We=>{var Ue;de=We,Vt()||((Ue=p.onExit)==null||Ue.call(p,We),he=!0),D(We,new Us(We))},Xi=(We,Ue)=>{de=We,di(We)},hs=Xi,Mi=()=>{if(!Vt())try{hs(de)}catch(We){jt(We)}},Ws=We=>{if(!he)try{We(),Mi()}catch(Ue){jt(Ue)}},Br=(We,Ue)=>{Ie[We>>2]=Ue;var mt=Ie[We>>2];Ie[We+4>>2]=(Ue-mt)/4294967296};function Jr(We,Ue,mt,Wt,_i){if(!We){_i(Ue,0,"IndexedDB not available!");return}var Ii=Ue+112,ji=Ie[Ii+64>>2];ji||(ji=Ie[Ue+8>>2]);var Bi=b0(ji);try{var vs=We.transaction(["FILES"],"readwrite"),Ys=vs.objectStore("FILES"),Ms=Ys.put(mt,Bi);Ms.onsuccess=$r=>{be[Ue+40>>1]=4,be[Ue+42>>1]=200,yo("OK",Ue+44,64),Wt(Ue,0,Bi)},Ms.onerror=$r=>{be[Ue+40>>1]=4,be[Ue+42>>1]=413,yo("Payload Too Large",Ue+44,64),_i(Ue,0,$r)}}catch($r){_i(Ue,0,$r)}}function Mn(We,Ue,mt,Wt){if(!We){Wt(Ue,0,"IndexedDB not available!");return}var _i=Ue+112,Ii=Ie[_i+64>>2];Ii||(Ii=Ie[Ue+8>>2]);var ji=b0(Ii);try{var Bi=We.transaction(["FILES"],"readonly"),vs=Bi.objectStore("FILES"),Ys=vs.get(ji);Ys.onsuccess=Ms=>{if(Ms.target.result){var $r=Ms.target.result,Xr=$r.byteLength||$r.length,bn=Y2(Xr);ge.set(new Uint8Array($r),bn),Ie[Ue+12>>2]=bn,Br(Ue+16,Xr),Br(Ue+24,0),Br(Ue+32,Xr),be[Ue+40>>1]=4,be[Ue+42>>1]=200,yo("OK",Ue+44,64),mt(Ue,0,$r)}else be[Ue+40>>1]=4,be[Ue+42>>1]=404,yo("Not Found",Ue+44,64),Wt(Ue,0,"no data")},Ys.onerror=Ms=>{be[Ue+40>>1]=4,be[Ue+42>>1]=404,yo("Not Found",Ue+44,64),Wt(Ue,0,Ms)}}catch(Ms){Wt(Ue,0,Ms)}}function $n(We,Ue,mt,Wt){if(!We){Wt(Ue,0,"IndexedDB not available!");return}var _i=Ue+112,Ii=Ie[_i+64>>2];Ii||(Ii=Ie[Ue+8>>2]);var ji=b0(Ii);try{var Bi=We.transaction(["FILES"],"readwrite"),vs=Bi.objectStore("FILES"),Ys=vs.delete(ji);Ys.onsuccess=Ms=>{var $r=Ms.target.result;Ie[Ue+12>>2]=0,Br(Ue+16,0),Br(Ue+24,0),Br(Ue+32,0),be[Ue+40>>1]=4,be[Ue+42>>1]=200,yo("OK",Ue+44,64),mt(Ue,0,$r)},Ys.onerror=Ms=>{be[Ue+40>>1]=4,be[Ue+42>>1]=404,yo("Not Found",Ue+44,64),Wt(Ue,0,Ms)}}catch(Ms){Wt(Ue,0,Ms)}}function Hr(We,Ue,mt,Wt,_i){var Ii=We+112,ji=Ie[Ii+36>>2],Bi=Ie[Ii+40>>2],vs=Ie[Ii+44>>2],Ys=Ie[Ii+48>>2],Ms=Ie[Ii+52>>2],$r=!!(Ms&64);function Xr(ht){$r?ht():Ws(ht)}var bn=(ht,gn,va)=>{Xr(()=>{ji?Ba(ji)(ht):Ue?.(ht)})},ya=(ht,gn,va)=>{Xr(()=>{vs?Ba(vs)(ht):Wt?.(ht)})},Wa=(ht,gn,va)=>{Xr(()=>{Bi?Ba(Bi)(ht):mt?.(ht)})},Ha=(ht,gn,va)=>{Xr(()=>{Ys?Ba(Ys)(ht):_i?.(ht)})},Xa=(ht,gn,va)=>{yt(ht,bn,Wa,ya,Ha)},ds=(ht,gn,va)=>{var jm=(En,Rx,tl)=>{Xr(()=>{ji?Ba(ji)(En):Ue?.(En)})},Vh=(En,Rx,tl)=>{Xr(()=>{ji?Ba(ji)(En):Ue?.(En)})};Jr(lt.dbInstance,ht,gn.response,jm,Vh)},br=(ht,gn,va)=>{yt(ht,ds,Wa,ya,Ha)},Bn=b0(Ii+0),ha=!!(Ms&16),Er=!!(Ms&4),d0=!!(Ms&32);if(Bn==="EM_IDB_STORE"){var Il=Ie[Ii+84>>2],Ji=Ie[Ii+88>>2];Jr(lt.dbInstance,We,ge.slice(Il,Il+Ji),bn,Wa)}else if(Bn==="EM_IDB_DELETE")$n(lt.dbInstance,We,bn,Wa);else if(!ha)Mn(lt.dbInstance,We,bn,d0?Wa:Er?br:Xa);else if(!d0)yt(We,Er?ds:bn,Wa,ya,Ha);else return 0;return We}var Ir={},u0=()=>I||"./this.program",tn=()=>{if(!tn.strings){var We=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",Ue={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:We,_:u0()};for(var mt in Ir)Ir[mt]===void 0?delete Ue[mt]:Ue[mt]=Ir[mt];var Wt=[];for(var mt in Ue)Wt.push(mt+"="+Ue[mt]);tn.strings=Wt}return tn.strings},W0=(We,Ue)=>{for(var mt=0;mt<We.length;++mt)me[Ue++]=We.charCodeAt(mt);me[Ue]=0},Va=(We,Ue)=>{var mt=0;return tn().forEach((Wt,_i)=>{var Ii=Ue+mt;Ie[We+_i*4>>2]=Ii,W0(Wt,Ii),mt+=Wt.length+1}),0},R0=(We,Ue)=>{var mt=tn();Ie[We>>2]=mt.length;var Wt=0;return mt.forEach(_i=>Wt+=_i.length+1),Ie[Ue>>2]=Wt,0},mr=We=>We%4===0&&(We%100!==0||We%400===0),Ee=(We,Ue)=>{for(var mt=0,Wt=0;Wt<=Ue;mt+=We[Wt++]);return mt},an=[31,29,31,30,31,30,31,31,30,31,30,31],Wi=[31,28,31,30,31,30,31,31,30,31,30,31],vt=(We,Ue)=>{for(var mt=new Date(We.getTime());Ue>0;){var Wt=mr(mt.getFullYear()),_i=mt.getMonth(),Ii=(Wt?an:Wi)[_i];if(Ue>Ii-mt.getDate())Ue-=Ii-mt.getDate()+1,mt.setDate(1),_i<11?mt.setMonth(_i+1):(mt.setMonth(0),mt.setFullYear(mt.getFullYear()+1));else return mt.setDate(mt.getDate()+Ue),mt}return mt};function gs(We,Ue,mt){var Wt=mt>0?mt:Mh(We)+1,_i=new Array(Wt),Ii=u2(We,_i,0,_i.length);return Ue&&(_i.length=Ii),_i}var Yt=(We,Ue)=>{me.set(We,Ue)},j2=(We,Ue,mt,Wt)=>{var _i=Ie[Wt+40>>2],Ii={tm_sec:ve[Wt>>2],tm_min:ve[Wt+4>>2],tm_hour:ve[Wt+8>>2],tm_mday:ve[Wt+12>>2],tm_mon:ve[Wt+16>>2],tm_year:ve[Wt+20>>2],tm_wday:ve[Wt+24>>2],tm_yday:ve[Wt+28>>2],tm_isdst:ve[Wt+32>>2],tm_gmtoff:ve[Wt+36>>2],tm_zone:_i?b0(_i):""},ji=b0(mt),Bi={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var vs in Bi)ji=ji.replace(new RegExp(vs,"g"),Bi[vs]);var Ys=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],Ms=["January","February","March","April","May","June","July","August","September","October","November","December"];function $r(ds,br,Bn){for(var ha=typeof ds=="number"?ds.toString():ds||"";ha.length<br;)ha=Bn[0]+ha;return ha}function Xr(ds,br){return $r(ds,br,"0")}function bn(ds,br){function Bn(Er){return Er<0?-1:Er>0?1:0}var ha;return(ha=Bn(ds.getFullYear()-br.getFullYear()))===0&&(ha=Bn(ds.getMonth()-br.getMonth()))===0&&(ha=Bn(ds.getDate()-br.getDate())),ha}function ya(ds){switch(ds.getDay()){case 0:return new Date(ds.getFullYear()-1,11,29);case 1:return ds;case 2:return new Date(ds.getFullYear(),0,3);case 3:return new Date(ds.getFullYear(),0,2);case 4:return new Date(ds.getFullYear(),0,1);case 5:return new Date(ds.getFullYear()-1,11,31);case 6:return new Date(ds.getFullYear()-1,11,30)}}function Wa(ds){var br=vt(new Date(ds.tm_year+1900,0,1),ds.tm_yday),Bn=new Date(br.getFullYear(),0,4),ha=new Date(br.getFullYear()+1,0,4),Er=ya(Bn),d0=ya(ha);return bn(Er,br)<=0?bn(d0,br)<=0?br.getFullYear()+1:br.getFullYear():br.getFullYear()-1}var Ha={"%a":ds=>Ys[ds.tm_wday].substring(0,3),"%A":ds=>Ys[ds.tm_wday],"%b":ds=>Ms[ds.tm_mon].substring(0,3),"%B":ds=>Ms[ds.tm_mon],"%C":ds=>{var br=ds.tm_year+1900;return Xr(br/100|0,2)},"%d":ds=>Xr(ds.tm_mday,2),"%e":ds=>$r(ds.tm_mday,2," "),"%g":ds=>Wa(ds).toString().substring(2),"%G":Wa,"%H":ds=>Xr(ds.tm_hour,2),"%I":ds=>{var br=ds.tm_hour;return br==0?br=12:br>12&&(br-=12),Xr(br,2)},"%j":ds=>Xr(ds.tm_mday+Ee(mr(ds.tm_year+1900)?an:Wi,ds.tm_mon-1),3),"%m":ds=>Xr(ds.tm_mon+1,2),"%M":ds=>Xr(ds.tm_min,2),"%n":()=>`
`,"%p":ds=>ds.tm_hour>=0&&ds.tm_hour<12?"AM":"PM","%S":ds=>Xr(ds.tm_sec,2),"%t":()=>"	","%u":ds=>ds.tm_wday||7,"%U":ds=>{var br=ds.tm_yday+7-ds.tm_wday;return Xr(Math.floor(br/7),2)},"%V":ds=>{var br=Math.floor((ds.tm_yday+7-(ds.tm_wday+6)%7)/7);if((ds.tm_wday+371-ds.tm_yday-2)%7<=2&&br++,br){if(br==53){var Bn=(ds.tm_wday+371-ds.tm_yday)%7;Bn!=4&&(Bn!=3||!mr(ds.tm_year))&&(br=1)}}else{br=52;var ha=(ds.tm_wday+7-ds.tm_yday-1)%7;(ha==4||ha==5&&mr(ds.tm_year%400-1))&&br++}return Xr(br,2)},"%w":ds=>ds.tm_wday,"%W":ds=>{var br=ds.tm_yday+7-(ds.tm_wday+6)%7;return Xr(Math.floor(br/7),2)},"%y":ds=>(ds.tm_year+1900).toString().substring(2),"%Y":ds=>ds.tm_year+1900,"%z":ds=>{var br=ds.tm_gmtoff,Bn=br>=0;return br=Math.abs(br)/60,br=br/60*100+br%60,(Bn?"+":"-")+("0000"+br).slice(-4)},"%Z":ds=>ds.tm_zone,"%%":()=>"%"};ji=ji.replace(/%%/g,"\0\0");for(var vs in Ha)ji.includes(vs)&&(ji=ji.replace(new RegExp(vs,"g"),Ha[vs](Ii)));ji=ji.replace(/\0\0/g,"%");var Xa=gs(ji,!1);return Xa.length>Ue?0:(Yt(Xa,We),Xa.length-1)},Wc=(We,Ue,mt,Wt,_i)=>j2(We,Ue,mt,Wt);Rn(),aa=p.BindingError=class extends Error{constructor(We){super(We),this.name="BindingError"}},ur=p.InternalError=class extends Error{constructor(We){super(We),this.name="InternalError"}},R2(),js(),ho(),U2=p.UnboundTypeError=Vo(Error,"UnboundTypeError"),da(),lt.init();var Jp={a:xn,s:dn,z:v2,l:Yo,f:vh,c:l0,o:Bt,y:Jx,r:Ih,e:Rc,b:h2,q:gl,m:fx,A:X2,B:Uc,g:El,d:$x,n:mx,h:m2,k:as,j:Ua,i:E0,p:v0,D:at,x:Je,w:He,C:Hr,u:Va,v:R0,t:Wc},gx=bs(),Y2=We=>(Y2=gx.G)(We),vl=We=>(vl=gx.I)(We),Ye=We=>(Ye=gx.J)(We),r_=We=>(r_=gx.K)(We);p.dynCall_viijii=(We,Ue,mt,Wt,_i,Ii,ji)=>(p.dynCall_viijii=gx.L)(We,Ue,mt,Wt,_i,Ii,ji),p.dynCall_iiiiij=(We,Ue,mt,Wt,_i,Ii,ji)=>(p.dynCall_iiiiij=gx.M)(We,Ue,mt,Wt,_i,Ii,ji),p.dynCall_iiiiijj=(We,Ue,mt,Wt,_i,Ii,ji,Bi,vs)=>(p.dynCall_iiiiijj=gx.N)(We,Ue,mt,Wt,_i,Ii,ji,Bi,vs),p.dynCall_iiiiiijj=(We,Ue,mt,Wt,_i,Ii,ji,Bi,vs,Ys)=>(p.dynCall_iiiiiijj=gx.O)(We,Ue,mt,Wt,_i,Ii,ji,Bi,vs,Ys);var tm;ts=function We(){tm||n_(),tm||(ts=We)};function n_(){if(vi>0||(Ut(),vi>0))return;function We(){tm||(tm=!0,p.calledRun=!0,!he&&(Ht(),_(p),p.onRuntimeInitialized&&p.onRuntimeInitialized(),mi()))}p.setStatus?(p.setStatus("Running..."),setTimeout(function(){setTimeout(function(){p.setStatus("")},1),We()},1)):We()}if(p.preInit)for(typeof p.preInit=="function"&&(p.preInit=[p.preInit]);p.preInit.length>0;)p.preInit.pop()();return n_(),d.ready}})();const Qa=oQ();Qa.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,m=>{m&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var QV;(function(m){m[m.DT_INVALID=0]="DT_INVALID",m[m.DT_FLOAT=1]="DT_FLOAT",m[m.DT_DOUBLE=2]="DT_DOUBLE",m[m.DT_INT32=3]="DT_INT32",m[m.DT_UINT8=4]="DT_UINT8",m[m.DT_INT16=5]="DT_INT16",m[m.DT_INT8=6]="DT_INT8",m[m.DT_STRING=7]="DT_STRING",m[m.DT_COMPLEX64=8]="DT_COMPLEX64",m[m.DT_INT64=9]="DT_INT64",m[m.DT_BOOL=10]="DT_BOOL",m[m.DT_QINT8=11]="DT_QINT8",m[m.DT_QUINT8=12]="DT_QUINT8",m[m.DT_QINT32=13]="DT_QINT32",m[m.DT_BFLOAT16=14]="DT_BFLOAT16",m[m.DT_QINT16=15]="DT_QINT16",m[m.DT_QUINT16=16]="DT_QUINT16",m[m.DT_UINT16=17]="DT_UINT16",m[m.DT_COMPLEX128=18]="DT_COMPLEX128",m[m.DT_HALF=19]="DT_HALF",m[m.DT_RESOURCE=20]="DT_RESOURCE",m[m.DT_VARIANT=21]="DT_VARIANT",m[m.DT_UINT32=22]="DT_UINT32",m[m.DT_UINT64=23]="DT_UINT64",m[m.DT_FLOAT_REF=101]="DT_FLOAT_REF",m[m.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",m[m.DT_INT32_REF=103]="DT_INT32_REF",m[m.DT_UINT8_REF=104]="DT_UINT8_REF",m[m.DT_INT16_REF=105]="DT_INT16_REF",m[m.DT_INT8_REF=106]="DT_INT8_REF",m[m.DT_STRING_REF=107]="DT_STRING_REF",m[m.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",m[m.DT_INT64_REF=109]="DT_INT64_REF",m[m.DT_BOOL_REF=110]="DT_BOOL_REF",m[m.DT_QINT8_REF=111]="DT_QINT8_REF",m[m.DT_QUINT8_REF=112]="DT_QUINT8_REF",m[m.DT_QINT32_REF=113]="DT_QINT32_REF",m[m.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",m[m.DT_QINT16_REF=115]="DT_QINT16_REF",m[m.DT_QUINT16_REF=116]="DT_QUINT16_REF",m[m.DT_UINT16_REF=117]="DT_UINT16_REF",m[m.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",m[m.DT_HALF_REF=119]="DT_HALF_REF",m[m.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",m[m.DT_VARIANT_REF=121]="DT_VARIANT_REF",m[m.DT_UINT32_REF=122]="DT_UINT32_REF",m[m.DT_UINT64_REF=123]="DT_UINT64_REF"})(QV||(QV={}));var Qg;(function(m){(function(d){d[d.LEGACY=0]="LEGACY",d[d.V1=1]="V1",d[d.V2=2]="V2"})(m.CheckpointFormatVersion||(m.CheckpointFormatVersion={}))})(Qg||(Qg={}));const k3={};function k4(m){return k3[m]}function k5(m,d,p,_,E){const S=d.inputParams[m];if(S&&S.inputIndexStart!==void 0){const D=S.inputIndexStart,k=S.inputIndexEnd===0?void 0:S.inputIndexEnd===void 0?D+1:S.inputIndexEnd,V=D<0?d.inputNames.length+D:D;if(S.type==="tensor")return k6(d.inputNames[V],p,_,E);if(S.type==="tensors"){const te=d.inputs.slice(D,k);return d.inputNames.slice(D,k).filter((xe,le)=>{var he;return((he=te[le])===null||he===void 0?void 0:he.op)!=="NoOp"}).map(xe=>k6(xe,p,_,E))}const $=k6(d.inputNames[V],p,_,E),Z=$.dataSync();return S.type==="number"?Z[0]:o8($.shape,Z)}const I=d.attrParams[m];return I&&I.value}function k6(m,d,p,_){const[E,S]=ko(m,p);if(_!=null){const D=_.getHashTableHandleByName(E);if(D!=null)return D}const I=p.currentContextIds.find(D=>!!d[k9(E,D)]);return I!==void 0?d[k9(E,I)][S]:void 0}function k7(m,d,p){return d[k9(m,p.currentContextId)]}function k8(m,d){const[p,_,E]=ko(m,d);return[k9(p,d&&d.currentContextId),_,E]}function k9(m,d){return d?m+"-"+d:m}function ko(m,d){if(m==="")return["",0,void 0];const p=d!=null&&d.parseNodeNameCache!=null;if(p){const S=d.parseNodeNameCache.get(m);if(S!=null)return S}const _=m.split(":");let E;if(_.length===1)E=[m,0,void 0];else{const S=_[0],I=_.length===3?_[1]:void 0,D=Number(_[_.length-1]);E=[S,D,I]}return p&&d.parseNodeNameCache.set(m,E),E}function kc(m,d,p){let _=k5("pad",m,d,p);if(_==="explicit"){_=k5("explicitPaddings",m,d,p);const E=[[0,0],[0,0],[0,0],[0,0]];for(let S=0;S<4;S++)E[S][0]=_[S*2],E[S][1]=_[S*2+1];return E}return _}function kG(m){return m.kept?m:Lx(m)}const ks=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var kz=Object.freeze({__proto__:null,json:ks});const kC=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var kL=Object.freeze({__proto__:null,json:kC});const kK=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var kr=Object.freeze({__proto__:null,json:kK});const kT=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var kq=Object.freeze({__proto__:null,json:kT});const kQ=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var kk=Object.freeze({__proto__:null,json:kQ});const kp=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var kw=Object.freeze({__proto__:null,json:kp});const kA=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var kZ=Object.freeze({__proto__:null,json:kA});const kF=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var kN=Object.freeze({__proto__:null,json:kF});const kO=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var kD=Object.freeze({__proto__:null,json:kO});const kn=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var ki=Object.freeze({__proto__:null,json:kn});const ke=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];var kP=Object.freeze({__proto__:null,json:ke});const kS=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];var kI=Object.freeze({__proto__:null,json:kS});const kB=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];var kj=Object.freeze({__proto__:null,json:kB});const kR=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var kH=Object.freeze({__proto__:null,json:kR});const ku=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var kX=Object.freeze({__proto__:null,json:ku});const kf=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var ky=Object.freeze({__proto__:null,json:kf});const kE=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var kW=Object.freeze({__proto__:null,json:kE});const kd=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var kM=Object.freeze({__proto__:null,json:kd});const kU=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var kJ=Object.freeze({__proto__:null,json:kU});class kt{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const d=[kz,kL,kr,kq,kk,kw,kZ,kN,kD,ki,kP,kI,kj,kH,kX,ky,kW,kM,kJ],p=[].concat(...d.map(_=>_.json));this.opMappers=p.reduce((_,E)=>(_[E.tfOpName]=E,_),{})}transformGraph(d,p={}){const _=d.node,E=[],S=[],I=[],D=_.reduce((he,de)=>(he[de.name]=this.mapNode(de),de.op.startsWith("Placeholder")?E.push(he[de.name]):de.op==="Const"?S.push(he[de.name]):(de.input==null||de.input.length===0)&&I.push(he[de.name]),he),{});let k=[];const V=[];let $={},Z={};p!=null&&($=this.mapSignatureEntries(p.inputs),Z=this.mapSignatureEntries(p.outputs));const te=Object.keys(D);te.forEach(he=>{const de=D[he];de.inputNames.forEach((me,ge)=>{const[be,,ye]=k8(me),ve=D[be];if(ve.outputs!=null){const Ie=ve.outputs.indexOf(ye);if(Ie!==-1){const je=be+":"+Ie;de.inputNames[ge]=je}}de.inputs.push(ve),ve.children.push(de)})}),Object.keys(Z).length===0?te.forEach(he=>{const de=D[he];de.children.length===0&&V.push(de)}):Object.keys(Z).forEach(he=>{const[de]=k8(he),me=D[de];me!=null&&(me.signatureKey=Z[he],V.push(me))}),Object.keys($).length>0?Object.keys($).forEach(he=>{const[de]=k8(he),me=D[de];me&&(me.signatureKey=$[he],k.push(me))}):k=E;let xe={};d.library!=null&&d.library.function!=null&&(xe=d.library.function.reduce((he,de)=>(he[de.signature.name]=this.mapFunction(de),he),{}));const le={nodes:D,inputs:k,outputs:V,weights:S,placeholders:E,signature:p,functions:xe};return I.length>0&&(le.initNodes=I),le}mapSignatureEntries(d){return Object.keys(d||{}).reduce((p,_)=>(p[d[_].name]=_,p),{})}mapNode(d){const p=k4(d.op)||this.opMappers[d.op]||{};d.attr==null&&(d.attr={});const _={name:d.name,op:d.op,category:p.category,inputNames:(d.input||[]).map(E=>E.startsWith("^")?E.slice(1):E),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:d.attr,outputs:p.outputs};return p.inputs!=null&&(_.inputParams=p.inputs.reduce((E,S)=>(E[S.name]={type:S.type,inputIndexStart:S.start,inputIndexEnd:S.end},E),{})),p.attrs!=null&&(_.attrParams=p.attrs.reduce((E,S)=>{const I=S.type;let D;switch(S.type){case"string":D=kY(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=kY(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"string[]":D=p2(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=p2(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"number":D=kx(d.attr,S.tfName,S.defaultValue||0),D===void 0&&S.tfDeprecatedName&&(D=kx(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"number[]":D=p1(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=p1(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"bool":D=km(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=km(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"bool[]":D=p4(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=p4(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"shape":D=p0(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=p0(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"shape[]":D=p3(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=p3(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"dtype":D=ka(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=ka(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"dtype[]":D=kV(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=kV(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"func":D=kb(d.attr,S.tfName,S.defaultValue),D===void 0&&S.tfDeprecatedName&&(D=kb(d.attr,S.tfDeprecatedName,S.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+S.type+" for op: "+d.op)}return E[S.name]={value:D,type:I},E},{})),_}mapFunction(d){const p=d.nodeDef,_=[],E=[];let S={};p!=null&&(S=p.reduce(($,Z)=>($[Z.name]=this.mapNode(Z),Z.op==="Const"&&E.push($[Z.name]),$),{}));const I=[],D=[];d.signature.inputArg.forEach($=>{const[Z]=k8($.name),te={name:Z,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:kl($.type),type:"dtype"}},children:[]};te.signatureKey=$.name,I.push(te),S[Z]=te}),Object.keys(S).forEach($=>{const Z=S[$];Z.inputNames.forEach((te,xe)=>{const[le,,he]=k8(te),de=S[le];if(de.outputs!=null){const me=de.outputs.indexOf(he);if(me!==-1){const ge=le+":"+me;Z.inputNames[xe]=ge}}Z.inputs.push(de),de.children.push(Z)})});const k=d.ret;d.signature.outputArg.forEach($=>{const[Z,te]=k8(k[$.name]),xe=S[Z];xe!=null&&(xe.defaultOutput=te,D.push(xe))});const V=this.mapArgsToSignature(d);return{nodes:S,inputs:I,outputs:D,weights:E,placeholders:_,signature:V}}mapArgsToSignature(d){return{methodName:d.signature.name,inputs:d.signature.inputArg.reduce((p,_)=>(p[_.name]=this.mapArgToTensorInfo(_),p),{}),outputs:d.signature.outputArg.reduce((p,_)=>(p[_.name]=this.mapArgToTensorInfo(_,d.ret),p),{})}}mapArgToTensorInfo(d,p){let _=d.name;return p!=null&&(_=p[_]),{name:_,dtype:d.type}}}function kv(m){const d=oQ().global;if(typeof d.atob<"u")return d.atob(m);if(typeof Buffer<"u")return new Buffer(m,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function kh(m,d){const p=Array.isArray(m)?String.fromCharCode.apply(null,m):kv(m);return d?p:p.toLowerCase()}function kY(m,d,p,_=!1){const E=m[d];return E!=null?kh(E.s,_):p}function km(m,d,p){const _=m[d];return _?_.b:p}function kx(m,d,p){const _=m[d]||{},E=_.i!=null?_.i:_.f!=null?_.f:p;return typeof E=="number"?E:parseInt(E,10)}function kl(m){switch(typeof m=="string"&&(m=QV[m]),m){case QV.DT_FLOAT:case QV.DT_HALF:return"float32";case QV.DT_INT32:case QV.DT_INT64:case QV.DT_INT8:case QV.DT_UINT8:return"int32";case QV.DT_BOOL:return"bool";case QV.DT_DOUBLE:return"float32";case QV.DT_STRING:return"string";case QV.DT_COMPLEX64:case QV.DT_COMPLEX128:return"complex64";default:return null}}function kb(m,d,p){const _=m[d];return _&&_.func?_.func.name:p}function ka(m,d,p){const _=m[d];return _&&_.type?kl(_.type):p}function kV(m,d,p){const _=m[d];return _&&_.list&&_.list.type?_.list.type.map(E=>kl(E)):p}function kg(m){if(!m.unknownRank)return m.dim!=null?m.dim.map(d=>typeof d.size=="number"?d.size:parseInt(d.size,10)):[]}function p0(m,d,p){const _=m[d];return _&&_.shape?kg(_.shape):p}function p1(m,d,p){const _=m[d];return _?((_.list.f&&_.list.f.length?_.list.f:_.list.i)||[]).map(E=>typeof E=="number"?E:parseInt(E,10)):p}function p2(m,d,p,_=!1){const E=m[d];return E&&E.list&&E.list.s?E.list.s.map(S=>kh(S,_)):p}function p3(m,d,p){const _=m[d];return _&&_.list&&_.list.shape?_.list.shape.map(E=>kg(E)):p}function p4(m,d,p){const _=m[d];return _&&_.list&&_.list.b?_.list.b:p}class p5{constructor(d,p,_){this.node=d,this.tensorMap=p,this.context=_,this.inputs=[],this.attrs={},this.inputs=d.inputNames.map(E=>this.getInput(E)),d.rawAttrs!=null&&(this.attrs=Object.keys(d.rawAttrs).reduce((E,S)=>(E[S]=this.getAttr(S),E),{}))}getInput(d){return k6(d,this.tensorMap,this.context)}getAttr(d,p){const _=this.node.rawAttrs[d];if(_.tensor!=null)return k6(d,this.tensorMap,this.context);if(_.i!=null||_.f!=null)return kx(this.node.rawAttrs,d,p);if(_.s!=null)return kY(this.node.rawAttrs,d,p);if(_.b!=null)return km(this.node.rawAttrs,d,p);if(_.shape!=null)return p0(this.node.rawAttrs,d,p);if(_.type!=null)return ka(this.node.rawAttrs,d,p);if(_.list!=null){if(_.list.i!=null||_.list.f!=null)return p1(this.node.rawAttrs,d,p);if(_.list.s!=null)return p2(this.node.rawAttrs,d,p);if(_.list.shape!=null)return p3(this.node.rawAttrs,d,p);if(_.list.b!=null)return p4(this.node.rawAttrs,d,p);if(_.list.type!=null)return kV(this.node.rawAttrs,d,p)}return p}}const p6={conv2d:Tj,depthwiseConv2d:Ty,matMul:TW},p7={resizeBilinear:qq};var p8=Object.freeze({__proto__:null,add:LT,addN:LO,atan2:Ln,avgPool:LY,cast:CB,concat:Lb,conv2d:KL,conv2dTranspose:Kq,cos:Kk,depthToSpace:Kw,depthwiseConv2d:KZ,expandDims:r0,fill:K8,floor:r4,fused:p6,gather:r6,greaterEqual:ro,image:p7,lessEqual:rL,logicalAnd:rQ,matMul:CR,max:Ky,maxPool:rA,maximum:rF,mean:rO,min:KW,minimum:re,mul:LA,neg:Cf,pad:rS,prelu:rf,range:T4,relu:T6,relu6:T8,reshape:Lv,scalar:KU,sigmoid:LV,sin:TG,squeeze:Tr,stack:Tq,stridedSlice:Tw,sub:rT,tensor1d:TA,tile:r2,transpose:Cd,zerosLike:KD});const p9=(m,d,p,_=p8)=>{switch(m.op){case"BiasAdd":case"AddV2":case"Add":return[_.add(k5("a",m,d,p),k5("b",m,d,p))];case"AddN":return[_.addN(k5("tensors",m,d,p))];case"FloorMod":case"Mod":return[_.mod(k5("a",m,d,p),k5("b",m,d,p))];case"Mul":return[_.mul(k5("a",m,d,p),k5("b",m,d,p))];case"RealDiv":case"Div":return[_.div(k5("a",m,d,p),k5("b",m,d,p))];case"DivNoNan":return[_.divNoNan(k5("a",m,d,p),k5("b",m,d,p))];case"FloorDiv":return[_.floorDiv(k5("a",m,d,p),k5("b",m,d,p))];case"Sub":return[_.sub(k5("a",m,d,p),k5("b",m,d,p))];case"Minimum":return[_.minimum(k5("a",m,d,p),k5("b",m,d,p))];case"Maximum":return[_.maximum(k5("a",m,d,p),k5("b",m,d,p))];case"Pow":return[_.pow(k5("a",m,d,p),k5("b",m,d,p))];case"SquaredDifference":return[_.squaredDifference(k5("a",m,d,p),k5("b",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}},po=(m,d,p,_=p8)=>{switch(m.op){case"Abs":case"ComplexAbs":return[_.abs(k5("x",m,d,p))];case"Acos":return[_.acos(k5("x",m,d,p))];case"Acosh":return[_.acosh(k5("x",m,d,p))];case"Asin":return[_.asin(k5("x",m,d,p))];case"Asinh":return[_.asinh(k5("x",m,d,p))];case"Atan":return[_.atan(k5("x",m,d,p))];case"Atan2":return[_.atan2(k5("x",m,d,p),k5("y",m,d,p))];case"Atanh":return[_.atanh(k5("x",m,d,p))];case"Ceil":return[_.ceil(k5("x",m,d,p))];case"Complex":return[_.complex(k5("real",m,d,p),k5("imag",m,d,p))];case"Cos":return[_.cos(k5("x",m,d,p))];case"Cosh":return[_.cosh(k5("x",m,d,p))];case"Elu":return[_.elu(k5("x",m,d,p))];case"Erf":return[_.erf(k5("x",m,d,p))];case"Exp":return[_.exp(k5("x",m,d,p))];case"Expm1":return[_.expm1(k5("x",m,d,p))];case"Floor":return[_.floor(k5("x",m,d,p))];case"Log":return[_.log(k5("x",m,d,p))];case"Log1p":return[_.log1p(k5("x",m,d,p))];case"Imag":return[_.imag(k5("x",m,d,p))];case"Neg":return[_.neg(k5("x",m,d,p))];case"Reciprocal":return[_.reciprocal(k5("x",m,d,p))];case"Real":return[_.real(k5("x",m,d,p))];case"Relu":return[_.relu(k5("x",m,d,p))];case"Round":return[_.round(k5("x",m,d,p))];case"Selu":return[_.selu(k5("x",m,d,p))];case"Sigmoid":return[_.sigmoid(k5("x",m,d,p))];case"Sin":return[_.sin(k5("x",m,d,p))];case"Sign":return[_.sign(k5("x",m,d,p))];case"Sinh":return[_.sinh(k5("x",m,d,p))];case"Softplus":return[_.softplus(k5("x",m,d,p))];case"Sqrt":return[_.sqrt(k5("x",m,d,p))];case"Square":return[_.square(k5("x",m,d,p))];case"Tanh":return[_.tanh(k5("x",m,d,p))];case"Tan":return[_.tan(k5("x",m,d,p))];case"ClipByValue":return[_.clipByValue(k5("x",m,d,p),k5("clipValueMin",m,d,p),k5("clipValueMax",m,d,p))];case"Relu6":return[_.relu6(k5("x",m,d,p))];case"Rsqrt":return[_.rsqrt(k6(m.inputNames[0],d,p))];case"LeakyRelu":return[_.leakyRelu(k5("x",m,d,p),k5("alpha",m,d,p))];case"Prelu":return[_.prelu(k5("x",m,d,p),k5("alpha",m,d,p))];case"IsNan":return[_.isNaN(k6(m.inputNames[0],d,p))];case"IsInf":return[_.isInf(k6(m.inputNames[0],d,p))];case"IsFinite":return[_.isFinite(k6(m.inputNames[0],d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}};function pc(m,d,p=""){if(!(typeof m=="number"||typeof d=="number")){A(m.length===d.length,()=>p+(" Shapes "+m+" and "+d+" must match"));for(let _=0;_<m.length;_++){const E=m[_],S=d[_];A(E<0||S<0||E===S,()=>p+(" Shapes "+m+" and "+d+" must match"))}}}function pG(m){return!(typeof m=="number"||m.some(d=>d<0))}function ps(m,d,p){let _=pz(m,p);const E=!pG(_);if(E&&d.length===0)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: "+_);if(E&&d.forEach(S=>{_=pz(S.shape,_)}),!pG(_))throw new Error("Non-fully-defined elementShape: "+_);return _}function pz(m,d){if(typeof m=="number")return d;if(typeof d=="number")return m;if(m.length!==d.length)throw new Error("Incompatible ranks during merge: "+m+" vs. "+d);const p=[];for(let _=0;_<m.length;++_){const E=m[_],S=d[_];if(E>=0&&S>=0&&E!==S)throw new Error("Incompatible shape during merge: "+m+" vs. "+d);p[_]=E>=0?E:S}return p}class pC{constructor(d,p,_,E,S,I,D){this.name=d,this.dtype=p,this.maxSize=_,this.elementShape=E,this.identicalElementShapes=S,this.dynamicSize=I,this.clearAfterRead=D,this.tensors=[],this.closed_=!1,this.idTensor=KU(0),z0(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(d){this.tensors.forEach(p=>{(d==null||!d.has(p.tensor.id))&&p.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(d){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(d<0||d>=this.size())throw new Error("Tried to read from index "+d+", but array size is: "+this.size());const p=this.tensors[d];if(p.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+d+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(p.cleared=!0),p.read=!0,p.tensor}readMany(d){return d.map(p=>this.read(p))}write(d,p){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(d<0||!this.dynamicSize&&d>=this.maxSize)throw new Error("Tried to write to index "+d+", but array is not resizeable and size is: "+this.maxSize);const _=this.tensors[d]||{};if(p.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+d+`,
          because the value dtype is `+p.dtype+", but TensorArray dtype is "+this.dtype+".");if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=p.shape),pc(this.elementShape,p.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+d+"."),_.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+d+", because it has already been read.");if(_.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+d+", because it has already been written.");_.tensor=p,z0(p),_.written=!0,this.tensors[d]=_}writeMany(d,p){if(d.length!==p.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+d.length+" is not the same as tensors size: "+p.length+".");d.forEach((_,E)=>this.write(_,p[E]))}gather(d,p){if(p&&p!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+p);if(d)d=d.slice(0,this.size());else{d=[];for(let E=0;E<this.size();E++)d.push(E)}if(d.length===0)return sY([],[0].concat(this.elementShape));const _=this.readMany(d);return pc(this.elementShape,_[0].shape,"TensorArray shape mismatch: "),Tq(_,0)}concat(d){if(d&&d!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+d);if(this.size()===0)return sY([],[0].concat(this.elementShape));const p=[];for(let E=0;E<this.size();E++)p.push(E);const _=this.readMany(p);return pc(this.elementShape,_[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+_[0].shape+")"),Lb(_,0)}scatter(d,p){if(p.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+p.dtype);if(d.length!==p.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+d.length+" vs. "+p.shape[0]);const _=Math.max(...d);if(!this.dynamicSize&&_>=this.maxSize)throw new Error("Max index must be < array size ("+_+"  vs. "+this.maxSize+")");this.writeMany(d,TO(p,0))}split(d,p){if(p.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+p.dtype);let _=0;const E=d.map(k=>(_+=k,_));if(_!==p.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+_+", and tensor's shape is: "+p.shape);if(!this.dynamicSize&&d.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+d.length+"), and the TensorArray is not marked as dynamically resizeable");const S=_===0?0:p.size/_,I=[];sV(()=>{p=Lv(p,[1,_,S]);for(let k=0;k<d.length;++k){const V=[0,k===0?0:E[k-1],0],$=[1,d[k],S];I[k]=Lv(K0(p,V,$),this.elementShape)}return I});const D=[];for(let k=0;k<d.length;k++)D[k]=k;this.writeMany(D,I)}}class pL{get id(){return this.idTensor.id}constructor(d,p,_,E=-1){this.tensors=d,this.elementShape=p,this.elementDtype=_,d?.forEach(S=>{if(_!==S.dtype)throw new Error("Invalid data types; op elements "+_+", but list elements "+S.dtype);pc(p,S.shape,"TensorList shape mismatch: "),z0(S)}),this.idTensor=KU(0),this.maxNumElements=E,z0(this.idTensor)}copy(){return new pL([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(d){this.tensors.forEach(p=>{(d==null||!d.has(p.id))&&p.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(d,p,_=-1){if(p!==this.elementDtype)throw new Error("Invalid data types; op elements "+p+", but list elements "+this.elementDtype);if(_!==-1&&this.tensors.length!==_)throw new Error("Operation expected a list with "+_+" elements but got a list with "+this.tensors.length+" elements.");pc(d,this.elementShape,"TensorList shape mismatch: ");const E=ps(this.elementShape,this.tensors,d);return sV(()=>{const S=this.tensors.map(I=>Lv(I,E));return Tq(S,0)})}popBack(d,p){if(p!==this.elementDtype)throw new Error("Invalid data types; op elements "+p+", but list elements "+this.elementDtype);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const _=ps(this.elementShape,this.tensors,d),E=this.tensors.pop();return E.kept=!1,pc(E.shape,d,"TensorList shape mismatch: "),Lv(E,_)}pushBack(d){if(d.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+d.dtype+", but list elements "+this.elementDtype);if(pc(d.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");z0(d),this.tensors.push(d)}resize(d){if(d<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+d);if(this.maxNumElements!==-1&&d>this.maxNumElements)throw new Error("TensorListResize input size "+d+" is greater maxNumElement "+this.maxNumElements+".");const p=new pL([],this.elementShape,this.elementDtype,this.maxNumElements);p.tensors.length=d;for(let _=0;_<Math.min(this.tensors.length,d);++_)p.tensors[_]=this.tensors[_];return p}getItem(d,p,_){if(_!==this.elementDtype)throw new Error("Invalid data types; op elements "+_+", but list elements "+this.elementDtype);if(d<0||d>this.tensors.length)throw new Error("Trying to access element "+d+" in a list with "+this.tensors.length+" elements.");if(this.tensors[d]==null)throw new Error("element at index "+d+" is null.");pc(this.tensors[d].shape,p,"TensorList shape mismatch: ");const E=ps(this.elementShape,this.tensors,p);return Lv(this.tensors[d],E)}setItem(d,p){if(p.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+p.dtype+", but list elements "+this.elementDtype);if(d<0||this.maxNumElements!==-1&&d>=this.maxNumElements)throw new Error("Trying to set element "+d+" in a list with max "+this.maxNumElements+" elements.");pc(this.elementShape,p.shape,"TensorList shape mismatch: "),z0(p),this.tensors[d]!=null&&(this.tensors[d].kept=!1),this.tensors[d]=p}gather(d,p,_){if(p!==this.elementDtype)throw new Error("Invalid data types; op elements "+p+", but list elements "+this.elementDtype);pc(this.elementShape,_,"TensorList shape mismatch: "),d=d.slice(0,this.size());const E=ps(this.elementShape,this.tensors,_);return d.length===0?sY([],[0].concat(E)):sV(()=>{const S=d.map(I=>Lv(this.tensors[I],E));return Tq(S,0)})}concat(d,p){if(d&&d!==this.elementDtype)throw new Error("TensorList dtype is "+this.elementDtype+" but concat requested dtype "+d);pc(this.elementShape,p,"TensorList shape mismatch: ");const _=ps(this.elementShape,this.tensors,p);return this.size()===0?sY([],[0].concat(_)):sV(()=>{const E=this.tensors.map(S=>Lv(S,_));return Lb(E,0)})}}function pK(m,d,p){const _=m.dtype;if(m.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+m.shape);if(m.dtype!==p)throw new Error("Invalid data types; op elements "+m.dtype+", but list elements "+p);const E=m.shape.slice(1);pc(E,d,"TensorList shape mismatch: ");const S=TO(m);return new pL(S,d,_)}function pr(m,d,p,_){return new pL([],m,d,_)}function pT(m,d,p,_){if(d.length!==m.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+d.length+" vs. "+m.shape[0]);const E=Math.max(...d);if(_!=null&&_!==-1&&E>=_)throw new Error("Max index must be < array size ("+E+"  vs. "+_+")");const S=new pL([],p,m.dtype,_),I=TO(m,0);return d.forEach((D,k)=>{S.setItem(D,I[k])}),S}function pq(m,d,p){let _=0;const E=d.map($=>(_+=$,_));if(_!==m.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+_+", and tensor's shape is: "+m.shape);const S=m.shape.slice(1),I=pz(S,p),D=_===0?0:m.size/_,k=sV(()=>{const $=[];m=Lv(m,[1,_,D]);for(let Z=0;Z<d.length;++Z){const te=[0,Z===0?0:E[Z-1],0],xe=[1,d[Z],D];$[Z]=Lv(K0(m,te,xe),I)}return m.dispose(),$}),V=new pL([],p,m.dtype,d.length);for(let $=0;$<k.length;$++)V.setItem($,k[$]);return V}const pQ=async(m,d,p)=>{switch(m.op){case"If":case"StatelessIf":{const _=k5("thenBranch",m,d,p),E=k5("elseBranch",m,d,p),S=k5("cond",m,d,p),I=k5("args",m,d,p);return(await S.data())[0]?p.functionMap[_].executeFunctionAsync(I,p.tensorArrayMap,p.tensorListMap):p.functionMap[E].executeFunctionAsync(I,p.tensorArrayMap,p.tensorListMap)}case"While":case"StatelessWhile":{const _=k5("body",m,d,p),E=k5("cond",m,d,p),S=k5("args",m,d,p),I=await p.functionMap[E].executeFunctionAsync(S,p.tensorArrayMap,p.tensorListMap),D=S.map($=>$.id);let k=await I[0].data();I.forEach($=>{!$.kept&&D.indexOf($.id)===-1&&$.dispose()});let V=S;for(;k[0];){const $=V;V=await p.functionMap[_].executeFunctionAsync(V,p.tensorArrayMap,p.tensorListMap);const Z=V.map(xe=>xe.id);$.forEach(xe=>{!xe.kept&&D.indexOf(xe.id)===-1&&Z.indexOf(xe.id)===-1&&xe.dispose()});const te=await p.functionMap[E].executeFunctionAsync(V,p.tensorArrayMap,p.tensorListMap);k=await te[0].data(),te.forEach(xe=>{!xe.kept&&D.indexOf(xe.id)===-1&&Z.indexOf(xe.id)===-1&&xe.dispose()})}return V}case"LoopCond":{const _=k5("pred",m,d,p);return[kG(_)]}case"Switch":{const _=k5("pred",m,d,p);let E=k5("data",m,d,p);return E.kept||(E=kG(E)),(await _.data())[0]?[void 0,E]:[E,void 0]}case"Merge":{const _=m.inputNames.find(E=>k6(E,d,p)!==void 0);if(_){const E=k6(_,d,p);return[kG(E)]}return}case"Enter":{const _=k5("frameName",m,d,p),E=k5("tensor",m,d,p);return p.enterFrame(_),[kG(E)]}case"Exit":{const _=k5("tensor",m,d,p);return p.exitFrame(),[kG(_)]}case"NextIteration":{const _=k5("tensor",m,d,p);return p.nextIteration(),[kG(_)]}case"TensorArrayV3":{const _=k5("size",m,d,p),E=k5("dtype",m,d,p),S=k5("elementShape",m,d,p),I=k5("dynamicSize",m,d,p),D=k5("clearAfterRead",m,d,p),k=k5("identicalElementShapes",m,d,p),V=k5("name",m,d,p),$=new pC(V,E,_,S,k,I,D);return p.addTensorArray($),[$.idTensor,KU(1)]}case"TensorArrayWriteV3":{const _=k5("tensorArrayId",m,d,p),E=k5("index",m,d,p),S=k5("tensor",m,d,p),I=p.getTensorArray(_.id);return I.write(E,S),[I.idTensor]}case"TensorArrayReadV3":{const _=k5("tensorArrayId",m,d,p),E=k5("index",m,d,p);return[p.getTensorArray(_.id).read(E)]}case"TensorArrayGatherV3":{const _=k5("tensorArrayId",m,d,p),E=k5("indices",m,d,p),S=k5("dtype",m,d,p);return[p.getTensorArray(_.id).gather(E,S)]}case"TensorArrayScatterV3":{const _=k5("tensorArrayId",m,d,p),E=k5("indices",m,d,p),S=k5("tensor",m,d,p),I=p.getTensorArray(_.id);return I.scatter(E,S),[I.idTensor]}case"TensorArrayConcatV3":{const _=k5("tensorArrayId",m,d,p),E=p.getTensorArray(_.id),S=k5("dtype",m,d,p);return[E.concat(S)]}case"TensorArraySplitV3":{const _=k5("tensorArrayId",m,d,p),E=k5("tensor",m,d,p),S=k5("lengths",m,d,p),I=p.getTensorArray(_.id);return I.split(S,E),[I.idTensor]}case"TensorArraySizeV3":{const _=k5("tensorArrayId",m,d,p),E=p.getTensorArray(_.id);return[KU(E.size(),"int32")]}case"TensorArrayCloseV3":{const _=k5("tensorArrayId",m,d,p),E=p.getTensorArray(_.id);return E.clearAndClose(),[E.idTensor]}case"TensorListSetItem":{const _=k5("tensorListId",m,d,p),E=k5("index",m,d,p),S=k5("tensor",m,d,p),I=p.getTensorList(_.id);return I.setItem(E,S),[I.idTensor]}case"TensorListGetItem":{const _=k5("tensorListId",m,d,p),E=k5("index",m,d,p),S=k5("elementShape",m,d,p),I=k5("elementDType",m,d,p);return[p.getTensorList(_.id).getItem(E,S,I)]}case"TensorListScatterV2":case"TensorListScatter":{const _=k5("indices",m,d,p),E=k5("tensor",m,d,p),S=k5("elementShape",m,d,p),I=k5("numElements",m,d,p),D=pT(E,_,S,I);return p.addTensorList(D),[D.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const _=k5("elementShape",m,d,p),E=k5("elementDType",m,d,p);let S;m.op==="TensorListReserve"?S="numElements":S="maxNumElements";const I=k5(S,m,d,p),D=m.op==="TensorListReserve"?-1:I,k=pr(_,E,I,D);return p.addTensorList(k),[k.idTensor]}case"TensorListGather":{const _=k5("tensorListId",m,d,p),E=k5("indices",m,d,p),S=k5("elementShape",m,d,p),I=k5("elementDType",m,d,p);return[p.getTensorList(_.id).gather(E,I,S)]}case"TensorListStack":{const _=k5("tensorListId",m,d,p),E=k5("elementShape",m,d,p),S=k5("elementDType",m,d,p),I=k5("numElements",m,d,p);return[p.getTensorList(_.id).stack(E,S,I)]}case"TensorListFromTensor":{const _=k5("tensor",m,d,p),E=k5("elementShape",m,d,p),S=k5("elementDType",m,d,p),I=pK(_,E,S);return p.addTensorList(I),[I.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const _=k5("tensorListId",m,d,p),E=p.getTensorList(_.id),S=k5("dtype",m,d,p),I=k5("elementShape",m,d,p);return[E.concat(S,I)]}case"TensorListPushBack":{const _=k5("tensorListId",m,d,p),E=k5("tensor",m,d,p),S=p.getTensorList(_.id);return S.pushBack(E),[S.idTensor]}case"TensorListPopBack":{const _=k5("tensorListId",m,d,p),E=k5("elementShape",m,d,p),S=k5("elementDType",m,d,p);return[p.getTensorList(_.id).popBack(E,S)]}case"TensorListSplit":{const _=k5("tensor",m,d,p),E=k5("elementShape",m,d,p),S=k5("lengths",m,d,p),I=pq(_,S,E);return p.addTensorList(I),[I.idTensor]}case"TensorListLength":{const _=k5("tensorListId",m,d,p),E=p.getTensorList(_.id);return[KU(E.size(),"int32")]}case"TensorListResize":{const _=k5("tensorListId",m,d,p),E=k5("size",m,d,p),S=p.getTensorList(_.id).resize(E);return p.addTensorList(S),[S.idTensor]}default:throw TypeError("Node type "+m.op+" is not implemented")}};function pk(m,d,p){const[_,E]=k5("fusedOps",m,d,p),S=_==="biasadd",I=!S,D=E==="prelu",k=_==="fusedbatchnorm",V=k5("numArgs",m,d,p);if(S){if(D&&V!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!D&&S&&V!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(k)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const $=k5("strides",m,d,p),Z=kc(m,d,p),te=k5("dataFormat",m,d,p).toUpperCase(),xe=k5("dilations",m,d,p);let[le,he]=k5("args",m,d,p);I&&(he=le,le=void 0);const de=k5("leakyreluAlpha",m,d,p);return{stride:$,pad:Z,dataFormat:te,dilations:xe,biasArg:le,preluArg:he,activationFunc:E,leakyreluAlpha:de}}const pp=(m,d,p,_=p8)=>{switch(m.op){case"Conv1D":{const E=k5("stride",m,d,p),S=k5("pad",m,d,p),I=k5("dataFormat",m,d,p).toUpperCase(),D=k5("dilation",m,d,p);return[_.conv1d(k5("x",m,d,p),k5("filter",m,d,p),E,S,I,D)]}case"Conv2D":{const E=k5("strides",m,d,p),S=kc(m,d,p),I=k5("dataFormat",m,d,p).toUpperCase(),D=k5("dilations",m,d,p);return[_.conv2d(k5("x",m,d,p),k5("filter",m,d,p),[E[1],E[2]],S,I,[D[1],D[2]])]}case"_FusedConv2D":{const{stride:E,pad:S,dataFormat:I,dilations:D,biasArg:k,preluArg:V,activationFunc:$,leakyreluAlpha:Z}=pk(m,d,p),te=m.name.endsWith("batch_normalization_88/FusedBatchNormV3")||m.name.endsWith("batch_normalization_90/FusedBatchNormV3")?oQ().get("WEBGL_USE_SHAPES_UNIFORMS"):void 0;te&&oQ().set("WEBGL_USE_SHAPES_UNIFORMS",!1);const xe=[_.fused.conv2d({x:k5("x",m,d,p),filter:k5("filter",m,d,p),strides:[E[1],E[2]],pad:S,dataFormat:I,dilations:[D[1],D[2]],bias:k,activation:$,preluActivationWeights:V,leakyreluAlpha:Z})];return te&&oQ().set("WEBGL_USE_SHAPES_UNIFORMS",!0),xe}case"FusedDepthwiseConv2dNative":{const{stride:E,pad:S,dataFormat:I,dilations:D,biasArg:k,preluArg:V,activationFunc:$,leakyreluAlpha:Z}=pk(m,d,p);return[_.fused.depthwiseConv2d({x:k5("x",m,d,p),filter:k5("filter",m,d,p),strides:[E[1],E[2]],pad:S,dataFormat:I,dilations:[D[1],D[2]],bias:k,activation:$,preluActivationWeights:V,leakyreluAlpha:Z})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const E=k5("outputShape",m,d,p),S=k5("strides",m,d,p),I=kc(m,d,p);return[_.conv2dTranspose(k5("x",m,d,p),k5("filter",m,d,p),E,[S[1],S[2]],I)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const E=k5("strides",m,d,p),S=kc(m,d,p),I=k5("dilations",m,d,p),D=k5("dataFormat",m,d,p).toUpperCase();return[_.depthwiseConv2d(k5("input",m,d,p),k5("filter",m,d,p),[E[1],E[2]],S,D,[I[1],I[2]])]}case"Conv3D":{const E=k5("strides",m,d,p),S=k5("pad",m,d,p),I=k5("dataFormat",m,d,p).toUpperCase(),D=k5("dilations",m,d,p);return[_.conv3d(k5("x",m,d,p),k5("filter",m,d,p),[E[1],E[2],E[3]],S,I,[D[1],D[2],D[3]])]}case"AvgPool":{const E=k5("strides",m,d,p),S=k5("pad",m,d,p),I=k5("kernelSize",m,d,p);return[_.avgPool(k5("x",m,d,p),[I[1],I[2]],[E[1],E[2]],S)]}case"MaxPool":{const E=k5("strides",m,d,p),S=k5("pad",m,d,p),I=k5("kernelSize",m,d,p);return[_.maxPool(k5("x",m,d,p),[I[1],I[2]],[E[1],E[2]],S)]}case"MaxPoolWithArgmax":{const E=k5("strides",m,d,p),S=k5("pad",m,d,p),I=k5("kernelSize",m,d,p),D=k5("includeBatchInIndex",m,d,p),{result:k,indexes:V}=_.maxPoolWithArgmax(k5("x",m,d,p),[I[1],I[2]],[E[1],E[2]],S,D);return[k,V]}case"AvgPool3D":{const E=k5("strides",m,d,p),S=k5("pad",m,d,p),I=k5("kernelSize",m,d,p);return[_.avgPool3d(k5("x",m,d,p),[I[1],I[2],I[3]],[E[1],E[2],E[3]],S)]}case"MaxPool3D":{const E=k5("strides",m,d,p),S=k5("pad",m,d,p),I=k5("kernelSize",m,d,p);return[_.maxPool3d(k5("x",m,d,p),[I[1],I[2],I[3]],[E[1],E[2],E[3]],S)]}case"Dilation2D":{const E=k5("strides",m,d,p),S=k5("pad",m,d,p),I=k5("dilations",m,d,p),D=E[1],k=E[2],V=I[1],$=I[2];return[_.dilation2d(k5("x",m,d,p),k5("filter",m,d,p),[D,k],S,[V,$],"NHWC")]}default:throw TypeError("Node type "+m.op+" is not implemented")}},pw=(m,d,p,_=p8)=>{switch(m.op){case"Fill":{const E=k5("shape",m,d,p),S=k5("dtype",m,d,p),I=k5("value",m,d,p);return[_.fill(E,I,S)]}case"LinSpace":{const E=k5("start",m,d,p),S=k5("stop",m,d,p),I=k5("num",m,d,p);return[_.linspace(E,S,I)]}case"Multinomial":{const E=k5("logits",m,d,p),S=k5("numSamples",m,d,p),I=k5("seed",m,d,p);return[_.multinomial(E,S,I)]}case"OneHot":{const E=k5("indices",m,d,p),S=k5("depth",m,d,p),I=k5("onValue",m,d,p),D=k5("offValue",m,d,p),k=k5("dtype",m,d,p);return[_.oneHot(E,S,I,D,k)]}case"Ones":return[_.ones(k5("shape",m,d,p),k5("dtype",m,d,p))];case"OnesLike":return[_.onesLike(k5("x",m,d,p))];case"RandomStandardNormal":return[_.randomStandardNormal(k5("shape",m,d,p),k5("dtype",m,d,p),k5("seed",m,d,p))];case"RandomUniform":return[_.randomUniform(k5("shape",m,d,p),k5("minval",m,d,p),k5("maxval",m,d,p),k5("dtype",m,d,p))];case"RandomUniformInt":return[_.randomUniformInt(k5("shape",m,d,p),k5("minval",m,d,p),k5("maxval",m,d,p),k5("seed",m,d,p))];case"Range":{const E=k5("start",m,d,p),S=k5("stop",m,d,p),I=k5("step",m,d,p);return[_.range(E,S,I,k5("dtype",m,d,p))]}case"TruncatedNormal":{const E=k5("shape",m,d,p),S=k5("mean",m,d,p),I=k5("stdDev",m,d,p),D=k5("seed",m,d,p);return[_.truncatedNormal(E,S,I,k5("dtype",m,d,p),D)]}case"Zeros":return[_.zeros(k5("shape",m,d,p),k5("dtype",m,d,p))];case"ZerosLike":return[_.zerosLike(k5("x",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}};function pA(m,d,p){const _=k5("boxes",m,d,p),E=k5("scores",m,d,p),S=k5("maxOutputSize",m,d,p),I=k5("iouThreshold",m,d,p),D=k5("scoreThreshold",m,d,p),k=k5("softNmsSigma",m,d,p);return{boxes:_,scores:E,maxOutputSize:S,iouThreshold:I,scoreThreshold:D,softNmsSigma:k}}const pZ=async(m,d,p,_,E=p8)=>{switch(m.op){case"NonMaxSuppressionV5":{const{boxes:S,scores:I,maxOutputSize:D,iouThreshold:k,scoreThreshold:V,softNmsSigma:$}=pA(m,d,p),Z=await E.image.nonMaxSuppressionWithScoreAsync(S,I,D,k,V,$);return[Z.selectedIndices,Z.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:S,scores:I,maxOutputSize:D,iouThreshold:k,scoreThreshold:V}=pA(m,d,p),$=k5("padToMaxOutputSize",m,d,p),Z=await E.image.nonMaxSuppressionPaddedAsync(S,I,D,k,V,$);return[Z.selectedIndices,Z.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:S,scores:I,maxOutputSize:D,iouThreshold:k,scoreThreshold:V}=pA(m,d,p);return[await E.image.nonMaxSuppressionAsync(S,I,D,k,V)]}case"Where":{const S=E.cast(k5("condition",m,d,p),"bool"),I=[await E.whereAsync(S)];return S.dispose(),I}case"ListDiff":return E.setdiff1dAsync(k5("x",m,d,p),k5("y",m,d,p));default:throw TypeError("Node type "+m.op+" is not implemented")}},pF=(m,d,p,_=p8)=>{switch(m.op){case"LowerBound":{const E=k5("sortedSequence",m,d,p),S=k5("values",m,d,p);return[_.lowerBound(E,S)]}case"TopKV2":{const E=k5("x",m,d,p),S=k5("k",m,d,p),I=k5("sorted",m,d,p),D=_.topk(E,S,I);return[D.values,D.indices]}case"UpperBound":{const E=k5("sortedSequence",m,d,p),S=k5("values",m,d,p);return[_.upperBound(E,S)]}case"Unique":{const E=k5("x",m,d,p),S=_.unique(E);return[S.values,S.indices]}case"UniqueV2":{const E=k5("x",m,d,p),S=k5("axis",m,d,p),I=_.unique(E,S);return[I.values,I.indices]}default:throw TypeError("Node type "+m.op+" is not implemented")}},pN=(m,d,p,_=p8)=>{switch(m.op){case"Const":return d[m.name];case"PlaceholderWithDefault":const E=k5("default",m,d,p);return[k6(m.name,d,p)||E];case"Placeholder":return[k6(m.name,d,p)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const $=k5("x",m,d,p);return[kG($)]}case"IdentityN":return k5("x",m,d,p).map($=>kG($));case"Snapshot":const S=k5("x",m,d,p);return[kG(S)];case"Shape":return[_.tensor1d(k5("x",m,d,p).shape,"int32")];case"ShapeN":return k5("x",m,d,p).map($=>_.tensor1d($.shape));case"Size":return[_.scalar(k5("x",m,d,p).size,"int32")];case"Rank":return[_.scalar(k5("x",m,d,p).rank,"int32")];case"NoOp":return[_.scalar(1)];case"Print":const I=k5("x",m,d,p),D=k5("data",m,d,p),k=k5("message",m,d,p),V=k5("summarize",m,d,p);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(k);for(let $=0;$<D.length;$++)console.log(Array.prototype.slice.call(D[$].dataSync()).slice(0,V));return[I];default:throw TypeError("Node type "+m.op+" is not implemented")}};class pO{get id(){return this.handle.id}constructor(d,p){this.keyDType=d,this.valueDType=p,this.handle=KU(0),this.tensorMap=new Map,z0(this.handle)}clearAndClose(){this.tensorMap.forEach(d=>d.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return KU(this.size(),"int32")}async import(d,p){this.checkKeyAndValueTensor(d,p);const _=await d.data();return this.tensorMap.forEach(E=>E.dispose()),this.tensorMap.clear(),sV(()=>{const E=TO(p),S=_.length,I=E.length;A(S===I,()=>"The number of elements doesn't match, keys has "+S+" elements, the values has "+I+" elements.");for(let D=0;D<S;D++){const k=_[D],V=E[D];z0(V),this.tensorMap.set(k,V)}return this.handle})}async find(d,p){this.checkKeyAndValueTensor(d,p);const _=await d.data();return sV(()=>{const E=[];for(let S=0;S<_.length;S++){const I=_[S],D=this.findWithDefault(I,p);E.push(D)}return Tq(E)})}findWithDefault(d,p){const _=this.tensorMap.get(d);return _??p}checkKeyAndValueTensor(d,p){if(d.dtype!==this.keyDType)throw new Error("Expect key dtype "+this.keyDType+", but got "+d.dtype);if(p.dtype!==this.valueDType)throw new Error("Expect value dtype "+this.valueDType+", but got "+p.dtype)}}const pD=async(m,d,p,_)=>{switch(m.op){case"HashTable":case"HashTableV2":{const E=_.getHashTableHandleByName(m.name);if(E!=null)return[E];{const S=k5("keyDType",m,d,p),I=k5("valueDType",m,d,p),D=new pO(S,I);return _.addHashTable(m.name,D),[D.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const E=k5("tableHandle",m,d,p,_),S=k5("keys",m,d,p),I=k5("values",m,d,p);return[await _.getHashTableById(E.id).import(S,I)]}case"LookupTableFind":case"LookupTableFindV2":{const E=k5("tableHandle",m,d,p,_),S=k5("keys",m,d,p),I=k5("defaultValue",m,d,p);return[await _.getHashTableById(E.id).find(S,I)]}case"LookupTableSize":case"LookupTableSizeV2":{const E=k5("tableHandle",m,d,p,_);return[_.getHashTableById(E.id).tensorSize()]}default:throw TypeError("Node type "+m.op+" is not implemented")}},pn=(m,d,p,_=p8)=>{switch(m.op){case"ResizeBilinear":{const E=k5("images",m,d,p),S=k5("size",m,d,p),I=k5("alignCorners",m,d,p),D=k5("halfPixelCenters",m,d,p);return[_.image.resizeBilinear(E,[S[0],S[1]],I,D)]}case"ResizeNearestNeighbor":{const E=k5("images",m,d,p),S=k5("size",m,d,p),I=k5("alignCorners",m,d,p),D=k5("halfPixelCenters",m,d,p);return[_.image.resizeNearestNeighbor(E,[S[0],S[1]],I,D)]}case"CropAndResize":{const E=k5("image",m,d,p),S=k5("boxes",m,d,p),I=k5("boxInd",m,d,p),D=k5("cropSize",m,d,p),k=k5("method",m,d,p),V=k5("extrapolationValue",m,d,p);return[_.image.cropAndResize(E,S,I,D,k,V)]}case"ImageProjectiveTransformV3":{const E=k5("images",m,d,p),S=k5("transforms",m,d,p),I=k5("outputShape",m,d,p),D=k5("fillValue",m,d,p),k=k5("interpolation",m,d,p),V=k5("fillMode",m,d,p);return[_.image.transform(E,S,k.toLowerCase(),V.toLowerCase(),D,I)]}default:throw TypeError("Node type "+m.op+" is not implemented")}},pi=(m,d,p,_=p8)=>{switch(m.op){case"Equal":return[_.equal(k5("a",m,d,p),k5("b",m,d,p))];case"NotEqual":return[_.notEqual(k5("a",m,d,p),k5("b",m,d,p))];case"Greater":return[_.greater(k5("a",m,d,p),k5("b",m,d,p))];case"GreaterEqual":return[_.greaterEqual(k5("a",m,d,p),k5("b",m,d,p))];case"Less":return[_.less(k5("a",m,d,p),k5("b",m,d,p))];case"LessEqual":return[_.lessEqual(k5("a",m,d,p),k5("b",m,d,p))];case"LogicalAnd":return[_.logicalAnd(k5("a",m,d,p),k5("b",m,d,p))];case"LogicalNot":return[_.logicalNot(k5("a",m,d,p))];case"LogicalOr":return[_.logicalOr(k5("a",m,d,p),k5("b",m,d,p))];case"Select":case"SelectV2":return[_.where(k5("condition",m,d,p),k5("a",m,d,p),k5("b",m,d,p))];case"BitwiseAnd":return[_.bitwiseAnd(k5("a",m,d,p),k5("b",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}},pe=(m,d,p,_=p8)=>{switch(m.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[_.matMul(k5("a",m,d,p),k5("b",m,d,p),k5("transposeA",m,d,p),k5("transposeB",m,d,p))];case"Einsum":return[_.einsum(k5("equation",m,d,p),...k5("tensors",m,d,p))];case"Transpose":return[_.transpose(k5("x",m,d,p),k5("perm",m,d,p))];case"_FusedMatMul":const[E,S]=k5("fusedOps",m,d,p),I=E==="biasadd",D=S==="prelu",k=k5("numArgs",m,d,p),V=k5("leakyreluAlpha",m,d,p);if(I){if(D&&k!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!D&&k!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[$,Z]=k5("args",m,d,p);return[_.fused.matMul({a:k5("a",m,d,p),b:k5("b",m,d,p),transposeA:k5("transposeA",m,d,p),transposeB:k5("transposeB",m,d,p),bias:$,activation:S,preluActivationWeights:Z,leakyreluAlpha:V})];case"MatrixBandPart":return[_.linalg.bandPart(k5("a",m,d,p),k5("numLower",m,d,p),k5("numUpper",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}},pP=(m,d,p,_=p8)=>{switch(m.op){case"EuclideanNorm":return[_.euclideanNorm(k5("x",m,d,p),k5("axis",m,d,p),k5("keepDims",m,d,p))];case"FusedBatchNorm":case"FusedBatchNormV2":return[_.batchNorm(k5("x",m,d,p),k5("mean",m,d,p),k5("variance",m,d,p),k5("offset",m,d,p),k5("scale",m,d,p),k5("epsilon",m,d,p))];case"FusedBatchNormV3":return[_.batchNorm(k5("x",m,d,p),k5("mean",m,d,p),k5("variance",m,d,p),k5("offset",m,d,p),k5("scale",m,d,p),k5("epsilon",m,d,p))];case"LRN":return[_.localResponseNormalization(k5("x",m,d,p),k5("radius",m,d,p),k5("bias",m,d,p),k5("alpha",m,d,p),k5("beta",m,d,p))];case"Softmax":return[_.softmax(k5("x",m,d,p))];case"LogSoftmax":return[_.logSoftmax(k5("x",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}},pS=(m,d,p,_=p8)=>{switch(m.op){case"RaggedGather":{const{outputNestedSplits:E,outputDenseValues:S}=_.raggedGather(k5("paramsNestedSplits",m,d,p),k5("paramsDenseValues",m,d,p),k5("indices",m,d,p),k5("outputRaggedRank",m,d,p));return E.concat(S)}case"RaggedRange":{const{rtNestedSplits:E,rtDenseValues:S}=_.raggedRange(k5("starts",m,d,p),k5("limits",m,d,p),k5("splits",m,d,p));return[E,S]}case"RaggedTensorToTensor":return[_.raggedTensorToTensor(k5("shape",m,d,p),k5("values",m,d,p),k5("defaultValue",m,d,p),k5("rowPartitionTensors",m,d,p),k5("rowPartitionTypes",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}},pI=(m,d,p,_=p8)=>{switch(m.op){case"Max":{const D=k5("axis",m,d,p),k=k5("keepDims",m,d,p);return[_.max(k5("x",m,d,p),D,k)]}case"Mean":{const D=k5("axis",m,d,p),k=k5("keepDims",m,d,p);return[_.mean(k5("x",m,d,p),D,k)]}case"Min":{const D=k5("axis",m,d,p),k=k5("keepDims",m,d,p);return[_.min(k5("x",m,d,p),D,k)]}case"Sum":{const D=k5("axis",m,d,p),k=k5("keepDims",m,d,p);return[_.sum(k5("x",m,d,p),D,k)]}case"All":{const D=k5("axis",m,d,p),k=k5("keepDims",m,d,p);return[_.all(k5("x",m,d,p),D,k)]}case"Any":{const D=k5("axis",m,d,p),k=k5("keepDims",m,d,p);return[_.any(k5("x",m,d,p),D,k)]}case"ArgMax":{const D=k5("axis",m,d,p);return[_.argMax(k5("x",m,d,p),D)]}case"ArgMin":{const D=k5("axis",m,d,p);return[_.argMin(k5("x",m,d,p),D)]}case"Prod":{const D=k5("axis",m,d,p),k=k5("keepDims",m,d,p);return[_.prod(k5("x",m,d,p),D,k)]}case"Cumprod":{const D=k5("axis",m,d,p),k=k5("exclusive",m,d,p),V=k5("reverse",m,d,p);return[_.cumprod(k5("x",m,d,p),D,k,V)]}case"Cumsum":{const D=k5("axis",m,d,p),k=k5("exclusive",m,d,p),V=k5("reverse",m,d,p);return[_.cumsum(k5("x",m,d,p),D,k,V)]}case"Bincount":const E=k5("x",m,d,p),S=k5("weights",m,d,p),I=k5("size",m,d,p);return[_.bincount(E,S,I)];case"DenseBincount":{const D=k5("x",m,d,p),k=k5("weights",m,d,p),V=k5("size",m,d,p),$=k5("binaryOutput",m,d,p);return[_.denseBincount(D,k,V,$)]}default:throw TypeError("Node type "+m.op+" is not implemented")}},pB=(m,d,p,_=p8)=>{switch(m.op){case"ConcatV2":case"Concat":{const E=k5("n",m,d,p),S=k5("axis",m,d,p);let I=k5("tensors",m,d,p);return I=I.slice(0,E),[_.concat(I,S)]}case"Gather":{const E=k5("x",m,d,p),S=k5("indices",m,d,p);return[_.gather(E,_.cast(S,"int32"),0)]}case"GatherV2":{const E=k5("axis",m,d,p),S=k5("batchDims",m,d,p),I=k5("x",m,d,p),D=k5("indices",m,d,p);return[_.gather(I,_.cast(D,"int32"),E,S)]}case"Reverse":{const E=k5("dims",m,d,p),S=[];for(let D=0;D<E.length;D++)E[D]&&S.push(D);const I=k5("x",m,d,p);return[_.reverse(I,S)]}case"ReverseV2":{const E=k5("axis",m,d,p),S=k5("x",m,d,p);return[_.reverse(S,E)]}case"Slice":{const E=k5("begin",m,d,p),S=k5("size",m,d,p);return[_.slice(k5("x",m,d,p),E,S)]}case"StridedSlice":{const E=k5("begin",m,d,p),S=k5("end",m,d,p),I=k5("strides",m,d,p),D=k5("beginMask",m,d,p),k=k5("endMask",m,d,p),V=k5("ellipsisMask",m,d,p),$=k5("newAxisMask",m,d,p),Z=k5("shrinkAxisMask",m,d,p),te=k5("x",m,d,p);return[_.stridedSlice(te,E,S,I,D,k,V,$,Z)]}case"Pack":return sV(()=>{const E=k5("axis",m,d,p),S=k5("tensors",m,d,p),I=S[0].shape,D=_.squeeze(S[0]).shape,k=S.map(V=>{const $=i(V.shape,I);if(!$&&!i(_.squeeze(V).shape,D))throw new Error("the input tensors shape does not match");return $?V:_.reshape(V,I)});return[_.stack(k,E)]});case"Unpack":{const E=k5("axis",m,d,p),S=k5("tensor",m,d,p);return _.unstack(S,E)}case"Tile":{const E=k5("reps",m,d,p);return[_.tile(k5("x",m,d,p),E)]}case"Split":case"SplitV":{const E=k5("axis",m,d,p),S=k5("numOrSizeSplits",m,d,p),I=k5("x",m,d,p);return _.split(I,S,E)}case"ScatterNd":{const E=k5("indices",m,d,p),S=k5("values",m,d,p),I=k5("shape",m,d,p);return[_.scatterND(E,S,I)]}case"GatherNd":{const E=k5("x",m,d,p),S=k5("indices",m,d,p);return[_.gatherND(E,S)]}case"SparseToDense":{const E=k5("sparseIndices",m,d,p),S=k5("outputShape",m,d,p),I=k5("sparseValues",m,d,p),D=k5("defaultValue",m,d,p);return[_.sparseToDense(E,I,S,I.dtype===D.dtype?D:_.cast(D,I.dtype))]}case"TensorScatterUpdate":{const E=k5("indices",m,d,p),S=k5("values",m,d,p),I=k5("tensor",m,d,p);return[_.tensorScatterUpdate(I,E,S)]}default:throw TypeError("Node type "+m.op+" is not implemented")}},pj=(m,d,p,_=p8)=>{switch(m.op){case"SparseFillEmptyRows":{const{outputIndices:E,outputValues:S,emptyRowIndicator:I,reverseIndexMap:D}=_.sparse.sparseFillEmptyRows(k5("indices",m,d,p),k5("values",m,d,p),k5("denseShape",m,d,p),k5("defaultValue",m,d,p));return[E,S,I,D]}case"SparseReshape":{const{outputIndices:E,outputShape:S}=_.sparse.sparseReshape(k5("inputIndices",m,d,p),k5("inputShape",m,d,p),k5("newShape",m,d,p));return[E,S]}case"SparseSegmentMean":return[_.sparse.sparseSegmentMean(k5("data",m,d,p),k5("indices",m,d,p),k5("segmentIds",m,d,p))];case"SparseSegmentSum":return[_.sparse.sparseSegmentSum(k5("data",m,d,p),k5("indices",m,d,p),k5("segmentIds",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}},pR=(m,d,p,_=p8)=>{switch(m.op){case"FFT":return[_.fft(k5("x",m,d,p))];case"IFFT":return[_.ifft(k5("x",m,d,p))];case"RFFT":return[_.rfft(k5("x",m,d,p))];case"IRFFT":return[_.irfft(k5("x",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}},pH=(m,d,p,_=p8)=>{switch(m.op){case"StaticRegexReplace":return[_.string.staticRegexReplace(k5("input",m,d,p),k5("pattern",m,d,p),k5("rewrite",m,d,p),k5("replaceGlobal",m,d,p))];case"StringNGrams":{const{nGrams:E,nGramsSplits:S}=_.string.stringNGrams(k5("data",m,d,p),k5("dataSplits",m,d,p),k5("separator",m,d,p),k5("nGramWidths",m,d,p),k5("leftPad",m,d,p),k5("rightPad",m,d,p),k5("padWidth",m,d,p),k5("preserveShortSequences",m,d,p));return[E,S]}case"StringSplit":{const{indices:E,values:S,shape:I}=_.string.stringSplit(k5("input",m,d,p),k5("delimiter",m,d,p),k5("skipEmpty",m,d,p));return[E,S,I]}case"StringToHashBucketFast":return[_.string.stringToHashBucketFast(k5("input",m,d,p),k5("numBuckets",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}},pu=(m,d,p,_=p8)=>{switch(m.op){case"Cast":return[_.cast(k5("x",m,d,p),k5("dtype",m,d,p))];case"ExpandDims":{const E=k5("axis",m,d,p);return[_.expandDims(k5("x",m,d,p),E)]}case"Squeeze":{const E=k5("axis",m,d,p);return[_.squeeze(k5("x",m,d,p),E)]}case"Reshape":return[_.reshape(k5("x",m,d,p),k5("shape",m,d,p))];case"EnsureShape":return[_.ensureShape(k5("x",m,d,p),k5("shape",m,d,p))];case"MirrorPad":return[_.mirrorPad(k5("x",m,d,p),k5("padding",m,d,p),k5("mode",m,d,p))];case"PadV2":case"Pad":return[_.pad(k5("x",m,d,p),k5("padding",m,d,p),k5("constantValue",m,d,p))];case"SpaceToBatchND":{const E=k5("blockShape",m,d,p),S=k5("paddings",m,d,p);return[_.spaceToBatchND(k5("x",m,d,p),E,S)]}case"BatchToSpaceND":{const E=k5("blockShape",m,d,p),S=k5("crops",m,d,p);return[_.batchToSpaceND(k5("x",m,d,p),E,S)]}case"DepthToSpace":{const E=k5("blockSize",m,d,p),S=k5("dataFormat",m,d,p).toUpperCase();return[_.depthToSpace(k5("x",m,d,p),E,S)]}case"BroadcastTo":return[_.broadcastTo(k5("x",m,d,p),k5("shape",m,d,p))];case"BroadcastArgs":return[_.broadcastArgs(k5("s0",m,d,p),k5("s1",m,d,p))];default:throw TypeError("Node type "+m.op+" is not implemented")}};function pX(m,d,p,_,E=sV){const S=((I,D,k)=>{switch(I.category){case"arithmetic":return E(()=>p9(I,D,k));case"basic_math":return E(()=>po(I,D,k));case"control":return pQ(I,D,k);case"convolution":return E(()=>pp(I,D,k));case"creation":return E(()=>pw(I,D,k));case"dynamic":return pZ(I,D,k);case"evaluation":return E(()=>pF(I,D,k));case"image":return E(()=>pn(I,D,k));case"graph":return E(()=>pN(I,D,k));case"logical":return E(()=>pi(I,D,k));case"matrices":return E(()=>pe(I,D,k));case"normalization":return E(()=>pP(I,D,k));case"ragged":return E(()=>pS(I,D,k));case"reduction":return E(()=>pI(I,D,k));case"slice_join":return E(()=>pB(I,D,k));case"sparse":return E(()=>pj(I,D,k));case"spectral":return E(()=>pR(I,D,k));case"string":return E(()=>pH(I,D,k));case"transformation":return E(()=>pu(I,D,k));case"hash_table":return pD(I,D,k,_);case"custom":const V=k4(I.op);if(V&&V.customExecutor)return V.customExecutor(new p5(I,D,k));throw TypeError("Custom op "+I.op+" is not registered.");default:throw TypeError("Unknown op '"+I.op+"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(m,d,p);return oC(S)?S.then(I=>[].concat(I)):[].concat(S)}class pf{constructor(d={},p={},_={},E={},S){this.weightMap=d,this.tensorArrayMap=p,this.tensorListMap=_,this.functionMap=E,this.parseNodeNameCache=S,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(d,p){return{id:d,frameName:p,iterationId:0}}set currentContext(d){this.contexts!==d&&(this.contexts=d,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const d=[];for(let p=0;p<this.contexts.length-1;p++){const _=this.contexts.slice(0,this.contexts.length-p);d.push(this.contextIdforContexts(_))}d.push(""),this._currentContextIds=d}contextIdforContexts(d){return d?d.map(p=>p.id===0&&p.iterationId===0?"":p.frameName+"-"+p.iterationId).join("/"):""}enterFrame(d){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,d)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const d=Object.assign({},this.contexts[this.contexts.length-1]);d.iterationId+=1,d.id=this.lastId,this.contexts.splice(-1,1,d),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(d){return this.weightMap[d]}addTensorArray(d){this.tensorArrayMap[d.id]=d}getTensorArray(d){return this.tensorArrayMap[d]}addTensorList(d){this.tensorListMap[d.id]=d}getTensorList(d){return this.tensorListMap[d]}dispose(d){for(const p in this.tensorArrayMap)this.tensorArrayMap[p].clearAndClose(d);for(const p in this.tensorListMap)this.tensorListMap[p].clearAndClose(d)}}function py(m,d,p,_){const E=new Set,S=[];let I=null,D=null;const k=new Set,V=new Set(Object.keys(m).map(te=>ko(te)[0]));_=_||[];const $=new Set(_.map(te=>ko(te.name)[0])),Z=[...d];for(;Z.length>0;){const te=Z.pop();if((ph(te)||pY(te)||pm(te))&&I==null&&(I=te,D=I.children.map(xe=>xe.name).filter(xe=>E.has(xe))),E.add(te.name),p[te.name]==null&&!V.has(te.name)&&!$.has(te.name)){if(te.inputs.length===0){S.push(te.name);continue}te.inputs.forEach(xe=>{k.has(xe.name)||(k.add(xe.name),Z.push(xe))})}}return{inputs:m,outputs:d,usedNodes:E,missingInputs:S,dynamicNode:I,syncInputs:D}}function pE(m,d){const{usedNodes:p,inputs:_}=d,E=Object.keys(_).map(de=>ko(de)[0]).map(de=>m.nodes[de]),S=m.initNodes||[],I=de=>p.has(typeof de=="string"?de:de.name);function D(de){return[...new Map(de.map(me=>[me.name,me])).values()]}const k=D([...E,...m.weights,...S]).filter(I),V=D([...k,...Object.values(m.nodes)]).filter(I),$=new Map(V.map(de=>[de.name,de])),Z={};for(const de of V){Z[de.name]=Z[de.name]||0;for(const me of de.children)I(me)||(Z[me.name]=Number.POSITIVE_INFINITY),Z[me.name]=(Z[me.name]||0)+1}const te=Object.entries(Z).filter(([,de])=>de===0).map(([de])=>de),xe=[...te];for(;te.length>0;){const de=te.pop(),me=$.get(de);for(const ge of me.children.filter(I))--Z[ge.name]===0&&(xe.push(ge.name),te.push(ge.name))}const le=xe.map(de=>$.get(de)),he=pW(le,k);return pM(he,k),he}function pW(m,d){const p=new Map(m.map(S=>[S.name,S])),_=d.map(S=>S.name),E=new Set(_);for(;_.length>0;){const S=_.pop(),I=p.get(S);for(const D of I.children)!p.has(D.name)||E.has(D.name)||(E.add(D.name),_.push(D.name))}return m.filter(S=>E.has(S.name))}class pd extends Error{constructor(d){super("NodesExecutionOrderError: "+d)}}function pM(m,d){const p=new Map(m.map((D,k)=>[D.name,k])),_=new Set(d.map(D=>D.name)),E=D=>_.has(typeof D=="string"?D:D.name),S=new Set(m.map(D=>D.name)),I=D=>S.has(typeof D=="string"?D:D.name);for(const D of m){for(const k of D.children.filter(I)){if(!p.has(k.name))throw new pd("Child "+k.name+" of node "+D.name+" is unreachable.");if(p.get(D.name)>p.get(k.name))throw new pd("Node "+D.name+" is scheduled to run after its child "+k.name+".")}if(!E(D))for(const k of D.inputs){if(!p.has(k.name))throw new pd("Input "+k.name+" of node "+D.name+" is unreachable.");if(p.get(k.name)>p.get(D.name))throw new pd("Node "+D.name+" is scheduled to run before its input "+k.name+".")}}}function pU(m){const d=new Map(m.map((D,k)=>[D.name,k])),p=Number.MAX_SAFE_INTEGER,_=m.map((D,k)=>ph(D)?p:k),E=D=>{const k=_[d.get(D.name)];return k??-1},S=m.map((D,k)=>D.children.map(E).reduce((V,$)=>Math.max(V,$),_[k])),I=new Map;for(let D=0;D<m.length;++D){const k=S[D];if(k===p)continue;const V=m[D],$=m[k];I.has($.name)||I.set($.name,[]),I.get($.name).push(V)}return I}const pJ=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),pt=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),pv=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function ph(m){return pJ.has(m.op)}function pY(m){return pt.has(m.op)}function pm(m){return pv.has(m.op)}class px{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(d){const p=Object.keys(d).map(_=>d[_].map(E=>E.id));this._weightIds=[].concat(...p),this._weightMap=d}set resourceManager(d){this._resourceManager=d}get inputs(){return this._inputs.map(d=>({name:d.name,shape:d.attrParams.shape?d.attrParams.shape.value:void 0,dtype:d.attrParams.dtype?d.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(d=>({name:d.name,shape:d.attrParams.shape?d.attrParams.shape.value:void 0,dtype:d.attrParams.dtype?d.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(d=>d.signatureKey||d.name)}get outputNodes(){return this._outputs.map(d=>{const p=d.signatureKey||d.name;return d.defaultOutput?p+":"+d.defaultOutput:p})}get functions(){return Object.keys(this._functions).reduce((d,p)=>(d[p]=this._functions[p].signature,d),{})}constructor(d,p){this.graph=d,this.parent=p,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=d.outputs,this._inputs=d.inputs,this._initNodes=d.initNodes,this._signature=d.signature,this._functions=d.functions,d.functions!=null&&Object.keys(d.functions).forEach(_=>{this._functionExecutorMap[_]=new px(d.functions[_],this)})}getCompilationKey(d,p){const _=d.map(S=>S.name).sort(),E=p.map(S=>S.name).sort();return _.join(this.SEPARATOR)+"--"+E.join(this.SEPARATOR)}compile(d,p){const _=py(d,p,this.weightMap,this._initNodes),{missingInputs:E,dynamicNode:S,syncInputs:I}=_;if(S!=null)throw new Error("This execution contains the node '"+S.name+"', which has the dynamic op '"+S.op+"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs ["+I+"]");if(E.length>0){const V=p.map(Z=>Z.name),$=Object.keys(d);throw new Error("Cannot compute the outputs ["+V+"] from the provided inputs ["+$+"]. Missing the following inputs: ["+E+"]")}const D=pE(this.graph,_),k=pU(D);return{orderedNodes:D,nodeLiveUntilMap:k}}cloneAndKeepTensor(d){if(d==null)return null;const p=d.clone();return z0(p),p}cloneTensorList(d){return d?d.map(p=>this.cloneAndKeepTensor(p)):null}cloneTensorMap(d){return Object.fromEntries(Object.entries(d).map(([p,_])=>[p,this.cloneTensorList(_)]))}execute(d,p){this.disposeIntermediateTensors(),d=this.mapInputs(d);const _=Object.keys(d).sort();this.checkInputs(d),this.checkInputShapeAndType(d),p=this.mapOutputs(p),this.checkOutputs(p);const E=_.map(te=>this.graph.nodes[ko(te)[0]]),S=p.map(te=>ko(te)[0]),I=new Set(S);let D=S.map(te=>this.graph.nodes[te]);D.length===0&&(D=this._outputs);const k=this.getCompilationKey(E,D);let V=this.compiledMap.get(k);V==null&&(V=this.compile(d,D),this.compiledMap.set(k,V));try{this.keepIntermediateTensors=oQ().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(te){this.keepIntermediateTensors=!1,console.warn(te.message)}const $={},Z={};return sV(()=>{const te=new pf(this.weightMap,$,Z,this.functionExecutorMap,this.parseNodeNameCache),xe=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(d).forEach(me=>{const[ge,be]=ko(me,te),ye=[];ye[be]=d[me],xe[ge]=ye,this.keepIntermediateTensors&&(this.clonedTensorsMap[ge]=this.cloneTensorList(ye))});const le=this.getFrozenTensorIds(xe),{orderedNodes:he,nodeLiveUntilMap:de}=V;for(const me of he){if(xe[me.name])continue;const ge=pX(me,xe,te,this._resourceManager);if(oC(ge))throw new Error("The execution of the op '"+me.op+"' returned a promise. Please use model.executeAsync() instead.");xe[me.name]=ge,this.keepIntermediateTensors&&(this.clonedTensorsMap[me.name]=this.cloneTensorList(ge)),this.checkTensorForDisposalWithNodeLiveUntilInfo(me,xe,te,le,I,de.get(me.name))}return this.parent==null&&te.dispose(le),p.map(me=>k6(me,xe,te))})}getFrozenTensorIds(d){const p=[].concat.apply([],Object.keys(d).map(_=>d[_]).map(_=>_.map(E=>E.id)));return new Set(p)}checkTensorForDisposal(d,p,_,E,S,I,D){if(!(ph(p)||I.has(d))){for(const k of _[d])k!=null&&(D[k.id]=(D[k.id]||0)+p.children.length);for(const k of p.inputs){if(ph(k))continue;const V=k7(k.name,_,E);if(V!=null)for(const $ of V){if(!$||$.kept||S.has($.id))continue;const Z=D[$.id];Z===1?($.dispose(),delete D[$.id]):Z!=null&&D[$.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(d,p,_,E,S,I){function D(k){return ph(k)||S.has(k.name)}if(!(ph(d)||I==null))for(const k of I){if(D(k))continue;const V=k7(k.name,p,_);for(const $ of V)!$||$.kept||E.has($.id)||$.dispose()}}async executeAsync(d,p){return this._executeAsync(d,p)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(d=>{for(const p of d)p&&!p.isDisposed&&p.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(d,p,_=!1,E={},S={}){this.disposeIntermediateTensors(),_||(d=this.mapInputs(d),this.checkInputs(d),this.checkInputShapeAndType(d),p=this.mapOutputs(p),this.checkOutputs(p));try{this.keepIntermediateTensors=oQ().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(te){this.keepIntermediateTensors=!1,console.warn(te.message)}const I=new pf(this.weightMap,E,S,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const D=await this.executeWithControlFlow(d,I,p,_),k=p.map(te=>k6(te,D,I)),V=k.map(te=>te.id),$=Object.keys(d).map(te=>d[te].id),Z=new Set([...V,...$,...this.weightIds]);return Object.values(D).forEach(te=>{te.forEach(xe=>{xe&&!xe.isDisposed&&!Z.has(xe.id)&&xe.dispose()})}),this.parent==null&&I.dispose(Z),k}async executeFunctionAsync(d,p,_){const E=d.reduce((S,I,D)=>(S[this.inputs[D].name]=I,S),{});return this._executeAsync(E,this.outputNodes,!0,p,_)}async executeWithControlFlow(d,p,_,E){const S=Object.keys(d),I=S.map(ye=>this.graph.nodes[ko(ye)[0]]),D=_.map(ye=>ko(ye)[0]),k=new Set(D);let V=D.map(ye=>this.graph.nodes[ye]);V.length===0&&(V=this._outputs);const{usedNodes:$,missingInputs:Z,dynamicNode:te,syncInputs:xe}=py(d,V,this.weightMap,this._initNodes),le=[...I,...this.graph.weights,...this._initNodes||[]].map(ye=>({node:ye,contexts:p.currentContext})),he=Object.assign({},this.weightMap);Object.keys(d).forEach(ye=>{const[ve,Ie]=ko(ye),je=[];je[Ie]=d[ye],he[ve]=je});const de={},me=this.getFrozenTensorIds(he),ge={};for(;le.length>0;){const ye=this.processStack(I,le,p,he,ge,me,k,de,$);await Promise.all(ye)}te==null&&!E&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const be=V.filter(ye=>!ph(ye)&&!k6(ye.name,he,p)).map(ye=>ye.name);if(be.length>0){let ye="";throw te!=null&&(ye="Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs ["+xe+"]"),new Error("Cannot compute the outputs ["+be+"] from the provided inputs ["+S+"]. Consider providing the following inputs: ["+Z+"]. "+ye)}return he}processStack(d,p,_,E,S,I,D,k,V){const $=[];for(;p.length>0;){const Z=p.pop();_.currentContext=Z.contexts;let te="";if(Z.node.op==="Enter"&&k5("isConstant",Z.node,E,_)&&([te]=k8(Z.node.name,_)),E[Z.node.name]==null){const xe=pX(Z.node,E,_,this._resourceManager);te||([te]=k8(Z.node.name,_));const le=_.currentContext;oC(xe)?$.push(xe.then(he=>(E[te]=he,this.keepIntermediateTensors&&(this.clonedTensorsMap[te]=this.cloneTensorList(he)),_.currentContext=le,this.checkTensorForDisposal(te,Z.node,E,_,I,D,k),this.processChildNodes(Z.node,p,_,E,S,V),he))):(E[te]=xe,this.keepIntermediateTensors&&(this.clonedTensorsMap[te]=this.cloneTensorList(xe)),this.checkTensorForDisposal(te,Z.node,E,_,I,D,k),this.processChildNodes(Z.node,p,_,E,S,V))}else this.processChildNodes(Z.node,p,_,E,S,V)}return $}processChildNodes(d,p,_,E,S,I){d.children.forEach(D=>{const[k]=k8(D.name,_);S[k]||!I.has(D.name)||(D.op==="Merge"?D.inputNames.some(V=>!!k6(V,E,_))&&(S[k]=!0,p.push({contexts:_.currentContext,node:D})):D.inputNames.every(V=>!!k6(V,E,_))&&(S[k]=!0,p.push({contexts:_.currentContext,node:D})))})}dispose(){Object.keys(this.weightMap).forEach(d=>this.weightMap[d].forEach(p=>p.dispose()))}checkInputShapeAndType(d){Object.keys(d).forEach(p=>{const _=d[p],[E]=ko(p),S=this.graph.nodes[E];if(S.attrParams.shape&&S.attrParams.shape.value){const I=S.attrParams.shape.value,D=I.length===_.shape.length&&_.shape.every((k,V)=>I[V]===-1||I[V]===k);A(D,()=>"The shape of dict['"+S.name+"'] provided in model.execute(dict) must be ["+I+"], but was ["+_.shape+"]")}S.attrParams.dtype&&S.attrParams.dtype.value&&A(_.dtype===S.attrParams.dtype.value,()=>"The dtype of dict['"+S.name+"'] provided in model.execute(dict) must be "+S.attrParams.dtype.value+", but was "+_.dtype)})}mapInputs(d){var p,_;const E={};for(const S in d){const I=(_=(p=this._signature)===null||p===void 0?void 0:p.inputs)===null||_===void 0?void 0:_[S];I!=null?E[I.name]=d[S]:E[S]=d[S]}return E}checkInputs(d){const p=Object.keys(d).filter(_=>{const[E]=ko(_);return this.graph.nodes[E]==null});if(p.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+p+"] that are not part of graph")}mapOutputs(d){return d.map(p=>{var _,E;const S=(E=(_=this._signature)===null||_===void 0?void 0:_.outputs)===null||E===void 0?void 0:E[p];return S!=null?S.name:p},{})}checkOutputs(d){d.forEach(p=>{const[_]=ko(p);if(!this.graph.nodes[_])throw new Error("The output '"+p+"' is not found in the graph")})}}class pl{constructor(d={},p={}){this.hashTableNameToHandle=d,this.hashTableMap=p}addHashTable(d,p){this.hashTableNameToHandle[d]=p.handle,this.hashTableMap[p.id]=p}getHashTableHandleByName(d){return this.hashTableNameToHandle[d]}getHashTableById(d){return this.hashTableMap[d]}dispose(){for(const d in this.hashTableMap)this.hashTableMap[d].clearAndClose(),delete this.hashTableMap[d];for(const d in this.hashTableNameToHandle)this.hashTableNameToHandle[d].dispose(),delete this.hashTableNameToHandle[d]}}const pb="?tfjs-format=file",pa="model.json";class pV{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(d,p={},_=CS){this.modelUrl=d,this.loadOptions=p,this.version="n/a",this.io=_,p==null&&(this.loadOptions={}),this.resourceManager=new pl}findIOHandler(){const d=this.modelUrl;if(d.load!=null)this.handler=d;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(d,this.loadOptions);else{const p=this.io.getLoadHandlers(d,this.loadOptions);if(p.length===0)p.push(this.io.browserHTTPRequest(d,this.loadOptions));else if(p.length>1)throw new Error("Found more than one ("+p.length+") load handlers for URL '"+[d]+"'");this.handler=p[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const d=this.handler.load();return oC(d)?d.then(p=>p.getWeightStream==null?this.loadSync(p):this.loadStreaming(p)):this.loadSync(d)}loadSync(d){const p=this.io.decodeWeights(d.weightData,d.weightSpecs);return this.loadWithWeightMap(d,p)}async loadStreaming(d){if(d.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const p=await zG(d.getWeightStream(),d.weightSpecs);return this.loadWithWeightMap(d,p)}loadWithWeightMap(d,p){this.artifacts=d;const _=this.artifacts.modelTopology;let E=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const S=this.artifacts.userDefinedMetadata;S.signature!=null&&(E=S.signature),S.structuredOutputKeys!=null&&(this.structuredOutputKeys=S.structuredOutputKeys)}if(this.signature=E,this.version=_.versions.producer+"."+_.versions.minConsumer,this.executor=new px(kt.Instance.transformGraph(_,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(p),this.executor.resourceManager=this.resourceManager,d.modelInitializer!=null&&d.modelInitializer.node!=null){const S=kt.Instance.transformGraph(d.modelInitializer);this.initializer=new px(S),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=d.initializerSignature}return!0}async save(d,p){if(typeof d=="string"){const _=this.io.getSaveHandlers(d);if(_.length===0)throw new Error("Cannot find any save handlers for URL '"+d+"'");if(_.length>1)throw new Error("Found more than one ("+_.length+") save handlers for URL '"+d+"'");d=_[0]}if(d.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return d.save(this.artifacts)}addStructuredOutputNames(d){if(this.structuredOutputKeys){const p=d instanceof sC?[d]:d,_={};return p.forEach((E,S)=>_[this.structuredOutputKeys[S]]=E),_}return d}predict(d,p){const _=this.execute(d,this.outputNodes);return this.addStructuredOutputNames(_)}async predictAsync(d,p){const _=await this.executeAsync(d,this.outputNodes);return this.addStructuredOutputNames(_)}normalizeInputs(d){var p;if(!(d instanceof sC)&&!Array.isArray(d)){const S=(p=this.signature)===null||p===void 0?void 0:p.inputs;if(S!=null)for(const I in S){const D=S[I];D.resourceId!=null&&(d[I]=this.resourceIdToCapturedInput[D.resourceId])}return d}d=Array.isArray(d)?d:[d];const _=Object.keys(this.resourceIdToCapturedInput).length;if(d.length+_!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has "+(this.inputNodes.length-_)+" non-resource placeholders, while there are "+d.length+" input tensors provided.");let E=0;return this.inputNodes.reduce((S,I)=>{var D,k,V;const $=(V=(k=(D=this.signature)===null||D===void 0?void 0:D.inputs)===null||k===void 0?void 0:k[I])===null||V===void 0?void 0:V.resourceId;return $!=null?S[I]=this.resourceIdToCapturedInput[$]:S[I]=d[E++],S},{})}normalizeOutputs(d){return d=d||this.outputNodes,Array.isArray(d)?d:[d]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(d){if(this.resourceIdToCapturedInput={},this.initializerSignature){const p=this.initializerSignature.outputs,_=Object.keys(p);for(let E=0;E<_.length;E++){const S=_[E],I=p[S];this.resourceIdToCapturedInput[I.resourceId]=d[E]}}}execute(d,p){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),d=this.normalizeInputs(d),p=this.normalizeOutputs(p);const _=this.executor.execute(d,p);return _.length>1?_:_[0]}async executeAsync(d,p){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),d=this.normalizeInputs(d),p=this.normalizeOutputs(p);const _=await this.executor.executeAsync(d,p);return _.length>1?_:_[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(d){return Object.keys(d).reduce((p,_)=>(p[_]=[d[_]],p),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&sg(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function pg(m,d={},p=CS){if(m==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");d==null&&(d={}),d.fromTFHub&&typeof m=="string"&&(m=w0(m));const _=new pV(m,d,p);return await _.load(),_}function w0(m){return m.endsWith("/")||(m=m+"/"),""+m+pa+pb}const w1={},w2={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function w3(m,d){w1[m]=d}function w4(m,d){if(!(m in w1)||d!=null){const _=w6(m,d);if(_!==null)w1[m]=_;else return console.log("Could not get context for WebGL version",m),null}const p=w1[m];return p==null||p.isContextLost()?(delete w1[m],w4(m)):(p.disable(p.DEPTH_TEST),p.disable(p.STENCIL_TEST),p.disable(p.BLEND),p.disable(p.DITHER),p.disable(p.POLYGON_OFFSET_FILL),p.disable(p.SAMPLE_COVERAGE),p.enable(p.SCISSOR_TEST),p.enable(p.CULL_FACE),p.cullFace(p.BACK),w1[m])}function w5(m){if(!oQ().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&m===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function w6(m,d){if(m!==1&&m!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const p=d??w5(m);return p.addEventListener("webglcontextlost",_=>{_.preventDefault(),delete w1[m]},!1),oQ().getBool("SOFTWARE_WEBGL_ENABLED")&&(w2.failIfMajorPerformanceCaveat=!1),m===1?p.getContext("webgl",w2)||p.getContext("experimental-webgl",w2):p.getContext("webgl2",w2)}var w7;(function(m){m[m.DENSE=0]="DENSE",m[m.SHARED_BATCH=1]="SHARED_BATCH"})(w7||(w7={}));var w8;(function(m){m[m.RENDER=0]="RENDER",m[m.UPLOAD=1]="UPLOAD",m[m.PIXELS=2]="PIXELS",m[m.DOWNLOAD=3]="DOWNLOAD"})(w8||(w8={}));var w9;(function(m){m[m.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",m[m.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",m[m.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",m[m.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",m[m.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(w9||(w9={}));function wo(m,d){return[d,m]}function wc(m,d){return m*d}function wG(m){const d=n(m),p=Math.ceil(d/4);return P(p)}function ws(m,d){return[Math.max(1,Math.ceil(d/2)),Math.max(1,Math.ceil(m/2))]}function wz(m,d){const[p,_]=ws(m,d);return p*_*4}function wC(m,d){const p=m;let _,E,S,I,D,k,V,$,Z,te;return oQ().getNumber("WEBGL_VERSION")===2?(_=p.R32F,E=p.R16F,S=p.RGBA16F,I=p.RGBA32F,D=p.RED,V=4,$=1,Z=p.HALF_FLOAT,te=p.FLOAT,k=p.RGBA8):(_=m.RGBA,E=m.RGBA,S=m.RGBA,I=p.RGBA,D=m.RGBA,V=4,$=4,Z=d!=null?d.HALF_FLOAT_OES:null,te=m.FLOAT,k=m.RGBA),{internalFormatFloat:_,internalFormatHalfFloat:E,internalFormatPackedHalfFloat:S,internalFormatPackedFloat:I,textureFormatFloat:D,downloadTextureFormat:k,downloadUnpackNumChannels:V,defaultNumChannels:$,textureTypeHalfFloat:Z,textureTypeFloat:te}}function wL(m,d){const p=d();return oQ().getBool("DEBUG")&&wK(m),p}function wK(m){const d=m.getError();if(d!==m.NO_ERROR)throw new Error("WebGL Error: "+wQ(m,d))}const wr=596e-10,wT=65504;function wq(m){return!!(oQ().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||m===0||wr<Math.abs(m)&&Math.abs(m)<wT)}function wQ(m,d){switch(d){case m.NO_ERROR:return"NO_ERROR";case m.INVALID_ENUM:return"INVALID_ENUM";case m.INVALID_VALUE:return"INVALID_VALUE";case m.INVALID_OPERATION:return"INVALID_OPERATION";case m.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case m.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case m.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+d}}function wk(m,d){return wy(m,()=>m.getExtension(d),'Extension "'+d+'" not supported on this browser.')}function wp(m,d){const p=wy(m,()=>m.createShader(m.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(wL(m,()=>m.shaderSource(p,d)),wL(m,()=>m.compileShader(p)),m.getShaderParameter(p,m.COMPILE_STATUS)===!1)throw console.log(m.getShaderInfoLog(p)),new Error("Failed to compile vertex shader.");return p}function ww(m,d){const p=wy(m,()=>m.createShader(m.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(wL(m,()=>m.shaderSource(p,d)),wL(m,()=>m.compileShader(p)),oQ().get("ENGINE_COMPILE_ONLY"))return p;if(m.getShaderParameter(p,m.COMPILE_STATUS)===!1)throw wZ(d,m.getShaderInfoLog(p)),new Error("Failed to compile fragment shader.");return p}const wA=/ERROR: [0-9]+:([0-9]+):/g;function wZ(m,d){const p=wA.exec(d);if(p==null){console.log("Couldn't parse line number in error: "+d),console.log(m);return}const _=+p[1],E=m.split(`
`),S=E.length.toString().length+2,I=E.map((Z,te)=>j((te+1).toString(),S)+Z);let D=0;for(let Z=0;Z<I.length;Z++)D=Math.max(I[Z].length,D);const k=I.slice(0,_-1),V=I.slice(_-1,_),$=I.slice(_);console.log(k.join(`
`)),console.log(d.split(`
`)[0]),console.log("%c "+j(V[0],D),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log($.join(`
`))}function wF(m){return wy(m,()=>m.createProgram(),"Unable to create WebGLProgram.")}function wN(m,d){if(wL(m,()=>m.linkProgram(d)),!oQ().get("ENGINE_COMPILE_ONLY")&&m.getProgramParameter(d,m.LINK_STATUS)===!1)throw console.log(m.getProgramInfoLog(d)),new Error("Failed to link vertex and fragment shaders.")}function wO(m,d){if(wL(m,()=>m.validateProgram(d)),m.getProgramParameter(d,m.VALIDATE_STATUS)===!1)throw console.log(m.getProgramInfoLog(d)),new Error("Shader program validation failed.")}function wD(m,d){const p=wy(m,()=>m.createBuffer(),"Unable to create WebGLBuffer");return wL(m,()=>m.bindBuffer(m.ARRAY_BUFFER,p)),wL(m,()=>m.bufferData(m.ARRAY_BUFFER,d,m.STATIC_DRAW)),p}function wn(m,d){const p=wy(m,()=>m.createBuffer(),"Unable to create WebGLBuffer");return wL(m,()=>m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,p)),wL(m,()=>m.bufferData(m.ELEMENT_ARRAY_BUFFER,d,m.STATIC_DRAW)),p}function wi(m){return wy(m,()=>m.createTexture(),"Unable to create WebGLTexture.")}function we(m,d){const p=oQ().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(m<=0||d<=0){const _="["+m+"x"+d+"]";throw new Error("Requested texture size "+_+" is invalid.")}if(m>p||d>p){const _="["+m+"x"+d+"]",E="["+p+"x"+p+"]";throw new Error("Requested texture size "+_+" greater than WebGL maximum on this browser / GPU "+E+".")}}function wP(m){return wy(m,()=>m.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function wS(m,d,p,_,E,S,I){const D=m.getAttribLocation(d,p);return D===-1?!1:(wL(m,()=>m.bindBuffer(m.ARRAY_BUFFER,_)),wL(m,()=>m.vertexAttribPointer(D,E,m.FLOAT,!1,S,I)),wL(m,()=>m.enableVertexAttribArray(D)),!0)}function wI(m,d,p){wE(m,p),wL(m,()=>m.activeTexture(m.TEXTURE0+p)),wL(m,()=>m.bindTexture(m.TEXTURE_2D,d))}function wB(m,d,p){return wy(m,()=>m.getUniformLocation(d,p),'uniform "'+p+'" not present in program.')}function wj(m,d,p){return m.getUniformLocation(d,p)}function wR(m,d,p,_){wL(m,()=>wI(m,d,_)),wL(m,()=>m.uniform1i(p,_))}function wH(m,d,p){wL(m,()=>m.bindFramebuffer(m.FRAMEBUFFER,p)),wL(m,()=>m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,d,0))}function wu(m,d){wL(m,()=>m.bindFramebuffer(m.FRAMEBUFFER,d)),wL(m,()=>m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,null,0))}function wX(m){const d=m.checkFramebufferStatus(m.FRAMEBUFFER);if(d!==m.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+wf(m,d))}function wf(m,d){switch(d){case m.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case m.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case m.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case m.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+d}}function wy(m,d,p){const _=wL(m,()=>d());if(_==null)throw new Error(p);return _}function wE(m,d){const p=m.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,_=d+m.TEXTURE0;if(_<m.TEXTURE0||_>p){const E="[gl.TEXTURE0, gl.TEXTURE"+p+"]";throw new Error("textureUnit must be in "+E+".")}}function wW(m,d=2){return n(m.slice(0,m.length-d))}function wd(m){if(m.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[m.length>1?m[m.length-2]:1,m[m.length-1]]}function wM(m){let d=[1,1,1];return m.length===0||m.length===1&&m[0]===1||(d=[wW(m),...wd(m)]),d}function wU(m,d=!1){let p=oQ().getNumber("WEBGL_MAX_TEXTURE_SIZE"),_=oQ().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");_===1/0&&oQ().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(_=p/2),d&&(p=p*2,_=_*2,m=m.map((D,k)=>k>=m.length-2?T(m[k]):m[k]),m.length===1&&(m=[2,m[0]])),m.length!==2&&(m=f(m).newShape);let E=n(m),S=null;m.length<=1&&E<=p?S=[1,E]:m.length===2&&m[0]<=p&&m[1]<=p?S=m:m.length===3&&m[0]*m[1]<=p&&m[2]<=p?S=[m[0]*m[1],m[2]]:m.length===3&&m[0]<=p&&m[1]*m[2]<=p?S=[m[0],m[1]*m[2]]:m.length===4&&m[0]*m[1]*m[2]<=p&&m[3]<=p?S=[m[0]*m[1]*m[2],m[3]]:m.length===4&&m[0]<=p&&m[1]*m[2]*m[3]<=p&&(S=[m[0],m[1]*m[2]*m[3]]);const I=S!=null&&Math.max(...S)>_&&Math.min(...S)<=(d?2:1)&&Math.min(...S)>0;if(S==null||I)if(d){const D=wW(m);let k=2,V=2;m.length&&([k,V]=wd(m)),E=D*(k/2)*(V/2),S=P(E).map($=>$*2)}else S=P(E);return S}function wJ(m){return m%2===0}function wt(m,d){if(m=m.slice(-2),d=d.slice(-2),i(m,d)||!m.length||!d.length||m[0]===0||m[1]===0||d[0]===0||d[1]===0)return!0;if(m.length!==d.length){const p=m[m.length-1],_=d[d.length-1];if(p===_||wJ(p)&&wJ(_)&&(m[0]===1||d[0]===1))return!0}return m[1]===d[1]&&wJ(m[0])&&wJ(d[0])}let wv,wh;function wY(m){if(wv==null){const d=w4(m);wv=d.getParameter(d.MAX_TEXTURE_SIZE)}return wv}function wm(m){if(wh==null){const d=w4(m);wh=d.getParameter(d.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,wh)}function wx(m){if(m===0)return 0;let d;const p=w4(m);return wl(p,"EXT_disjoint_timer_query_webgl2")&&m===2?d=2:wl(p,"EXT_disjoint_timer_query")?d=1:d=0,d}function wl(m,d){return m.getExtension(d)!=null}function wb(m){try{if(w4(m)!=null)return!0}catch(d){return console.log("Error when getting WebGL context: ",d),!1}return!1}function wa(m){if(m===0)return!1;const d=w4(m);if(m===1){if(!wl(d,"OES_texture_float"))return!1}else if(!wl(d,"EXT_color_buffer_float"))return!1;return wg(d)}function wV(m){if(m===0)return!1;const d=w4(m);if(m===1){if(!wl(d,"OES_texture_float")||!wl(d,"WEBGL_color_buffer_float"))return!1}else{if(wl(d,"EXT_color_buffer_float"))return wg(d);const p="EXT_color_buffer_half_float";if(wl(d,p)){const _=d.getExtension(p);return A0(d,_)}return!1}return wg(d)}function wg(m){const d=wC(m),p=m.createTexture();m.bindTexture(m.TEXTURE_2D,p),m.texImage2D(m.TEXTURE_2D,0,d.internalFormatFloat,1,1,0,d.textureFormatFloat,d.textureTypeFloat,null);const S=m.createFramebuffer();m.bindFramebuffer(m.FRAMEBUFFER,S),m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,p,0);const I=m.checkFramebufferStatus(m.FRAMEBUFFER)===m.FRAMEBUFFER_COMPLETE;return m.bindTexture(m.TEXTURE_2D,null),m.bindFramebuffer(m.FRAMEBUFFER,null),m.deleteTexture(p),m.deleteFramebuffer(S),I}function A0(m,d){const p=wC(m,d),_=m.createTexture();m.bindTexture(m.TEXTURE_2D,_),m.texImage2D(m.TEXTURE_2D,0,p.internalFormatHalfFloat,1,1,0,p.textureFormatFloat,p.textureTypeHalfFloat,null);const I=m.createFramebuffer();m.bindFramebuffer(m.FRAMEBUFFER,I),m.framebufferTexture2D(m.FRAMEBUFFER,m.COLOR_ATTACHMENT0,m.TEXTURE_2D,_,0);const D=m.checkFramebufferStatus(m.FRAMEBUFFER)===m.FRAMEBUFFER_COMPLETE;return m.bindTexture(m.TEXTURE_2D,null),m.bindFramebuffer(m.FRAMEBUFFER,null),m.deleteTexture(_),m.deleteFramebuffer(I),D}function A1(m){return m!==2?!1:w4(m).fenceSync!=null}function A2(m,d){Array.isArray(m)||(m=[m]),m.forEach(p=>{p!=null&&A(p.dtype!=="complex64",()=>d+" does not support complex64 tensors in the WebGL backend.")})}const A3=oQ();A3.registerFlag("HAS_WEBGL",()=>A3.getNumber("WEBGL_VERSION")>0),A3.registerFlag("WEBGL_VERSION",()=>wb(2)?2:wb(1)?1:0),A3.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),A3.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>A3.get("WEBGL_VERSION")===2),A3.registerFlag("WEBGL_CPU_FORWARD",()=>!0),A3.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),A3.registerFlag("WEBGL_PACK",()=>A3.getBool("HAS_WEBGL")),A3.registerFlag("WEBGL_PACK_NORMALIZATION",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_PACK_CLIP",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_PACK_REDUCE",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_LAZILY_UNPACK",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_CONV_IM2COL",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>A3.getBool("WEBGL_PACK")),A3.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>wY(A3.getNumber("WEBGL_VERSION"))),A3.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>wm(A3.getNumber("WEBGL_VERSION"))),A3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const m=A3.getNumber("WEBGL_VERSION");return m===0?0:wx(m)}),A3.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>A3.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!su()),A3.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>wa(A3.getNumber("WEBGL_VERSION"))),A3.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>A3.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:A3.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),A3.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>wV(A3.getNumber("WEBGL_VERSION"))),A3.registerFlag("WEBGL_FENCE_API_ENABLED",()=>A1(A3.getNumber("WEBGL_VERSION"))),A3.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>A3.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),A3.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,m=>{if(typeof m!="number")throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got "+m+".");if(m<0&&m!==-1)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got "+m+".")}),A3.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>su()?1:-1,m=>{if(typeof m!="number")throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+m+".");if(m<0&&m!==-1)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got "+m+".")}),A3.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),A3.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),A3.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),A3.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),A3.registerFlag("WEBGL_EXP_CONV",()=>!1),A3.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>A3.getBool("IS_TEST")),A3.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),A3.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),A3.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),A3.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function A4(){let m,d,p,_,E,S,I,D,k,V;return oQ().getNumber("WEBGL_VERSION")===2?(m="#version 300 es",d="in",p="out",_="in",E="texture",S="outputColor",I="out vec4 outputColor;",D=oQ().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",k="",V=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(m="",d="attribute",p="varying",_="varying",E="texture2D",S="gl_FragColor",I="",D=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,k=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,V=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:m,attribute:d,varyingVs:p,varyingFs:_,texture2D:E,output:S,defineOutput:I,defineSpecialNaN:D,defineSpecialInf:k,defineRound:V}}function A5(m,d,p="index"){const _=o6(d);return _.map((E,S)=>{const I="int "+m[S]+" = "+p+" / "+E,D=S===_.length-1?"int "+m[S+1]+" = "+p+" - "+m[S]+" * "+E:"index -= "+m[S]+" * "+E;return I+"; "+D+";"}).join("")}function A6(m,d,p="index"){const _=o6(d);return _.map((E,S)=>{const I="int "+m[S]+" = "+p+" / outShapeStrides["+S+"]",D=S===_.length-1?"int "+m[S+1]+" = "+p+" - "+m[S]+" * outShapeStrides["+S+"]":"index -= "+m[S]+" * outShapeStrides["+S+"]";return I+"; "+D+";"}).join("")}function A7(m,d){const p=m.length,_=m.map(S=>d+"["+S+"]"),E=new Array(p-1);E[p-2]=_[p-1];for(let S=p-3;S>=0;--S)E[S]="("+E[S+1]+" * "+_[S+1]+")";return E}function A8(m,d,p="index"){const _=m.map((S,I)=>I),E=A7(_,d);return E.map((S,I)=>{const D="int "+m[I]+" = "+p+" / "+E[I],k=I===E.length-1?"int "+m[I+1]+" = "+p+" - "+m[I]+" * "+E[I]:"index -= "+m[I]+" * "+E[I];return D+"; "+k+";"}).join("")}function A9(m){const d=o6(m).map(p=>p.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * `+d[0]+" + coords.y * "+d[1]+` + coords.z;
  }
`}function Ao(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const Ac=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:AG}=QD;function As(m,d,p){const _=[];if(m.forEach(te=>{const xe=n(te.shapeInfo.logicalShape);if(te.shapeInfo.isUniform?_.push("uniform float "+te.name+(xe>1?"["+xe+"]":"")+";"):(_.push("uniform sampler2D "+te.name+";"),_.push("uniform int offset"+te.name+";")),p.enableShapeUniforms){const{uniformShape:le}=Am(p.packedInputs,te.shapeInfo.logicalShape,te.shapeInfo.texShape);switch(le.length){case 1:_.push("uniform int "+te.name+"Shape;");break;case 2:_.push("uniform ivec2 "+te.name+"Shape;");break;case 3:_.push("uniform ivec3 "+te.name+"Shape;");break;case 4:_.push("uniform ivec4 "+te.name+"Shape;");break}_.push("uniform ivec2 "+te.name+"TexShape;")}}),p.enableShapeUniforms){switch(d.logicalShape.length){case 1:_.push("uniform int outShape;");break;case 2:_.push("uniform ivec2 outShape;"),_.push("uniform int outShapeStrides;");break;case 3:_.push("uniform ivec3 outShape;"),_.push("uniform ivec2 outShapeStrides;");break;case 4:_.push("uniform ivec4 outShape;"),_.push("uniform ivec3 outShapeStrides;");break}_.push("uniform ivec2 outTexShape;")}p.customUniforms&&p.customUniforms.forEach(te=>{_.push("uniform "+te.type+" "+te.name+(te.arrayIndex?"["+te.arrayIndex+"]":"")+";")});const E=_.join(`
`),S=m.map(te=>AL(te,d,p.packedInputs,p.enableShapeUniforms)).join(`
`),I=d.texShape,D=A4(),k=AT(D);let V,$,Z=Ak(D);return d.isPacked?(V=AK(d.logicalShape,I,p.enableShapeUniforms),$=AQ(D)):(V=Ar(d.logicalShape,I,p.enableShapeUniforms),$=Aq(D)),p.packedInputs&&(Z+=AZ),[Z,k,$,E,V,S,p.userCode].join(`
`)}function Az(m,d=!1){const p=m.shapeInfo.logicalShape;switch(p.length){case 0:return AH(m,d);case 1:return AX(m,d);case 2:return Ay(m,d);case 3:return AW(m,d);case 4:return AM(m,d);case 5:return AU(m);case 6:return AJ(m);default:throw new Error(p.length+"-D input sampling is not yet supported")}}function AC(m,d){switch(m.shapeInfo.logicalShape.length){case 0:return AR(m);case 1:return Au(m,d);case 2:return Af(m,d);case 3:return AE(m,d);default:return Ad(m,d)}}function AL(m,d,p=!1,_){let E="";p?E+=AC(m,_):E+=Az(m,_);const S=m.shapeInfo.logicalShape,I=d.logicalShape;return S.length<=I.length&&(p?E+=Av(m,d):E+=Ah(m,d)),E}function AK(m,d,p){switch(m.length){case 0:return AF();case 1:return AN(m,d,p);case 2:return AI(m,d,p);case 3:return AD(m,d,p);default:return Ai(m,d,p)}}function Ar(m,d,p){switch(m.length){case 0:return AF();case 1:return AO(m,d,p);case 2:return AB(m,d,p);case 3:return An(m,d,p);case 4:return Ae(m,d,p);case 5:return AP(m,d);case 6:return AS(m,d);default:throw new Error(m.length+"-D output sampling is not yet supported")}}function AT(m){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return `+m.texture2D+`(textureSampler, uv).r;
    }
  `}function Aq(m){return`
    void setOutput(float val) {
      `+m.output+` = vec4(val, 0, 0, 0);
    }
  `}function AQ(m){return`
    void setOutput(vec4 val) {
      `+m.output+` = val;
    }
  `}function Ak(m){return m.version+`
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    `+m.varyingFs+` vec2 resultUV;
    `+m.defineOutput+`
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    `+m.defineSpecialNaN+`
    `+m.defineSpecialInf+`
    `+m.defineRound+`

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    `+Ap+`
    `+Aw+`
    `+AA+`
  `}const Ap=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Aw=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,AA=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,AZ=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function AF(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function AN(m,d,p){const _=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)];return _[0]===1?p?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * `+_[1]+`.0);
      }
    `:_[1]===1?p?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * `+_[0]+`.0);
      }
    `:p?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+_[0]+", "+_[1]+`));
      return 2 * (resTexRC.x * `+_[1]+` + resTexRC.y);
    }
  `}function AO(m,d,p){return d[0]===1?p?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * `+d[1]+`.0);
      }
    `:d[1]===1?p?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * `+d[0]+`.0);
      }
    `:p?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+d[0]+", "+d[1]+`));
      return resTexRC.x * `+d[1]+` + resTexRC.y;
    }
  `}function AD(m,d,p){if(p)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const _=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)],E=Math.ceil(m[2]/2),S=E*Math.ceil(m[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+_[0]+", "+_[1]+`));
      int index = resTexRC.x * `+_[1]+` + resTexRC.y;

      int b = index / `+S+`;
      index -= b * `+S+`;

      int r = 2 * (index / `+E+`);
      int c = imod(index, `+E+`) * 2;

      return ivec3(b, r, c);
    }
  `}function An(m,d,p){if(p)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    `+A6(["r","c","d"],m)+`
    return ivec3(r, c, d);
  }
`;const _=A5(["r","c","d"],m);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+d[0]+", "+d[1]+`));
      int index = resTexRC.x * `+d[1]+` + resTexRC.y;
      `+_+`
      return ivec3(r, c, d);
    }
  `}function Ai(m,d,p){if(p)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const _=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)],E=Math.ceil(m[m.length-1]/2),S=E*Math.ceil(m[m.length-2]/2);let I=S,D="",k="b, r, c";for(let V=2;V<m.length-1;V++)I*=m[m.length-V-1],D=`
      int b`+V+" = index / "+I+`;
      index -= b`+V+" * "+I+`;
    `+D,k="b"+V+", "+k;return`
    ivec`+m.length+` getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+_[0]+", "+_[1]+`));
      int index = resTexRC.x * `+_[1]+` + resTexRC.y;

      `+D+`

      int b = index / `+S+`;
      index -= b * `+S+`;

      int r = 2 * (index / `+E+`);
      int c = imod(index, `+E+`) * 2;

      return ivec`+m.length+"("+k+`);
    }
  `}function Ae(m,d,p){if(p)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      `+A6(["r","c","d","d2"],m)+`
      return ivec4(r, c, d, d2);
    }
  `;const _=A5(["r","c","d","d2"],m);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+d[0]+", "+d[1]+`));
      int index = resTexRC.x * `+d[1]+` + resTexRC.y;
      `+_+`
      return ivec4(r, c, d, d2);
    }
  `}function AP(m,d){const p=A5(["r","c","d","d2","d3"],m);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(`+d[0]+`,
                             `+d[1]+`));

      int index = resTexRC.x * `+d[1]+` + resTexRC.y;

      `+p+`

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function AS(m,d){const p=A5(["r","c","d","d2","d3","d4"],m);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+d[0]+", "+d[1]+`));
      int index = resTexRC.x * `+d[1]+` + resTexRC.y;

      `+p+`

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function AI(m,d,p){const _=[Math.ceil(d[0]/2),Math.ceil(d[1]/2)];if(i(m,d))return p?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(`+_[0]+", "+_[1]+`));
      }
    `;const E=Math.ceil(m[1]/2);return p?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+_[0]+", "+_[1]+`));

      int index = resTexRC.x * `+_[1]+` + resTexRC.y;
      int r = 2 * (index / `+E+`);
      int c = imod(index, `+E+`) * 2;

      return ivec2(r, c);
    }
  `}function AB(m,d,p){return i(m,d)?p?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(`+d[0]+", "+d[1]+`));
      }
    `:m[1]===1?p?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+d[0]+", "+d[1]+`));
        int index = resTexRC.x * `+d[1]+` + resTexRC.y;
        return ivec2(index, 0);
      }
    `:m[0]===1?p?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+d[0]+", "+d[1]+`));
        int index = resTexRC.x * `+d[1]+` + resTexRC.y;
        return ivec2(0, index);
      }
    `:p?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+d[0]+", "+d[1]+`));
      int index = resTexRC.x * `+d[1]+` + resTexRC.y;
      int r = index / `+m[1]+`;
      int c = index - r * `+m[1]+`;
      return ivec2(r, c);
    }
  `}function Aj(m){return"offset"+m}function AR(m){const d=m.name,p="get"+d.charAt(0).toUpperCase()+d.slice(1),_=A4();return`
    vec4 `+p+`() {
      return `+_.texture2D+"("+d+`, halfCR);
    }
  `}function AH(m,d){const p=m.name,_="get"+p.charAt(0).toUpperCase()+p.slice(1);if(m.shapeInfo.isUniform)return"float "+_+"() {return "+p+";}";const[E,S]=m.shapeInfo.texShape;if(E===1&&S===1)return`
      float `+_+`() {
        return sampleTexture(`+p+`, halfCR);
      }
    `;const I=Aj(p);if(d)return`
    float `+_+`() {
      vec2 uv = uvFromFlat(`+p+"TexShape[0], "+p+"TexShape[1], "+I+`);
      return sampleTexture(`+p+`, uv);
    }
  `;const[D,k]=m.shapeInfo.texShape;return`
    float `+_+`() {
      vec2 uv = uvFromFlat(`+D+", "+k+", "+I+`);
      return sampleTexture(`+p+`, uv);
    }
  `}function Au(m,d){const p=m.name,_="get"+p.charAt(0).toUpperCase()+p.slice(1),E=m.shapeInfo.texShape,S=A4();if(d)return`
    vec4 `+_+`(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(`+p+"TexShape[0]) / 2.0), ceil(float("+p+`TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return `+S.texture2D+"("+p+`, uv);
    }
  `;const I=[Math.ceil(E[0]/2),Math.ceil(E[1]/2)];return`
    vec4 `+_+`(int index) {
      vec2 uv = packedUVfrom1D(
        `+I[0]+", "+I[1]+`, index);
      return `+S.texture2D+"("+p+`, uv);
    }
  `}function AX(m,d){const p=m.name,_="get"+p.charAt(0).toUpperCase()+p.slice(1);if(m.shapeInfo.isUniform)return`
      float `+_+`(int index) {
        `+At(m)+`
      }
    `;const E=m.shapeInfo.texShape,S=E[0],I=E[1];if(I===1&&S===1)return`
      float `+_+`(int index) {
        return sampleTexture(`+p+`, halfCR);
      }
    `;const D=Aj(p);return I===1?d?`
      float `+_+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+D+") + 0.5) / float("+p+`TexShape[0]));
        return sampleTexture(`+p+`, uv);
      }
    `:`
      float `+_+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+D+") + 0.5) / "+S+`.0);
        return sampleTexture(`+p+`, uv);
      }
    `:S===1?d?`
      float `+_+`(int index) {
        vec2 uv = vec2((float(index + `+D+") + 0.5) / float("+p+`TexShape[1]), 0.5);
        return sampleTexture(`+p+`, uv);
      }
    `:`
      float `+_+`(int index) {
        vec2 uv = vec2((float(index + `+D+") + 0.5) / "+I+`.0, 0.5);
        return sampleTexture(`+p+`, uv);
      }
    `:d?`
    float `+_+`(int index) {
      vec2 uv = uvFromFlat(`+p+"TexShape[0], "+p+"TexShape[1], index + "+D+`);
      return sampleTexture(`+p+`, uv);
    }
  `:`
    float `+_+`(int index) {
      vec2 uv = uvFromFlat(`+S+", "+I+", index + "+D+`);
      return sampleTexture(`+p+`, uv);
    }
  `}function Af(m,d){const p=m.shapeInfo.logicalShape,_=m.name,E="get"+_.charAt(0).toUpperCase()+_.slice(1),S=m.shapeInfo.texShape,I=S[0],D=S[1],k=A4();if(S!=null&&i(p,S))return d?`
      vec4 `+E+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+_+"TexShape[1], "+_+`TexShape[0]);

        return `+k.texture2D+"("+_+`, uv);
      }
    `:`
      vec4 `+E+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+D+".0, "+I+`.0);

        return `+k.texture2D+"("+_+`, uv);
      }
    `;if(d)return`
    vec4 `+E+`(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+_+"TexShape[0]) / 2.0), ceil(float("+_+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+_+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return `+k.texture2D+"("+_+`, uv);
    }
  `;const V=[Math.ceil(S[0]/2),Math.ceil(S[1]/2)],$=Math.ceil(p[1]/2);return`
    vec4 `+E+`(int row, int col) {
      vec2 uv = packedUVfrom2D(`+$+", "+V[0]+", "+V[1]+`, row, col);
      return `+k.texture2D+"("+_+`, uv);
    }
  `}function Ay(m,d){const p=m.shapeInfo.logicalShape,_=m.name,E="get"+_.charAt(0).toUpperCase()+_.slice(1),S=m.shapeInfo.texShape;if(S!=null&&i(p,S)){if(d)return`
      float `+E+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+_+"TexShape[1], "+_+`TexShape[0]);
        return sampleTexture(`+_+`, uv);
      }
    `;const te=S[0],xe=S[1];return`
    float `+E+`(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(`+xe+".0, "+te+`.0);
      return sampleTexture(`+_+`, uv);
    }
  `}const{newShape:I,keptDims:D}=f(p),k=I;if(k.length<p.length){const te=Ax(m,k),xe=["row","col"];return`
      `+Az(te,d)+`
      float `+E+`(int row, int col) {
        return `+E+"("+Al(xe,D)+`);
      }
    `}if(m.shapeInfo.isUniform)return`
      float `+E+`(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(`+p[1]+`, 1)));
        `+At(m)+`
      }
    `;const V=S[0],$=S[1],Z=Aj(_);return $===1?d?`
      float `+E+`(int row, int col) {
        float index = dot(vec3(row, col, `+Z+"), vec3("+_+`Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(`+_+`TexShape[0]));
        return sampleTexture(`+_+`, uv);
      }
    `:`
    float `+E+`(int row, int col) {
      float index = dot(vec3(row, col, `+Z+"), vec3("+p[1]+`, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / `+V+`.0);
      return sampleTexture(`+_+`, uv);
    }
  `:V===1?d?`
      float `+E+`(int row, int col) {
        float index = dot(vec3(row, col, `+Z+"), vec3("+_+`Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(`+_+`TexShape[1]), 0.5);
        return sampleTexture(`+_+`, uv);
      }
    `:`
    float `+E+`(int row, int col) {
      float index = dot(vec3(row, col, `+Z+"), vec3("+p[1]+`, 1, 1));
      vec2 uv = vec2((index + 0.5) / `+$+`.0, 0.5);
      return sampleTexture(`+_+`, uv);
    }
  `:d?`
      float `+E+`(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+_+"Shape[1] + col + "+Z+`;
        vec2 uv = uvFromFlat(`+_+"TexShape[0], "+_+`TexShape[1], index);
        return sampleTexture(`+_+`, uv);
      }
    `:`
  float `+E+`(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * `+p[1]+" + col + "+Z+`;
    vec2 uv = uvFromFlat(`+V+", "+$+`, index);
    return sampleTexture(`+_+`, uv);
  }
`}function AE(m,d){const p=m.shapeInfo.logicalShape,_=m.name,E="get"+_.charAt(0).toUpperCase()+_.slice(1),S=m.shapeInfo.texShape,I=[Math.ceil(S[0]/2),Math.ceil(S[1]/2)];if(p[0]===1){const te=p.slice(1),xe=[1,2],le=Ax(m,te),he=["b","row","col"];return`
        `+AC(le,d)+`
        vec4 `+E+`(int b, int row, int col) {
          return `+E+"("+Al(he,xe)+`);
        }
      `}const D=A4();if(d)return`
    vec4 `+E+`(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+_+"TexShape[0]) / 2.0), ceil(float("+_+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+_+`Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+_+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return `+D.texture2D+"("+_+`, uv);
    }
  `;const k=I[0],V=I[1],$=Math.ceil(p[2]/2),Z=$*Math.ceil(p[1]/2);return`
    vec4 `+E+`(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        `+k+", "+V+", "+Z+", "+$+`, b, row, col);
      return `+D.texture2D+"("+_+`, uv);
    }
  `}function AW(m,d){const p=m.shapeInfo.logicalShape,_=m.name,E="get"+_.charAt(0).toUpperCase()+_.slice(1),S=p[1]*p[2],I=p[2],{newShape:D,keptDims:k}=f(p),V=D;if(V.length<p.length){const he=Ax(m,V),de=["row","col","depth"];return`
        `+Az(he,d)+`
        float `+E+`(int row, int col, int depth) {
          return `+E+"("+Al(de,k)+`);
        }
      `}if(m.shapeInfo.isUniform)return`
      float `+E+`(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(`+S+", "+I+`, 1)));
        `+At(m)+`
      }
    `;const $=m.shapeInfo.texShape,Z=$[0],te=$[1],xe=m.shapeInfo.flatOffset;if(te===S&&xe==null)return d?`
      float `+E+`(int row, int col, int depth) {
        int stride1 = `+_+`Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+_+"TexShape[1], "+_+`TexShape[0]);
        return sampleTexture(`+_+`, uv);
      }
    `:`
        float `+E+`(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(`+I+`, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(`+te+".0, "+Z+`.0);
          return sampleTexture(`+_+`, uv);
        }
      `;if(te===I&&xe==null)return d?`
      float `+E+`(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(`+_+`Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+_+"TexShape[1], "+_+`TexShape[0]);
        return sampleTexture(`+_+`, uv);
      }
    `:`
    float `+E+`(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(`+p[1]+`, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+te+".0, "+Z+`.0);
      return sampleTexture(`+_+`, uv);
    }
  `;const le=Aj(_);return d?`
    float `+E+`(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = `+_+"Shape[1] * "+_+`Shape[2];
      int stride1 = `+_+`Shape[2];
      int index = row * stride0 + col * stride1 + depth + `+le+`;
      vec2 uv = uvFromFlat(`+_+"TexShape[0], "+_+`TexShape[1], index);
      return sampleTexture(`+_+`, uv);
    }
    `:`
      float `+E+`(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+S+" + col * "+I+" + depth + "+le+`;
        vec2 uv = uvFromFlat(`+Z+", "+te+`, index);
        return sampleTexture(`+_+`, uv);
      }
  `}function Ad(m,d){const p=m.name,_="get"+p.charAt(0).toUpperCase()+p.slice(1),E=A4();if(d)return`
    vec4 `+_+`(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(`+p+`Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+p+`Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= `+p+`Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(`+p+"TexShape[0]) / 2.0), ceil(float("+p+`TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return `+E.texture2D+"("+p+`, uv);
    }
  `;const S=m.shapeInfo.logicalShape,I=S.length,D=m.shapeInfo.texShape,k=[Math.ceil(D[0]/2),Math.ceil(D[1]/2)],V=k[0],$=k[1],Z=Math.ceil(S[I-1]/2);let te=Z*Math.ceil(S[I-2]/2),xe="int b, int row, int col",le="b * "+te+" + (row / 2) * "+Z+" + (col / 2)";for(let he=2;he<I-1;he++)xe="int b"+he+", "+xe,te*=S[I-he-1],le="b"+he+" * "+te+" + "+le;return`
    vec4 `+_+"("+xe+`) {
      int index = `+le+`;
      int texR = index / `+$+`;
      int texC = index - texR * `+$+`;
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+$+", "+V+`);
      return `+E.texture2D+"("+p+`, uv);
    }
  `}function AM(m,d){const p=m.shapeInfo.logicalShape,_=m.name,E="get"+_.charAt(0).toUpperCase()+_.slice(1),S=p[3],I=p[2]*S,D=p[1]*I,{newShape:k,keptDims:V}=f(p);if(k.length<p.length){const ge=Ax(m,k),be=["row","col","depth","depth2"];return`
      `+Az(ge,d)+`
      float `+E+`(int row, int col, int depth, int depth2) {
        return `+E+"("+Al(be,V)+`);
      }
    `}if(m.shapeInfo.isUniform)return`
      float `+E+`(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(`+D+", "+I+", "+S+`, 1)));
        `+At(m)+`
      }
    `;const $=m.shapeInfo.flatOffset,Z=m.shapeInfo.texShape,te=Z[0],xe=Z[1],le="int stride2 = "+_+"Shape[3];",he="int stride1 = "+_+"Shape[2] * stride2;",de="int stride0 = "+_+"Shape[1] * stride1;";if(xe===D&&$==null)return d?`
      float `+E+`(int row, int col, int depth, int depth2) {
        `+le+`
        `+he+`
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+_+"TexShape[1], "+_+`TexShape[0]);
        return sampleTexture(`+_+`, uv);
      }
    `:`
      float `+E+`(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(`+I+", "+S+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+xe+".0, "+te+`.0);
        return sampleTexture(`+_+`, uv);
      }
    `;if(xe===S&&$==null)return d?`
      float `+E+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+_+"Shape[1] * "+_+"Shape[2], "+_+`Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+_+"TexShape[1], "+_+`TexShape[0]);
        return sampleTexture(`+_+`, uv);
      }
    `:`
      float `+E+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+p[1]*p[2]+", "+p[2]+`, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+xe+".0, "+te+`.0);
        return sampleTexture(`+_+`, uv);
      }
    `;const me=Aj(_);return d?`
    float `+E+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      `+le+`
      `+he+`
      `+de+`
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(`+_+"TexShape[0], "+_+"TexShape[1], index + "+me+`);
      return sampleTexture(`+_+`, uv);
    }
  `:`
    float `+E+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+D+" + col * "+I+` +
          depth * `+S+` + depth2;
      vec2 uv = uvFromFlat(`+te+", "+xe+", index + "+me+`);
      return sampleTexture(`+_+`, uv);
    }
  `}function AU(m){const d=m.shapeInfo.logicalShape,p=m.name,_="get"+p.charAt(0).toUpperCase()+p.slice(1),E=d[4],S=d[3]*E,I=d[2]*S,D=d[1]*I,{newShape:k,keptDims:V}=f(d);if(k.length<d.length){const he=Ax(m,k),de=["row","col","depth","depth2","depth3"];return`
      `+Az(he)+`
      float `+_+`(int row, int col, int depth, int depth2, int depth3) {
        return `+_+"("+Al(de,V)+`);
      }
    `}if(m.shapeInfo.isUniform)return`
      float `+_+`(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(`+D+", "+I+", "+S+", "+E+`)) +
          depth3;
        `+At(m)+`
      }
    `;const $=m.shapeInfo.flatOffset,Z=m.shapeInfo.texShape,te=Z[0],xe=Z[1];if(xe===D&&$==null)return`
      float `+_+`(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(`+I+", "+S+", "+E+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+xe+".0, "+te+`.0);
        return sampleTexture(`+p+`, uv);
      }
    `;if(xe===E&&$==null)return`
      float `+_+`(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(`+d[1]*d[2]*d[3]+`,
               `+d[2]*d[3]+", "+d[3]+`, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+xe+".0, "+te+`.0);
        return sampleTexture(`+p+`, uv);
      }
    `;const le=Aj(p);return`
    float `+_+`(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+D+" + col * "+I+" + depth * "+S+` +
          depth2 * `+E+" + depth3 + "+le+`;
      vec2 uv = uvFromFlat(`+te+", "+xe+`, index);
      return sampleTexture(`+p+`, uv);
    }
  `}function AJ(m){const d=m.shapeInfo.logicalShape,p=m.name,_="get"+p.charAt(0).toUpperCase()+p.slice(1),{newShape:E,keptDims:S}=f(d);if(E.length<d.length){const de=Ax(m,E),me=["row","col","depth","depth2","depth3","depth4"];return`
      `+Az(de)+`
      float `+_+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return `+_+"("+Al(me,S)+`);
      }
    `}const I=d[5],D=d[4]*I,k=d[3]*D,V=d[2]*k,$=d[1]*V;if(m.shapeInfo.isUniform)return`
      float `+_+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(`+$+", "+V+", "+k+", "+D+`)) +
          dot(
            vec2(depth3, depth4),
            vec2(`+I+`, 1)));
        `+At(m)+`
      }
    `;const Z=m.shapeInfo.flatOffset,te=m.shapeInfo.texShape,xe=te[0],le=te[1];if(le===$&&Z==null)return`
      float `+_+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(`+V+", "+k+", "+D+", "+I+`)) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+le+".0, "+xe+`.0);
        return sampleTexture(`+p+`, uv);
      }
    `;if(le===I&&Z==null)return`
      float `+_+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(`+d[1]*d[2]*d[3]*d[4]+`,
               `+d[2]*d[3]*d[4]+`,
               `+d[3]*d[4]+`,
               `+d[4]+`)) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+le+".0, "+xe+`.0);
        return sampleTexture(`+p+`, uv);
      }
    `;const he=Aj(p);return`
    float `+_+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+$+" + col * "+V+" + depth * "+k+` +
          depth2 * `+D+" + depth3 * "+I+" + depth4 + "+he+`;
      vec2 uv = uvFromFlat(`+xe+", "+le+`, index);
      return sampleTexture(`+p+`, uv);
    }
  `}function At(m){const d=m.name,p=n(m.shapeInfo.logicalShape);return p<2?"return "+d+";":`
    for (int i = 0; i < `+p+`; i++) {
      if (i == index) {
        return `+d+`[i];
      }
    }
  `}function Av(m,d){const p=m.name,_=p.charAt(0).toUpperCase()+p.slice(1),E="get"+_+"AtOutCoords",S=m.shapeInfo.logicalShape.length,I=d.logicalShape.length,D=AG(m.shapeInfo.logicalShape,d.logicalShape),k=AY(I),V=I-S;let $;const Z=["x","y","z","w","u","v"];S===0?$="":I<2&&D.length>=1?$="coords = 0;":$=D.map(de=>"coords."+Z[de+V]+" = 0;").join(`
`);let te="";I<2&&S>0?te="coords":te=m.shapeInfo.logicalShape.map((de,me)=>"coords."+Z[me+V]).join(", ");let xe="return outputValue;";const le=n(m.shapeInfo.logicalShape)===1,he=n(d.logicalShape)===1;if(S===1&&!le&&!he)xe=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(le&&!he)I===1?xe=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:xe=`
        return vec4(outputValue.x);
      `;else if(D.length){const de=S-2,me=S-1;D.indexOf(de)>-1&&D.indexOf(me)>-1?xe="return vec4(outputValue.x);":D.indexOf(de)>-1?xe="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":D.indexOf(me)>-1&&(xe="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 `+E+`() {
      `+k+` coords = getOutputCoords();
      `+$+`
      vec4 outputValue = get`+_+"("+te+`);
      `+xe+`
    }
  `}function Ah(m,d){const p=m.name,_=p.charAt(0).toUpperCase()+p.slice(1),E="get"+_+"AtOutCoords",S=d.texShape,I=m.shapeInfo.texShape,D=m.shapeInfo.logicalShape.length,k=d.logicalShape.length;if(!m.shapeInfo.isUniform&&D===k&&m.shapeInfo.flatOffset==null&&i(I,S))return`
      float `+E+`() {
        return sampleTexture(`+p+`, resultUV);
      }
    `;const V=AY(k),$=AG(m.shapeInfo.logicalShape,d.logicalShape),Z=k-D;let te;const xe=["x","y","z","w","u","v"];D===0?te="":k<2&&$.length>=1?te="coords = 0;":te=$.map(he=>"coords."+xe[he+Z]+" = 0;").join(`
`);let le="";return k<2&&D>0?le="coords":le=m.shapeInfo.logicalShape.map((he,de)=>"coords."+xe[de+Z]).join(", "),`
    float `+E+`() {
      `+V+` coords = getOutputCoords();
      `+te+`
      return get`+_+"("+le+`);
    }
  `}function AY(m){if(m<=1)return"int";if(m===2)return"ivec2";if(m===3)return"ivec3";if(m===4)return"ivec4";if(m===5)return"ivec5";if(m===6)return"ivec6";throw Error("GPU for rank "+m+" is not yet supported")}function Am(m,d,p){const{newShape:_,keptDims:E}=f(d),S=d.length,I=m&&S===3&&d[0]===1,D=I?d.slice(1):_,k=!m&&S>1&&!i(d,p)&&_.length<S||I;return{useSqueezeShape:k,uniformShape:k?D:d,keptDims:E}}function Ax(m,d){const p=JSON.parse(JSON.stringify(m));return p.shapeInfo.logicalShape=d,p}function Al(m,d){return d.map(p=>m[p]).join(", ")}function Ab(m,d,p,_){const E=p.map(($,Z)=>{const te={logicalShape:$.shape,texShape:$.isUniform?null:$.texData.texShape,isUniform:$.isUniform,isPacked:$.isUniform?!1:$.texData.isPacked,flatOffset:null};return $.texData!=null&&$.texData.slice!=null&&$.texData.slice.flatOffset>0&&(te.flatOffset=$.texData.slice.flatOffset),{name:d.variableNames[Z],shapeInfo:te}}),S=E.map($=>$.shapeInfo),I={logicalShape:_.shape,texShape:_.texData.texShape,isUniform:!1,isPacked:_.texData.isPacked,flatOffset:null},D=As(E,I,d),k=ww(m.gl,D),V=m.createProgram(k);return oQ().get("ENGINE_COMPILE_ONLY")?{program:d,fragmentShader:k,source:D,webGLProgram:V,inShapeInfos:S,outShapeInfo:I,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(m.buildVao(V),Object.assign({program:d,fragmentShader:k,source:D,webGLProgram:V,inShapeInfos:S,outShapeInfo:I},Aa(m,d,V)))}function Aa(m,d,p){const _=[],E=[];let S,I,D,k=null,V=null;V=m.getUniformLocation(p,"NAN",!1),oQ().getNumber("WEBGL_VERSION")===1&&(k=m.getUniformLocation(p,"INFINITY",!1));const $=!1;for(const Z of d.variableNames){const te={name:Z,uniform:m.getUniformLocation(p,Z,$),offset:m.getUniformLocation(p,"offset"+Z,$)};d.enableShapeUniforms&&(te.shape=m.getUniformLocation(p,Z+"Shape",$),te.texShape=m.getUniformLocation(p,Z+"TexShape",$)),_.push(te)}if(d.enableShapeUniforms&&(S=m.getUniformLocation(p,"outShape",$),D=m.getUniformLocation(p,"outShapeStrides",$),I=m.getUniformLocation(p,"outTexShape",$)),d.customUniforms)for(const Z of d.customUniforms)E.push(m.getUniformLocation(p,Z.name,$));return{variablesLocations:_,customUniformLocations:E,infLoc:k,nanLoc:V,outShapeLocation:S,outShapeStridesLocation:D,outTexShapeLocation:I}}function AV(m,d){if(m.length!==d.length)throw Error("Binary was compiled with "+m.length+" inputs, but was executed with "+d.length+" inputs");m.forEach((p,_)=>{const E=p.logicalShape,S=d[_],I=S.shape;if(!i(E,I))throw Error("Binary was compiled with different shapes than the current args. Shapes "+E+" and "+I+" must match");if(p.isUniform&&S.isUniform)return;const D=p.texShape,k=S.isUniform?null:S.texData.texShape;if(!i(D,k))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+D+" and "+k+" must match")})}function Ag(m,d,p,_,E){d.program.enableShapeUniforms||(AV(d.inShapeInfos,p),AV([d.outShapeInfo],[_]));const S=_.texData.texture,I=_.texData.texShape;_.texData.isPacked?m.setOutputPackedMatrixTexture(S.texture,I[0],I[1]):m.setOutputMatrixTexture(S.texture,I[0],I[1]),m.setProgram(d.webGLProgram),m.bindVertexArray(d.webGLProgram.vao),oQ().getNumber("WEBGL_VERSION")===1&&d.infLoc!==null&&m.gl.uniform1f(d.infLoc,1/0),d.nanLoc!==null&&m.gl.uniform1f(d.nanLoc,NaN);for(let k=0;k<p.length;++k){const V=p[k],{uniform:$,offset:Z,shape:te,texShape:xe}=d.variablesLocations[k];if(te){const{uniformShape:le}=Am(d.program.packedInputs,V.shape,V.texData.texShape);switch(le.length){case 1:m.gl.uniform1iv(te,new Int32Array(le));break;case 2:m.gl.uniform2iv(te,new Int32Array(le));break;case 3:m.gl.uniform3iv(te,new Int32Array(le));break;case 4:m.gl.uniform4iv(te,new Int32Array(le));break}}if(xe&&m.gl.uniform2i(xe,V.texData.texShape[0],V.texData.texShape[1]),$!=null){if(V.isUniform){if(n(V.shape)<2)m.gl.uniform1f($,V.uniformValues[0]);else{let le=V.uniformValues;le instanceof Float32Array||(le=new Float32Array(le)),m.gl.uniform1fv($,le)}continue}V.texData.slice!=null&&Z!=null&&m.gl.uniform1i(Z,V.texData.slice.flatOffset),m.setInputMatrixTexture(V.texData.texture.texture,$,k)}}const D=d.outShapeLocation;if(D)switch(_.shape.length){case 1:m.gl.uniform1iv(D,new Int32Array(_.shape));break;case 2:m.gl.uniform2iv(D,new Int32Array(_.shape));break;case 3:m.gl.uniform3iv(D,new Int32Array(_.shape));break;case 4:m.gl.uniform4iv(D,new Int32Array(_.shape));break}if(d.outShapeStridesLocation){const k=o6(_.shape);switch(_.shape.length){case 2:m.gl.uniform1iv(d.outShapeStridesLocation,new Int32Array(k));break;case 3:m.gl.uniform2iv(d.outShapeStridesLocation,new Int32Array(k));break;case 4:m.gl.uniform3iv(d.outShapeStridesLocation,new Int32Array(k));break}}if(d.outTexShapeLocation&&m.gl.uniform2i(d.outTexShapeLocation,_.texData.texShape[0],_.texData.texShape[1]),d.program.customUniforms&&E)for(let k=0;k<d.program.customUniforms.length;++k){const V=d.program.customUniforms[k],$=d.customUniformLocations[k],Z=E[k];if(V.type==="float")m.gl.uniform1fv($,Z);else if(V.type==="vec2")m.gl.uniform2fv($,Z);else if(V.type==="vec3")m.gl.uniform3fv($,Z);else if(V.type==="vec4")m.gl.uniform4fv($,Z);else if(V.type==="int")m.gl.uniform1iv($,Z);else if(V.type==="ivec2")m.gl.uniform2iv($,Z);else if(V.type==="ivec3")m.gl.uniform3iv($,Z);else if(V.type==="ivec4")m.gl.uniform4iv($,Z);else throw Error("uniform type "+V.type+" is not supported yet.")}m.executeProgram()}function Z0(m,d,p){let _="";d.concat(p).forEach(I=>{const D=I.texData!=null&&I.texData.slice!=null&&I.texData.slice.flatOffset>0;if(m.enableShapeUniforms&&!I.isUniform){const k=I.texData.texShape,{useSqueezeShape:V,uniformShape:$,keptDims:Z}=Am(m.packedInputs,I.shape,k);let te="",xe="",le="";if($.length===1&&m.packedInputs){const ve=[Math.ceil(k[0]/2),Math.ceil(k[1]/2)];te=(ve[0]>1)+"_"+(ve[1]>1)}else if($.length===2&&!m.packedInputs)xe=($[0]>1)+"_"+($[1]>1);else if($.length>2&&!m.packedInputs){const ve=o6($);le=(ve[0]===k[1])+"_"+(ve[ve.length-1]===k[1])}const he=I.shape.length,de=$.length===2&&i(I.shape,k),me=n(I.shape)===1,ge=CM(I.shape,p.shape),be=!m.packedInputs&&he===p.shape.length&&i(k,p.texData.texShape),ye=m.packedInputs||$.length>2?"":(k[0]>1)+"_"+(k[1]>1);_+=he+"_"+be+"_"+(V?Z:"")+"_"+$.length+"_"+me+"_"+ge+"_"+de+"_"+te+"_"+xe+"_"+le+"_"+ye+"_"+D}else{const k=I.isUniform?"uniform":I.texData.texShape;_+=I.shape+"_"+k+"_"+D}});const E=m.userCode;let S=m.constructor.name;return S+="_"+_+"_"+E+(""+oQ().getNumber("WEBGL_VERSION")),S}function Z1(m){return oQ().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&m<=4}class Z2{constructor(d){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=w7.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const p=A4();this.outputShape=d,this.enableShapeUniforms=Z1(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?A6(["r","c","d"],d):A5(["r","c","d"],d))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        `+p.output+` = result;
      }
    `}}class Z3{constructor(d){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=w7.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const p=A4();this.outputShape=d,this.enableShapeUniforms=Z1(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?A6(["r","c","d"],d):A5(["r","c","d"],d))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        `+p.output+` = result;
      }
    `}}class Z4{constructor(d){this.variableNames=["A"],this.outTexUsage=w8.DOWNLOAD;const p=A4();this.outputShape=d,this.userCode=`
      `+Ac+`

      void main() {
        float x = getAAtOutCoords();
        `+p.output+` = encode_float(x);
      }
    `}}class Z5{constructor(d){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=w8.DOWNLOAD;const p=A4();this.outputShape=d,this.userCode=`
      `+Ac+`

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        `+p.output+` = encode_float(x);
      }
    `}}const Z6={R:0,G:1,B:2,A:3};class Z7{constructor(d,p=!1,_="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const E=A4();this.outputShape=d,this.enableShapeUniforms=Z1(this.outputShape.length);let S="result";p&&(S="floor(result * 255. + 0.5)");let I="";for(let D=0;D<_.length;D++){const k=_[D];I+=`
          if(offset == `+D+`) {
            result = values[`+Z6[k]+`];
          }`}this.userCode=`
      `+(this.enableShapeUniforms?Ao():A9(d))+`

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, `+_.length+`);

        flatIndex = idiv(flatIndex, `+_.length+`, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = `+E.texture2D+`(A, uv);
          `+I+`
        }
        `+E.output+" = vec4("+S+`, 0., 0., 0.);
      }
    `}}class Z8{constructor(d,p=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const _=A4();this.outputShape=d,this.enableShapeUniforms=Z1(this.outputShape.length);let E="",S="result";p&&(S="floor(result * 255. + 0.5)");for(let I=0;I<=1;I++)for(let D=0;D<=1;D++){const k=I*2+D;E+=`
          localCoords = coords;
          if(localCoords[2] + `+D+" < "+(this.enableShapeUniforms?"outShape[2]":""+d[2])+`) {
          localCoords[2] += `+D+`;
          if (localCoords[1] + `+I+" < "+(this.enableShapeUniforms?"outShape[1]":""+d[1])+`) {
            localCoords[1] += `+I+`;

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = `+_.texture2D+`(A, uv);

            if (offset == 0) {
              result[`+k+`] = values[0];
            } else if (offset == 1) {
              result[`+k+`] = values[1];
            } else if (offset == 2) {
              result[`+k+`] = values[2];
            } else {
              result[`+k+`] = values[3];
            }
          }
        }
        `}this.userCode=`
        `+(this.enableShapeUniforms?Ao():A9(d))+`

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          `+E+`

          `+_.output+" = "+S+`;
        }
    `}}function Z9(m){const d=A4(),p=d.version+`
    precision highp float;
    `+d.attribute+` vec3 clipSpacePos;
    `+d.attribute+` vec2 uv;
    `+d.varyingVs+` vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return wp(m,p)}function Zo(m){const d=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return wD(m,d)}function Zc(m){const d=new Uint16Array([0,1,2,2,1,3]);return wn(m,d)}function ZG(m,d,p,_,E,S){we(d,p);const I=wi(m),D=m.TEXTURE_2D;return wL(m,()=>m.bindTexture(D,I)),wL(m,()=>m.texParameteri(D,m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE)),wL(m,()=>m.texParameteri(D,m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE)),wL(m,()=>m.texParameteri(D,m.TEXTURE_MIN_FILTER,m.NEAREST)),wL(m,()=>m.texParameteri(D,m.TEXTURE_MAG_FILTER,m.NEAREST)),oQ().getNumber("WEBGL_VERSION")===1?wL(m,()=>m.texImage2D(D,0,_,d,p,0,E,S,null)):wL(m,()=>m.texStorage2D(D,1,_,d,p)),wL(m,()=>m.bindTexture(m.TEXTURE_2D,null)),{texture:I,texShape:[p,d]}}function Zs(m){return m.internalFormatFloat}function Zz(m,d,p,_){const[E,S]=wo(d,p);return ZG(m,E,S,Zs(_),_.textureFormatFloat,m.FLOAT)}function ZC(m){return m.internalFormatHalfFloat}function ZL(m,d,p,_){const[E,S]=wo(d,p);return ZG(m,E,S,ZC(_),_.textureFormatFloat,_.textureTypeHalfFloat)}function ZK(m){return m.downloadTextureFormat}function Zr(m,d,p,_){const[E,S]=wo(d,p);return ZG(m,E,S,ZK(_),m.RGBA,m.UNSIGNED_BYTE)}function ZT(m){return m.internalFormatPackedFloat}function Zq(m,d,p,_){const[E,S]=ws(d,p);return ZG(m,E,S,ZT(_),m.RGBA,m.FLOAT)}function ZQ(m){return m.internalFormatPackedHalfFloat}function Zk(m,d,p,_){const[E,S]=ws(d,p);return ZG(m,E,S,ZQ(_),m.RGBA,_.textureTypeHalfFloat)}function Zp(m,d,p){return wL(m,()=>m.bindBuffer(m.ARRAY_BUFFER,p)),wS(m,d,"clipSpacePos",p,3,20,0)&&wS(m,d,"uv",p,2,20,12)}function Zw(m,d,p,_,E,S){wL(m,()=>m.bindTexture(m.TEXTURE_2D,d));let I,D,k;E instanceof Uint8Array?(I=new Uint8Array(p*_*4),D=m.UNSIGNED_BYTE,k=m.RGBA):(I=new Float32Array(p*_*4),D=m.FLOAT,k=S.internalFormatPackedFloat),I.set(E),oQ().getNumber("WEBGL_VERSION")===2?wL(m,()=>m.texSubImage2D(m.TEXTURE_2D,0,0,0,p,_,m.RGBA,D,I)):wL(m,()=>m.texImage2D(m.TEXTURE_2D,0,k,p,_,0,m.RGBA,D,I)),wL(m,()=>m.bindTexture(m.TEXTURE_2D,null))}function ZA(m,d,p){wL(m,()=>m.bindTexture(m.TEXTURE_2D,d)),p.data instanceof Uint8Array?oQ().getNumber("WEBGL_VERSION")===2?wL(m,()=>m.texSubImage2D(m.TEXTURE_2D,0,0,0,p.width,p.height,m.RGBA,m.UNSIGNED_BYTE,p.data)):wL(m,()=>m.texImage2D(m.TEXTURE_2D,0,m.RGBA,p.width,p.height,0,m.RGBA,m.UNSIGNED_BYTE,p.data)):oQ().getNumber("WEBGL_VERSION")===2?wL(m,()=>m.texSubImage2D(m.TEXTURE_2D,0,0,0,m.RGBA,m.UNSIGNED_BYTE,p)):wL(m,()=>m.texImage2D(m.TEXTURE_2D,0,m.RGBA,m.RGBA,m.UNSIGNED_BYTE,p)),wL(m,()=>m.bindTexture(m.TEXTURE_2D,null))}function ZZ(m,d,p,_){const E=m.createBuffer();wL(m,()=>m.bindBuffer(m.PIXEL_PACK_BUFFER,E));const S=4*4*d*p;return wL(m,()=>m.bufferData(m.PIXEL_PACK_BUFFER,S,m.STREAM_READ)),wL(m,()=>m.readPixels(0,0,p,d,m.RGBA,m.FLOAT,0)),wL(m,()=>m.bindBuffer(m.PIXEL_PACK_BUFFER,null)),E}function ZF(m,d,p){const _=m,E=new Float32Array(p);return _.bindBuffer(_.PIXEL_PACK_BUFFER,d),_.getBufferSubData(_.PIXEL_PACK_BUFFER,0,E),_.bindBuffer(_.PIXEL_PACK_BUFFER,null),E}function ZN(m,d,p,_){const[E,S]=wo(d,p),I=4,D=new Uint8Array(wc(d*p,I));return wL(m,()=>m.readPixels(0,0,E,S,_.downloadTextureFormat,m.UNSIGNED_BYTE,D)),new Float32Array(D.buffer)}function ZO(m,d,p,_,E,S,I,D){const k=m,V=new Float32Array(wz(S,I));return k.bindBuffer(k.PIXEL_PACK_BUFFER,d),k.getBufferSubData(k.PIXEL_PACK_BUFFER,0,V),k.bindBuffer(k.PIXEL_PACK_BUFFER,null),V}function ZD(m,d,p){const _=new Float32Array(d*p*4);return wL(m,()=>m.readPixels(0,0,p,d,m.RGBA,m.FLOAT,_)),_}class Zn{constructor(d){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const p=oQ().getNumber("WEBGL_VERSION");if(d!=null?(this.gl=d,w3(p,d)):this.gl=w4(p),d=this.gl,oQ().getNumber("WEBGL_VERSION")===2){const S=d;this.createVertexArray=()=>wL(S,()=>S.createVertexArray()),this.bindVertexArray=I=>wL(S,()=>S.bindVertexArray(I)),this.deleteVertexArray=I=>wL(S,()=>S.deleteVertexArray(I)),this.getVertexArray=()=>wL(S,()=>S.getParameter(S.VERTEX_ARRAY_BINDING))}else if(d!=null){const S=d.getExtension("OES_vertex_array_object");if(S==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>wL(d,()=>S.createVertexArrayOES()),this.bindVertexArray=I=>wL(d,()=>S.bindVertexArrayOES(I)),this.deleteVertexArray=I=>wL(d,()=>S.deleteVertexArrayOES(I)),this.getVertexArray=()=>wL(d,()=>d.getParameter(S.VERTEX_ARRAY_BINDING_OES))}let _="WEBGL_color_buffer_float";const E="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),oQ().getNumber("WEBGL_VERSION")===1){const S="OES_texture_float",I="OES_texture_half_float";if(this.textureFloatExtension=wk(this.gl,S),wl(this.gl,I))this.textureHalfFloatExtension=wk(this.gl,I);else if(oQ().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(_),wl(this.gl,E))this.colorBufferHalfFloatExtension=wk(this.gl,E);else if(oQ().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(_="EXT_color_buffer_float",wl(this.gl,_))this.colorBufferFloatExtension=this.gl.getExtension(_);else if(wl(this.gl,E))this.colorBufferHalfFloatExtension=this.gl.getExtension(E);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Zo(this.gl),this.indexBuffer=Zc(this.gl),this.framebuffer=wP(this.gl),this.textureConfig=wC(this.gl,this.textureHalfFloatExtension)}get debug(){return oQ().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const d=this.gl;wL(d,()=>d.finish()),wL(d,()=>d.bindFramebuffer(d.FRAMEBUFFER,null)),wL(d,()=>d.deleteFramebuffer(this.framebuffer)),wL(d,()=>d.bindBuffer(d.ARRAY_BUFFER,null)),wL(d,()=>d.bindBuffer(d.ELEMENT_ARRAY_BUFFER,null)),wL(d,()=>d.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(d,p){return this.throwIfDisposed(),Zz(this.gl,d,p,this.textureConfig)}createFloat16MatrixTexture(d,p){return this.throwIfDisposed(),ZL(this.gl,d,p,this.textureConfig)}createUnsignedBytesMatrixTexture(d,p){return this.throwIfDisposed(),Zr(this.gl,d,p,this.textureConfig)}uploadPixelDataToTexture(d,p){this.throwIfDisposed(),ZA(this.gl,d,p)}uploadDenseMatrixToTexture(d,p,_,E){this.throwIfDisposed(),Zw(this.gl,d,p,_,E,this.textureConfig)}createFloat16PackedMatrixTexture(d,p){return this.throwIfDisposed(),Zk(this.gl,d,p,this.textureConfig)}createPackedMatrixTexture(d,p){return this.throwIfDisposed(),Zq(this.gl,d,p,this.textureConfig)}deleteMatrixTexture(d){this.throwIfDisposed(),this.outputTexture===d&&(wu(this.gl,this.framebuffer),this.outputTexture=null),wL(this.gl,()=>this.gl.deleteTexture(d))}downloadByteEncodedFloatMatrixFromOutputTexture(d,p,_){return this.downloadMatrixDriver(d,()=>ZN(this.gl,p,_,this.textureConfig))}downloadPackedMatrixFromBuffer(d,p,_,E,S,I){return ZO(this.gl,d,p,_,E,S,I,this.textureConfig)}downloadFloat32MatrixFromBuffer(d,p){return ZF(this.gl,d,p)}createBufferFromTexture(d,p,_){this.bindTextureToFrameBuffer(d);const E=ZZ(this.gl,p,_,this.textureConfig);return this.unbindTextureToFrameBuffer(),E}createAndWaitForFence(){const d=this.createFence(this.gl);return this.pollFence(d)}createFence(d){let p,_;if(oQ().getBool("WEBGL_FENCE_API_ENABLED")){const E=d,S=E.fenceSync(E.SYNC_GPU_COMMANDS_COMPLETE,0);d.flush(),_=()=>{const I=E.clientWaitSync(S,0,0);return I===E.ALREADY_SIGNALED||I===E.CONDITION_SATISFIED},p=S}else oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(p=this.beginQuery(),this.endQuery(),_=()=>this.isQueryAvailable(p,oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):_=()=>!0;return{query:p,isFencePassed:_}}downloadMatrixFromPackedTexture(d,p,_){return this.downloadMatrixDriver(d,()=>ZD(this.gl,p,_))}createProgram(d){this.throwIfDisposed();const p=this.gl;this.vertexShader==null&&(this.vertexShader=Z9(p));const _=wF(p);wL(p,()=>p.attachShader(_,this.vertexShader)),wL(p,()=>p.attachShader(_,d)),wN(p,_);const E=Object.assign(_,{vao:this.createVertexArray()});return this.debug&&wO(p,E),E}buildVao(d){this.setProgram(d),this.bindVertexArray(d.vao);const p=this.gl;wL(p,()=>p.bindBuffer(p.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Zp(p,d,this.vertexBuffer)}deleteProgram(d){this.throwIfDisposed(),d===this.program&&(this.program=null),d!=null&&(wL(this.gl,()=>this.gl.deleteProgram(d)),this.deleteVertexArray(d.vao))}setProgram(d){this.throwIfDisposed(),this.program=d,this.program!=null&&this.debug&&wO(this.gl,this.program),wL(this.gl,()=>this.gl.useProgram(d))}getUniformLocation(d,p,_=!0){return this.throwIfDisposed(),_?wB(this.gl,d,p):wj(this.gl,d,p)}getAttributeLocation(d,p){return this.throwIfDisposed(),wL(this.gl,()=>this.gl.getAttribLocation(d,p))}getUniformLocationNoThrow(d,p){return this.throwIfDisposed(),this.gl.getUniformLocation(d,p)}setInputMatrixTexture(d,p,_){this.throwIfDisposed(),this.throwIfNoProgram(),wR(this.gl,d,p,_)}setOutputMatrixTexture(d,p,_){this.setOutputMatrixTextureDriver(d,_,p)}setOutputPackedMatrixTexture(d,p,_){this.throwIfDisposed();const[E,S]=ws(p,_);this.setOutputMatrixTextureDriver(d,E,S)}setOutputMatrixWriteRegion(d,p,_,E){this.setOutputMatrixWriteRegionDriver(_,d,E,p)}setOutputPackedMatrixWriteRegion(d,p,_,E){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&wO(this.gl,this.program),wX(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const d=this.gl;if(this.debug){const p=this.getVertexArray();console.assert(p===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}wL(d,()=>d.drawElements(d.TRIANGLES,6,d.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),wL(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=wk(this.gl,oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const _=this.gl,E=this.getQueryTimerExtensionWebGL2(),S=_.createQuery();return _.beginQuery(E.TIME_ELAPSED_EXT,S),S}const d=this.getQueryTimerExtensionWebGL1(),p=d.createQueryEXT();return d.beginQueryEXT(d.TIME_ELAPSED_EXT,p),p}endQuery(){if(oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const p=this.gl,_=this.getQueryTimerExtensionWebGL2();p.endQuery(_.TIME_ELAPSED_EXT);return}const d=this.getQueryTimerExtensionWebGL1();d.endQueryEXT(d.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(d){return await R(()=>this.disposed||this.isQueryAvailable(d,oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(d,oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(d,p){if(p===0)return null;if(p===2){const _=this.gl;return _.getQueryParameter(d,_.QUERY_RESULT)/1e6}else{const _=this.getQueryTimerExtensionWebGL1();return _.getQueryObjectEXT(d,_.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(d,p){if(p===0)return!0;if(p===2){const _=this.gl,E=this.getQueryTimerExtensionWebGL2(),S=_.getQueryParameter(d,_.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(E.GPU_DISJOINT_EXT)),S&&!this.disjoint}else{const _=this.getQueryTimerExtensionWebGL1(),E=_.getQueryObjectEXT(d,_.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(_.GPU_DISJOINT_EXT)),E&&!this.disjoint}}pollFence(d){return new Promise(p=>{this.addItemToPoll(()=>d.isFencePassed(),()=>p())})}pollItems(){const d=Zi(this.itemsToPoll.map(p=>p.isDoneFn));for(let p=0;p<=d;++p){const{resolveFn:_}=this.itemsToPoll[p];_()}this.itemsToPoll=this.itemsToPoll.slice(d+1)}addItemToPoll(d,p){if(this.itemsToPoll.push({isDoneFn:d,resolveFn:p}),this.itemsToPoll.length>1)return;let _;"setTimeoutCustom"in oQ().platform&&(_=oQ().platform.setTimeoutCustom.bind(oQ().platform)),R(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,_)}bindTextureToFrameBuffer(d){this.throwIfDisposed(),wH(this.gl,d,this.framebuffer),this.debug&&wX(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(wH(this.gl,this.outputTexture,this.framebuffer),this.debug&&wX(this.gl)):wu(this.gl,this.framebuffer)}downloadMatrixDriver(d,p){this.bindTextureToFrameBuffer(d);const _=p();return this.unbindTextureToFrameBuffer(),_}setOutputMatrixTextureDriver(d,p,_){this.throwIfDisposed();const E=this.gl;wH(E,d,this.framebuffer),this.debug&&wX(E),this.outputTexture=d,wL(E,()=>E.viewport(0,0,p,_)),wL(E,()=>E.scissor(0,0,p,_))}setOutputMatrixWriteRegionDriver(d,p,_,E){this.throwIfDisposed(),wL(this.gl,()=>this.gl.scissor(d,p,_,E))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Zi(m){let d=0;for(;d<m.length&&m[d]();++d);return d-1}function Ze(m,d){Array.isArray(m)||(m=[m]),m.forEach(p=>{p!=null&&A(p.dtype!=="complex64",()=>d+" does not support complex64 tensors in the CPU backend.")})}function ZP(m){const d=new Float32Array(m.length);for(let p=0;p<m.length;++p)d[p]=Math.abs(m[p]);return d}const ZS=m=>{const{x:d}=m.inputs,p=m.backend;Ze(d,"abs");let _=new Float32Array(n(d.shape));const E=p.data.get(d.dataId).values;return _=ZP(E),p.makeOutput(_,d.shape,d.dtype)},ZI={kernelName:oO,backendName:"cpu",kernelFunc:ZS};function ZB(m){return(d,p,_,E,S)=>{const I=CJ(d,p),D=I.length,k=o6(I),V=n(I),$=M(S,V),Z=d.length,te=p.length,xe=o6(d),le=o6(p),he=CM(d,I),de=CM(p,I);if(he.length+de.length===0)for(let me=0;me<$.length;++me)$[me]=m(_[me%_.length],E[me%E.length]);else for(let me=0;me<$.length;++me){const ge=oz(me,D,k),be=ge.slice(-Z);he.forEach(je=>be[je]=0);const ye=os(be,Z,xe),ve=ge.slice(-te);de.forEach(je=>ve[je]=0);const Ie=os(ve,te,le);$[me]=m(_[ye],E[Ie])}return[$,I]}}function Zj(m){const{inputs:d,backend:p}=m,{real:_,imag:E}=d,S=p.data.get(_.dataId).values,I=p.data.get(E.dataId).values,D=p.makeTensorInfo(_.shape,"complex64"),k=p.data.get(D.dataId);return k.complexTensorInfos={real:p.makeTensorInfo(_.shape,"float32",S),imag:p.makeTensorInfo(E.shape,"float32",I)},D}function ZR(m,d,p="float32"){if(p==="complex64"){const E=ZR(m,d,"float32"),S=ZR(m,d,"float32");return Zj({inputs:{real:E,imag:S},backend:m})}const _=oc(n(d),p);return m.makeTensorInfo(d,p,_)}function ZH(m){const{inputs:d,backend:p}=m,{x:_}=d;return p.incRef(_.dataId),{dataId:_.dataId,shape:_.shape,dtype:_.dtype}}const Zu={kernelName:c0,backendName:"cpu",kernelFunc:ZH};function ZX(m){const{inputs:d,backend:p}=m,{input:_}=d,E=p.data.get(_.dataId).complexTensorInfos.real,S=p.data.get(E.dataId).values;return p.makeTensorInfo(E.shape,E.dtype,S)}function Zf(m,d,p,_){if(_==="int32"){const E=Int32Array.from(m);return[d,"int32",E]}if(_==="bool"){const E=Gv([0],p),[S,I]=ZB((D,k)=>D!==k?1:0)(d,[],m,E,"bool");return[I,"bool",S]}throw new Error("Error in Cast: failed to cast "+p+" to "+_)}function Zy(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{dtype:S}=_;if(S==="complex64"){if(E.dtype==="complex64")return ZH({inputs:{x:E},backend:p});const $=ZR(p,E.shape,E.dtype),Z=Zy({inputs:{x:E},backend:p,attrs:{dtype:"float32"}}),te=Zj({inputs:{real:Z,imag:$},backend:p});return p.disposeIntermediateTensorInfo($),p.disposeIntermediateTensorInfo(Z),te}if(E.dtype==="complex64"){const $=ZX({inputs:{input:E},backend:p}),Z=Zy({inputs:{x:$},backend:p,attrs:{dtype:S}});return p.disposeIntermediateTensorInfo($),Z}if(!h(E.dtype,S)){const $=ZH({inputs:{x:E},backend:p});return{dataId:$.dataId,shape:$.shape,dtype:S}}const I=p.data.get(E.dataId).values,[D,k,V]=Zf(I,E.shape,E.dtype,S);return p.makeTensorInfo(D,k,V)}const ZE={kernelName:oB,backendName:"cpu",kernelFunc:Zy};function ZW(m,d,p,_){return p==null?({inputs:E,backend:S})=>{const{a:I,b:D}=E,k=S;Ze([I,D],m);const V=k.data.get(I.dataId).values,$=k.data.get(D.dataId).values,Z=I.dtype==="string"?QN(V):V,te=I.dtype==="string"?QN($):$,xe=_||I.dtype,[le,he]=d(I.shape,D.shape,Z,te,xe);return k.makeTensorInfo(he,xe,le)}:({inputs:E,backend:S})=>{const{a:I,b:D}=E,k=S;if(I.dtype==="complex64"||D.dtype==="complex64"){const V=Zy({inputs:{x:I},backend:k,attrs:{dtype:"complex64"}}),$=k.data.get(V.dataId),Z=$.complexTensorInfos.real,te=$.complexTensorInfos.imag,xe=k.data.get(Z.dataId).values,le=k.data.get(te.dataId).values,he=Zy({inputs:{x:D},backend:k,attrs:{dtype:"complex64"}}),de=k.data.get(he.dataId),me=de.complexTensorInfos.real,ge=de.complexTensorInfos.imag,be=k.data.get(me.dataId).values,ye=k.data.get(ge.dataId).values,[ve,Ie,je]=p(I.shape,D.shape,xe,le,be,ye),Me=k.makeTensorInfo(je,"float32",ve),xt=k.makeTensorInfo(je,"float32",Ie),bt=Zj({inputs:{real:Me,imag:xt},backend:k});return k.disposeIntermediateTensorInfo(V),k.disposeIntermediateTensorInfo(he),k.disposeIntermediateTensorInfo(Me),k.disposeIntermediateTensorInfo(xt),bt}else{const V=k.data.get(I.dataId).values,$=k.data.get(D.dataId).values,Z=_||I.dtype,[te,xe]=d(I.shape,D.shape,V,$,Z);return k.makeTensorInfo(xe,Z,te)}}}function Zd(m){return(d,p,_,E,S,I)=>{const D=CJ(d,p),k=n(D),V=D.length,$=o6(D),Z=M("float32",k),te=M("float32",k),xe=CM(d,D),le=CM(p,D),he=qm(_,E),de=qm(S,I),me=d.length,ge=o6(d),be=p.length,ye=o6(p);if(xe.length+le.length===0)for(let ve=0;ve<Z.length;ve++){const Ie=ve%he.length,je=ve%de.length,Me=m(he[Ie*2],he[Ie*2+1],de[je*2],de[je*2+1]);Z[ve]=Me.real,te[ve]=Me.imag}else for(let ve=0;ve<Z.length;ve++){const Ie=oz(ve,V,$),je=Ie.slice(-me);xe.forEach(Xt=>je[Xt]=0);const Me=os(je,me,ge),xt=Ie.slice(-be);le.forEach(Xt=>xt[Xt]=0);const bt=os(xt,be,ye),gt=m(he[Me*2],he[Me*2+1],de[bt*2],de[bt*2+1]);Z[ve]=gt.real,te[ve]=gt.imag}return[Z,te,D]}}const ZM=ZB((m,d)=>m+d),ZU=Zd((m,d,p,_)=>({real:m+p,imag:d+_})),ZJ=ZW(oD,ZM,ZU),Zt={kernelName:oD,backendName:"cpu",kernelFunc:ZJ};function Zv(m,d,p,_,E){const S=n(_),I=oc(E,p);for(let D=0;D<m.length;D++){const k=m[D];if(k<0)throw new Error("Input x must be non-negative!");k>=E||(S>0?I[k]+=d[D]:I[k]+=1)}return I}function Zh(m,d,p,_=!1){const E=m.shape[0],S=m.shape[1],I=K7([E,p],d.dtype);for(let D=0;D<E;D++)for(let k=0;k<S;k++){const V=m.get(D,k);if(V<0)throw new Error("Input x must be non-negative!");V>=p||(_?I.set(1,D,V):d.size>0?I.set(I.get(D,V)+d.get(D,k),D,V):I.set(I.get(D,V)+1,D,V))}return I}const ZY=ZB((m,d)=>m&d);function Zm(m){return(d,p,_)=>{const E=U(p,d.length);for(let S=0;S<d.length;++S)E[S]=m(d[S],_);return E}}function Zx(m,d,p){const _=Zm(d);return Zl(m,_,p)}function Zl(m,d,p){return({inputs:_,attrs:E,backend:S})=>{const{x:I}=_;Ze(I,m);const D=S,k=D.data.get(I.dataId).values;let V;if(I.dtype==="string"){if(!Array.isArray(k))throw new Error("String tensor's value was not an instance of Array");V=QN(k)}else V=k;const $=p||I.dtype,Z=d(V,$,E);return D.makeTensorInfo(I.shape,$,Z)}}const Zb=Zm(m=>Math.ceil(m));function Za(m,d,p,_){const E=U(p,n(d));if(_&&p!=="string"){let S=0;m.forEach(I=>{const D=n(I.shape);E.set(I.vals,S),S+=D})}else{let S=0;m.forEach(I=>{const D=p==="string"?QN(I.vals):I.vals;let k=0;for(let V=0;V<I.shape[0];++V){const $=V*d[1]+S;for(let Z=0;Z<I.shape[1];++Z)E[$+Z]=D[k++]}S+=I.shape[1]})}return E}const ZV=ZB((m,d)=>m===d?1:0),Zg=Zm(m=>Math.exp(m)),F0=Zm(m=>Math.expm1(m)),F1=Zm(m=>Math.floor(m)),F2=Zl(ol,F1),F3={kernelName:ol,backendName:"cpu",kernelFunc:F2},F4=ZB((m,d)=>Math.floor(m/d));function F5(m,d,p,_,E,S,I,D,k){const V=K7([_,S],p);for(let $=0;$<_;$++){const Z=[];let te=0;for(let xe=0;xe<E;xe++){const le=m[$*E+xe];te+=le*I[xe],Z.push(le)}if(te<0||te>=k/S)throw new Error("Invalid indices: "+Z+" does not index into "+D);for(let xe=0;xe<S;xe++)V.values[$*S+xe]=d.get(...d.indexToLoc(te*S+xe))}return V}function F6(m,d,p){const _=K7(p,m.dtype);for(let E=0;E<_.size;++E){const S=_.indexToLoc(E).slice(),I=S[0],D=S[2],k=d.locToIndex([I,D]);S[2]=d.values[k];const V=m.locToIndex(S);0<=V&&V<m.values.length&&(_.values[E]=m.values[V])}return _}const F7=ZB((m,d)=>m>d?1:0),F8=ZB((m,d)=>m>=d?1:0),F9=ZW(og,F8,null,"bool"),Fo={kernelName:og,backendName:"cpu",kernelFunc:F9},Fc=ZB((m,d)=>m<d?1:0),FG=ZW(c3,Fc,null,"bool"),Fs={kernelName:c3,backendName:"cpu",kernelFunc:FG},Fz=ZB((m,d)=>m<=d?1:0),FC=ZW(c4,Fz,null,"bool"),FL={kernelName:c4,backendName:"cpu",kernelFunc:FC};function FK(m,d,p){const _=(d-m)/(p-1),E=oc(p,"float32");E[0]=m;for(let S=1;S<E.length;S++)E[S]=E[S-1]+_;return E}const Fr=Zm(m=>Math.log(m));function FT(m,d,p,_){const E=M(_,n(p));for(let S=0;S<E.length;++S){const I=S*d;let D=m[I];for(let k=0;k<d;++k){const V=m[I+k];(Number.isNaN(V)||V>D)&&(D=V)}E[S]=D}return E}const Fq=ZB((m,d)=>Math.max(m,d)),FQ=ZW(c8,Fq),Fk={kernelName:c8,backendName:"cpu",kernelFunc:FQ},Fp=ZB((m,d)=>Math.min(m,d)),Fw=ZW(cG,Fp),FA={kernelName:cG,backendName:"cpu",kernelFunc:Fw},FZ=ZB((m,d)=>m*d),FF=Zd((m,d,p,_)=>({real:m*p-d*_,imag:m*_+d*p})),FN=ZW(cs,FZ,FF),FO={kernelName:cs,backendName:"cpu",kernelFunc:FN};function FD(m,d,p){const _=GJ(-1,p);return FZ([],d,_,m,p)}function Fn(m){const{inputs:d,backend:p}=m,{x:_}=d;Ze(_,"neg");const E=p.data.get(_.dataId).values,[S,I]=FD(E,_.shape,_.dtype);return p.makeTensorInfo(I,_.dtype,S)}const Fi={kernelName:cz,backendName:"cpu",kernelFunc:Fn},Fe=ZB((m,d)=>m!==d?1:0);function FP(m,d,p,_,E){const S=d.length,I=n(d),D=o6(d),k=o6(E),V=M(p,n(E));for(let $=0;$<I;++$){const Z=oz($,S,D),te=new Array(Z.length);for(let le=0;le<te.length;le++)te[le]=Z[_[le]];const xe=os(te,S,k);V[xe]=m[$]}return V}function FS(m){const{inputs:d,attrs:p,backend:_}=m,{x:E}=d,{perm:S}=p;Ze(E,"transpose");const I=E.shape.length,D=new Array(I);for(let $=0;$<D.length;$++)D[$]=E.shape[S[$]];const k=_.data.get(E.dataId).values,V=FP(k,E.shape,E.dtype,S,D);return{dataId:_.write(V,D,E.dtype),shape:D,dtype:E.dtype}}const FI={kernelName:cy,backendName:"cpu",kernelFunc:FS};function FB(m,d,p,_){const[E,S]=KB(m,_),I=sA(d,"int32"),D=oc(n(E),I),k=n(S);for(let V=0;V<D.length;++V){const $=V*k;let Z=1;for(let te=0;te<k;++te)Z*=p[$+te];D[V]=Z}return{outVals:D,outShape:E,outDtype:I}}function Fj(m,d,p){m.forEach((_,E)=>{if(_<0||_>=p){const S=oz(E,d.length,o6(d)).join(",");throw new Error("indices["+S+"] = "+_+" is not in [0, "+p+")")}})}function FR(m,d){for(let p=0;p<m.length;++p){const _=m[p],E=p===m.length-1?d:m[p+1].length;if(_.length===0)throw new Error("Ragged splits may not be empty");if(_[0]<0)throw new Error("Ragged splits must be non-negative");if(_[_.length-1]>E)throw new Error("Ragged splits must not point past values");for(let S=1;S<_.length;++S)if(_[S-1]>_[S])throw new Error("Ragged splits must be sorted in ascending order")}}function FH(m,d,p,_){const E=[];let S=0;const I=d.length-1+p.length,D=new Array(I).fill(null).map(()=>[0]);FR(p,_);let k=1;for(let V=0;V<d.length-1;++V){k*=d[V];const $=d[V+1];for(let Z=1;Z<k+1;++Z)D[V].push(Z*$)}for(let V=0;V<m.length;++V){let $=m[V],Z=m[V]+1;for(let te=0;te<p.length;++te){const xe=p[te],le=te+d.length-1;if(le>=0){const he=D[le],de=he[he.length-1]-xe[$];for(let me=$;me<Z;++me)D[le].push(xe[me+1]+de)}$=xe[$],Z=xe[Z]}Z!==$&&(E.push([$,Z]),S+=Z-$)}return{outSplits:D,valueSlices:E,numValues:S}}function Fu(m){const d=[];for(let p=0;p<m.length;++p){const _=m[p].length,E=U("int32",_);d.push(E),m[p].forEach((S,I)=>E[I]=S)}return d}function FX(m,d){const p=m.slice(0,d);for(;p.length<d;)p.push(1);for(let _=d;_<m.length;_++)p[d-1]*=m[_];return p}function Ff(m,d,p,_,E,S){const I=FX(d,2)[1],D=FX(S,2)[1];let k=0;for(const V of p)for(let $=V[0];$<V[1];++$){for(let Z=0;Z<_;++Z)E[k*D+Z]=m[$*I+Z];++k}}function Fy(m,d,p,_,E){const S=d.slice();S[0]=E;const I=U(p,n(S)),D=m.length,k=D===0?0:D/d[0];return Ff(m,d,_,k,I,S),[I,S]}function FE(m,d,p,_,E,S,I,D){if(m.length===0)throw new Error("paramsNestedSplits must be non empty");if(d[0].length===0)throw new Error("Split tensors must not be scalars");const k=d[0][0]-1;if(Fj(S,I,k),_.length===0)throw new Error("params.rank must be nonzero");const V=_[0],{outSplits:$,valueSlices:Z,numValues:te}=FH(S,I,m,V),xe=Fu($),le=Fy(p,_,E,Z,te);return[xe,le[0],le[1]]}const FW=2147483647;function Fd(m,d,p,_,E,S,I){if(d.length>1)throw new Error("starts must be a scalar or vector");if(E.length>1)throw new Error("limits must be a scalar or vector");if(I.length>1)throw new Error("deltas must be a scalar or vector");const D=d.length===0,k=E.length===0,V=I.length===0,$=[];D||$.push(d[0]),k||$.push(E[0]),V||$.push(I[0]);for(let de=1;de<$.length;++de)if($[de]!==$[de-1])throw new Error("starts, limits, and deltas must have the same shape");const Z=$.length===0?1:$[0],te=U("int32",Z+1);te[0]=0;for(let de=0;de<Z;++de){const me=D?m[0]:m[de],ge=k?_[0]:_[de],be=V?S[0]:S[de];if(be===0)throw new Error("Requires delta != 0");let ye;if(be>0&&ge<me||be<0&&ge>me)ye=0;else if(ye=Math.ceil(Math.abs((ge-me)/be)),ye>FW)throw new Error("Requires ((limit - start) / delta) <= "+FW);te[de+1]=te[de]+ye}const xe=te[Z],le=U(p,xe);let he=0;for(let de=0;de<Z;++de){const me=te[de+1]-te[de];let ge=D?m[0]:m[de];const be=V?S[0]:S[de];for(let ye=0;ye<me;++ye)le[he++]=ge,ge+=be}return[te,le]}var FM=qP;class FU{constructor(d,p,_,E,S,I,D,k,V,$){this.shape=d,this.shapeShape=p,this.values=_,this.valuesShape=E,this.valuesDType=S,this.defaultValue=I,this.defaultValueShape=D,this.rowPartitionValues=k,this.rowPartitionValuesShapes=V,this.rowPartitionTypes=qI($),this.raggedRank=qB(this.rowPartitionTypes)}getRowPartitionTypeByDimension(d){return this.rowPartitionTypes[0]===FM.FIRST_DIM_SIZE?this.rowPartitionTypes[d+1]:this.rowPartitionTypes[d]}getRowPartitionTensor(d){return this.rowPartitionTypes[0]===FM.FIRST_DIM_SIZE?this.rowPartitionValues[d+1]:this.rowPartitionValues[d]}getMaxWidth(d){const p=this.getRowPartitionTensor(d-1);switch(this.getRowPartitionTypeByDimension(d-1)){case FM.VALUE_ROWIDS:return FU.getMaxWidthValueRowID(p);case FM.ROW_SPLITS:return FU.getMaxWidthRowSplit(p);default:throw new Error("Cannot handle partition type "+FM[this.getRowPartitionTypeByDimension(d-1)])}}static getMaxWidthRowSplit(d){const p=d.length;if(p===0||p===1)return 0;let _=0;for(let E=0;E<p-1;++E){const S=d[E+1]-d[E];S>_&&(_=S)}return _}static getMaxWidthValueRowID(d){const p=d.length;if(p===0)return 0;let _=0,E=d[0],S=0;for(let I=1;I<p;++I){const D=d[I];D!==E&&(E=D,S=Math.max(I-_,S),_=I)}return Math.max(p-_,S)}tensorShapeFromTensor(d,p,_=!0){if(p.length===0){if(d[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Ft(d,_)}calculateOutputSize(d){const p=this.valuesShape,_=this.defaultValueShape;qj(_,p);const E=this.tensorShapeFromTensor(this.shape,this.shapeShape),S=qS(this.raggedRank,E,p);S[0]<0&&(S[0]=d);for(let I=1;I<=this.raggedRank;++I)S[I]<0&&(S[I]=this.getMaxWidth(I));return S}calculateFirstParentOutputIndex(d,p,_){const E=Math.min(d,_),S=[];let I=0;for(let D=0;D<E;++D,I+=p)S.push(I);for(let D=E;D<d;++D)S.push(-1);return A(S.length===d,()=>"Final length of result must be equal to firstDimension."),S}calculateOutputIndexRowSplit(d,p,_,E){const S=d.length,I=[];for(let D=0;D<S-1;++D){const k=d[D+1]-d[D];let V=Math.min(E,k),$=p[D];$===-1&&(V=0);for(let Z=0;Z<V;++Z)I.push($),$+=_;for(let Z=0;Z<k-V;++Z)I.push(-1)}if(S>0&&I.length!==d[S-1])throw new Error("Invalid row split size.");return I}calculateOutputIndexValueRowID(d,p,_,E){const S=d.length,I=[];if(S===0)return[];let D=0,k=d[0];if(k>=p.length)throw new Error("Got currentValueRowId="+k+", which is not less than "+p.length);let V=p[k];I.push(V);for(let $=1;$<S;++$){const Z=d[$];if(Z===k)V>=0&&(++D,D<E?V+=_:V=-1);else{if(D=0,k=Z,Z>=p.length)throw new Error("Got nextValueRowId="+Z+" which is not less than "+p.length);V=p[Z]}I.push(V)}if(I.length!==d.length)throw new Error("Invalid row ids.");return I}calculateOutputIndex(d,p,_,E){const S=this.getRowPartitionTensor(d),I=this.getRowPartitionTypeByDimension(d);switch(I){case FM.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(S,p,_,E);case FM.ROW_SPLITS:if(S.length-1>p.length)throw new Error("Row partition size is greater than output size: "+(S.length-1)+" > "+p.length);return this.calculateOutputIndexRowSplit(S,p,_,E);default:throw new Error("Unsupported partition type: "+FM[I])}}getFirstDimensionSize(){const d=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const p=this.rowPartitionTypes[0];switch(p){case FM.FIRST_DIM_SIZE:return d[0];case FM.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case FM.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+FM[p])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const d=this.getFirstDimensionSize(),p=this.calculateOutputSize(d),_=new Array(this.raggedRank+1);_[_.length-1]=1;for(let I=_.length-2;I>=0;--I)_[I]=_[I+1]*p[I+1];const E=Ft(p,!1),S=U(this.valuesDType,n(E));if(_[0]*p[0]>0){let I=this.calculateFirstParentOutputIndex(d,_[0],p[0]);for(let D=1;D<=this.raggedRank;++D)I=this.calculateOutputIndex(D-1,I,_[D],p[D]);this.setOutput(this.raggedRank,I,S,E)}return[E,S]}setOutput(d,p,_,E){if(_.length===0)return;const S=this.values,I=_;let D=E.slice();D=D.slice(d+1);const k=n(D),V=p.length;let $=this.defaultValue;if($.length!==k&&$.length!==1){const le=this.defaultValueShape;sV(()=>{const he=Lv($,le);$=K6(he,D).dataSync()})}let Z=0,te=0,xe=0;for(let le=0;le<=V;++le){let he=le<V?p[le]:-1;if(he===xe){++xe;continue}if(te<xe){const de=S.subarray(Z*k),me=I.subarray(te*k),ge=(xe-te)*k;FJ(me,de,ge)}if(le>=V){const de=_.length;he=Math.floor(de/k)}if(he>xe)if(this.defaultValue.length===1)I.subarray(xe*k,he*k).fill(this.defaultValue[0]),xe=he;else for(;he>xe;){const de=I.slice(xe*k);FJ(de,$,k),++xe}he<0?(Z=le+1,te=xe):(Z=le,te=xe,xe=te+1)}}}function FJ(m,d,p){for(let _=0;_<p;_++)m[_]=d[_]}function Ft(m,d){const p=[];for(let _ of m){if(_<0){if(!d)throw new Error("Dimension "+_+" must be >= 0");if(_<-1)throw new Error("Dimension "+_+" must be >= -1");_=-1}p.push(_)}return p}function Fv(m,d,p,_,E,S,I,D,k,V){return new FU(m,d,p,_,E,S,I,D,k,V).compute()}function Fh(m,d,p,_){const E=m===d,S=m<d&&p<0,I=d<m&&p>1;if(E||S||I)return oc(0,_);const D=Math.abs(Math.ceil((d-m)/p)),k=oc(D,_);d<m&&p===1&&(p=-1),k[0]=m;for(let V=1;V<k.length;V++)k[V]=k[V-1]+p;return k}const FY=Zm(m=>1/Math.sqrt(m));function Fm(m,d,p,_,E,S,I,D,k,V){const $=[_/E,E],Z=m.values,te=d.values;if(_===0)return K7(p,d.dtype);const xe=k instanceof so?k:K7($,d.dtype);typeof k=="string"||typeof k=="number"?xe.values.fill(k):typeof k=="boolean"&&xe.values.fill(+k);for(let le=0;le<S;le++){const he=[];let de=0;for(let me=0;me<I;me++){const ge=Z[le*I+me];he.push(ge),de+=ge*D[me]}if(de<0||de>=_/E)throw new Error("Invalid indices: "+he+" does not index into "+p);for(let me=0;me<E;me++)V?xe.values[de*E+me]+=te[le*E+me]:xe.values[de*E+me]=d.rank===0?te[0]:te[le*E+me]}return xe}const Fx=Zm(m=>1/(1+Math.exp(-m))),Fl=Zx(cP,m=>1/(1+Math.exp(-m))),Fb={kernelName:cP,backendName:"cpu",kernelFunc:Fl};function Fa(m,d,p,_,E){const S=Lc(_,d,p),I=n(p),D=o6(_);if(S){const Z=LG(d,D);return E==="string"?m.slice(Z,Z+I):m.subarray(Z,Z+I)}const k=E==="string"?QN(m):m,V=K7(_,E,k),$=K7(p,E);for(let Z=0;Z<$.size;++Z){const te=$.indexToLoc(Z),xe=te.map((le,he)=>le+d[he]);$.set(V.get(...xe),...te)}return E==="string"?QO($.values):$.values}function FV(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{begin:S,size:I}=_;Ze(E,"slice");const[D,k]=Ls(E,S,I);Cg(E,D,k);const V=p.data.get(E.dataId).values,$=Fa(V,D,k,E.shape,E.dtype);return p.makeTensorInfo(k,E.dtype,$)}const Fg={kernelName:ci,backendName:"cpu",kernelFunc:FV};function N0(m,d,p,_,E,S,I){const D=d[0],k=S[0],V=new Array(k),$=new Array(D),Z=d[1];if(k===0){if(D!==0)throw new Error(QG(D));const de=U(p,0),me=U(E,0);return[de,[0,Z],me,V,$]}let te=!0,xe=0;const le=new Array(k).fill(0);for(let de=0;de<D;++de){const me=m[de*Z];if(me<0)throw new Error(Qs(de,me));if(me>=k)throw new Error(Qz(de,me,k));++le[me],te=te&&me>=xe,xe=me}let he=!0;for(let de=0;de<k;++de){const me=le[de]===0;V[de]=me,he=he&&!me,le[de]=Math.max(le[de],1),de>0&&(le[de]+=le[de-1])}if(he&&te){const de=m,me=_;for(let ge=0;ge<D;++ge)$[ge]=ge;return[de,[D,Z],me,V,$]}else{const de=le[k-1],me=U(p,de*Z),ge=U(E,de),be=new Array(k).fill(0);for(let ye=0;ye<D;++ye){const ve=m[ye*Z],Ie=be[ve],je=(ve===0?0:le[ve-1])+Ie;be[ve]++;for(let Me=0;Me<Z;++Me)me[je*Z+Me]=m[ye*Z+Me];ge[je]=_[ye],$[ye]=je}for(let ye=0;ye<k;++ye)if(be[ye]===0){const ve=ye===0?0:le[ye-1];me[ve*Z+0]=ye;for(let Ie=1;Ie<Z;++Ie)me[ve*Z+Ie]=0;ge[ve]=I}return[me,[de,Z],ge,V,$]}}function N1(m,d,p,_,E){const S=n(_),I=d[0],D=E.length,k=[];let V=1,$=-1;for(let he=0;he<D;++he){const de=E[he];if(de===-1){if($!==-1)throw new Error(QC($,he));$=he,k.push(1)}else{if(de<0)throw new Error(QL(he,de));V*=de,k.push(de)}}if($!==-1){if(V<=0)throw new Error(QK());const he=Math.trunc(S/V);if(V*he!==S)throw new Error(Qr(_,k));k[$]=he}if(n(k)!==S)throw new Error(QT(_,k));const Z=_.length,te=[];if(Z>0){te[Z-1]=1;for(let he=Z-2;he>=0;--he)te[he]=te[he+1]*_[he+1]}const xe=[];if(D>0){xe[D-1]=1;for(let he=D-2;he>=0;--he)xe[he]=xe[he+1]*k[he+1]}const le=U(p,I*D);for(let he=0;he<I;++he){let de=0;for(let me=0;me<Z;++me)de+=m[he*Z+me]*te[me];for(let me=0;me<D;++me)le[he*D+me]=Math.trunc(de/xe[me]),de%=xe[me]}return[le,[I,D],k]}function N2(m,d,p,_,E,S=!1,I=0){const D=_.length,k=[d[0],m.length/d[0]],V=k[1],$=D>0?E[D-1]+1:0;if($<0)throw new Error(Qq());const Z=d.slice();Z[0]=$;const te=Z.reduce((ge,be)=>ge*be,1),xe=U(p,te);if(D===0)return $>0&&xe.fill(I),[xe,Z];if($<=0)throw new Error(Qq());let le=0,he=1,de=0,me=E[le];for(;;){let ge=0;if(he<D){if(ge=E[he],me===ge){++he;continue}if(me>=ge)throw new Error(QQ())}if(me<0||me>=$)throw new Error(Qk(me,$));me>de&&xe.fill(I,de*V,me*V);for(let be=le;be<he;++be){const ye=_[be];if(ye<0||ye>=k[0])throw new Error(Qp(be,_[be],k[0]));for(let ve=0;ve<V;ve++)xe[me*V+ve]+=m[ye*V+ve]}if(S)for(let be=0;be<V;be++)xe[me*V+be]/=he-le;if(le=he,++he,de=me+1,me=ge,he>D)break}return de<$&&xe.fill(I,de*V,$*V),[xe,Z]}const N3=Zm(m=>Math.sqrt(m)),N4=Zx(cS,m=>Math.sqrt(m)),N5={kernelName:cS,backendName:"cpu",kernelFunc:N4},N6=ZB((m,d)=>{const p=m-d;return p*p}),N7=Zm((m,d)=>{const{pattern:p,replaceGlobal:_,rewrite:E}=d;return m.replace(new RegExp(p,_?"g":""),E)});function N8(m,d,p,_){const E=K7(m,d.dtype);for(let S=0;S<E.size;S++){const I=E.indexToLoc(S),D=new Array(I.length);for(let k=0;k<D.length;k++)D[k]=I[k]*p[k]+_[k];E.set(d.get(...D),...I)}return E}class N9{constructor(d,p,_,E,S,I){this.separator=GY(d),this.nGramWidths=p,this.leftPad=GY(_),this.rightPad=GY(E),this.padWidth=S,this.preserveShort=I}getPadWidth(d){return Math.min(this.padWidth<0?d-1:this.padWidth,d-1)}getNumNGrams(d,p){const _=this.getPadWidth(p);return Math.max(0,d+2*_-p+1)}createNGrams(d,p,_,E,S,I){for(let D=0;D<S;++D){const k=this.getPadWidth(I),V=Math.max(0,k-D),$=Math.max(0,k-(S-(D+1))),Z=I-(V+$),te=p+(V>0?0:D-k);let xe=0;xe+=V*this.leftPad.length;for(let ge=0;ge<Z;++ge)xe+=d[te+ge].length;xe+=$*this.rightPad.length;const le=V+$+Z-1;xe+=le*this.separator.length,_[E+D]=new Uint8Array(xe);const he=_[E+D];let de=0;const me=ge=>ge.forEach(be=>he[de++]=be);for(let ge=0;ge<V;++ge)me(this.leftPad),me(this.separator);for(let ge=0;ge<Z-1;++ge)me(d[te+ge]),me(this.separator);if(Z>0){me(d[te+Z-1]);for(let ge=0;ge<$;++ge)me(this.separator),me(this.rightPad)}else{for(let ge=0;ge<$-1;++ge)me(this.rightPad),me(this.separator);me(this.rightPad)}}}compute(d,p){const _=d.length,E=p.length;if(E>0){let k=p[0];if(k!==0)throw new Error("First split value must be 0, got "+k);for(let V=1;V<E;++V){let $=p[V]>=k;if($=$&&p[V]<=_,!$)throw new Error("Invalid split value "+p[V]+", must be in ["+k+", "+_+"]");k=p[V]}if(k!==_)throw new Error("Last split value must be data size. Expected "+_+", got "+k)}const S=E-1,I=U("int32",E);if(_===0||E===0){const k=new Array(_);for(let V=0;V<=S;++V)I[V]=0;return[k,I]}I[0]=0;for(let k=1;k<=S;++k){const V=p[k]-p[k-1];let $=0;this.nGramWidths.forEach(Z=>{$+=this.getNumNGrams(V,Z)}),this.preserveShort&&V>0&&$===0&&($=1),I[k]=I[k-1]+$}const D=new Array(I[S]);for(let k=0;k<S;++k){const V=p[k];let $=I[k];if(this.nGramWidths.forEach(Z=>{const te=p[k+1]-p[k],xe=this.getNumNGrams(te,Z);this.createNGrams(d,V,D,$,xe,Z),$+=xe}),this.preserveShort&&$===I[k]){const Z=p[k+1]-p[k];if(Z===0)continue;const te=Z+2*this.padWidth;this.createNGrams(d,V,D,$,1,te)}}return[D,I]}}function No(m,d,p,_,E,S,I,D){return new N9(p,_,E,S,I,D).compute(m,d)}function Nc(m,d,p,_){if(!m.length)return;if(d.length===0){for(let S=0;S<m.length;++S)_.push(m.subarray(S,S+1));return}if(d.length===1){const S=d[0];let I=m.indexOf(S);for(;I!==-1;){const D=m.subarray(0,I);(!p||D.length!==0)&&_.push(D),m=m.subarray(I+1),I=m.indexOf(S)}(!p||m.length!==0)&&_.push(m);return}let E=0;for(let S=0;S<m.length+1;S++)if(S===m.length||d.indexOf(m[S])!==-1){const I=m.subarray(E,S);(!p||I.length!==0)&&_.push(I),E=S+1}}function NG(m,d,p){const _=m.length,E=[];let S=0,I=0;const D=new Array(_);for(let te=0;te<_;++te){const xe=E.length;Nc(m[te],d,p,E);const le=E.length-xe;D[te]=le,S+=le,I=Math.max(I,le)}const k=U("int32",S*2),V=new Array(S),$=[_,I];let Z=0;for(let te=0;te<_;++te)for(let xe=0;xe<D[te];++xe)k[Z*2]=te,k[Z*2+1]=xe,V[Z]=E[Z],++Z;return[k,V,$]}function Ns(m,d){const p=U("int32",m.length);for(let _=0;_<m.length;++_)p[_]=GU(m[_]).modulo(d).getLowBitsUnsigned();return p}const Nz=ZB((m,d)=>m-d),NC=Zd((m,d,p,_)=>({real:m-p,imag:d-_})),NL=ZW(cu,Nz,NC),NK={kernelName:cu,backendName:"cpu",kernelFunc:NL};function Nr(m,d){const p=new Array(m.rank);for(let E=0;E<p.length;E++)p[E]=m.shape[E]*d[E];const _=K7(p,m.dtype);for(let E=0;E<_.values.length;++E){const S=_.indexToLoc(E),I=new Array(m.rank);for(let k=0;k<I.length;k++)I[k]=S[k]%m.shape[k];const D=m.locToIndex(I);_.values[E]=m.values[D]}return _}const NT=(m,d)=>{const p=d.value-m.value;return p===0?m.index-d.index:p};function Nq(m,d,p=0,_=m.length-1){for(;_>p;){if(_-p>600){const D=_-p+1,k=d-p+1,V=Math.log(D),$=.5*Math.exp(2*V/3),Z=.5*Math.sqrt(V*$*(D-$)/D)*Math.sign(k-D/2),te=Math.max(p,Math.floor(d-k*$/D+Z)),xe=Math.min(_,Math.floor(d+(D-k)*$/D+Z));Nq(m,d,te,xe)}const E=m[d];let S=p,I=_;for(q(m,p,d),NT(m[_],E)>0&&q(m,p,_);S<I;){for(q(m,S,I),S++,I--;NT(m[S],E)<0;)S=S+1;for(;NT(m[I],E)>0;)I=I-1}NT(m[p],E)===0?q(m,p,I):(I=I+1,q(m,I,_)),I<=d&&(p=I+1),d<=I&&(_=I-1)}}function NQ(m,d,p,_,E){const S=d[d.length-1],[I,D]=[m.length/S,S],k=M(p,I*_),V=M("int32",I*_);for(let Z=0;Z<I;Z++){const te=Z*D,xe=m.subarray(te,te+D);let le=new Array(xe.length);xe.forEach((ge,be)=>le[be]={value:ge,index:be}),_<le.length&&(Nq(le,_),le=le.slice(0,_)),E&&le.sort(NT);const he=Z*_,de=k.subarray(he,he+_),me=V.subarray(he,he+_);for(let ge=0;ge<_;ge++)de[ge]=le[ge].value,me[ge]=le[ge].index}const $=d.slice();return $[$.length-1]=_,[K7($,p,k),K7($,"int32",V)]}function Nk(m,d,p,_){const E=X(d,p)[0],S=[1,p[0],1];for(let le=0;le<E;le++)S[0]*=p[le];S[1]=p[E];for(let le=E+1;le<p.length;le++)S[2]*=p[le];const I=new Map,D=new Int32Array(p[E]),k=new so(S,_,m),V=[],$=S[0]===1&&S[2]===1;for(let le=0;le<p[E];le++){let he;if($)he=m[le].toString();else{const me=[];for(let ge=0;ge<S[0];ge++)for(let be=0;be<S[2];be++)me.push(k.get(ge,le,be));he=me.join(",")}const de=I.get(he);if(de!=null)D[le]=de;else{const me=I.size;I.set(he,me),D[le]=me,V.push(le)}}const Z=S.slice();Z[1]=I.size;const te=new so(Z,_);V.forEach((le,he)=>{for(let de=0;de<S[0];de++)for(let me=0;me<S[2];me++)te.set(k.get(de,le,me),de,he,me)});const xe=p.slice();return xe[E]=Z[1],{outputValues:te.values,outputShape:xe,indices:D}}var Np=Object.freeze({__proto__:null,addImpl:ZM,bincountImpl:Zv,bincountReduceImpl:Zh,bitwiseAndImpl:ZY,castImpl:Zf,ceilImpl:Zb,concatImpl:Za,equalImpl:ZV,expImpl:Zg,expm1Impl:F0,floorDivImpl:F4,floorImpl:F1,gatherNdImpl:F5,gatherV2Impl:F6,greaterEqualImpl:F8,greaterImpl:F7,lessEqualImpl:Fz,lessImpl:Fc,linSpaceImpl:FK,logImpl:Fr,maxImpl:FT,maximumImpl:Fq,minimumImpl:Fp,multiplyImpl:FZ,negImpl:FD,notEqualImpl:Fe,prodImpl:FB,raggedGatherImpl:FE,raggedRangeImpl:Fd,raggedTensorToTensorImpl:Fv,rangeImpl:Fh,rsqrtImpl:FY,scatterImpl:Fm,sigmoidImpl:Fx,simpleAbsImpl:ZP,sliceImpl:Fa,sparseFillEmptyRowsImpl:N0,sparseReshapeImpl:N1,sparseSegmentReductionImpl:N2,sqrtImpl:N3,squaredDifferenceImpl:N6,staticRegexReplaceImpl:N7,stridedSliceImpl:N8,stringNGramsImpl:No,stringSplitImpl:NG,stringToHashBucketFastImpl:Ns,subImpl:Nz,tileImpl:Nr,topKImpl:NQ,transposeImpl:FP,uniqueImpl:Nk});const{addImpl:Nw,bincountImpl:NA,bincountReduceImpl:NZ,bitwiseAndImpl:NF,castImpl:NN,ceilImpl:NO,concatImpl:ND,equalImpl:Nn,expImpl:Ni,expm1Impl:Ne,floorImpl:NP,gatherNdImpl:NS,gatherV2Impl:NI,greaterImpl:NB,greaterEqualImpl:Nj,lessImpl:NR,lessEqualImpl:NH,linSpaceImpl:Nu,logImpl:NX,maxImpl:Nf,maximumImpl:Ny,minimumImpl:NE,multiplyImpl:NW,negImpl:Nd,notEqualImpl:NM,prodImpl:NU,raggedGatherImpl:NJ,raggedRangeImpl:Nv,raggedTensorToTensorImpl:Nh,rangeImpl:NY,rsqrtImpl:Nm,scatterImpl:Nx,sigmoidImpl:Nl,simpleAbsImpl:Nb,sliceImpl:Na,sparseFillEmptyRowsImpl:NV,sparseReshapeImpl:Ng,sparseSegmentReductionImpl:O0,sqrtImpl:O1,staticRegexReplaceImpl:O2,stridedSliceImpl:O3,stringNGramsImpl:O4,stringSplitImpl:O5,stringToHashBucketFastImpl:O6,subImpl:O7,tileImpl:O8,topKImpl:O9,transposeImpl:Oo,uniqueImpl:Oc}=Np;function OG(m,d){return["x","y","z","w","u","v"].slice(0,d).map(p=>m+"."+p)}function Os(m,d){return d===1?[m]:OG(m,d)}function Oz(m,d){if(m===1)return"rc";let p="";for(let _=0;_<m;_++)p+=d[_],_<m-1&&(p+=",");return p}class OC{constructor(d){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=d,this.rank=d.length,this.enableShapeUniforms=Z1(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const p=Os("rc",this.rank),_=AY(this.rank),E=this.getOutOfBoundsCondition(p),S=this.getSetup(p),I=this.getOutput(p);this.userCode=`
        void main() {
          `+_+` rc = getOutputCoords();

          if(`+E+`) {
            setOutput(vec4(0));
          } else {
            `+S+`

            setOutput(vec4(`+I+`));
          }
        }
      `}}getSourceCoordsArr(d){const p=[];for(let _=0;_<=1;_++)for(let E=0;E<=1;E++){let S=(_===0?"r":"rp1")+", "+(E===0?"c":"cp1");for(let I=2;I<this.rank;I++)S=d[d.length-1-I]+","+S;p.push(S)}return p}getOutOfBoundsCondition(d){if(this.rank===1)return"rc > "+(this.enableShapeUniforms?"outShape":this.outputShape[0]);let p="";for(let _=this.rank-2;_<this.rank;_++)p+=d[_]+" >= "+(this.enableShapeUniforms?"outShape["+_+"]":this.outputShape[_]),_<this.rank-1&&(p+="||");return p}getSetup(d){if(this.rank===1)return"";const p=d.slice(-2),_=this.enableShapeUniforms?"outShape["+this.rank+" - 1]":this.outputShape[this.rank-1],E=this.enableShapeUniforms?"outShape["+this.rank+" - 2]":this.outputShape[this.rank-2];return`
      int r = `+p[0]+`;
      int c = `+p[1]+`;
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= `+_+`;
      bool rEdge = rp1 >= `+E+`;
    `}getOutput(d){const p=this.getSourceCoordsArr(d);return this.rank===1?"getA(rc), (rc + 1 >= "+(this.enableShapeUniforms?"outShape":this.outputShape[0])+" ? 0. : getA(rc + 1)), 0, 0":"getA("+p[0]+`),
            cEdge ? 0. : getA(`+p[1]+`),
            rEdge ? 0. : getA(`+p[2]+`),
            rEdge || cEdge ? 0. : getA(`+p[3]+")"}}class OL{constructor(d,p){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=d,this.enableShapeUniforms=Z1(this.outputShape.length);let _="";for(let E=0;E<4;E++){let S="thisRC = rc;";E%2===1&&(S+="thisRC.z += 1;"),E>1&&(S+="thisRC.y += 1;"),_+=`
        `+S+`
        `+(E>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+`
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[`+E+`] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        `+(E>0?"}":"")+`
      `}this.userCode=`
      `+OK(p,this.enableShapeUniforms)+`
      `+(this.enableShapeUniforms?Ao():A9(d))+`

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = `+(this.enableShapeUniforms?"outShape[1]":d[1])+`;
        int cols = `+(this.enableShapeUniforms?"outShape[2]":d[2])+`;

        `+_+`

        setOutput(result);
      }
    `}}function OK(m,d){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      `+(d?A8(["r","c","d"],"inputShape"):A5(["r","c","d"],m))+`
      return ivec3(r, c, d);
    }
  `}class Or{constructor(d){this.gpgpu=d,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(d,p,_){const E=Op(p,_),S=Ow(d,E,_);S in this.freeTextures||(this.freeTextures[S]=[]),S in this.usedTextures||(this.usedTextures[S]=[]);const I=Oq(d,E,this.gpgpu.gl,this.gpgpu.textureConfig,_);if(this.freeTextures[S].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=I,this.log();const k=this.freeTextures[S].pop();return this.usedTextures[S].push(k),k}let D;return E===w9.PACKED_2X2_FLOAT32?D=this.gpgpu.createPackedMatrixTexture(d[0],d[1]):E===w9.PACKED_2X2_FLOAT16?D=this.gpgpu.createFloat16PackedMatrixTexture(d[0],d[1]):E===w9.UNPACKED_FLOAT32?D=this.gpgpu.createFloat32MatrixTexture(d[0],d[1]):E===w9.UNPACKED_FLOAT16?D=this.gpgpu.createFloat16MatrixTexture(d[0],d[1]):E===w9.PACKED_4X1_UNSIGNED_BYTE&&(D=this.gpgpu.createUnsignedBytesMatrixTexture(d[0],d[1])),this.usedTextures[S].push(D),this.numUsedTextures++,this._numBytesAllocated+=I,this.log(),D}releaseTexture(d,p,_,E){if(this.freeTextures==null)return;const S=Op(_,E),I=Ow(p,S,E);I in this.freeTextures||(this.freeTextures[I]=[]);const D=Oq(p,S,this.gpgpu.gl,this.gpgpu.textureConfig,E),k=oQ().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");k!==-1&&this._numBytesAllocated>k?(this.gpgpu.deleteMatrixTexture(d.texture),this._numBytesAllocated-=D):(this.freeTextures[I].push(d),this.numFreeTextures++,this._numBytesFree+=D),this.numUsedTextures--;const V=this.usedTextures[I],$=V&&V.indexOf(d);if($==null||$<0)throw new Error("Cannot release a texture that was never provided by this texture manager");V[$]=V[V.length-1],V.pop(),this.log()}log(){if(!this.logEnabled)return;const d=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+d+")");const p=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log("Bytes unused: "+this._numBytesFree+" ("+Math.round(100*p)+"%)")}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const d in this.freeTextures)this.freeTextures[d].forEach(p=>{this.gpgpu.deleteMatrixTexture(p.texture)});for(const d in this.usedTextures)this.usedTextures[d].forEach(p=>{this.gpgpu.deleteMatrixTexture(p.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function OT(m,d){const p=m;if(d===p.R32F)return 4;if(d===p.R16F)return 2;if(d===p.RGBA32F||d===m.RGBA)return 16;if(d===p.RGBA16F)return 8;if(d===p.RGBA8)return 4;throw new Error("Unknown internal format "+d)}function Oq(m,d,p,_,E){const S=OQ(d,_);let I;if(E){const[k,V]=ws(m[0],m[1]);I=k*V}else{const[k,V]=wo(m[0],m[1]);I=k*V}const D=OT(p,S);return I*D}function OQ(m,d){switch(m){case w9.PACKED_2X2_FLOAT32:return ZT(d);case w9.PACKED_2X2_FLOAT16:return ZQ(d);case w9.UNPACKED_FLOAT32:return Zs(d);case w9.UNPACKED_FLOAT16:return ZC(d);case w9.PACKED_4X1_UNSIGNED_BYTE:return ZK(d);default:throw new Error("Unknown physical texture type "+m)}}function Ok(m){return oQ().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?m?w9.PACKED_2X2_FLOAT32:w9.UNPACKED_FLOAT32:m?w9.PACKED_2X2_FLOAT16:w9.UNPACKED_FLOAT16}function Op(m,d){if(m===w8.UPLOAD)return w9.PACKED_2X2_FLOAT32;if(m===w8.RENDER||m==null)return Ok(d);if(m===w8.DOWNLOAD||m===w8.PIXELS)return w9.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+m)}function Ow(m,d,p){return m[0]+"_"+m[1]+"_"+d+"_"+p}class OA{constructor(d,p){this.variableNames=["A"],this.outputShape=d,this.enableShapeUniforms=Z1(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        `+p+`
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const OZ="if (isnan(x)) return x;",OF="return x;",ON="return abs(x);",OO="return (x >= 0.0) ? x : (exp(x) - 1.0);",OD=OZ+`
  return (x < 0.0) ? 0.0 : x;
`,On=OZ+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Oi="return x;",Oe="return 1.0 / (1.0 + exp(-1.0 * x));",OP="return x;",OS=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,OI=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,OB=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Oj="return 1.0 / (1.0 + exp(-1.0 * x));";class OR{constructor(d,p){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=d,this.enableShapeUniforms=Z1(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        `+p+`
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class OH{constructor(d){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=d,this.enableShapeUniforms=Z1(this.outputShape.length);const p=d.length,_=Os("rc",p),E=AY(p),S=Oz(p,_),I=_.slice(-2),D=p<=1?"rc":"vec2("+I.join(",")+")";this.userCode=`
      void main() {
        `+E+` rc = getOutputCoords();
        vec4 packedInput = getA(`+S+`);

        setOutput(getChannel(packedInput, `+D+`));
      }
    `}}const Ou=TD,OX=1e-7,Of=1e-4,Oy={};function OE(m){return m in Oy||(Oy[m]={}),Oy[m]}const OW=oQ().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Od=600;function OM(){return oQ().global.screen==null?1024:oQ().global.screen.height*oQ().global.screen.width*window.devicePixelRatio*Od/1024/1024}class OU extends C{nextDataId(){return OU.nextDataId++}constructor(d){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!oQ().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let p;if(d!=null){if(d instanceof Zn)p=d;else{const _=w4(oQ().getNumber("WEBGL_VERSION"),d);p=new Zn(_)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const _=w4(oQ().getNumber("WEBGL_VERSION"));p=new Zn(_),this.binaryCache=OE(oQ().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=p,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Or(this.gpgpu),this.numMBBeforeWarning=OM(),this.texData=new z(this,sa())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(d,p,_,E,S,I){const D=this.makeTensorInfo(p,_),k=this.texData.get(D.dataId);k.isPacked=!1,k.texture={texture:d,texShape:[E,S]},k.texShape=[E,S];const V=wM(p),$=new Z7(V,!1,I),Z=this.runWebGLProgram($,[D],_,[[E,S]]);return Z.shape=p,k.texture=null,this.disposeIntermediateTensorInfo(D),Z.dataId}write(d,p,_){if((oQ().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||oQ().getBool("DEBUG"))&&this.checkNumericalProblems(d),_==="complex64"&&d!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const E={id:this.nextDataId()};return this.texData.set(E,{shape:p,dtype:_,values:d,usage:w8.UPLOAD,refCount:1}),E}refCount(d){return this.texData.has(d)?this.texData.get(d).refCount:0}incRef(d){const p=this.texData.get(d);p.refCount++}decRef(d){if(this.texData.has(d)){const p=this.texData.get(d);p.refCount--}}move(d,p,_,E,S){if(oQ().getBool("DEBUG")&&this.checkNumericalProblems(p),E==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(d,{shape:_,dtype:E,values:p,usage:w8.UPLOAD,refCount:S})}disposeIntermediateTensorInfo(d){this.disposeData(d.dataId)}readSync(d){const p=this.texData.get(d),{values:_,dtype:E,complexTensorInfos:S,slice:I,shape:D,isPacked:k}=p;if(I!=null){let te;k?te=new OR(D,Oi):te=new OA(D,Oi);const xe=this.runWebGLProgram(te,[{dataId:d,shape:D,dtype:E}],E),le=this.readSync(xe.dataId);return this.disposeIntermediateTensorInfo(xe),le}if(_!=null)return this.convertAndCacheOnCPU(d);if(E==="string")return _;const V=this.activeTimers!=null;let $;V&&($=Gh());let Z;if(E==="complex64"){const te=this.readSync(S.real.dataId),xe=this.readSync(S.imag.dataId);Z=qm(te,xe)}else Z=this.getValuesFromTexture(d);return V&&(this.downloadWaitMs+=Gh()-$),this.convertAndCacheOnCPU(d,Z)}async read(d){if(this.pendingRead.has(d)){const le=this.pendingRead.get(d);return new Promise(he=>le.push(he))}const p=this.texData.get(d),{values:_,shape:E,slice:S,dtype:I,complexTensorInfos:D,isPacked:k}=p;if(S!=null){let le;k?le=new OR(E,Oi):le=new OA(E,Oi);const he=this.runWebGLProgram(le,[{dataId:d,shape:E,dtype:I}],I),de=this.read(he.dataId);return this.disposeIntermediateTensorInfo(he),de}if(_!=null)return this.convertAndCacheOnCPU(d);if(oQ().getBool("DEBUG")&&!oQ().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&oQ().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let V=null,$;if(I!=="complex64"&&oQ().get("WEBGL_BUFFER_SUPPORTED")){$=this.decode(d);const le=this.texData.get($.dataId);V=this.gpgpu.createBufferFromTexture(le.texture.texture,...wG(E))}this.pendingRead.set(d,[]),I!=="complex64"&&await this.gpgpu.createAndWaitForFence();let Z;if(I==="complex64"){const le=await Promise.all([this.read(D.real.dataId),this.read(D.imag.dataId)]),he=le[0],de=le[1];Z=qm(he,de)}else if(V==null)Z=this.getValuesFromTexture(d);else{const le=n(E);Z=this.gpgpu.downloadFloat32MatrixFromBuffer(V,le)}if($!=null&&this.disposeIntermediateTensorInfo($),V!=null){const le=this.gpgpu.gl;wL(le,()=>le.deleteBuffer(V))}const te=this.convertAndCacheOnCPU(d,Z),xe=this.pendingRead.get(d);return this.pendingRead.delete(d),xe.forEach(le=>le(te)),this.pendingDisposal.has(d)&&(this.pendingDisposal.delete(d),this.disposeData(d)&&sa().removeDataId(d,this),this.pendingDeletes--),te}readToGPU(d,p={}){const _=this.texData.get(d),{values:E,shape:S,slice:I,dtype:D,isPacked:k,texture:V}=_;if(D==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(I!=null){let xe;k?xe=new OR(S,Oi):xe=new OA(S,Oi);const le=this.runWebGLProgram(xe,[{dataId:d,shape:S,dtype:D}],D),he=this.readToGPU(le,p);return this.disposeIntermediateTensorInfo(le),he}if(V==null)throw E!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const $=this.decode(d,p.customTexShape),Z=sa().makeTensorFromTensorInfo($),te=this.texData.get($.dataId);return Object.assign({tensorRef:Z},te.texture)}bufferSync(d){const p=this.readSync(d.dataId);if(d.dtype==="string")try{const _=p.map(E=>Gm(E));return K7(d.shape,d.dtype,_)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return K7(d.shape,d.dtype,p)}checkNumericalProblems(d){if(d!=null)for(let p=0;p<d.length;p++){const _=d[p];if(!wq(_))throw oQ().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error("The value "+_+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"):Error("The value "+_+" cannot be represented on this device.")}}getValuesFromTexture(d){const{shape:p,dtype:_,isPacked:E}=this.texData.get(d),S=n(p);if(oQ().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const te=this.decode(d),xe=this.texData.get(te.dataId),le=this.gpgpu.downloadMatrixFromPackedTexture(xe.texture.texture,...wG(p)).subarray(0,S);return this.disposeIntermediateTensorInfo(te),le}const I=oQ().getBool("WEBGL_PACK")&&E===!0,D=I?wM(p):p,k=I?new Z5(D):new Z4(D),V=this.runWebGLProgram(k,[{shape:D,dtype:_,dataId:d}],"float32"),$=this.texData.get(V.dataId),Z=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture($.texture.texture,$.texShape[0],$.texShape[1]).subarray(0,S);return this.disposeIntermediateTensorInfo(V),Z}timerAvailable(){return oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(d){const p=this.activeTimers,_=[];let E=!1;this.programTimersStack==null?(this.programTimersStack=_,E=!0):this.activeTimers.push(_),this.activeTimers=_,d();const S=Gl(this.activeTimers.map(k=>k.query)).filter(k=>k!=null),I=Gl(this.activeTimers.map(k=>k.name)).filter(k=>k!=null);this.activeTimers=p,E&&(this.programTimersStack=null);const D={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const k=await Promise.all(S);D.kernelMs=Q(k),D.getExtraProfileInfo=()=>k.map((V,$)=>({name:I[$],ms:V})).map(V=>V.name+": "+V.ms).join(", ")}else D.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,D})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Gh(),endMs:null}}endTimer(d){return oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),d):(d.endMs=Gh(),d)}async getQueryTime(d){if(oQ().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(d);const p=d;return p.endMs-p.startMs}disposeData(d,p=!1){if(this.pendingDisposal.has(d))return!1;if(!this.texData.has(d))return!0;if(p?this.texData.get(d).refCount=0:this.texData.get(d).refCount--,!p&&this.texData.get(d).refCount>0)return!1;if(this.pendingRead.has(d))return this.pendingDisposal.add(d),this.pendingDeletes++,!1;this.releaseGPUData(d);const{complexTensorInfos:_}=this.texData.get(d);return _!=null&&(this.disposeData(_.real.dataId,p),this.disposeData(_.imag.dataId,p)),this.texData.delete(d),!0}releaseGPUData(d){const{texture:p,dtype:_,texShape:E,usage:S,isPacked:I,slice:D}=this.texData.get(d),k=D&&D.origDataId||d,V=this.dataRefCount.get(k);V>1?this.dataRefCount.set(k,V-1):(this.dataRefCount.delete(k),p!=null&&(this.numBytesInGPU-=this.computeBytes(E,_),this.textureManager.releaseTexture(p,E,S,I)));const $=this.texData.get(d);$.texture=null,$.texShape=null,$.isPacked=!1,$.slice=null}getTexture(d){return this.uploadToGPU(d),this.texData.get(d).texture.texture}getDataInfo(d){return this.texData.get(d)}shouldExecuteOnCPU(d,p=OW){return oQ().getBool("WEBGL_CPU_FORWARD")&&d.every(_=>this.texData.get(_.dataId).texture==null&&n(_.shape)<p)}getGPGPUContext(){return this.gpgpu}where(d){ch("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const p=d.dataSync();return Ou(d.shape,p)}packedUnaryOp(d,p,_){const E=new OR(d.shape,p),S=this.compileAndRun(E,[d],_);return sa().makeTensorFromTensorInfo(S)}abs(d){if(this.shouldExecuteOnCPU([d])&&d.dtype!=="complex64"){const E=Nb(this.texData.get(d.dataId).values);return this.makeOutput(d.shape,d.dtype,E)}if(oQ().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(d,ON,d.dtype);const p=new OA(d.shape,ON),_=this.compileAndRun(p,[d]);return sa().makeTensorFromTensorInfo(_)}makeTensorInfo(d,p,_){let E;if(p==="string"&&_!=null&&_.length>0&&o0(_[0])){const S=_.map(I=>GY(I));E=this.write(S,d,p)}else E=this.write(_,d,p);return this.texData.get(E).usage=null,{dataId:E,shape:d,dtype:p}}makeOutput(d,p,_){return sa().makeTensorFromTensorInfo(this.makeTensorInfo(d,p,_),this)}unpackTensor(d){const p=new OH(d.shape);return this.runWebGLProgram(p,[d],d.dtype)}packTensor(d){const p=new OC(d.shape);return this.runWebGLProgram(p,[d],d.dtype,null,!0)}packedReshape(d,p){const _=[wW(d.shape),...wd(d.shape)],E={dtype:d.dtype,shape:_,dataId:d.dataId},S=[wW(p),...wd(p)],I=new OL(S,_),D=!0,k=[_],V=this.runWebGLProgram(I,[E],d.dtype,k,D);return{dataId:V.dataId,shape:p,dtype:V.dtype}}decode(d,p){const _=this.texData.get(d),{isPacked:E,shape:S,dtype:I}=_;if(p!=null){const te=n(S),xe=p[0]*p[1]*4;A(te<=xe,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const D=wM(S);let k;E?k=new Z3(D):k=new Z2(D);const V=!0,$=[p??wG(D)],Z=this.runWebGLProgram(k,[{shape:D,dtype:I,dataId:d}],I,$,V,p);return{dtype:I,shape:S,dataId:Z.dataId}}runWebGLProgram(d,p,_,E,S=!1,I){const D=this.makeTensorInfo(d.outputShape,_),k=this.texData.get(D.dataId);if(d.packedOutput&&(k.isPacked=!0),d.outPackingScheme===w7.DENSE){const me=I??wG(d.outputShape);k.texShape=me.map(ge=>ge*2)}if(d.outTexUsage!=null&&(k.usage=d.outTexUsage),n(D.shape)===0)return k.values=M(D.dtype,0),D;const V=[],$=p.map(me=>{if(me.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let ge=this.texData.get(me.dataId);if(ge.texture==null){if(!d.packedInputs&&n(me.shape)<=oQ().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:me.shape,texData:null,isUniform:!0,uniformValues:ge.values};d.packedInputs&&(ge.isPacked=!0,ge.shape=me.shape)}if(this.uploadToGPU(me.dataId),!!ge.isPacked!=!!d.packedInputs)me=ge.isPacked?this.unpackTensor(me):this.packTensor(me),V.push(me),ge=this.texData.get(me.dataId);else if(ge.isPacked&&!wt(ge.shape,me.shape)){const be=me,ye=me.shape;me.shape=ge.shape,me=this.packedReshape(me,ye),V.push(me),ge=this.texData.get(me.dataId),be.shape=ye}return{shape:me.shape,texData:ge,isUniform:!1}});this.uploadToGPU(D.dataId);const Z={shape:D.shape,texData:k,isUniform:!1},te=Z0(d,$,Z),xe=this.getAndSaveBinary(te,()=>Ab(this.gpgpu,d,$,Z)),le=this.activeTimers!=null;let he;le&&(he=this.startTimer()),oQ().get("ENGINE_COMPILE_ONLY")||Ag(this.gpgpu,xe,$,Z,E),V.forEach(me=>this.disposeIntermediateTensorInfo(me)),le&&(he=this.endTimer(he),this.activeTimers.push({name:d.constructor.name,query:this.getQueryTime(he)}));const de=oQ().getNumber("WEBGL_FLUSH_THRESHOLD");if(de>0){const me=Gh();me-this.lastGlFlushTime>de&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=me)}if(!oQ().getBool("WEBGL_LAZILY_UNPACK")&&k.isPacked&&S===!1){const me=this.unpackTensor(D);return this.disposeIntermediateTensorInfo(D),me}return D}compileAndRun(d,p,_,E,S=!1){return _=_||p[0].dtype,this.runWebGLProgram(d,p,_,E,S)}getAndSaveBinary(d,p){return d in this.binaryCache||(this.binaryCache[d]=p()),this.binaryCache[d]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(oQ().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(d=>{this.gpgpu.deleteProgram(this.binaryCache[d].webGLProgram),delete this.binaryCache[d]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=sV(()=>{if(!oQ().get("WEBGL_RENDER_FLOAT32_ENABLED")){const d=oQ().getBool("DEBUG");oQ().set("DEBUG",!1);const p=this.abs(KU(1e-8)).dataSync()[0];if(oQ().set("DEBUG",d),p>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?OX:Of}uploadToGPU(d){const p=this.texData.get(d),{shape:_,dtype:E,values:S,texture:I,usage:D,isPacked:k}=p;if(I!=null)return;const V=this.activeTimers!=null;let $;V&&($=Gh());let Z=p.texShape;if(Z==null&&(Z=wU(_,k),p.texShape=Z),S!=null){const te=wM(_);let xe,le=Z[1],he=Z[0];const de=S instanceof Uint8Array||S instanceof Uint8ClampedArray;(k||!de)&&([le,he]=ws(Z[0],Z[1])),k?xe=new Z8(te,de):xe=new Z7(te,de);const me=de?[he,le]:Z,ge=this.makeTensorInfo(me,E),be=this.texData.get(ge.dataId);de?be.usage=w8.PIXELS:be.usage=w8.UPLOAD,be.texShape=me,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(ge.dataId),le,he,S);const ye=[[he,le]],ve=!0,Ie=this.runWebGLProgram(xe,[ge],E,ye,ve),je=this.texData.get(Ie.dataId);p.texShape=je.texShape,p.isPacked=je.isPacked,p.usage=je.usage,oQ().get("ENGINE_COMPILE_ONLY")?this.disposeData(Ie.dataId):(p.texture=je.texture,p.values=null,this.texData.delete(Ie.dataId)),this.disposeIntermediateTensorInfo(ge),V&&(this.uploadWaitMs+=Gh()-$)}else{const te=this.acquireTexture(Z,D,E,k);p.texture=te}}convertAndCacheOnCPU(d,p){const _=this.texData.get(d),{dtype:E}=_;return p!=null&&(_.values=OJ(p,E)),_.values}acquireTexture(d,p,_,E){if(this.numBytesInGPU+=this.computeBytes(d,_),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const S=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+S+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(d,p,E)}computeBytes(d,p){return d[0]*d[1]*Y(p)}checkCompileCompletion(){for(const[,d]of Object.entries(this.binaryCache))this.checkCompletion_(d)}async checkCompileCompletionAsync(){const d=[];if(this.gpgpu.parallelCompilationExtension){for(const[,p]of Object.entries(this.binaryCache))d.push(this.checkCompletionAsync_(p));return Promise.all(d)}else{for(const[,p]of Object.entries(this.binaryCache)){const _=new Promise(E=>{try{this.checkCompletion_(p),E(!0)}catch(S){throw S}});d.push(_)}return Promise.all(d)}}async checkCompletionAsync_(d){return this.gpgpu.gl.getProgramParameter(d.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(d):(await qn(),this.checkCompletionAsync_(d))}checkCompletion_(d){if(this.gpgpu.gl.getProgramParameter(d.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(d.webGLProgram)),this.gpgpu.gl.getShaderParameter(d.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(wZ(d.source,this.gpgpu.gl.getShaderInfoLog(d.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const d of Object.values(this.binaryCache)){this.gpgpu.buildVao(d.webGLProgram);const{variablesLocations:p,customUniformLocations:_,infLoc:E,nanLoc:S,outShapeLocation:I,outShapeStridesLocation:D,outTexShapeLocation:k}=Aa(this.gpgpu,d.program,d.webGLProgram);d.variablesLocations=p,d.customUniformLocations=_,d.infLoc=E,d.nanLoc=S,d.outShapeLocation=I,d.outShapeStridesLocation=D,d.outTexShapeLocation=k}}createTensorFromGPUData(d,p,_){d.channels=d.channels||"RGBA";const{texture:E,height:S,width:I,channels:D}=d,k=sa().backend;if(!k.gpgpu.gl.isTexture(E))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const V=k.writeTexture(E,p,_,S,I,D);return sa().makeTensorFromDataId(V,p,_,k)}}OU.nextDataId=0;function OJ(m,d){if(d==="float32"||d==="complex64")return m;if(d==="int32"||d==="bool"){const p=d==="int32"?new Int32Array(m.length):new Uint8Array(m.length);for(let _=0;_<p.length;++_)p[_]=Math.round(m[_]);return p}else throw new Error("Unknown dtype "+d)}sX()&&z3("webgl",()=>new OU,2);const Ot="return abs(x);";function Ov(m){const{inputs:d,backend:p}=m,{x:_}=d;if(p.shouldExecuteOnCPU([_])&&_.dtype!=="complex64"){const S=p.texData.get(_.dataId),I=Nb(S.values);return p.makeTensorInfo(_.shape,_.dtype,I)}let E;return oQ().getBool("WEBGL_PACK_UNARY_OPERATIONS")?E=new OR(_.shape,Ot):E=new OA(_.shape,Ot),p.runWebGLProgram(E,[_],_.dtype)}const Oh={kernelName:oO,backendName:"webgl",kernelFunc:Ov},OY=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Om{constructor(d,p,_){this.variableNames=["A","B"],this.outputShape=CJ(p,_),this.enableShapeUniforms=Z1(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        `+d+`
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const Ox=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Ol{constructor(d,p,_,E=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=CJ(p,_);const S=this.outputShape.length;this.enableShapeUniforms=Z1(S);let I="";if(E)if(S===0||n(this.outputShape)===1)I=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(I=`
          `+AY(S)+` coords = getOutputCoords();
        `,S===1)this.enableShapeUniforms?I+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:I+=`
            result.y = (coords + 1) >= `+this.outputShape[0]+` ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const D=Os("coords",S);this.enableShapeUniforms?I+=`
            bool nextRowOutOfBounds =
              (`+D[S-2]+" + 1) >= outShape["+S+` - 2];
            bool nextColOutOfBounds =
              (`+D[S-1]+" + 1) >= outShape["+S+` - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:I+=`
            bool nextRowOutOfBounds =
              (`+D[S-2]+" + 1) >= "+this.outputShape[S-2]+`;
            bool nextColOutOfBounds =
              (`+D[S-1]+" + 1) >= "+this.outputShape[S-1]+`;
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        `+d+`
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        `+I+`

        setOutput(result);
      }
    `}}function Ob(m){const{inputs:d,backend:p}=m,{x:_}=d;return p.incRef(_.dataId),{dataId:_.dataId,shape:_.shape,dtype:_.dtype}}const Oa={kernelName:c0,backendName:"webgl",kernelFunc:Ob};function OV(m){const{inputs:d,backend:p}=m,{real:_,imag:E}=d,S=p.makeTensorInfo(_.shape,"complex64"),I=p.texData.get(S.dataId),D=Ob({inputs:{x:_},backend:p}),k=Ob({inputs:{x:E},backend:p});return I.complexTensorInfos={real:D,imag:k},S}const Og="return (a < 0.) ? b * a : a;",D0=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,D1="return (a < 0.) ? b * a : a;",D2=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function D3(m){const{inputs:d,backend:p}=m,{x:_,alpha:E}=d,S=oQ().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ol(D2,_.shape,E.shape):new Om(D1,_.shape,E.shape);return p.runWebGLProgram(S,[_,E],"float32")}const D4={kernelName:cQ,backendName:"webgl",kernelFunc:D3},D5="if (isnan(x)) return x;";function D6({opSnippet:m,packedOpSnippet:d,cpuKernelImpl:p,dtype:_}){return({inputs:E,backend:S})=>{const{x:I}=E,D=S,k=_||I.dtype;if(D.shouldExecuteOnCPU([I])&&p!=null){const Z=D.texData.get(I.dataId),te=p(Z.values,k);return D.makeTensorInfo(I.shape,k,te)}const V=oQ().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&d!=null;let $;return V?$=new OR(I.shape,d):$=new OA(I.shape,m),D.runWebGLProgram($,[I],k)}}function D7({opSnippet:m,packedOpSnippet:d,checkOutOfBounds:p=!1,supportsComplex:_=!1,cpuKernelImpl:E,dtype:S}){return({inputs:I,backend:D})=>{const{a:k,b:V}=I,$=D;if(_&&k.dtype==="complex64"){const le=$.texData.get(k.dataId),he=$.texData.get(V.dataId),[de,me]=[[le.complexTensorInfos.real,he.complexTensorInfos.real],[le.complexTensorInfos.imag,he.complexTensorInfos.imag]].map(be=>{const[ye,ve]=be,Ie={dataId:ye.dataId,dtype:ye.dtype,shape:k.shape},je={dataId:ve.dataId,dtype:ve.dtype,shape:V.shape},Me=new Om(m,k.shape,V.shape);return $.runWebGLProgram(Me,[Ie,je],sA(ye.dtype,ve.dtype))}),ge=OV({inputs:{real:de,imag:me},backend:$});return $.disposeIntermediateTensorInfo(de),$.disposeIntermediateTensorInfo(me),ge}const Z=S||sA(k.dtype,V.dtype);if((k.dtype==="string"||V.dtype==="string"||$.shouldExecuteOnCPU([k,V]))&&E!=null){const le=$.texData.get(k.dataId).values,he=$.texData.get(V.dataId).values,de=k.dtype==="string"?QN(le):le,me=k.dtype==="string"?QN(he):he,[ge,be]=E(k.shape,V.shape,de,me,Z),ye=$.makeTensorInfo(be,Z),ve=$.texData.get(ye.dataId);return ve.values=ge,ye}const te=oQ().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&d!=null;let xe;return te?xe=new Ol(d,k.shape,V.shape,p):xe=new Om(m,k.shape,V.shape),$.runWebGLProgram(xe,[k,V],Z)}}function D8(m,d=!1){if(m==="linear")return d?OP:OF;if(m==="relu")return d?OI:OD;if(m==="elu")return d?OS:OO;if(m==="relu6")return d?OB:On;if(m==="prelu")return d?D2:D1;if(m==="leakyrelu")return d?D0:Og;if(m==="sigmoid")return d?Oj:Oe;throw new Error("Activation "+m+" has not been implemented for the WebGL backend.")}const D9="return a + b;",Do=D7({opSnippet:D9,packedOpSnippet:D9,supportsComplex:!0,cpuKernelImpl:Nw}),Dc={kernelName:oD,backendName:"webgl",kernelFunc:Do};class DG{constructor(d,p){this.outputShape=[],this.outputShape=d,this.variableNames=p.map((S,I)=>"T"+I);const _=[];this.variableNames.forEach(S=>{_.push("float v"+S+" = get"+S+"AtOutCoords();")});const E=this.variableNames.map(S=>"v"+S).join(" + ");this.userCode=`
      void main() {
        `+_.join(`
        `)+`

        float result = `+E+`;
        setOutput(result);
      }
    `}}class Ds{constructor(d,p){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=d,this.variableNames=p.map((S,I)=>"T"+I);const _=[];this.variableNames.forEach(S=>{_.push("vec4 v"+S+" = get"+S+"AtOutCoords();")});const E=this.variableNames.map(S=>"v"+S).join(" + ");this.userCode=`
      void main() {
        `+_.join(`
        `)+`

        vec4 result = `+E+`;
        setOutput(result);
      }
    `}}function Dz(m){const{inputs:d,backend:p}=m,_=d;if(_.length===1)return Ob({inputs:{x:_[0]},backend:p});if(_.length>oQ().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const D=Math.floor(_.length/2),k=Dz({inputs:_.slice(0,D),backend:p}),V=Dz({inputs:_.slice(D),backend:p});return Dz({inputs:[k,V],backend:p})}const E=_.map(D=>D.dtype).reduce((D,k)=>sA(D,k)),S=_.map(D=>D.shape),I=oQ().getBool("WEBGL_PACK")?new Ds(_[0].shape,S):new DG(_[0].shape,S);return p.runWebGLProgram(I,_,E)}const DC={kernelName:on,backendName:"webgl",kernelFunc:Dz},DL=OY+`
  return atan(a, b);
`,DK=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ox+`
  return result;
`,Dr=D7({opSnippet:DL,packedOpSnippet:DK}),DT={kernelName:oi,backendName:"webgl",kernelFunc:Dr};class Dq{constructor(d,p,_,E=!1,S=!1){if(this.variableNames=["x"],p==="avg"&&_)throw new Error("Cannot compute positions for average pool.");const I=d.filterWidth,D=d.strideHeight,k=d.strideWidth,V=d.dilationHeight,$=d.dilationWidth,Z=d.effectiveFilterHeight,te=d.effectiveFilterWidth,xe=d.padInfo.top,le=d.padInfo.left;this.outputShape=d.outShape;const he=p==="avg",de="((batch  * "+d.inHeight+" + xR) * "+d.inWidth+" + xC) * "+d.inChannels+" + d",me="(xR * "+d.inWidth+" + xC) * "+d.inChannels+" + d";let ge="0.0";if(he||(ge="-1.0 / 1e-20"),_){const Me=">=";this.userCode=`
        const ivec2 strides = ivec2(`+D+", "+k+`);
        const ivec2 pads = ivec2(`+xe+", "+le+`);

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < `+Z+`;
              wR += `+V+`) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= `+d.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+te+`;
                wC += `+$+`) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= `+d.inWidth+`) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value `+Me+` currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = `+(E?S?de:me:"wR * "+te+" + wC")+`;
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const be="max";let ye=p+"("+p+"("+p+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";p==="avg"&&(ye="avgValue / max(count, 1.0)");const ve=Math.floor(I/4)*4,Ie=I%4,je=`
      if (`+he+`) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = `+be+`(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(`+D+", "+k+`);
      const ivec2 pads = ivec2(`+xe+", "+le+`);
      const float initializationValue = `+ge+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= `+d.inWidth+`) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(`+ge+`);
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < `+Z+`;
            wR += `+V+`) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= `+d.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+ve+`; wC += 4) {
            int xC = xCCorner + wC * `+$+`;

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+$+`, d),
              getValue(batch, xR, xC + 2 * `+$+`, d),
              getValue(batch, xR, xC + 3 * `+$+`, d)
            );

            `+je+`
          }

          int xC = xCCorner + `+ve+`;
          if (`+(Ie===1)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            `+je+`
          } else if (`+(Ie===2)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+$+`, d),
              initializationValue,
              initializationValue
            );

            `+je+`
          } else if (`+(Ie===3)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+$+`, d),
              getValue(batch, xR, xC + 2 * `+$+`, d),
              initializationValue
            );

            `+je+`
          }
        }
        setOutput(`+ye+`);
      }
    `}}function DQ(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d;A2(E,"avgPool");const{filterSize:S,strides:I,pad:D,dimRoundingMode:k}=_,V=1;A(Ld(I,V),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+I+" and dilations '"+V+"'");const $=Le(E.shape,S,I,V,D,k);if($.filterWidth===1&&$.filterHeight===1&&i($.inShape,$.outShape))return Ob({inputs:{x:E},backend:p});const Z=new Dq($,"avg",!1);return p.runWebGLProgram(Z,[E],"float32")}const Dk={kernelName:oe,backendName:"webgl",kernelFunc:DQ};class Dp{constructor(d,p,_,E=!1,S=!1,I=!1,D=null,k=!1,V=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=_,this.enableShapeUniforms=Z1(this.outputShape.length);const $=E?d[1]:d[2],Z=Math.ceil($/2),te=E?"i * 2, rc.y":"rc.y, i * 2",xe=S?"rc.z, i * 2":"i * 2, rc.z",le=E?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],he=S?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let de="",me="";D&&(k?de=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+D+`
        }`:V?de=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+D+`
        }`:de=`vec4 activation(vec4 x) {
          `+D+`
        }`,me="result = activation(result);");const ge=I?"result += getBiasAtOutCoords();":"";I&&this.variableNames.push("bias"),k&&this.variableNames.push("preluActivationWeights"),V&&this.variableNames.push("leakyreluAlpha");let be="rc.x",ye="rc.x";d[0]<p[0]?be="imod(rc.x, "+d[0]+")":p[0]<d[0]&&(ye="imod(rc.x, "+p[0]+")"),this.userCode=`
      `+de+`
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = `+Z+`.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = `+be+`;
        int batchB = `+ye+`;
        for (int i = 0; i < `+Z+`; i++) {
          vec4 a = getMatrixA(batchA, `+te+`);
          vec4 b = getMatrixB(batchB, `+xe+`);

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (`+le[0]+" * "+he[0]+`);
          result += (`+le[1]+" * "+he[1]+`);
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        `+ge+`

        `+me+`

        setOutput(result);
      }
    `}}const Dw={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class DA{constructor(d,p,_){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=CJ(p,_),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        `+d+`
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const DZ="return a * b;";function DF(m){const{inputs:d,backend:p}=m,{a:_,b:E}=d,S=sA(_.dtype,E.dtype);if(_.dtype==="complex64"){const D=p.texData.get(_.dataId),k=p.texData.get(E.dataId),V=new DA(Dw.REAL,_.shape,E.shape),$=new DA(Dw.IMAG,_.shape,E.shape),Z=[{dataId:D.complexTensorInfos.real.dataId,dtype:D.complexTensorInfos.real.dtype,shape:_.shape},{dataId:D.complexTensorInfos.imag.dataId,dtype:D.complexTensorInfos.imag.dtype,shape:_.shape},{dataId:k.complexTensorInfos.real.dataId,dtype:k.complexTensorInfos.real.dtype,shape:E.shape},{dataId:k.complexTensorInfos.imag.dataId,dtype:k.complexTensorInfos.imag.dtype,shape:E.shape}],te=p.runWebGLProgram(V,Z,"float32"),xe=p.runWebGLProgram($,Z,"float32"),le=OV({inputs:{real:te,imag:xe},backend:p});return p.disposeIntermediateTensorInfo(te),p.disposeIntermediateTensorInfo(xe),le}if(p.shouldExecuteOnCPU([_,E])){const D=p.texData.get(_.dataId),k=p.texData.get(E.dataId),[V,$]=NW(_.shape,E.shape,D.values,k.values,S),Z=p.makeTensorInfo($,S),te=p.texData.get(Z.dataId);return te.values=V,Z}let I;return oQ().getBool("WEBGL_PACK_BINARY_OPERATIONS")?I=new Ol(DZ,_.shape,E.shape):I=new Om(DZ,_.shape,E.shape),p.runWebGLProgram(I,[_,E],S)}const DN={kernelName:cs,backendName:"webgl",kernelFunc:DF};function DO(m,d,p){const _=[wW(m.shape),...wd(m.shape)],E={dtype:m.dtype,shape:_,dataId:m.dataId},S=[wW(d),...wd(d)],I=new OL(S,_),D=!0,k=[_],V=p.runWebGLProgram(I,[E],m.dtype,k,D);return{dataId:V.dataId,shape:d,dtype:V.dtype}}function DD(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{shape:S}=_,I=p,D=n(E.shape),k=H(S,D),V=n(k);A(D===V,()=>"The new shape ("+k+") has "+V+" elements and the old shape ("+E.shape+") has "+D+" elements. The new shape and old shape must have the same number of elements.");const $=I.texData.get(E.dataId);return $.isPacked&&!wt(E.shape,k)&&!($.texture!==null&&wt($.shape,k))?DO(E,k,I):(I.incRef(E.dataId),{dataId:E.dataId,shape:k,dtype:E.dtype})}const Dn={kernelName:cA,backendName:"webgl",kernelFunc:DD};class Di{constructor(d,p){this.variableNames=["x"];const{windowSize:_,batchSize:E,inSize:S,outSize:I}=d;this.outputShape=[E,I];const D=Math.floor(_/4)*4,k=_%4;let V="sumValue += dot(values, ones);";if(p!=null){const Z=1/p;V="sumValue += dot(values * "+(e(Z)?Z.toPrecision(2):Z)+", ones);"}let $="";S%_>0&&($=`
        if (inIdx < 0 || inIdx >= `+S+`) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+$+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+_+`;

        float sumValue = 0.0;

        for (int i = 0; i < `+D+`; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+V+`
        }

        int inIdx = inOffset + `+D+`;
        if (`+(k===1)+`) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          `+V+`
        } else if (`+(k===2)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          `+V+`
        } else if (`+(k===3)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          `+V+`
        }
        setOutput(sumValue);
      }
    `}}class De{constructor(d,p){this.variableNames=["x"];const{windowSize:_,batchSize:E,inSize:S,outSize:I}=d;this.outputShape=[E,I];let D="0.0",k="";p==="prod"?D="1.0":p==="min"?(D="1.0 / 1e-20",k="min"):p==="max"&&(D="-1.0 / 1e-20",k="max");let V=p+"("+p+"("+p+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";p==="sum"?V="sumValue":p==="prod"?V="prodValue":p==="all"?V="allValue":p==="any"&&(V="anyValue");const $=Math.floor(_/4)*4,Z=_%4;let te=`
      if (`+(p==="sum")+`) {
        sumValue += dot(values, ones);
      } else if (`+(p==="prod")+`) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = `+k+`(values, minMaxValue);
        if (`+(p==="min")+" || "+(p==="max")+`) {
          minMaxValue = `+k+`(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,xe="vec4";p==="all"?(D="1.0",te=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,xe="bvec4"):p==="any"&&(D="0.0",te=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,xe="bvec4");let le="";S%_>0&&(le=`
        if (inIdx < 0 || inIdx >= `+S+`) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = `+D+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+le+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+_+`;

        vec4 minMaxValue = vec4(`+D+`);
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < `+$+`; i += 4) {
          int inIdx = inOffset + i;
          `+xe+" values = "+xe+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+te+`
        }

        int inIdx = inOffset + `+$+`;
        if (`+(Z===1)+`) {
          `+xe+" values = "+xe+`(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          `+te+`
        } else if (`+(Z===2)+`) {
          `+xe+" values = "+xe+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          `+te+`
        } else if (`+(Z===3)+`) {
          `+xe+" values = "+xe+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          `+te+`
        }
        setOutput(`+V+`);
      }
    `}}function DP(m){const d=[];for(;d.length===0||d[d.length-1].outSize!==1;){const p=d.length?d[d.length-1].outSize:m[1],_=qH(p);d.push({inSize:p,windowSize:_,outSize:Math.ceil(p/_)})}return d}function DS(m,d,p,_){const E=DP(m.shape);let S=m;for(let I=0;I<E.length;I++){const{inSize:D,windowSize:k,outSize:V}=E[I];let $,Z;p==="mean"?$=I===0?new Di({windowSize:k,inSize:D,batchSize:m.shape[0],outSize:V},D):new Di({windowSize:k,inSize:D,batchSize:m.shape[0],outSize:V}):$=new De({windowSize:k,inSize:D,batchSize:m.shape[0],outSize:V},p),Z=S,S=_.runWebGLProgram($,[S],d),Z.dataId!==m.dataId&&_.disposeIntermediateTensorInfo(Z)}return S}class DI{constructor(d,p){this.variableNames=["A"];const _=new Array(d.length);for(let I=0;I<_.length;I++)_[I]=d[p[I]];this.outputShape=_,this.rank=_.length;const E=AY(this.rank),S=DB(p);this.userCode=`
    void main() {
      `+E+` resRC = getOutputCoords();
      setOutput(getA(`+S+`));
    }
    `}}function DB(m){const d=m.length;if(d>6)throw Error("Transpose for rank "+d+" is not yet supported");const p=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],_=new Array(d);for(let E=0;E<m.length;E++)_[m[E]]=p[E];return _.join()}class Dj{constructor(d,p){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const _=new Array(d.length);for(let $=0;$<_.length;$++)_[$]=d[p[$]];if(this.outputShape=_,this.rank=_.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");const E=AY(this.rank),S=OG("rc",this.rank),I=new Array(this.rank);for(let $=0;$<p.length;$++)I[p[$]]=S[$];const D="vec2("+I.slice(-2).join()+")",k="++"+S[this.rank-1]+" < "+_[this.rank-1],V="getChannel(getA("+I.join()+"), "+D+")";this.userCode=`
    void main() {
      `+E+` rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = `+V+`;
      if(`+k+`) {
        result[1] = `+V+`;
      }
      --`+S[this.rank-1]+`;
      if(++`+S[this.rank-2]+" < "+_[this.rank-2]+`) {
        result[2] = `+V+`;
        if(`+k+`) {
          result[3] = `+V+`;
        }
      }
      setOutput(result);
    }
    `}}function DR(m,d,p){const _=oQ().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dj(m.shape,d):new DI(m.shape,d);return p.runWebGLProgram(_,[m],m.dtype)}function DH(m,d,p,_){const E=d,S=m.shape.length,I=X(E,m.shape);let D=I;const k=KH(D,S),V=k!=null;let $=m;V&&($=DR(m,k,_),D=KX(D.length,S)),KR("sum",D,S);const[Z,te]=KB($.shape,D);let xe=Z;p&&(xe=Kj(Z,I));const le=n(te),he=n(m.shape)/le,de=DD({inputs:{x:$},attrs:{shape:[he,le]},backend:_}),me=sZ(m.dtype),ge=DS(de,me,"sum",_),be=DD({inputs:{x:ge},attrs:{shape:xe},backend:_});return _.disposeIntermediateTensorInfo(de),_.disposeIntermediateTensorInfo(ge),V&&_.disposeIntermediateTensorInfo($),be}function Du(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{axis:S,keepDims:I}=_;return DH(E,S,I,p)}const DX={kernelName:cI,backendName:"webgl",kernelFunc:Du};function Df(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{perm:S}=_,I=p,D=E.shape.length,k=new Array(D);for(let $=0;$<k.length;$++)k[$]=E.shape[S[$]];let V;if(I.shouldExecuteOnCPU([E])){const $=I.texData.get(E.dataId).values,Z=Oo($,E.shape,E.dtype,S,k);V=I.makeTensorInfo(k,E.dtype);const te=I.texData.get(V.dataId);te.values=Z}else V=DR(E,S,I);return V}const Dy={kernelName:cy,backendName:"webgl",kernelFunc:Df},DE=1e3;function DW({a:m,b:d,transposeA:p,transposeB:_,backend:E,bias:S=null,preluActivationWeights:I=null,leakyreluAlpha:D=0,activation:k=null}){const V=m.shape.length,$=d.shape.length,Z=p?m.shape[V-2]:m.shape[V-1],te=_?d.shape[$-1]:d.shape[$-2],xe=p?m.shape[V-1]:m.shape[V-2],le=_?d.shape[$-2]:d.shape[$-1],he=m.shape.slice(0,-2),de=d.shape.slice(0,-2),me=n(he),ge=n(de),be=CJ(m.shape.slice(0,-2),d.shape.slice(0,-2)).concat([xe,le]);A(Z===te,()=>"Error in matMul: inner shapes ("+Z+") and ("+te+") of Tensors with shapes "+m.shape+" and "+d.shape+" and transposeA="+p+" and transposeB="+_+" must match.");const ye=p?[me,Z,xe]:[me,xe,Z],ve=_?[ge,le,te]:[ge,te,le],Ie=DD({inputs:{x:m},backend:E,attrs:{shape:ye}}),je=DD({inputs:{x:d},backend:E,attrs:{shape:ve}}),Me=[Ie,je],xt=Math.max(me,ge),bt=p?Ie.shape[1]:Ie.shape[2],gt=S!=null,Xt=I!=null,Ut=k==="leakyrelu",Ht=k!=null?D8(k,!0):null,mi=gt||Xt||Ut||Ht!=null;let gi;if((xe===1||le===1)&&bt>DE&&mi===!1){let yi=Ie,vi=je;p&&(yi=Df({inputs:{x:Ie},backend:E,attrs:{perm:[0,2,1]}}),Me.push(yi)),_&&(vi=Df({inputs:{x:je},backend:E,attrs:{perm:[0,2,1]}}),Me.push(vi));const ts=le!==1,us=le===1;let bi=yi;ts&&(bi=DD({inputs:{x:yi},backend:E,attrs:{shape:[xt,bt,1]}}),Me.push(bi));const Ri=le===1?2:1;let Nt=vi;us&&(Nt=DD({inputs:{x:vi},backend:E,attrs:{shape:[xt,1,bt]}}),Me.push(Nt));const $t=DF({inputs:{a:bi,b:Nt},backend:E});gi=Du({inputs:{x:$t},backend:E,attrs:{axis:Ri,keepDims:!0}}),Me.push($t)}else{const yi=sA(m.dtype,d.dtype),vi=new Dp(ye,ve,[xt,xe,le],p,_,gt,Ht,Xt,Ut),ts=[Ie,je];if(S!=null&&ts.push(S),Xt&&ts.push(I),Ut){const us=E.makeTensorInfo([],"float32",GJ(D,"float32"));ts.push(us),Me.push(us)}gi=E.runWebGLProgram(vi,ts,yi)}const Ui=DD({inputs:{x:gi},backend:E,attrs:{shape:be}});Me.push(gi);for(const yi of Me)E.disposeIntermediateTensorInfo(yi);return Ui}function Dd(m){const{inputs:d,backend:p,attrs:_}=m,{a:E,b:S}=d,{transposeA:I,transposeB:D}=_;return DW({a:E,b:S,transposeA:I,transposeB:D,backend:p})}const DM={kernelName:oP,backendName:"webgl",kernelFunc:Dd},DU="return float(a != b);",DJ=D7({opSnippet:DU,cpuKernelImpl:NM,dtype:"bool"});function Dt(m){const{inputs:d,backend:p}=m,{input:_}=d,E=p.texData.get(_.dataId);return Ob({inputs:{x:E.complexTensorInfos.real},backend:p})}const Dv="return float(int(x));";function Dh(m,d){const p=new OA(m.shape,Dv),_=d.runWebGLProgram(p,[m],"int32");return{dataId:_.dataId,shape:_.shape,dtype:_.dtype}}function DY(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{dtype:S}=_;if(S==="complex64"){if(E.dtype==="complex64")return Ob({inputs:{x:E},backend:p});const I=rD(E.shape),D=DY({inputs:{x:E},backend:p,attrs:{dtype:"float32"}}),k=OV({inputs:{real:D,imag:I},backend:p});return I.dispose(),p.disposeIntermediateTensorInfo(D),k}if(E.dtype==="complex64"){const I=Dt({inputs:{input:E},backend:p}),D=DY({inputs:{x:I},backend:p,attrs:{dtype:S}});return p.disposeIntermediateTensorInfo(I),D}if(!h(E.dtype,S)){const I=Ob({inputs:{x:E},backend:p});return{dataId:I.dataId,shape:I.shape,dtype:S}}if(p.shouldExecuteOnCPU([E])){const I=p.texData.get(E.dataId).values,[D,k,V]=NN(I,E.shape,E.dtype,S);return p.makeTensorInfo(D,k,V)}if(S==="int32")return Dh(E,p);if(S==="bool"){const I=p.makeTensorInfo([],"bool",M("bool",1)),D=DJ({inputs:{a:E,b:I},backend:p});return p.disposeIntermediateTensorInfo(I),D}throw new Error("Error in Cast: failed to cast "+E.dtype+" to "+S)}const Dm={kernelName:oB,backendName:"webgl",kernelFunc:DY};class Dx{constructor(d){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=d,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class Dl{constructor(d){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=d,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function Db(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{clipValueMin:S,clipValueMax:I}=_;let D;oQ().getBool("WEBGL_PACK_CLIP")?D=new Dl(E.shape):D=new Dx(E.shape);const k=[[S],[I]];return p.runWebGLProgram(D,[E],E.dtype,k)}const Da={kernelName:oj,backendName:"webgl",kernelFunc:Db};class DV{constructor(d){this.outputShape=[],this.outputShape=qe(d,1),this.variableNames=d.map((I,D)=>"T"+D);const p=new Array(d.length-1);p[0]=d[0][1];for(let I=1;I<p.length;I++)p[I]=p[I-1]+d[I][1];const _=["if (yC < "+p[0]+") setOutput(getT0(yR, yC));"];for(let I=1;I<p.length;I++){const D=p[I-1];_.push("else if (yC < "+p[I]+") setOutput(getT"+I+"(yR, yC-"+D+"));")}const E=p.length,S=p[p.length-1];_.push("else setOutput(getT"+E+"(yR, yC-"+S+"));"),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        `+_.join(`
        `)+`
      }
    `}}class Dg{constructor(d,p){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=qe(d,p);const _=this.outputShape,E=_.length,S=AY(E),I=Os("coords",E),D=["x","y","z","w","u","v"].slice(0,E);this.variableNames=d.map((he,de)=>"T"+de);const k=new Array(d.length-1);k[0]=d[0][p];for(let he=1;he<k.length;he++)k[he]=k[he-1]+d[he][p];const V=D[p],$=D.slice(-2),Z=D.join();let te="if ("+V+" < "+k[0]+`) {
        return getChannel(
            getT0(`+Z+"), vec2("+$.join()+`));
        }`;for(let he=1;he<k.length;he++){const de=k[he-1];te+=`
        if (`+V+" < "+k[he]+"  && "+V+" >= "+k[he-1]+`) {
          return getChannel(
            getT`+he+"("+n0(D,V,de)+`),
            vec2(`+n0($,V,de)+`));
        }`}const xe=k.length,le=k[k.length-1];te+=`
        return getChannel(
          getT`+xe+"("+n0(D,V,le)+`),
          vec2(`+n0($,V,le)+"));",this.userCode=`
      float getValue(`+D.map(he=>"int "+he)+`) {
        `+te+`
      }

      void main() {
        `+S+` coords = getOutputCoords();
        vec4 result = vec4(getValue(`+I+`), 0., 0., 0.);

        `+I[E-1]+" = "+I[E-1]+` + 1;
        if (`+I[E-1]+" < "+_[E-1]+`) {
          result.g = getValue(`+I+`);
        }

        `+I[E-2]+" = "+I[E-2]+` + 1;
        if (`+I[E-2]+" < "+_[E-2]+`) {
          result.a = getValue(`+I+`);
        }

        `+I[E-1]+" = "+I[E-1]+` - 1;
        if (`+I[E-2]+" < "+_[E-2]+` &&
            `+I[E-1]+" < "+_[E-1]+`) {
          result.b = getValue(`+I+`);
        }
        setOutput(result);
      }
    `}}function n0(m,d,p){const _=m.indexOf(d);return m.map((E,S)=>S===_?E+" - "+p:E).join()}function n1(m){const{inputs:d,backend:p}=m,{input:_}=d,E=p.texData.get(_.dataId);return Ob({inputs:{x:E.complexTensorInfos.imag},backend:p})}function n2(m,d,p){const _=m[0].dtype;if(_==="complex64"){const xe=m.map(ge=>Dt({inputs:{input:ge},backend:p})),le=m.map(ge=>n1({inputs:{input:ge},backend:p})),he=n2(xe,d,p),de=n2(le,d,p),me=OV({inputs:{real:he,imag:de},backend:p});return xe.forEach(ge=>p.disposeIntermediateTensorInfo(ge)),le.forEach(ge=>p.disposeIntermediateTensorInfo(ge)),p.disposeIntermediateTensorInfo(he),p.disposeIntermediateTensorInfo(de),me}let E=p.shouldExecuteOnCPU(m);if(_==="string"&&(E=!0),E){const xe=m.map(ye=>{const ve=[-1,n(ye.shape.slice(d))];return DD({inputs:{x:ye},backend:p,attrs:{shape:ve}})}),le=xe.map(ye=>({vals:p.readSync(ye.dataId),shape:ye.shape})),he=qe(xe.map(ye=>ye.shape),1),de=xe[0].shape[0]===1,me=ND(le,he,_,de),ge=qe(m.map(ye=>ye.shape),d),be=p.makeTensorInfo(ge,_,me);return xe.forEach(ye=>p.disposeIntermediateTensorInfo(ye)),be}const S=m.filter(xe=>n(xe.shape)>0),I=oQ().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&S[0].shape.length>1;if(S.length===1){const xe=I?new OA(m[0].shape,Oi):new OR(m[0].shape,Oi);return p.runWebGLProgram(xe,m,_)}const D=oQ().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(S.length>D){const xe=[];for(let he=0;he<S.length;he+=D){const de=S.slice(he,he+D);xe.push(n2(de,d,p))}const le=n2(xe,d,p);for(const he of xe)p.disposeIntermediateTensorInfo(he);return le}if(I){const xe=new Dg(S.map(le=>le.shape),d);return p.runWebGLProgram(xe,S,_)}const{tensors2D:k,outShape:V}=n3(S,d,p),$=new DV(k.map(xe=>xe.shape)),Z=p.runWebGLProgram($,k,_);k.forEach(xe=>p.disposeIntermediateTensorInfo(xe));const te=DD({inputs:{x:Z},attrs:{shape:V},backend:p});return p.disposeIntermediateTensorInfo(Z),te}function n3(m,d,p){const _=qe(m.map(E=>E.shape),d);return{tensors2D:m.map(E=>DD({inputs:{x:E},attrs:{shape:[-1,n(E.shape.slice(d))]},backend:p})),outShape:_}}function n4(m){const{inputs:d,backend:p,attrs:_}=m,{axis:E}=_,S=X(E,d[0].shape)[0],I=d.map(V=>V.shape);qi(I,S);const D=qe(d.map(V=>V.shape),S);if(n(D)===0)return p.makeTensorInfo(D,d[0].dtype,[]);const k=d.filter(V=>n(V.shape)>0);return k.length===1?Ob({inputs:{x:k[0]},backend:p}):n2(k,S,p)}const n5={kernelName:ou,backendName:"webgl",kernelFunc:n4};class n6{constructor(d,p=!1,_=null,E=!1,S=!1){this.variableNames=["x","W"],this.outputShape=d.outShape;const I=d.padInfo.top,D=d.padInfo.left,k=d.strideHeight,V=d.strideWidth,$=d.dilationHeight,Z=d.dilationWidth,te=d.filterHeight,xe=d.filterWidth,le=Math.floor(d.inChannels/4)*4,he=d.inChannels%4,de=d.dataFormat==="channelsLast",me=de?1:2,ge=de?2:3,be=de?3:1;let ye="",ve="";_&&(E?ye=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+_+`
        }`:S?ye=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+_+`
        }`:ye=`
          float activation(float x) {
            `+_+`
          }
        `,ve="result = activation(result);");const Ie=p?"result += getBiasAtOutCoords();":"";p&&this.variableNames.push("bias"),E&&this.variableNames.push("preluActivationWeights"),S&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+ye+`

      const ivec2 strides = ivec2(`+k+", "+V+`);
      const ivec2 pads = ivec2(`+I+", "+D+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[`+be+`];

        ivec2 xRCCorner =
            ivec2(coords[`+me+"], coords["+ge+`]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+te+`; wR++) {
          int xR = xRCorner + wR * `+$+`;

          if (xR < 0 || xR >= `+d.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+xe+`; wC++) {
            int xC = xCCorner + wC * `+Z+`;

            if (xC < 0 || xC >= `+d.inWidth+`) {
              continue;
            }

            for (int d1 = 0; d1 < `+le+`; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (`+de+`) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (`+(he===1)+`) {

              if (`+de+`) {
                dotProd +=
                    getX(batch, xR, xC, `+le+`) *
                    getW(wR, wC, `+le+`, d2);
              } else {
                dotProd +=
                    getX(batch, `+le+`, xR, xC) *
                    getW(wR, wC, `+le+`, d2);
              }

            } else if (`+(he===2)+`) {
              vec2 wValues = vec2(
                getW(wR, wC, `+le+`, d2),
                getW(wR, wC, `+le+` + 1, d2)
              );

              if (`+de+`) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, `+le+`),
                  getX(batch, xR, xC, `+le+` + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, `+le+`, xR, xC),
                  getX(batch, `+le+` + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (`+(he===3)+`) {
              vec3 wValues = vec3(
                getW(wR, wC, `+le+`, d2),
                getW(wR, wC, `+le+` + 1, d2),
                getW(wR, wC, `+le+` + 2, d2)
              );

              if (`+de+`) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, `+le+`),
                  getX(batch, xR, xC, `+le+` + 1),
                  getX(batch, xR, xC, `+le+` + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, `+le+`, xR, xC),
                  getX(batch, `+le+` + 1, xR, xC),
                  getX(batch, `+le+` + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        `+Ie+`
        `+ve+`
        setOutput(result);
      }
    `}}class n7{constructor(d,p=!1,_=null,E=!1,S=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=d.outShape,this.enableShapeUniforms=Z1(this.outputShape.length);const I=d.padInfo.left,D=d.strideWidth,k=d.dilationWidth,V=d.filterHeight,$=d.filterWidth,Z=$;let te=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let de=0;de<$;de++)te+=`
           vec4 xTexelC`+de*2+`;
           int xTexelC`+de*2+`Ready;
           vec4 xTexelC`+(de*2+1)+`;
           int xTexelC`+(de*2+1)+`Ready;
           vec4 xC`+de+";";te+=`
     for (int r = 0; r < `+V+`; r++) {
      for (int d1 = 0; d1 < `+d.inChannels+`; d1 += 2) {
       `;for(let de=0;de<$;de++)te+=`
           xTexelC`+de*2+` = vec4(0.0);
           xTexelC`+de*2+`Ready = 0;
           xTexelC`+(de*2+1)+` = vec4(0.0);
           xTexelC`+(de*2+1)+`Ready = 0;
           xC`+de+" = vec4(0.0);";te+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let de=0;de<(Z+1)/2;de++){const me=de*2;if(te+=`
           xC = xCCorner + `+me*k+`;
           `,D===1){if(me<$&&(I%2===1?(te+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+me+`Ready == 0) {
                   xTexelC`+me+` = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+me+`.zw = vec2(0.0);
                   }
                   xTexelC`+me+`Ready = 1;
                 }
               `,k===1&&me>0?te+=`
                 xC`+me+" = vec4(xTexelC"+(me-2)+".zw, xTexelC"+me+`.xy);
                 `:te+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC`+me+" = vec4(previous.zw, xTexelC"+me+`.xy);
                   } else {
                     xC`+me+" = vec4(0.0, 0.0, xTexelC"+me+`.xy);
                   }
                   `):te+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC`+me+`Ready == 0) {
                   xTexelC`+me+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+me+`.zw = vec2(0.0);
                   }
                   xTexelC`+me+`Ready = 1;
                 }

                 xC`+me+" = xTexelC"+me+`;
                 `,me+1<$)){const ge=I%2===0?T(k):k;k%2===0&&I%2===1||k%2!==0&&I%2!==1?(te+=`
                   xCOffset = xC + imod(pads[1], 2) + `+ge+`;

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(me+1)+`Ready == 0) {
                     xTexelC`+(me+1)+` = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC`+(me+1)+`.zw = vec2(0.0);
                     }
                     xTexelC`+(me+1)+`Ready = 1;
                   }
                   `,k>1?te+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC`+(me+1)+" = vec4(previous.zw, xTexelC"+(me+1)+`.xy);
                     } else {
                      xC`+(me+1)+" = vec4(0.0, 0.0, xTexelC"+(me+1)+`.xy);
                     }
                     `:te+=`
                     xC`+(me+1)+" = vec4(xTexelC"+me+".zw, xTexelC"+(me+1)+`.xy);
                     `):ge===1?te+=`
                     xC`+(me+1)+" = xTexelC"+me+`;
                     `:te+=`
                     xCOffset = xC + `+ge+`;

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(me+1)+`Ready == 0) {
                       xTexelC`+(me+1)+` = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC`+(me+1)+`.zw = vec2(0.0);
                       }
                       xTexelC`+(me+1)+`Ready = 1;
                     }

                     xC`+(me+1)+" = xTexelC"+(me+1)+`;
                     `}}else me<$&&(I%2===1?(te+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+me+`Ready == 0) {
                   xTexelC`+me+` = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+me+`.zw = vec2(0.0);
                   }
                   xTexelC`+me+`Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(me+1)+`Ready == 0) {
                   xTexelC`+(me+1)+` = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC`+(me+1)+`.zw = vec2(0.0);
                   }
                   xTexelC`+(me+1)+`Ready = 1;
                 }

                 xC`+me+" = vec4(xTexelC"+me+".zw, xTexelC"+(me+1)+`.zw);
               `,me+1<$&&(te+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC`+(me+1)+" = vec4(xTexelC"+(me+1)+`.xy, final.xy);
                 `)):(te+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC`+me+`Ready == 0) {
                   xTexelC`+me+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+me+`.zw = vec2(0.0);
                   }
                   xTexelC`+me+`Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(me+1)+`Ready == 0) {
                   xTexelC`+(me+1)+` = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+(me+1)+`.zw = vec2(0.);
                   }
                   xTexelC`+(me+1)+`Ready = 1;
                 }

                 xC`+me+` = vec4(
                   xTexelC`+me+".xy, xTexelC"+(me+1)+`.xy);
               `,me+1<$&&(te+=`
                   xC`+(me+1)+" = vec4(xTexelC"+me+".zw, xTexelC"+(me+1)+`.zw);
                 `)));me<$&&(te+=`
             wTexel = getW(r, `+me+`, d1, d2);
             dotProd += xC`+me+`.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < `+d.inChannels+`) {
               dotProd += xC`+me+`.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,me+1<$&&(te+=`
               wTexel = getW(r, `+(me+1)+`, d1, d2);
               dotProd += xC`+(me+1)+`.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < `+d.inChannels+`) {
                 dotProd += xC`+(me+1)+`.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}te+=`
     }
   `,te+=`
     }
   `,te+=`
     }
   `;let xe="",le="";_&&(E?xe=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           `+_+`
         }`:S?xe=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           `+_+`
         }`:xe=`vec4 activation(vec4 x) {
           `+_+`
         }`,le="result = activation(result);");const he=p?"result += getBiasAtOutCoords();":"";p&&this.variableNames.push("bias"),E&&this.variableNames.push("preluActivationWeights"),S&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       `+xe+`

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         `+te+`

         vec4 result = dotProd - vec4(0.000000000000001);
         `+he+`
         `+le+`
         setOutput(result);
       }
     `}}class n8{constructor(d,p){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=d,this.enableShapeUniforms=Z1(this.outputShape.length);const{dataFormat:_}=p,E=A4(),S=_==="channelsLast",I=S?1:2,D=S?2:3,k=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < "+d[2]+" && pos < "+d[1]+") {";let V="";for(let $=0;$<=1;$++)for(let Z=0;Z<=1;Z++)V+=`
          blockIndex = rc.z + `+Z+`;
          pos = rc.y + `+$+`;

          `+k+`
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[`+I+`] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[`+D+`] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (`+S+`) {
                  innerDims = vec2(d1, ch);
                  result[`+($*2+Z)+`] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[`+($*2+Z)+`] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        `+V+`

        `+E.output+` = result;
      }
    `}}function n9(m,d){const p=m.length;return p>=3?d?[...m.slice(0,-3),m[p-3]*m[p-2],m[p-1]]:[...m.slice(0,-3),m[p-3],m[p-2]*m[p-1]]:!d&&p===1&&m[0]>1?[m[0],1]:null}function no({x:m,filter:d,convInfo:p,backend:_,bias:E=null,preluActivationWeights:S=null,leakyreluAlpha:I=0,activation:D=null}){const k=m.shape,V=_.texData.get(m.dataId),$=p.inChannels,Z=k[0]*k[1]*k[2],te=p.outChannels,xe=p.dataFormat==="channelsLast",le=!1,he=!1;let de;const me=[];if(S!=null){const ge=n9(S.shape,xe);ge!=null&&(S=DD({inputs:{x:S},backend:_,attrs:{shape:ge}}),me.push(S))}if(E!=null){const ge=n9(E.shape,xe);ge!=null&&(E=DD({inputs:{x:E},backend:_,attrs:{shape:ge}}),me.push(E))}if(!((Z===1||te===1)&&$>DE)&&V.isPacked&&xe&&V.texture!=null&&k[2]%2!==0&&i(V.shape.slice(-3),k.slice(-3))){const ge=k[0]*k[1]*(k[2]+1),be={dataId:m.dataId,shape:[1,ge,p.inChannels],dtype:m.dtype},ye=V.shape;V.shape=V.shape.slice(),V.shape[V.shape.length-2]++,A(wt(V.shape,be.shape),()=>"packed reshape "+V.shape+" to "+be.shape+" isn't free");const ve=DD({inputs:{x:d},backend:_,attrs:{shape:[1,p.inChannels,p.outChannels]}});me.push(ve);const Ie=DW({a:be,b:ve,backend:_,transposeA:le,transposeB:he,bias:E,activation:D,preluActivationWeights:S,leakyreluAlpha:I}),je=_.texData.get(Ie.dataId);A(je.isPacked,()=>"batchMatMul result is expected to be packed"),V.shape=ye,je.shape=p.outShape,de=Ob({inputs:{x:Ie},backend:_}),de.shape=p.outShape,me.push(Ie)}else{const ge=p.outHeight*p.outWidth,be=DD({inputs:{x:m},backend:_,attrs:{shape:xe?[p.batchSize,ge,p.inChannels]:[p.batchSize,p.inChannels,ge]}}),ye=DD({inputs:{x:d},backend:_,attrs:{shape:[1,p.inChannels,p.outChannels]}}),ve=DW({a:xe?be:ye,b:xe?ye:be,transposeA:!xe,transposeB:he,backend:_,bias:E,activation:D,preluActivationWeights:S,leakyreluAlpha:I});de=DD({inputs:{x:ve},backend:_,attrs:{shape:p.outShape}}),me.push(be),me.push(ye),me.push(ve)}for(const ge of me)_.disposeIntermediateTensorInfo(ge);return de}function nc({x:m,filter:d,convInfo:p,backend:_,bias:E=null,preluActivationWeights:S=null,leakyreluAlpha:I=0,activation:D=null}){const{filterWidth:k,filterHeight:V,inChannels:$,outWidth:Z,outHeight:te,dataFormat:xe}=p,le=xe==="channelsLast",he=k*V*$,de=te*Z,me=[p.batchSize,he,de],ge=!0,be=!1,ye=[];if(S!=null){const yi=n9(S.shape,le);yi!=null&&(S=DD({inputs:{x:S},backend:_,attrs:{shape:yi}}),ye.push(S))}if(E!=null){const yi=n9(E.shape,le);yi!=null&&(E=DD({inputs:{x:E},backend:_,attrs:{shape:yi}}),ye.push(E))}const ve=DD({inputs:{x:d},backend:_,attrs:{shape:[1,he,n(d.shape)/he]}});ye.push(ve);const Ie=new n8(me,p),je=[m.shape,[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inChannels],[p.filterWidth*p.inChannels],[p.outWidth]],Me=_.runWebGLProgram(Ie,[m],"float32",je),xt=DD({inputs:{x:Me},backend:_,attrs:{shape:me}});ye.push(Me),ye.push(xt);const bt=E!=null,gt=S!=null,Xt=D==="leakyrelu",Ut=D?D8(D,!0):null,Ht=new Dp(le?xt.shape:ve.shape,le?ve.shape:xt.shape,le?[p.batchSize,de,p.outChannels]:[p.batchSize,p.outChannels,de],ge,be,bt,Ut,gt,Xt),mi=le?[xt,ve]:[ve,xt];if(E&&mi.push(E),gt&&mi.push(S),Xt){const yi=_.makeTensorInfo([],"float32",GJ(I,"float32"));mi.push(yi),ye.push(yi)}const gi=_.runWebGLProgram(Ht,mi,"float32"),Ui=DD({inputs:{x:gi},backend:_,attrs:{shape:p.outShape}});ye.push(gi);for(const yi of ye)_.disposeIntermediateTensorInfo(yi);return Ui}function nG(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,filter:S}=d,{strides:I,pad:D,dataFormat:k,dilations:V,dimRoundingMode:$}=_,Z=LU(k),te=LS(E.shape,S.shape,I,V,D,$,!1,Z);let xe;if(te.filterHeight===1&&te.filterWidth===1&&te.dilationHeight===1&&te.dilationWidth===1&&te.strideHeight===1&&te.strideWidth===1&&(te.padInfo.type==="SAME"||te.padInfo.type==="VALID"))xe=no({x:E,filter:S,convInfo:te,backend:p});else if(te.strideWidth<=2&&Z==="channelsLast"&&oQ().getBool("WEBGL_EXP_CONV")){const he=new n7(te),de=[[te.padInfo.top,te.padInfo.left],[te.strideHeight,te.strideWidth],[te.dilationHeight,te.dilationWidth],[te.inHeight,te.inWidth]];xe=p.runWebGLProgram(he,[E,S],"float32",de)}else if(oQ().getBool("WEBGL_CONV_IM2COL"))xe=nc({x:E,filter:S,convInfo:te,backend:p});else{const he=new n6(te);xe=p.runWebGLProgram(he,[E,S],"float32")}const le=DD({inputs:{x:xe},backend:p,attrs:{shape:te.outShape}});return p.disposeIntermediateTensorInfo(xe),le}const ns={kernelName:oX,backendName:"webgl",kernelFunc:nG};class nz{constructor(d){this.variableNames=["dy","W"],this.outputShape=d.inShape;const p=d.filterHeight,_=d.filterWidth,E=d.strideHeight,S=d.strideWidth,I=d.dataFormat==="channelsLast",D=p-1-d.padInfo.top,k=_-1-d.padInfo.left,V=I?1:2,$=I?2:3,Z=I?3:1;this.userCode=`
      const ivec2 pads = ivec2(`+D+", "+k+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[`+Z+`];

        ivec2 dyCorner = ivec2(coords[`+V+"], coords["+$+`]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+p+`; wR++) {
          float dyR = float(dyRCorner + wR) / `+E+`.0;

          if (dyR < 0.0 || dyR >= `+d.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = `+p+` - 1 - wR;

          for (int wC = 0; wC < `+_+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+S+`.0;

            if (dyC < 0.0 || dyC >= `+d.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = `+_+` - 1 - wC;

            for (int d2 = 0; d2 < `+d.outChannels+`; d2++) {

              if (`+I+`) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class nC{constructor(d){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=d.inShape,this.enableShapeUniforms=Z1(this.outputShape.length);const p=d.filterHeight,_=d.filterWidth,E=p-1-d.padInfo.top,S=_-1-d.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(`+E+", "+S+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < `+p+`; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= `+d.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = `+p+` - 1 - wR;

          for (int wC = 0; wC < `+_+`; wC++) {
            int wCPerm = `+_+` - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < `+d.outWidth+`.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < `+d.outWidth+`.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < `+d.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < `+d.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < `+d.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function nL(m){const{inputs:d,backend:p,attrs:_}=m,{dy:E,filter:S}=d,{inputShape:I,strides:D,pad:k,dataFormat:V,dimRoundingMode:$}=_,Z=LU(V),te=LS(I,S.shape,D,1,k,$,!1,Z);if(oQ().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&Z==="channelsLast"){const xe=[[te.strideHeight,te.strideWidth]],le=new nC(te);return p.runWebGLProgram(le,[E,S],"float32",xe)}else{const xe=new nz(te);return p.runWebGLProgram(xe,[E,S],"float32")}}const nK={kernelName:oy,backendName:"webgl",kernelFunc:nL},nr=D5+`
  return cos(x);
`,nT=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  `+Ox+`
  return result;
`,nq=D6({opSnippet:nr,packedOpSnippet:nT}),nQ={kernelName:oE,backendName:"webgl",kernelFunc:nq};class nk{constructor(d,p,_,E,S){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[I,D,k,V]=d,[$]=p,[Z,te]=_;this.outputShape=[$,Z,te,V];const xe=E==="bilinear"?1:0,[le,he]=[D-1+".0",k-1+".0"],[de,me,ge]=Z>1?[""+(D-1)/(Z-1),"(y2-y1) * height_ratio","y1*"+le+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+le],[be,ye,ve]=te>1?[""+(k-1)/(te-1),"(x2-x1) * width_ratio","x1*"+he+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+he];this.userCode=`
      const float height_ratio = float(`+de+`);
      const float width_ratio = float(`+be+`);
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= `+I+`) {
          return;
        }

        float height_scale = `+me+`;
        float width_scale = `+ye+`;

        float in_y = `+ge+`;
        if( in_y < 0.0 || in_y > `+le+` ) {
          setOutput(float(`+S+`));
          return;
        }
        float in_x = `+ve+`;
        if( in_x < 0.0 || in_x > `+he+` ) {
          setOutput(float(`+S+`));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(`+xe+` == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const np=m=>{const{inputs:d,backend:p,attrs:_}=m,{image:E,boxes:S,boxInd:I}=d,{cropSize:D,method:k,extrapolationValue:V}=_,$=new nk(E.shape,S.shape,D,k,V);return p.runWebGLProgram($,[E,S,I],"float32")},nw={kernelName:oW,backendName:"webgl",kernelFunc:np};class nA{constructor(d,p,_){this.variableNames=["x"],this.outputShape=[],this.outputShape=d,this.blockSize=p,this.dataFormat=_,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = `+this.getHeightCoordString()+`;
      int w = `+this.getWidthCoordString()+`;
      int d = `+this.getDepthCoordString()+`;

      int in_h = h / `+p+`;
      int offset_h = imod(h, `+p+`);
      int in_w = w / `+p+`;
      int offset_w = imod(w, `+p+`);
      int offset_d = (offset_h * `+p+` + offset_w) *
        `+this.getOutputDepthSize()+`;
      int in_d = d + offset_d;

      float result = `+this.getInputSamplingString()+`;
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function nZ(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{blockSize:S,dataFormat:I}=_,D=E.shape[0],k=I==="NHWC"?E.shape[1]:E.shape[2],V=I==="NHWC"?E.shape[2]:E.shape[3],$=I==="NHWC"?E.shape[3]:E.shape[1],Z=k*S,te=V*S,xe=$/(S*S),le=I==="NHWC"?[D,Z,te,xe]:[D,xe,Z,te],he=new nA(le,S,I);return p.runWebGLProgram(he,[E],E.dtype)}const nF={kernelName:od,backendName:"webgl",kernelFunc:nZ};class nN{constructor(d,p=!1,_=null,E=!1,S=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=d.outShape,this.enableShapeUniforms=Z1(this.outputShape.length);const I=d.filterHeight,D=d.filterWidth,k=d.outChannels/d.inChannels;let V="",$="";_&&(E?V=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+_+`
        }`:S?V=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+_+`
        }`:V=`
          float activation(float x) {
            `+_+`
          }
        `,$="result = activation(result);");const Z=p?"result += getBiasAtOutCoords();":"";p&&this.variableNames.push("bias"),E&&this.variableNames.push("preluActivationWeights"),S&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+V+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+k+`;
        int q = d2 - d1 * `+k+`;

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < `+I+`; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < `+D+`; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        `+Z+`
        `+$+`
        setOutput(result);
      }
    `}}class nO{constructor(d,p=!1,_=null,E=!1,S=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=d.outShape,this.enableShapeUniforms=Z1(this.outputShape.length);const I=d.outChannels/d.inChannels,D=d.padInfo.left,k=d.strideWidth,V=d.dilationWidth,$=d.filterHeight,Z=d.filterWidth,te=Z;let xe=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let me=0;me<Z;me++)xe+=`
          vec4 xTexelC`+me*2+`;
          int xTexelC`+me*2+`Ready;
          vec4 xTexelC`+(me*2+1)+`;
          int xTexelC`+(me*2+1)+`Ready;
          vec4 xC`+me+";";xe+=`
    for (int r = 0; r < `+$+`; r++) {
      `;for(let me=0;me<Z;me++)xe+=`
          xTexelC`+me*2+` = vec4(0.0);
          xTexelC`+me*2+`Ready = 0;
          xTexelC`+(me*2+1)+` = vec4(0.0);
          xTexelC`+(me*2+1)+`Ready = 0;
          xC`+me+" = vec4(0.0);";xe+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let me=0;me<(te+1)/2;me++){const ge=me*2;if(xe+=`
          xC = xCCorner + `+ge*V+`;
          `,k===1){if(ge<Z&&(D%2===1?(xe+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+ge+`Ready == 0) {
                  xTexelC`+ge+` = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+ge+`.zw = vec2(0.0);
                  }
                  xTexelC`+ge+`Ready = 1;
                }
              `,V===1&&ge>0?xe+=`
                xC`+ge+" = vec4(xTexelC"+(ge-2)+".zw, xTexelC"+ge+`.xy);
                `:xe+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC`+ge+" = vec4(previous.zw, xTexelC"+ge+`.xy);
                  } else {
                    xC`+ge+" = vec4(0.0, 0.0, xTexelC"+ge+`.xy);
                  }
                  `):xe+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC`+ge+`Ready == 0) {
                  xTexelC`+ge+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+ge+`.zw = vec2(0.0);
                  }
                  xTexelC`+ge+`Ready = 1;
                }

                xC`+ge+" = xTexelC"+ge+`;
                `,ge+1<Z)){const be=D%2===0?T(V):V;V%2===0&&D%2===1||V%2!==0&&D%2!==1?(xe+=`
                  xCOffset = xC + imod(pads[1], 2) + `+be+`;

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(ge+1)+`Ready == 0) {
                    xTexelC`+(ge+1)+` = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC`+(ge+1)+`.zw = vec2(0.0);
                    }
                    xTexelC`+(ge+1)+`Ready = 1;
                  }
                  `,V>1?xe+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC`+(ge+1)+" = vec4(previous.zw, xTexelC"+(ge+1)+`.xy);
                    } else {
                     xC`+(ge+1)+" = vec4(0.0, 0.0, xTexelC"+(ge+1)+`.xy);
                    }
                    `:xe+=`
                    xC`+(ge+1)+" = vec4(xTexelC"+ge+".zw, xTexelC"+(ge+1)+`.xy);
                    `):be===1?xe+=`
                    xC`+(ge+1)+" = xTexelC"+ge+`;
                    `:xe+=`
                    xCOffset = xC + `+be+`;

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(ge+1)+`Ready == 0) {
                      xTexelC`+(ge+1)+` = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC`+(ge+1)+`.zw = vec2(0.0);
                      }
                      xTexelC`+(ge+1)+`Ready = 1;
                    }

                    xC`+(ge+1)+" = xTexelC"+(ge+1)+`;
                    `}}else ge<Z&&(D%2===1?(xe+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+ge+`Ready == 0) {
                  xTexelC`+ge+` = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+ge+`.zw = vec2(0.0);
                  }
                  xTexelC`+ge+`Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(ge+1)+`Ready == 0) {
                  xTexelC`+(ge+1)+` = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC`+(ge+1)+`.zw = vec2(0.0);
                  }
                  xTexelC`+(ge+1)+`Ready = 1;
                }

                xC`+ge+" = vec4(xTexelC"+ge+".zw, xTexelC"+(ge+1)+`.zw);
              `,ge+1<Z&&(xe+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC`+(ge+1)+" = vec4(xTexelC"+(ge+1)+`.xy, final.xy);
                `)):(xe+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC`+ge+`Ready == 0) {
                  xTexelC`+ge+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+ge+`.zw = vec2(0.0);
                  }
                  xTexelC`+ge+`Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(ge+1)+`Ready == 0) {
                  xTexelC`+(ge+1)+` = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+(ge+1)+`.zw = vec2(0.);
                  }
                  xTexelC`+(ge+1)+`Ready = 1;
                }

                xC`+ge+` = vec4(
                  xTexelC`+ge+".xy, xTexelC"+(ge+1)+`.xy);
              `,ge+1<Z&&(xe+=`
                  xC`+(ge+1)+" = vec4(xTexelC"+ge+".zw, xTexelC"+(ge+1)+`.zw);
                `)));ge<Z&&(xe+=`
            wTexel = getW(r, `+ge+`, d1, q);
            dotProd += xC`+ge+` * vec4(wTexel.xz, wTexel.xz);
          `,ge+1<Z&&(xe+=`
              wTexel = getW(r, `+(ge+1)+`, d1, q);
              dotProd += xC`+(ge+1)+` * vec4(wTexel.xz, wTexel.xz);
            `))}xe+=`
    }
  `,xe+=`
      }
    `;let le="",he="";_&&(E?le=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+_+`
        }`:S?le=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+_+`
        }`:le=`vec4 activation(vec4 x) {
          `+_+`
        }`,he="result = activation(result);");const de=p?"result += getBiasAtOutCoords();":"";p&&this.variableNames.push("bias"),E&&this.variableNames.push("preluActivationWeights"),S&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+le+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+I+`;
        int q = d2 - d1 * `+I+`;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        `+xe+`

        vec4 result = dotProd - vec4(0.000000000000001);
        `+de+`
        `+he+`
        setOutput(result);
      }
    `}}function nD(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,filter:S}=d,{strides:I,pad:D,dilations:k,dimRoundingMode:V}=_;let $=k;$==null&&($=[1,1]),A(Ld(I,$),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+I+" and dilations '"+$+"'");const Z=LS(E.shape,S.shape,I,$,D,V,!0);let te;oQ().getBool("WEBGL_PACK_DEPTHWISECONV")&&Z.strideWidth<=2&&Z.outChannels/Z.inChannels===1?te=new nO(Z):te=new nN(Z);const xe=[[Z.padInfo.top,Z.padInfo.left],[Z.strideHeight,Z.strideWidth],[Z.dilationHeight,Z.dilationWidth],[Z.inHeight,Z.inWidth]];return p.runWebGLProgram(te,[E,S],"float32",xe)}const nn={kernelName:oM,backendName:"webgl",kernelFunc:nD};function ni(m){const{inputs:d,attrs:p,backend:_}=m,{dim:E}=p,{input:S}=d,I=S.shape.length,D=S.shape.slice();let k=E;return E<0&&(A(-(I+1)<=E,()=>"Axis must be in the interval ["+-(I+1)+", "+I+"]"),k=I+E+1),D.splice(k,0,1),DD({inputs:{x:S},backend:_,attrs:{shape:D}})}const ne={kernelName:oY,backendName:"webgl",kernelFunc:ni};class nP{constructor(d,p){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=d,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function nS(m){const{backend:d,attrs:p}=m,{shape:_,value:E}=p;let{dtype:S}=p;if(S=S||o3(E),S==="string"){const I=U(S,n(_));return I.fill(E),d.makeTensorInfo(_,S,I)}else{const I=new nP(_,E),D=[[E]];return d.runWebGLProgram(I,[],S,D)}}const nI={kernelName:om,backendName:"webgl",kernelFunc:nS},nB="return floor(x);",nj=D6({opSnippet:nB,packedOpSnippet:nB,cpuKernelImpl:NP}),nR={kernelName:ol,backendName:"webgl",kernelFunc:nj};class nH{constructor(d){this.variableNames=["A"];const p=A4(),[_,E]=d;this.outputShape=d,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+E+".0, "+_+`.0);

        vec4 values = `+p.texture2D+`(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class nu{constructor(d){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const p=A4(),[_,E]=d;this.outputShape=d,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(`+E+".0, "+_+`.0);
            vec4 values = `+p.texture2D+`(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        `+p.output+` = result;
      }
    `}}const nX={kernelName:cM,backendName:"webgl",kernelFunc:nE};let nf,ny=oQ().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function nE(m){const{inputs:d,backend:p,attrs:_}=m;let{pixels:E}=d;const{numChannels:S}=_,I=typeof HTMLVideoElement<"u"&&E instanceof HTMLVideoElement,D=typeof HTMLImageElement<"u"&&E instanceof HTMLImageElement,[k,V]=I?[E.videoWidth,E.videoHeight]:[E.width,E.height],$=[V,k],Z=[V,k,S];if(D||I){const he=oQ().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(nf==null||he!==ny)&&(ny=he,nf=document.createElement("canvas").getContext("2d",{willReadFrequently:ny})),nf.canvas.width=k,nf.canvas.height=V,nf.drawImage(E,0,0,k,V),E=nf.canvas}const te=p.makeTensorInfo($,"int32");p.texData.get(te.dataId).usage=w8.PIXELS,p.gpgpu.uploadPixelDataToTexture(p.getTexture(te.dataId),E);const xe=oQ().getBool("WEBGL_PACK")?new nu(Z):new nH(Z),le=p.runWebGLProgram(xe,[te],"int32");return p.disposeData(te.dataId),le}function nW(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,filter:S,bias:I,preluActivationWeights:D}=d,{strides:k,pad:V,dataFormat:$,dilations:Z,dimRoundingMode:te,activation:xe,leakyreluAlpha:le}=_,he=LU($),de=LS(E.shape,S.shape,k,Z,V,te,!1,he);let me;const ge=[],be=I!=null,ye=D!=null,ve=xe==="leakyrelu",Ie=()=>{const Me=[E,S],xt=(bt,gt)=>{if(gt==="NCHW"&&bt.shape.length===1&&bt.shape[0]!==1){const Xt=DD({inputs:{x:bt},backend:p,attrs:{shape:[bt.shape[0],1,1]}});return ge.push(Xt),Xt}return bt};if(be&&Me.push(xt(I,$)),ye&&Me.push(xt(D,$)),ve){const bt=p.makeTensorInfo([],"float32",GJ(le,"float32"));Me.push(bt),ge.push(bt)}return Me};if(de.filterHeight===1&&de.filterWidth===1&&de.dilationHeight===1&&de.dilationWidth===1&&de.strideHeight===1&&de.strideWidth===1&&(de.padInfo.type==="SAME"||de.padInfo.type==="VALID"))me=no({x:E,filter:S,convInfo:de,backend:p,bias:I,activation:xe,preluActivationWeights:D,leakyreluAlpha:le});else if(de.strideWidth<=2&&he==="channelsLast"&&oQ().getBool("WEBGL_EXP_CONV")){const Me=xe?D8(xe,!0):null,xt=new n7(de,be,Me,ye,ve),bt=[[de.padInfo.top,de.padInfo.left],[de.strideHeight,de.strideWidth],[de.dilationHeight,de.dilationWidth],[de.inHeight,de.inWidth]],gt=Ie();me=p.runWebGLProgram(xt,gt,"float32",bt)}else if(oQ().getBool("WEBGL_CONV_IM2COL"))me=nc({x:E,filter:S,convInfo:de,backend:p,bias:I,activation:xe,preluActivationWeights:D,leakyreluAlpha:le});else{const Me=xe?D8(xe,!1):null,xt=new n6(de,be,Me,ye,ve),bt=Ie();me=p.runWebGLProgram(xt,bt,"float32")}const je=DD({inputs:{x:me},backend:p,attrs:{shape:de.outShape}});return ge.push(me),ge.forEach(Me=>p.disposeIntermediateTensorInfo(Me)),je}const nd={kernelName:ct,backendName:"webgl",kernelFunc:nW};function nM(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,filter:S,bias:I,preluActivationWeights:D}=d,{strides:k,pad:V,dilations:$,dimRoundingMode:Z,activation:te,leakyreluAlpha:xe}=_,le=[];let he=$;he==null&&(he=[1,1]),A(Ld(k,he),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+k+" and dilations '"+he+"'");const de=LS(E.shape,S.shape,k,he,V,Z,!0),me=oQ().getBool("WEBGL_PACK_DEPTHWISECONV")&&de.strideWidth<=2&&de.outChannels/de.inChannels===1,ge=te?D8(te,me):null,be=[E,S],ye=I!=null,ve=D!=null,Ie=te==="leakyrelu";if(ye&&be.push(I),ve&&be.push(D),Ie){const bt=p.makeTensorInfo([],"float32",GJ(xe,"float32"));be.push(bt),le.push(bt)}let je;me?je=new nO(de,ye,ge,ve,Ie):je=new nN(de,ye,ge,ve,Ie);const Me=[[de.padInfo.top,de.padInfo.left],[de.strideHeight,de.strideWidth],[de.dilationHeight,de.dilationWidth],[de.inHeight,de.inWidth]],xt=p.runWebGLProgram(je,be,"float32",Me);return le.forEach(bt=>p.disposeIntermediateTensorInfo(bt)),xt}const nU={kernelName:cv,backendName:"webgl",kernelFunc:nM};class nJ{constructor(d,p){this.variableNames=["A","indices"],this.outputShape=p,this.rank=p.length;const _=AY(this.rank),E=nt(d);this.userCode=`
      void main() {
        `+_+` resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < `+d[2]+`) ? 1.0 : 0.0;
        setOutput(inBounds * getA(`+E+`));
      }
    `}}function nt(m,d){const p=["resRC.x","resRC.y","resRC.z","resRC.w"],_=[];for(let E=0;E<m.length;E++)E===2?_.push("index"):_.push(""+p[E]);return _.join()}function nv(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,indices:S}=d,{axis:I,batchDims:D}=_,k=X(I,E.shape)[0];if(oQ().get("DEBUG")){const ge=p.readSync(S.dataId),be=E.shape[k];for(let ye=0;ye<ge.length;++ye){const ve=ge[ye];A(ve<=be-1&&ve>=0,()=>"GatherV2: the index value "+ve+" is not in [0, "+(be-1)+"]")}}const V=QZ(E,S,k,D),$=n(S.shape),Z=[],te=DD({inputs:{x:E},backend:p,attrs:{shape:[V.batchSize,V.outerSize,V.dimSize,V.sliceSize]}}),xe=DD({inputs:{x:S},backend:p,attrs:{shape:[V.batchSize,$/V.batchSize]}});Z.push(te),Z.push(xe);const le=[V.batchSize,V.outerSize,$/V.batchSize,V.sliceSize];if(p.shouldExecuteOnCPU([E,S])||E.dtype==="string"){const ge=p.bufferSync(xe),be=p.bufferSync(te),ye=NI(be,ge,le);return Z.forEach(ve=>p.disposeIntermediateTensorInfo(ve)),p.makeTensorInfo(V.outputShape,ye.dtype,ye.values)}const he=new nJ(te.shape,le),de=p.runWebGLProgram(he,[te,xe],te.dtype);Z.push(de);const me=DD({inputs:{x:de},backend:p,attrs:{shape:V.outputShape}});return Z.forEach(ge=>p.disposeIntermediateTensorInfo(ge)),me}const nh={kernelName:oa,backendName:"webgl",kernelFunc:nv},nY="return float(a >= b);",nm=`
  return vec4(greaterThanEqual(a, b));
`,nx=D7({opSnippet:nY,packedOpSnippet:nm,dtype:"bool",cpuKernelImpl:Nj}),nl={kernelName:og,backendName:"webgl",kernelFunc:nx},nb="return float(a < b);",na=`
  return vec4(lessThan(a, b));
`,nV=D7({opSnippet:nb,packedOpSnippet:na,cpuKernelImpl:NR,dtype:"bool"}),ng={kernelName:c3,backendName:"webgl",kernelFunc:nV},i0="return float(a <= b);",i1=`
  return vec4(lessThanEqual(a, b));
`,i2=D7({opSnippet:i0,packedOpSnippet:i1,cpuKernelImpl:NH,dtype:"bool"}),i3={kernelName:c4,backendName:"webgl",kernelFunc:i2},i4="return float(a >= 1.0 && b >= 1.0);",i5=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,i6=D7({opSnippet:i4,packedOpSnippet:i5,dtype:"bool"}),i7={kernelName:c5,backendName:"webgl",kernelFunc:i6},i8="return float(a >= 1.0 || b >= 1.0);",i9=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,ic=D7({opSnippet:i8,packedOpSnippet:i9,dtype:"bool"}),iG={kernelName:c6,backendName:"webgl",kernelFunc:ic};function is(m,d,p,_){const E=n(d),S=n(m.shape)/E,I=DD({inputs:{x:m},attrs:{shape:[S,E]},backend:_}),D=DS(I,m.dtype,"max",_),k=DD({inputs:{x:D},attrs:{shape:p},backend:_});return _.disposeIntermediateTensorInfo(I),_.disposeIntermediateTensorInfo(D),k}function iz(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{reductionIndices:S,keepDims:I}=_,D=E.shape.length,k=X(S,E.shape);let V=k;const $=KH(V,D),Z=$!=null,te=p.shouldExecuteOnCPU([E]);let xe=E;if(Z){if(te){const ge=p.texData.get(xe.dataId).values,be=new Array(D);for(let Ie=0;Ie<be.length;Ie++)be[Ie]=E.shape[$[Ie]];const ye=Oo(ge,E.shape,E.dtype,$,be);xe=p.makeTensorInfo(be,E.dtype);const ve=p.texData.get(xe.dataId);ve.values=ye}else xe=DR(E,$,p);V=KX(V.length,D)}KR("max",V,D);const[le,he]=KB(xe.shape,V);let de=le;I&&(de=Kj(le,k));let me;if(te){const ge=p.texData.get(xe.dataId).values,be=Nf(ge,n(he),de,E.dtype);me=p.makeTensorInfo(de,E.dtype);const ye=p.texData.get(me.dataId);ye.values=be}else me=is(xe,he,de,p);return Z&&p.disposeIntermediateTensorInfo(xe),me}const iC={kernelName:c7,backendName:"webgl",kernelFunc:iz};function iL(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d;A2(E,"maxPool");const{filterSize:S,strides:I,pad:D,dimRoundingMode:k}=_,V=1;A(Ld(I,V),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+I+" and dilations '"+V+"'");const $=Le(E.shape,S,I,V,D,k);if($.filterWidth===1&&$.filterHeight===1&&i($.inShape,$.outShape))return Ob({inputs:{x:E},backend:p});const Z=new Dq($,"max",!1);return p.runWebGLProgram(Z,[E],E.dtype)}const iK={kernelName:c9,backendName:"webgl",kernelFunc:iL},ir=OY+`
  return max(a, b);
`,iT=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ox+`
  return result;
`,iq=D7({opSnippet:ir,packedOpSnippet:iT,cpuKernelImpl:Ny}),iQ={kernelName:c8,backendName:"webgl",kernelFunc:iq};function ik(m,d,p,_){const E=n(d),S=n(m.shape)/E,I=DD({inputs:{x:m},attrs:{shape:[S,E]},backend:_}),D=DS(I,"float32","mean",_),k=DD({inputs:{x:D},attrs:{shape:p},backend:_});return _.disposeIntermediateTensorInfo(I),_.disposeIntermediateTensorInfo(D),k}const ip={kernelName:co,backendName:"webgl",kernelFunc:({inputs:m,attrs:d,backend:p})=>{const{x:_}=m,{keepDims:E,axis:S}=d,I=p,D=_.shape.length,k=X(S,_.shape);let V=k;const $=KH(V,D),Z=$!=null,te=I.shouldExecuteOnCPU([_]),xe=[];let le=_;if(Z){if(te){const be=I.texData.get(le.dataId).values,ye=new Array(D);for(let je=0;je<ye.length;je++)ye[je]=_.shape[$[je]];const ve=Oo(be,_.shape,_.dtype,$,ye);le=I.makeTensorInfo(ye,_.dtype);const Ie=I.texData.get(le.dataId);Ie.values=ve}else le=DR(_,$,I);xe.push(le),V=KX(V.length,D)}KR("sum",V,D);const[he,de]=KB(le.shape,V);let me=he;E&&(me=Kj(he,k));const ge=ik(le,de,me,I);for(const be of xe)I.disposeIntermediateTensorInfo(be);return ge}};function iw(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{axis:S,keepDims:I}=_,D=E.shape.length,k=X(S,E.shape);let V=k;const $=KH(V,D);let Z=E;$!=null&&(Z=Df({inputs:{x:E},backend:p,attrs:{perm:$}}),V=KX(V.length,E.shape.length)),KR("min",V,D);const[te,xe]=KB(Z.shape,V),le=n(xe),he=DD({inputs:{x:Z},backend:p,attrs:{shape:[-1,le]}}),de=DS(he,he.dtype,"min",p);let me;if(I){const ge=Kj(te,k);me=DD({inputs:{x:de},backend:p,attrs:{shape:ge}})}else me=DD({inputs:{x:de},backend:p,attrs:{shape:te}});return p.disposeIntermediateTensorInfo(he),p.disposeIntermediateTensorInfo(de),$!=null&&p.disposeIntermediateTensorInfo(Z),me}const iA={kernelName:cc,backendName:"webgl",kernelFunc:iw},iZ=OY+`
  return min(a, b);
`,iF=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ox+`
  return result;
`,iN=D7({opSnippet:iZ,packedOpSnippet:iF,cpuKernelImpl:NE}),iO={kernelName:cG,backendName:"webgl",kernelFunc:iN},iD=OZ+`
  return -x;
`,ii=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function ie(m){const{inputs:d,backend:p}=m,{x:_}=d;if(p.shouldExecuteOnCPU([_])){const S=p.texData.get(_.dataId),[I,D]=Nd(S.values,_.shape,_.dtype);return p.makeTensorInfo(D,_.dtype,I)}let E;return oQ().getBool("WEBGL_PACK_UNARY_OPERATIONS")?E=new OR(_.shape,ii):E=new OA(_.shape,iD),p.runWebGLProgram(E,[_],_.dtype)}const iP={kernelName:cz,backendName:"webgl",kernelFunc:ie};function iS(m){const{inputs:d,backend:p,attrs:_}=m,{axis:E}=_;if(d.length===1)return ni({inputs:{input:d[0]},backend:p,attrs:{dim:E}});const S=d[0].shape,I=d[0].dtype;d.forEach($=>{N(S,$.shape,"All tensors passed to stack must have matching shapes"),A(I===$.dtype,()=>"All tensors passed to stack must have matching dtypes")});const D=[],k=d.map($=>{const Z=ni({inputs:{input:$},backend:p,attrs:{dim:E}});return D.push(Z),Z}),V=n4({inputs:k,backend:p,attrs:{axis:E}});return D.forEach($=>p.disposeIntermediateTensorInfo($)),V}const iI={kernelName:cr,backendName:"webgl",kernelFunc:iS};class iB{constructor(d,p,_){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=p.map((V,$)=>V[0]+d[$]+V[1]);const E=d.length,S=AY(E),I=p.map(V=>V[0]).join(","),D=p.map((V,$)=>V[0]+d[$]).join(","),k=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,E);if(E===1){this.userCode=`
        int start = `+I+`;
        int end = `+D+`;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      `+S+" start = "+S+"("+I+`);
      `+S+" end = "+S+"("+D+`);

      void main() {
        `+S+` outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          `+S+` coords = outC - start;
          setOutput(getX(`+k+`));
        }
      }
    `}}class ij{constructor(d,p,_){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=p.map((he,de)=>he[0]+d[de]+he[1]);const E=d.length,S=AY(E),I=p.map(he=>he[0]).join(","),D=p.map((he,de)=>he[0]+d[de]).join(","),k=Os("rc",E),V=Os("source",E),$=k[E-1]+" < "+this.outputShape[E-1],Z=E===1?"source":"vec2("+V.slice(-2).join()+")",te=[S+" rc = outputLoc;",k[E-1]+` += 1;
       if(`+$+`) {
      `,E===1?"":`}
       rc = outputLoc;
       `+k[E-2]+` += 1;
       if(`+k[E-2]+" < "+this.outputShape[E-2]+") {",E===1?"":"  "+k[E-1]+` += 1;
         if(`+$+") {"],xe=E===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let le="";for(let he=0,de=E===1?2:4;he<de;he++)le+=`
        `+te[he]+`
        if (`+xe+`) {
          result[`+he+`] = float(value);
        } else {
          `+S+` source = rc - start;
          result[`+he+"] = getChannel(getX("+V.join()+"), "+Z+`);
        }
      `;le+=E===1?"} ":"}}",this.userCode=`
      const `+S+" start = "+S+"("+I+`);
      const `+S+" end = "+S+"("+D+`);

      void main() {
        `+S+` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        `+le+`
        setOutput(result);
      }
    `}}const iR=m=>{const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{paddings:S,constantValue:I}=_;if(n(E.shape)===0){const V=S.map(($,Z)=>$[0]+E.shape[Z]+$[1]);return nS({backend:p,attrs:{shape:V,value:I,dtype:E.dtype}})}const D=oQ().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ij(E.shape,S,I):new iB(E.shape,S,I),k=[[I]];return p.runWebGLProgram(D,[E],E.dtype,k)},iH={kernelName:cT,backendName:"webgl",kernelFunc:iR},iu=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,iX=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Ox+`
  return result;
`,iy=D7({opSnippet:iu,packedOpSnippet:iX}),iE={kernelName:cq,backendName:"webgl",kernelFunc:iy},iW=m=>{const{backend:d,attrs:p}=m,{start:_,stop:E,step:S,dtype:I}=p,D=NY(_,E,S,I);return d.makeTensorInfo([D.length],I,D)},id={kernelName:ck,backendName:"webgl",kernelFunc:iW},iM=`
if (a == b) {
  return 1.0;
};
return a / b;`,iU=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,iJ=D7({opSnippet:iM,packedOpSnippet:iU,checkOutOfBounds:!0}),it={kernelName:ot,backendName:"webgl",kernelFunc:iJ},iv=OZ+`
  return (x < 0.0) ? 0.0 : x;
`,ih=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,iY=D6({opSnippet:iv,packedOpSnippet:ih}),im={kernelName:cw,backendName:"webgl",kernelFunc:iY},ix=OZ+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,il=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ib=D6({opSnippet:ix,packedOpSnippet:il}),ia={kernelName:cN,backendName:"webgl",kernelFunc:ib};class iV{constructor(d,p,_,E,S){this.variableNames=["A"],this.outputShape=[];const[I,D,k,V]=d;this.outputShape=[I,p,_,V];const $=[E&&p>1?D-1:D,E&&_>1?k-1:k],Z=[E&&p>1?p-1:p,E&&_>1?_-1:_];let te;S?te="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":te="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          `+$[0]/Z[0]+`,
          `+$[1]/Z[1]+`);
      const vec2 inputShapeRC = vec2(`+D+".0, "+k+`.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = `+te+`;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class ig{constructor(d,p,_,E,S){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[I,D,k,V]=d;this.outputShape=[I,p,_,V];const $=[E&&p>1?D-1:D,E&&_>1?k-1:k],Z=[E&&p>1?p-1:p,E&&_>1?_-1:_];let te;S?te="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":te="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          `+$[0]/Z[0]+`,
          `+$[1]/Z[1]+`,
          `+$[1]/Z[1]+`);
      const vec3 inputShapeRC = vec3(`+D+".0, "+k+`.0,
                                     `+k+`.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = `+te+`;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < `+(V-1)+`;
        bool hasNextRow = coords.z < `+(_-1)+`;

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function e0(m){const{inputs:d,backend:p,attrs:_}=m,{images:E}=d,{alignCorners:S,halfPixelCenters:I,size:D}=_,[k,V]=D,$=oQ().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ig(E.shape,k,V,S,I):new iV(E.shape,k,V,S,I);return p.runWebGLProgram($,[E],"float32")}const e1={kernelName:cF,backendName:"webgl",kernelFunc:e0};class e2{constructor(d,p){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const _=d[1],E=d[2];this.outputShape=d;let S="";typeof p=="number"?S="float outputValue = "+p.toFixed(2)+";":S=`
        vec3 fill = vec3(`+p.join(",")+`);
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          `+S+`
          if(coordX >= 0 && coordX < `+E+" && coordY >= 0 && coordY < "+_+`) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const e3={kernelName:cU,backendName:"webgl",kernelFunc:({inputs:m,attrs:d,backend:p})=>{const{image:_}=m,{radians:E,fillValue:S,center:I}=d,D=p,k=new e2(_.shape,S),[V,$]=qu(I,_.shape[1],_.shape[2]),Z=[[V,$,Math.sin(E),Math.cos(E)]];return D.runWebGLProgram(k,[_],_.dtype,Z)}},e4=D5+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,e5=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,e6=D6({opSnippet:e4,packedOpSnippet:e5,cpuKernelImpl:Nl}),e7={kernelName:cP,backendName:"webgl",kernelFunc:e6},e8=D5+`
  return sin(x);
`,e9=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  `+Ox+`
  return result;
`,eo=D6({opSnippet:e8,packedOpSnippet:e9}),ec={kernelName:ce,backendName:"webgl",kernelFunc:eo};class eG{constructor(d){this.variableNames=["source"],this.outputShape=d,this.rank=d.length;const p=AY(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const _=ez(this.rank);let E;const S=d.map((I,D)=>"sourceLoc."+es[D]+" = start["+D+"] + coords."+es[D]+";");E=`
        `+p+` sourceLoc;
        `+p+` coords = getOutputCoords();
        `+S.join(`
`)+`
      `,this.userCode=`
      void main() {
        `+E+`
        setOutput(getSource(`+_+`));
      }
    `}}const es=["x","y","z","w","u","v"];function ez(m){if(m===1)return"sourceLoc";if(m<=6)return es.slice(0,m).map(d=>"sourceLoc."+d).join(",");throw Error("Slicing for rank "+m+" is not yet supported")}class eC{constructor(d){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=d,this.rank=d.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const p=AY(this.rank),_=Os("coords",this.rank),E=Os("sourceLoc",this.rank),S=this.rank===1?"sourceLoc":"vec2("+E.slice(-2).join()+")",I="getChannel(getSource("+E.join()+"), "+S+")",D=`
      result.x = `+I+`;
      if (++`+_[this.rank-1]+" < "+d[this.rank-1]+`) {
        ++`+E[this.rank-1]+`;
        result.y = `+I+`;
        --`+E[this.rank-1]+`;
      }
    `,k=this.rank===1?"":`
      --`+_[this.rank-1]+`;
      if (++`+_[this.rank-2]+" < "+d[this.rank-2]+`) {
        ++`+E[this.rank-2]+`;
        result.z = `+I+`;
        if (++`+_[this.rank-1]+" < "+d[this.rank-1]+`) {
          ++`+E[this.rank-1]+`;
          result.w = `+I+`;
        }
      }
    `,V=this.rank<=4?`sourceLoc = coords +
            `+p+"("+d.map(($,Z)=>"start["+Z+"]").join()+");":d.map(($,Z)=>E[Z]+" = "+_[Z]+" + start["+Z+"];").join(`
`);this.userCode=`
      void main() {
        `+p+` coords = getOutputCoords();
        `+p+` sourceLoc;
        `+V+`
        vec4 result = vec4(0.);
        `+D+`
        `+k+`
        setOutput(result);
      }
    `}}function eL(m,d,p,_){const E=_.texData.get(m.dataId),S=_.makeTensorInfo(p,m.dtype),I=_.texData.get(S.dataId);Object.assign(I,E),I.refCount=1,I.shape=p,I.dtype=m.dtype;let D=LG(d,o6(m.shape));E.slice&&(D+=E.slice.flatOffset),I.slice={flatOffset:D,origDataId:E.slice&&E.slice.origDataId||m.dataId};const k=_.dataRefCount.get(I.slice.origDataId)||1;return _.dataRefCount.set(I.slice.origDataId,k+1),S}function eK(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{begin:S,size:I}=_,[D,k]=Ls(E,S,I);if(Cg(E,D,k),n(k)===0)return p.makeTensorInfo(k,E.dtype,[]);if(p.shouldExecuteOnCPU([E])||E.dtype==="string"){const Z=p.texData.get(E.dataId),te=Na(Z.values,D,k,E.shape,E.dtype);return p.makeTensorInfo(k,E.dtype,te)}const{isPacked:V}=p.texData.get(E.dataId),$=Lc(E.shape,D,k);if(V||!$){const Z=oQ().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eC(k):new eG(k),te=[D];return p.runWebGLProgram(Z,[E],E.dtype,te)}return p.uploadToGPU(E.dataId),eL(E,D,k,p)}const er={kernelName:ci,backendName:"webgl",kernelFunc:eK},eT="return sqrt(x);",eq=D6({opSnippet:eT,packedOpSnippet:eT,cpuKernelImpl:O1}),eQ={kernelName:cS,backendName:"webgl",kernelFunc:eq},ek="return x * x;",ep=D6({opSnippet:ek}),ew={kernelName:cR,backendName:"webgl",kernelFunc:ep};class eA{constructor(d,p,_){this.variableNames=["x"],this.outputShape=_;const E=_.length,S=AY(_.length),I=AY(_.length);let D="";if(E===1)D="coords * strides + begin";else{let k=0;D=_.map((V,$)=>(k++,_.length===1?"coords * strides["+$+"] + begin["+$+"]":"coords["+(k-1)+"] * strides["+$+"] + begin["+$+"]")).join(",")}this.userCode=`
      `+S+" begin = "+S+"("+d+`);
      `+S+" strides = "+S+"("+p+`);

      void main() {
        `+I+` coords = getOutputCoords();
        setOutput(getX(`+D+`));
      }
    `}}function eZ(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{begin:S,end:I,strides:D,beginMask:k,endMask:V,ellipsisMask:$,newAxisMask:Z,shrinkAxisMask:te}=_,{finalShapeSparse:xe,finalShape:le,isIdentity:he,sliceDim0:de,isSimpleSlice:me,begin:ge,end:be,strides:ye}=Lz(E.shape,S,I,D,k,V,$,Z,te);let ve;if(he)ve=DD({inputs:{x:E},backend:p,attrs:{shape:le}});else if(de||me){A(E.shape.length>=1,()=>"Input must have rank at least 1, got: "+E.shape.length);const je=L1(ge,be,ye),Me=eK({inputs:{x:E},backend:p,attrs:{begin:ge,size:je}});ve=DD({inputs:{x:Me},backend:p,attrs:{shape:le}}),p.disposeIntermediateTensorInfo(Me)}else if(p.shouldExecuteOnCPU([E])){const je=p.readSync(E.dataId),Me=K7(E.shape,E.dtype,je),xt=O3(xe,Me,ye,ge);ve=p.makeTensorInfo(le,E.dtype,xt.values)}else{const je=new eA(ge,ye,xe);ve=p.runWebGLProgram(je,[E],E.dtype)}const Ie=DD({inputs:{x:ve},backend:p,attrs:{shape:le}});return p.disposeIntermediateTensorInfo(ve),Ie}const eF={kernelName:cH,backendName:"webgl",kernelFunc:eZ},eN="return a - b;",eO=D7({opSnippet:eN,packedOpSnippet:eN,supportsComplex:!0,cpuKernelImpl:O7}),eD={kernelName:cu,backendName:"webgl",kernelFunc:eO};class en{constructor(d,p){this.variableNames=["A"];const _=new Array(d.length);for(let I=0;I<_.length;I++)_[I]=d[I]*p[I];this.outputShape=_,this.rank=_.length;const E=AY(this.rank),S=ei(d);this.userCode=`
      void main() {
        `+E+` resRC = getOutputCoords();
        setOutput(getA(`+S+`));
      }
    `}}function ei(m){const d=m.length;if(d>5)throw Error("Tile for rank "+d+" is not yet supported");if(d===1)return"imod(resRC, "+m[0]+")";const p=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],_=[];for(let E=0;E<m.length;E++)_.push("imod("+p[E]+", "+m[E]+")");return _.join()}function ee(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{reps:S}=_;if(E.dtype==="string"||E.shape.length>5){const D=p.readSync(E.dataId),k=E.dtype==="string"?D.map(Z=>Gm(Z)):D,V=K7(E.shape,E.dtype,k),$=O8(V,S);return p.makeTensorInfo($.shape,$.dtype,$.values)}const I=new en(E.shape,S);return p.runWebGLProgram(I,[E],E.dtype)}const eP={kernelName:cX,backendName:"webgl",kernelFunc:ee};class eS{constructor(d,p,_,E,S,I){this.variableNames=["Image","Transforms"],this.outputShape=I;const D=_==="nearest"?1:2;let k;switch(E){case"constant":k=1;break;case"reflect":k=2;break;case"wrap":k=3;break;case"nearest":k=4;break;default:k=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(`+k+` == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+k+` == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+k+` == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < `+d+" && 0 <= coordX && coordX < "+p+`) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(`+S+`);
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(`+S+`);
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(`+p+`));
                float mapY = mapCoord(inY, float(`+d+`));

                if (`+D+` == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function eI(m){const{inputs:d,backend:p,attrs:_}=m,{image:E,transforms:S}=d,{interpolation:I,fillMode:D,fillValue:k,outputShape:V}=_,[$,Z,te,xe]=E.shape,[le,he]=V??[Z,te],de=[$,le,he,xe],me=new eS(Z,te,I,D,k,de);return p.runWebGLProgram(me,[E,S],"float32")}const eB={kernelName:cf,backendName:"webgl",kernelFunc:eI};function ej(m){const{inputs:d,backend:p}=m,{x:_}=d;if(_.dtype==="complex64"){const E=Dt({inputs:{input:_},backend:p}),S=ej({inputs:{x:E},backend:p}),I=n1({inputs:{input:_},backend:p}),D=ej({inputs:{x:I},backend:p}),k=OV({inputs:{real:S,imag:D},backend:p});return p.disposeIntermediateTensorInfo(E),p.disposeIntermediateTensorInfo(S),p.disposeIntermediateTensorInfo(I),p.disposeIntermediateTensorInfo(D),k}else return nS({attrs:{shape:_.shape,dtype:_.dtype,value:_.dtype==="string"?"":0},backend:p})}const eR={kernelName:cW,backendName:"webgl",kernelFunc:ej};function eH(m){const{inputs:d,backend:p,attrs:_}=m,{a:E,b:S,bias:I,preluActivationWeights:D}=d,{transposeA:k,transposeB:V,activation:$,leakyreluAlpha:Z}=_;return DW({a:E,b:S,transposeA:k,transposeB:V,backend:p,bias:I,preluActivationWeights:D,leakyreluAlpha:Z,activation:$})}const eu={kernelName:cJ,backendName:"webgl",kernelFunc:eH},eX=TD;class ef extends C{nextDataId(){return ef.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new z(this,sa())}write(d,p,_){this.firstUse&&(this.firstUse=!1,oQ().get("IS_NODE")&&ch(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const E={id:this.nextDataId()};return this.data.set(E,{values:d,dtype:_,refCount:1}),E}makeTensorInfo(d,p,_){let E;if(p==="string"&&_!=null&&_.length>0&&o0(_[0])){const S=_.map(I=>GY(I));E=this.write(S,d,p)}else E=this.write(_,d,p);return{dataId:E,shape:d,dtype:p}}refCount(d){return this.data.has(d)?this.data.get(d).refCount:0}incRef(d){const p=this.data.get(d);p.refCount++}decRef(d){if(this.data.has(d)){const p=this.data.get(d);p.refCount--}}move(d,p,_,E,S){this.data.set(d,{values:p,dtype:E,refCount:S})}numDataIds(){return this.data.numDataIds()}async read(d){return this.readSync(d)}readSync(d){const{dtype:p,complexTensorInfos:_}=this.data.get(d);if(p==="complex64"){const E=this.readSync(_.real.dataId),S=this.readSync(_.imag.dataId);return qm(E,S)}return o9(this.data.get(d).values,p)}bufferSync(d){const p=this.readSync(d.dataId);if(d.dtype==="string")try{const _=p.map(E=>Gm(E));return K7(d.shape,d.dtype,_)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return K7(d.shape,d.dtype,p)}makeOutput(d,p,_){return sa().makeTensorFromTensorInfo(this.makeTensorInfo(p,_,d),this)}disposeData(d,p=!1){if(this.data.has(d)){if(this.data.get(d).refCount--,!p&&this.data.get(d).refCount>0)return!1;const{complexTensorInfos:_}=this.data.get(d);_!=null&&(this.disposeData(_.real.dataId,!0),this.disposeData(_.imag.dataId,!0)),this.data.delete(d)}return!0}disposeIntermediateTensorInfo(d){this.disposeData(d.dataId)}async time(d){const p=Gh();return d(),{kernelMs:Gh()-p}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(d){Ze([d],"where");const p=this.readSync(d.dataId);return eX(d.shape,p)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}ef.nextDataId=0,z3("cpu",()=>new ef,1);function ey(m){const{inputs:d,backend:p}=m,_=d;Ze(d,"addN");const E=_.map(D=>p.data.get(D.dataId).values),S=K7(_[0].shape,_[0].dtype),I=S.values;for(let D=0;D<_.length;D++){const k=E[D];for(let V=0;V<I.length;V++)I[V]+=k[V]}return p.makeTensorInfo(S.shape,S.dtype,S.values)}const eE={kernelName:on,backendName:"cpu",kernelFunc:ey},eW=ZB((m,d)=>Math.atan2(m,d)),ed=ZW(oi,eW),eM={kernelName:oi,backendName:"cpu",kernelFunc:ed};function eU(m,d,p,_,E,S){const I=E.strideHeight,D=E.strideWidth,k=E.dilationHeight,V=E.dilationWidth,$=E.effectiveFilterHeight,Z=E.effectiveFilterWidth,te=E.padInfo.top,xe=E.padInfo.left,le=S==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,he=K7(E.outShape,p),de=he.values,me=E.outShape[1]*E.outShape[2]*E.outShape[3],ge=E.outShape[2]*E.outShape[3],be=E.outShape[3];for(let ye=0;ye<E.batchSize;++ye){const ve=ye*me,Ie=ye*_[0];for(let je=0;je<E.inChannels;++je)for(let Me=0;Me<E.outHeight;++Me){const xt=Me*I-te,bt=Math.max(0,xt),gt=Math.min(E.inHeight,$+xt),Xt=ve+Me*ge;for(let Ut=0;Ut<E.outWidth;++Ut){const Ht=Ut*D-xe,mi=Math.max(0,Ht),gi=Math.min(E.inWidth,Z+Ht);let Ui=le,yi=0,vi=0;for(let us=bt;us<gt;us+=k){const bi=Ie+us*_[1];for(let Ri=mi;Ri<gi;Ri+=V){const Nt=bi+Ri*_[2],$t=m[Nt+je];S==="max"&&$t>Ui?Ui=$t:S==="avg"&&(yi+=$t,vi++)}if(isNaN(Ui))break}const ts=Xt+Ut*be+je;de[ts]=S==="avg"?yi/vi:Ui}}}return he}function eJ(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d;Ze(E,"avgPool");const{filterSize:S,strides:I,pad:D,dimRoundingMode:k}=_,V=1;A(Ld(I,V),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+I+" and dilations '"+V+"'");const $=Le(E.shape,S,I,V,D,k);let Z;if($.filterWidth===1&&$.filterHeight===1&&i($.inShape,$.outShape))Z=ZH({inputs:{x:E},backend:p});else{const te=p.data.get(E.dataId).values,xe=o6(E.shape),le=eU(te,E.shape,E.dtype,xe,$,"avg");Z=p.makeTensorInfo($.outShape,E.dtype,le.values)}return Z}const et={kernelName:oe,backendName:"cpu",kernelFunc:eJ};function ev(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{shape:S}=_,I=n(E.shape),D=H(S,I),k=n(D);A(I===k,()=>"The new shape ("+D+") has "+k+" elements and the old shape ("+E.shape+") has "+I+" elements. The new shape and old shape must have the same number of elements."),p.incRef(E.dataId);const V=p.data.get(E.dataId);if(V.complexTensorInfos!=null){const $=V.complexTensorInfos.real,Z=V.complexTensorInfos.imag;$.shape=D,Z.shape=D}return{dataId:E.dataId,shape:D,dtype:E.dtype}}const eh={kernelName:cA,backendName:"cpu",kernelFunc:ev};function eY(m){const{inputs:d,backend:p,attrs:_}=m,{a:E,b:S}=d,{transposeA:I,transposeB:D}=_;Ze([E,S],"matMul");const k=E.shape.length,V=S.shape.length,$=I?E.shape[k-2]:E.shape[k-1],Z=D?S.shape[V-1]:S.shape[V-2],te=I?E.shape[k-1]:E.shape[k-2],xe=D?S.shape[V-2]:S.shape[V-1],le=E.shape.slice(0,-2),he=S.shape.slice(0,-2),de=n(le),me=n(he),ge=CJ(E.shape.slice(0,-2),S.shape.slice(0,-2)).concat([te,xe]);A($===Z,()=>"Error in matMul: inner shapes ("+$+") and ("+Z+") of Tensors with shapes "+E.shape+" and "+S.shape+" and transposeA="+I+" and transposeB="+D+" must match.");const be=I?[de,$,te]:[de,te,$],ye=D?[me,xe,Z]:[me,Z,xe],ve=ev({inputs:{x:E},backend:p,attrs:{shape:be}}),Ie=ev({inputs:{x:S},backend:p,attrs:{shape:ye}}),je=I?ve.shape[1]:ve.shape[2],Me=I?ve.shape[2]:ve.shape[1],xt=D?Ie.shape[1]:Ie.shape[2],bt=Math.max(de,me),gt=p.data.get(ve.dataId).values,Xt=p.data.get(Ie.dataId).values,Ut=o6(ve.shape),Ht=o6(Ie.shape),[mi,gi,Ui]=I?[Ut[0],1,Ut[1]]:[Ut[0],Ut[1],1],[yi,vi,ts]=D?[1,Ht[1],Ht[0]]:[Ht[1],1,Ht[0]],us=Me*xt,bi=K7([bt,Me,xt],ve.dtype),Ri=bi.values,Nt=p.blockSize;for(let $t=0;$t<bt;$t++){const li=$t%de,Ei=$t%me;for(let xs=0;xs<Me;xs+=Nt){const Vs=Math.min(xs+Nt,Me);for(let ms=0;ms<xt;ms+=Nt){const bs=Math.min(ms+Nt,xt);for(let Us=0;Us<je;Us+=Nt){const Mr=Math.min(Us+Nt,je);for(let ar=xs;ar<Vs;ar++)for(let yr=ms;yr<bs;yr++){let jr=0;for(let xn=Us;xn<Mr;xn++){const dn=gt[li*mi+ar*gi+xn*Ui],Rn=Xt[xn*yi+yr*vi+Ei*ts];jr+=dn*Rn}Ri[$t*us+(ar*xt+yr)]+=jr}}}}}return p.disposeIntermediateTensorInfo(ve),p.disposeIntermediateTensorInfo(Ie),p.makeTensorInfo(ge,bi.dtype,bi.values)}const em={kernelName:oP,backendName:"cpu",kernelFunc:eY},ex=Zx(oj,(m,d)=>{const p=d;return m>p.clipValueMax?p.clipValueMax:m<p.clipValueMin?p.clipValueMin:m}),el={kernelName:oj,backendName:"cpu",kernelFunc:ex};function eb(m){const{inputs:d,backend:p}=m,{input:_}=d,E=p.data.get(_.dataId).complexTensorInfos.imag,S=p.data.get(E.dataId).values;return p.makeTensorInfo(E.shape,E.dtype,S)}function ea(m){const{inputs:d,backend:p,attrs:_}=m,{axis:E}=_,S=X(E,d[0].shape)[0],I=d.map(he=>he.shape);qi(I,S);let D=qe(d.map(he=>he.shape),S);if(n(D)===0)return p.makeTensorInfo(D,d[0].dtype,[]);const k=d.filter(he=>n(he.shape)>0);if(k.length===1)return ZH({inputs:{x:k[0]},backend:p});if(k[0].dtype==="complex64"){const he=k.map(ye=>ZX({inputs:{input:ye},backend:p})),de=k.map(ye=>eb({inputs:{input:ye},backend:p})),me=ea({inputs:he,backend:p,attrs:{axis:S}}),ge=ea({inputs:de,backend:p,attrs:{axis:S}}),be=Zj({inputs:{real:me,imag:ge},backend:p});return he.forEach(ye=>p.disposeIntermediateTensorInfo(ye)),de.forEach(ye=>p.disposeIntermediateTensorInfo(ye)),p.disposeIntermediateTensorInfo(me),p.disposeIntermediateTensorInfo(ge),be}const V=k.map(he=>{const de=[-1,n(he.shape.slice(S))];return ev({inputs:{x:he},backend:p,attrs:{shape:de}})}),$=V.map(he=>({vals:p.data.get(he.dataId).values,shape:he.shape}));D=qe(V.map(he=>he.shape),1);const Z=V[0].shape[0]===1,te=Za($,D,d[0].dtype,Z),xe=qe(k.map(he=>he.shape),S),le=p.makeTensorInfo(xe,d[0].dtype,te);return V.forEach(he=>p.disposeIntermediateTensorInfo(he)),le}const eV={kernelName:ou,backendName:"cpu",kernelFunc:ea};function eg(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,filter:S}=d,{strides:I,pad:D,dataFormat:k,dilations:V,dimRoundingMode:$}=_;Ze([E,S],"conv2d");const Z=LU(k),te=LS(E.shape,S.shape,I,V,D,$,!1,Z),xe=te.filterHeight,le=te.filterWidth,he=te.dilationHeight,de=te.dilationWidth,me=te.padInfo.left,ge=te.padInfo.top,be=te.dataFormat==="channelsLast",ye=new so(te.outShape,E.dtype),ve=o6(E.shape),Ie=o6(S.shape),je=ve[0],Me=be?ve[1]:ve[2],xt=be?ve[2]:1,bt=be?1:ve[1],gt=ye.strides[0],Xt=be?ye.strides[1]:ye.strides[2],Ut=be?ye.strides[2]:1,Ht=be?1:ye.strides[1],mi=p.data.get(E.dataId).values,gi=p.data.get(S.dataId).values,Ui=ye.values;for(let yi=0;yi<te.batchSize;++yi){const vi=yi*je,ts=yi*gt;for(let us=0;us<te.outHeight;++us){const bi=ts+us*Xt,Ri=us*te.strideHeight-ge;for(let Nt=0;Nt<xe;++Nt){const $t=Ri+Nt*he;if($t<0||$t>=te.inHeight)continue;const li=Nt*Ie[0],Ei=vi+$t*Me;for(let xs=0;xs<te.outWidth;++xs){const Vs=bi+xs*Ut,ms=xs*te.strideWidth-me;for(let bs=0;bs<le;++bs){const Us=ms+bs*de;if(Us<0||Us>=te.inWidth)continue;const Mr=li+bs*Ie[1],ar=Ei+Us*xt;let yr=Mr;for(let jr=0;jr<te.inChannels;++jr){const xn=mi[ar+jr*bt];for(let dn=0;dn<te.outChannels;++dn)Ui[Vs+dn*Ht]+=xn*gi[yr+dn];yr+=te.outChannels}}}}}}return p.makeTensorInfo(ye.shape,ye.dtype,Ui)}const P0={kernelName:oX,backendName:"cpu",kernelFunc:eg};function P1(m){const{inputs:d,backend:p,attrs:_}=m,{dy:E,filter:S}=d,{inputShape:I,strides:D,pad:k,dataFormat:V,dimRoundingMode:$}=_;Ze([E,S],"conv2dBackpropInput");const Z=o6(S.shape),te=o6(E.shape);let xe=LU(V);const le=LS(I,S.shape,D,1,k,$,!1,xe),he=new so(le.inShape,"float32"),de=he.values,me=p.data.get(E.dataId).values,ge=p.data.get(S.dataId).values,[be,ye,ve]=Z,{batchSize:Ie,filterHeight:je,filterWidth:Me,inChannels:xt,inHeight:bt,inWidth:gt,outChannels:Xt,outHeight:Ut,outWidth:Ht,strideHeight:mi,strideWidth:gi}=le;xe=le.dataFormat;const Ui=je-1-le.padInfo.top,yi=Me-1-le.padInfo.left,vi=xe==="channelsLast",ts=he.strides[0],us=vi?he.strides[1]:he.strides[2],bi=vi?he.strides[2]:1,Ri=vi?1:he.strides[1],Nt=te[0],$t=vi?te[1]:te[2],li=vi?te[2]:1,Ei=vi?1:te[1];for(let xs=0;xs<Ie;++xs)for(let Vs=0;Vs<xt;++Vs)for(let ms=0;ms<bt;++ms){const bs=ms-Ui,Us=Math.max(0,Math.ceil(bs/mi)),Mr=Math.min(Ut,(je+bs)/mi);for(let ar=0;ar<gt;++ar){const yr=ar-yi,jr=Math.max(0,Math.ceil(yr/gi)),xn=Math.min(Ht,(Me+yr)/gi);let dn=0;for(let Vn=Us;Vn<Mr;++Vn){const Hi=Vn*mi-bs;for(let Ya=jr;Ya<xn;++Ya){const _o=Ya*gi-yr,jo=Nt*xs+$t*Vn+li*Ya,aa=be*(je-1-Hi)+ye*(Me-1-_o)+ve*Vs;for(let Ur=0;Ur<Xt;++Ur){const ur=me[jo+Ei*Ur],Y0=ge[aa+Ur];dn+=ur*Y0}}}const Rn=ts*xs+us*ms+bi*ar+Ri*Vs;de[Rn]=dn}}return p.makeTensorInfo(he.shape,he.dtype,he.values)}const P2={kernelName:oy,backendName:"cpu",kernelFunc:P1},P3=Zx(oE,m=>Math.cos(m)),P4={kernelName:oE,backendName:"cpu",kernelFunc:P3};function P5(m){const{inputs:d,backend:p,attrs:_}=m,{image:E,boxes:S,boxInd:I}=d,{cropSize:D,method:k,extrapolationValue:V}=_,[$,Z,te,xe]=E.shape,le=S.shape[0],[he,de]=D,me=K7([le,he,de,xe],"float32"),ge=p.data.get(S.dataId).values,be=p.data.get(I.dataId).values,ye=p.data.get(E.dataId).values,ve=o6(E.shape),Ie=o6(me.shape);for(let je=0;je<le;je++){const Me=je*4,xt=ge[Me],bt=ge[Me+1],gt=ge[Me+2],Xt=ge[Me+3],Ut=be[je];if(Ut>=$)continue;const Ht=he>1?(gt-xt)*(Z-1)/(he-1):0,mi=de>1?(Xt-bt)*(te-1)/(de-1):0;for(let gi=0;gi<he;gi++){const Ui=he>1?xt*(Z-1)+gi*Ht:.5*(xt+gt)*(Z-1);if(Ui<0||Ui>Z-1){for(let yi=0;yi<de;yi++)for(let vi=0;vi<xe;vi++){const ts=vi+yi*Ie[2]+gi*Ie[1]+je*Ie[0];me.values[ts]=V}continue}if(k==="bilinear"){const yi=Math.floor(Ui),vi=Math.ceil(Ui),ts=Ui-yi;for(let us=0;us<de;us++){const bi=de>1?bt*(te-1)+us*mi:.5*(bt+Xt)*(te-1);if(bi<0||bi>te-1){for(let li=0;li<xe;li++){const Ei=li+us*Ie[2]+gi*Ie[1]+je*Ie[0];me.values[Ei]=V}continue}const Ri=Math.floor(bi),Nt=Math.ceil(bi),$t=bi-Ri;for(let li=0;li<xe;li++){let Ei=li+Ri*ve[2]+yi*ve[1]+Ut*ve[0];const xs=ye[Ei];Ei=li+Nt*ve[2]+yi*ve[1]+Ut*ve[0];const Vs=ye[Ei];Ei=li+Ri*ve[2]+vi*ve[1]+Ut*ve[0];const ms=ye[Ei];Ei=li+Nt*ve[2]+vi*ve[1]+Ut*ve[0];const bs=ye[Ei],Us=xs+(Vs-xs)*$t,Mr=ms+(bs-ms)*$t;Ei=li+us*Ie[2]+gi*Ie[1]+je*Ie[0],me.values[Ei]=Us+(Mr-Us)*ts}}}else for(let yi=0;yi<de;++yi){const vi=de>1?bt*(te-1)+yi*mi:.5*(bt+Xt)*(te-1);if(vi<0||vi>te-1){for(let bi=0;bi<xe;bi++){const Ri=bi+yi*Ie[2]+gi*Ie[1]+je*Ie[0];me.values[Ri]=V}continue}const ts=Math.round(vi),us=Math.round(Ui);for(let bi=0;bi<xe;bi++){const Ri=bi+ts*ve[2]+us*ve[1]+Ut*ve[0],Nt=bi+yi*Ie[2]+gi*Ie[1]+je*Ie[0];me.values[Nt]=ye[Ri]}}}}return p.makeTensorInfo(me.shape,me.dtype,me.values)}const P6={kernelName:oW,backendName:"cpu",kernelFunc:P5};function P7(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{blockSize:S,dataFormat:I}=_;A(I==="NHWC",()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+I);const D=E.shape[0],k=E.shape[1],V=E.shape[2],$=E.shape[3],Z=k*S,te=V*S,xe=$/(S*S),le=p.data.get(E.dataId).values,he=new Float32Array(D*Z*te*xe);let de=0;for(let me=0;me<D;++me)for(let ge=0;ge<Z;++ge){const be=Math.floor(ge/S),ye=ge%S;for(let ve=0;ve<te;++ve){const Ie=Math.floor(ve/S),je=ve%S,Me=(ye*S+je)*xe;for(let xt=0;xt<xe;++xt){const bt=xt+Me+$*(Ie+V*(be+k*me));he[de++]=le[bt]}}}return p.makeTensorInfo([D,Z,te,xe],E.dtype,he)}const P8={kernelName:od,backendName:"cpu",kernelFunc:P7};function P9(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,filter:S}=d,{strides:I,pad:D,dilations:k,dimRoundingMode:V}=_;Ze([E,S],"depthwiseConv2DNative");const $=o6(E.shape),Z=o6(S.shape);let te=k;te==null&&(te=[1,1]),A(Ld(I,te),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+I+" and dilations '"+te+"'");const xe=LS(E.shape,S.shape,I,te,D,V,!0),{filterHeight:le,filterWidth:he,dilationHeight:de,dilationWidth:me,padInfo:ge}=xe,be=ge.left,ye=ge.top,ve=xe.outChannels/xe.inChannels,Ie=new so(xe.outShape,E.dtype),je=p.data.get(E.dataId).values,Me=p.data.get(S.dataId).values,xt=Ie.values;for(let bt=0;bt<xe.batchSize;++bt){const gt=bt*$[0],Xt=bt*Ie.strides[0];for(let Ut=0;Ut<xe.outHeight;++Ut){const Ht=Xt+Ut*Ie.strides[1],mi=Ut*xe.strideHeight-ye;for(let gi=0;gi<le;++gi){const Ui=mi+gi*de;if(Ui<0||Ui>=xe.inHeight)continue;const yi=gi*Z[0],vi=gt+Ui*$[1];for(let ts=0;ts<xe.outWidth;++ts){const us=Ht+ts*Ie.strides[2],bi=ts*xe.strideWidth-be;for(let Ri=0;Ri<he;++Ri){const Nt=bi+Ri*me;if(Nt<0||Nt>=xe.inWidth)continue;const $t=yi+Ri*Z[1],li=vi+Nt*xe.inChannels;let Ei=us,xs=$t;for(let Vs=0;Vs<xe.inChannels;++Vs){const ms=je[li+Vs];for(let bs=0;bs<ve;++bs)xt[Ei+bs]+=ms*Me[xs+bs];Ei+=ve,xs+=ve}}}}}}return p.makeTensorInfo(Ie.shape,Ie.dtype,Ie.values)}const Po={kernelName:oM,backendName:"cpu",kernelFunc:P9};function Pc(m){const{inputs:d,backend:p,attrs:_}=m,{input:E}=d,{dim:S}=_,I=E.shape.length,D=E.shape.slice();let k=S;return S<0&&(A(-(I+1)<=S,()=>"Axis must be in the interval ["+-(I+1)+", "+I+"]"),k=I+S+1),D.splice(k,0,1),ev({inputs:{x:E},backend:p,attrs:{shape:D}})}const PG={kernelName:oY,backendName:"cpu",kernelFunc:Pc};function Ps(m){const{backend:d,attrs:p}=m,{shape:_,value:E,dtype:S}=p,I=S||o3(E),D=U(I,n(_));return PC(D,E,I),d.makeTensorInfo(_,I,D)}const Pz={kernelName:om,backendName:"cpu",kernelFunc:Ps};function PC(m,d,p){m.fill(d)}const PL=Zx(oh,m=>m>=0?m:Math.exp(m)-1);function PK(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{alpha:S}=_;Ze([E],"leakyRelu");const I=n(E.shape),D=p.data.get(E.dataId).values,k=M("float32",I);for(let V=0;V<D.length;V++)k[V]=D[V]<0?S*D[V]:D[V];return p.makeTensorInfo(E.shape,"float32",k)}const Pr=ZB((m,d)=>m<0?d*m:m);function PT(m){const{inputs:d,backend:p}=m,{x:_,alpha:E}=d;Ze([_,E],"prelu");const S=p.data.get(_.dataId).values,I=p.data.get(E.dataId).values,[D,k]=Pr(_.shape,E.shape,S,I,"float32");return p.makeTensorInfo(k,"float32",D)}const Pq={kernelName:cQ,backendName:"cpu",kernelFunc:PT},PQ=Zx(cw,m=>Math.max(0,m)),Pk={kernelName:cw,backendName:"cpu",kernelFunc:PQ},Pp=Zx(cN,m=>Math.min(Math.max(0,m),6)),Pw={kernelName:cN,backendName:"cpu",kernelFunc:Pp};function PA(m,d,p,_,E){if(p==="linear")return ZH({inputs:{x:d},backend:m});if(p==="relu")return PQ({inputs:{x:d},backend:m});if(p==="elu")return PL({inputs:{x:d},backend:m});if(p==="relu6")return Pp({inputs:{x:d},backend:m});if(p==="prelu")return PT({inputs:{x:d,alpha:_},backend:m});if(p==="leakyrelu")return PK({inputs:{x:d},backend:m,attrs:{alpha:E}});if(p==="sigmoid")return Fl({inputs:{x:d},backend:m});throw new Error("Activation "+p+" has not been implemented for the CPU backend.")}function PZ(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,filter:S,bias:I,preluActivationWeights:D}=d,{strides:k,pad:V,dataFormat:$,dilations:Z,dimRoundingMode:te,activation:xe,leakyreluAlpha:le}=_;let he=eg({inputs:{x:E,filter:S},backend:p,attrs:{strides:k,pad:V,dataFormat:$,dilations:Z,dimRoundingMode:te}});if(I){const de=he;if($==="NCHW"&&I.shape.length===1&&I.shape[0]!==1){const me=ev({inputs:{x:I},backend:p,attrs:{shape:[I.shape[0],1,1]}});he=ZJ({inputs:{a:he,b:me},backend:p}),p.disposeIntermediateTensorInfo(me)}else he=ZJ({inputs:{a:he,b:I},backend:p});p.disposeIntermediateTensorInfo(de)}if(xe){const de=he;if($==="NCHW"&&xe==="prelu"&&D.shape.length===1&&D.shape[0]!==1){const me=ev({inputs:{x:D},backend:p,attrs:{shape:[D.shape[0],1,1]}});he=PA(p,he,xe,me,le),p.disposeIntermediateTensorInfo(me)}else he=PA(p,he,xe,D,le);p.disposeIntermediateTensorInfo(de)}return he}const PF={kernelName:ct,backendName:"cpu",kernelFunc:PZ};function PN(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,filter:S,bias:I,preluActivationWeights:D}=d,{strides:k,pad:V,dataFormat:$,dilations:Z,dimRoundingMode:te,activation:xe,leakyreluAlpha:le}=_;let he=P9({inputs:{x:E,filter:S},backend:p,attrs:{strides:k,pad:V,dataFormat:$,dilations:Z,dimRoundingMode:te}});if(I){const de=he;he=ZJ({inputs:{a:he,b:I},backend:p}),p.disposeIntermediateTensorInfo(de)}if(xe){const de=he;he=PA(p,he,xe,D,le),p.disposeIntermediateTensorInfo(de)}return he}const PO={kernelName:cv,backendName:"cpu",kernelFunc:PN};function PD(m){const{inputs:d,backend:p,attrs:_}=m,{x:E,indices:S}=d,{axis:I,batchDims:D}=_;Ze([E,S],"gatherV2");const k=X(I,E.shape)[0],V=p.data.get(S.dataId).values,$=E.shape[k];for(let ye=0;ye<V.length;++ye){const ve=V[ye];A(ve<=$-1&&ve>=0,()=>"GatherV2: the index value "+ve+" is not in [0, "+($-1)+"]")}let Z=D;D==null&&(Z=0);const te=n(S.shape),xe=QZ(E,S,k,Z),le=ev({inputs:{x:E},backend:p,attrs:{shape:[xe.batchSize,xe.outerSize,xe.dimSize,xe.sliceSize]}}),he=ev({inputs:{x:S},backend:p,attrs:{shape:[xe.batchSize,te/xe.batchSize]}}),de=[xe.batchSize,xe.outerSize,te/xe.batchSize,xe.sliceSize],me=p.bufferSync(he),ge=p.bufferSync(le),be=F6(ge,me,de);return p.disposeIntermediateTensorInfo(le),p.disposeIntermediateTensorInfo(he),p.makeTensorInfo(xe.outputShape,be.dtype,be.values)}const Pn={kernelName:oa,backendName:"cpu",kernelFunc:PD},Pi=ZB((m,d)=>m&&d),Pe=ZW(c5,Pi,null,"bool"),PP={kernelName:c5,backendName:"cpu",kernelFunc:Pe},PS=ZB((m,d)=>m||d),PI=ZW(c6,PS,null,"bool"),PB={kernelName:c6,backendName:"cpu",kernelFunc:PI};function Pj(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{reductionIndices:S,keepDims:I}=_,D=p;let k=E.shape;const V=k.length,$=X(S,k);let Z=$;const te=KH(Z,V);let xe=D.data.get(E.dataId).values;if(te!=null){const ye=new Array(V);for(let ve=0;ve<ye.length;ve++)ye[ve]=k[te[ve]];xe=FP(xe,k,E.dtype,te,ye),Z=KX(Z.length,V),k=ye}Ze(E,"max"),KR("max",Z,V);const[le,he]=KB(k,Z),de=n(he),me=FT(xe,de,le,E.dtype),ge=D.write(me,le,E.dtype);let be=le;return I&&(be=Kj(le,$)),{dataId:ge,shape:be,dtype:E.dtype}}const PR={kernelName:c7,backendName:"cpu",kernelFunc:Pj};function PH(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d;Ze(E,"maxPool");const{filterSize:S,strides:I,pad:D,dimRoundingMode:k}=_,V=1;A(Ld(I,V),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+I+" and dilations '"+V+"'");const $=Le(E.shape,S,I,V,D,k);let Z;if($.filterWidth===1&&$.filterHeight===1&&i($.inShape,$.outShape))Z=ZH({inputs:{x:E},backend:p});else{const te=p.data.get(E.dataId).values,xe=o6(E.shape),le=eU(te,E.shape,E.dtype,xe,$,"max");Z=p.makeTensorInfo($.outShape,E.dtype,le.values)}return Z}const Pu={kernelName:c9,backendName:"cpu",kernelFunc:PH},PX=ZB((m,d)=>m/d),Pf=ZW(ot,PX),Py={kernelName:ot,backendName:"cpu",kernelFunc:Pf};function PE(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{axis:S,keepDims:I}=_;Ze(E,"sum");let D;E.dtype==="bool"?D=Zy({inputs:{x:E},backend:p,attrs:{dtype:"int32"}}):D=ZH({inputs:{x:E},backend:p});const k=D.shape.length,V=X(S,D.shape),$=KH(V,k);let Z=V,te=D;$!=null&&(te=FS({inputs:{x:D},backend:p,attrs:{perm:$}}),Z=KX(Z.length,k)),KR("sum",Z,te.shape.length);const[xe,le]=KB(te.shape,Z),he=sA(te.dtype,"int32");let de=ZR(p,xe,he);const me=n(le),ge=p.data.get(de.dataId).values,be=p.data.get(te.dataId).values;for(let ye=0;ye<ge.length;++ye){const ve=ye*me;let Ie=0;for(let je=0;je<me;++je)Ie+=be[ve+je];ge[ye]=Ie}if(I){const ye=Kj(de.shape,V),ve=de;de=ev({inputs:{x:de},backend:p,attrs:{shape:ye}}),p.disposeIntermediateTensorInfo(ve)}return p.disposeIntermediateTensorInfo(D),$!=null&&p.disposeIntermediateTensorInfo(te),de}const PW={kernelName:cI,backendName:"cpu",kernelFunc:PE};function Pd(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{axis:S,keepDims:I}=_,D=X(S,E.shape),k=KB(E.shape,D)[1],V=n(k),$=[],Z=p.makeTensorInfo([],"float32",new Float32Array([V]));$.push(Z);const te=Zy({inputs:{x:E},backend:p,attrs:{dtype:"float32"}});$.push(te);const xe=Pf({inputs:{a:te,b:Z},backend:p});$.push(xe);const le=PE({inputs:{x:xe},backend:p,attrs:{axis:S,keepDims:I}});return $.forEach(he=>p.disposeIntermediateTensorInfo(he)),le}const PM={kernelName:co,backendName:"cpu",kernelFunc:Pd};function PU(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{axis:S,keepDims:I}=_;Ze(E,"min");const D=X(S,E.shape);let k=D;const V=KH(k,E.shape.length);let $=E;V!=null&&($=FS({inputs:{x:E},backend:p,attrs:{perm:V}}),k=KX(k.length,E.shape.length)),KR("min",k,$.shape.length);const[Z,te]=KB($.shape,k),xe=n(te),le=oc(n(Z),$.dtype),he=p.data.get($.dataId).values;for(let me=0;me<le.length;++me){const ge=me*xe;let be=he[ge];for(let ye=0;ye<xe;++ye){const ve=he[ge+ye];(Number.isNaN(ve)||ve<be)&&(be=ve)}le[me]=be}V!=null&&p.disposeIntermediateTensorInfo($);const de=p.makeTensorInfo(Z,$.dtype,le);if(I){const me=Kj(Z,D),ge=ev({inputs:{x:de},backend:p,attrs:{shape:me}});return p.disposeIntermediateTensorInfo(de),ge}return de}const PJ={kernelName:cc,backendName:"cpu",kernelFunc:PU};function Pt(m){const{inputs:d,backend:p,attrs:_}=m,{axis:E}=_;if(d.length===1)return Pc({inputs:{input:d[0]},backend:p,attrs:{dim:E}});const S=d[0].shape,I=d[0].dtype;d.forEach($=>{N(S,$.shape,"All tensors passed to stack must have matching shapes"),A(I===$.dtype,()=>"All tensors passed to stack must have matching dtypes")});const D=[],k=d.map($=>{const Z=Pc({inputs:{input:$},backend:p,attrs:{dim:E}});return D.push(Z),Z}),V=ea({inputs:k,backend:p,attrs:{axis:E}});return D.forEach($=>p.disposeIntermediateTensorInfo($)),V}const Pv={kernelName:cr,backendName:"cpu",kernelFunc:Pt};function Ph(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{paddings:S,constantValue:I}=_;Ze(E,"pad");const D=S.map((me,ge)=>me[0]+E.shape[ge]+me[1]),k=S.map(me=>me[0]),V=p.data.get(E.dataId).values,$=n(E.shape),Z=E.shape.length,te=o6(E.shape),xe=n(D),le=D.length,he=o6(D),de=M(E.dtype,xe);I!==0&&de.fill(I);for(let me=0;me<$;me++){const ge=oz(me,Z,te).map((ye,ve)=>ye+k[ve]),be=os(ge,le,he);de[be]=V[me]}return{dataId:p.write(de,D,E.dtype),shape:D,dtype:E.dtype}}const PY={kernelName:cT,backendName:"cpu",kernelFunc:Ph},Pm=ZB((m,d)=>Math.pow(m,d)),Px=ZW(cq,Pm),Pl={kernelName:cq,backendName:"cpu",kernelFunc:Px};function Pb(m){const{backend:d,attrs:p}=m,{start:_,stop:E,dtype:S,step:I}=p,D=Fh(_,E,I,S);return d.makeTensorInfo([D.length],S,D)}const Pa={kernelName:ck,backendName:"cpu",kernelFunc:Pb};function PV(m){const{inputs:d,backend:p,attrs:_}=m,{images:E}=d,{alignCorners:S,halfPixelCenters:I,size:D}=_;Ze(E,"resizeBilinear");const k=o6(E.shape),[V,$]=D,[Z,te,xe,le]=E.shape,he=p.data.get(E.dataId).values,de=new Float32Array(n([Z,V,$,le])),me=[S&&V>1?te-1:te,S&&$>1?xe-1:xe],ge=[S&&V>1?V-1:V,S&&$>1?$-1:$];let be=0;const ye=me[0]/ge[0],ve=me[1]/ge[1];for(let Ie=0;Ie<Z;Ie++)for(let je=0;je<V;je++){let Me;I?Me=ye*(je+.5)-.5:Me=ye*je;const xt=Math.max(0,Math.floor(Me)),bt=Me-xt,gt=Math.min(te-1,Math.ceil(Me)),Xt=Ie*k[0]+xt*k[1],Ut=Ie*k[0]+gt*k[1];for(let Ht=0;Ht<$;Ht++){let mi;I?mi=ve*(Ht+.5)-.5:mi=ve*Ht;const gi=Math.max(0,Math.floor(mi)),Ui=mi-gi,yi=Math.min(xe-1,Math.ceil(mi)),vi=Xt+gi*k[2],ts=Ut+gi*k[2],us=Xt+yi*k[2],bi=Ut+yi*k[2];for(let Ri=0;Ri<le;Ri++){const Nt=he[vi+Ri],$t=he[ts+Ri],li=he[us+Ri],Ei=he[bi+Ri],xs=Nt+(li-Nt)*Ui,Vs=$t+(Ei-$t)*Ui,ms=xs+(Vs-xs)*bt;de[be++]=ms}}}return p.makeTensorInfo([Z,V,$,le],"float32",de)}const Pg={kernelName:cF,backendName:"cpu",kernelFunc:PV},S0={kernelName:cU,backendName:"cpu",kernelFunc:({inputs:m,attrs:d,backend:p})=>{const{image:_}=m,{radians:E,fillValue:S,center:I}=d,D=p,k=M(_.dtype,n(_.shape)),[V,$,Z,te]=_.shape,[xe,le]=qu(I,$,Z),he=255,de=Math.sin(E),me=Math.cos(E),ge=D.data.get(_.dataId).values;for(let be=0;be<V;be++){const ye=be*Z*$*te;for(let ve=0;ve<$;ve++){const Ie=ve*(Z*te);for(let je=0;je<Z;je++){const Me=je*te;for(let xt=0;xt<te;xt++){const bt=[V,ve,je,xt],gt=bt[2],Xt=bt[1];let Ut=(gt-xe)*me-(Xt-le)*de,Ht=(gt-xe)*de+(Xt-le)*me;Ut=Math.round(Ut+xe),Ht=Math.round(Ht+le);let mi=S;if(typeof S!="number"&&(xt===3?mi=he:mi=S[xt]),Ut>=0&&Ut<Z&&Ht>=0&&Ht<$){const Ui=Ht*(Z*te),yi=Ut*te,vi=ye+Ui+yi+xt;mi=ge[vi]}const gi=ye+Ie+Me+xt;k[gi]=mi}}}}return{dataId:D.write(k,_.shape,_.dtype),shape:_.shape,dtype:_.dtype}}},S1=Zx(ce,m=>Math.sin(m)),S2={kernelName:ce,backendName:"cpu",kernelFunc:S1},S3={kernelName:cR,backendName:"cpu",kernelFunc:({inputs:m,backend:d})=>{const{x:p}=m,_=d;Ze(p,"square");const E=_.data.get(p.dataId).values,S=new Float32Array(E.length);for(let I=0;I<E.length;++I){const D=E[I];S[I]=D*D}return{dataId:_.write(S,p.shape,p.dtype),shape:p.shape,dtype:p.dtype}}};function S4(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{begin:S,end:I,strides:D,beginMask:k,endMask:V,ellipsisMask:$,newAxisMask:Z,shrinkAxisMask:te}=_;Ze(E,"stridedSlice");const{finalShapeSparse:xe,finalShape:le,isIdentity:he,sliceDim0:de,isSimpleSlice:me,begin:ge,end:be,strides:ye}=Lz(E.shape,S,I,D,k,V,$,Z,te);let ve;if(he)ve=ev({inputs:{x:E},backend:p,attrs:{shape:le}});else if(de||me){A(E.shape.length>=1,()=>"Input must have rank at least 1, got: "+E.shape.length);const Ie=L1(ge,be,ye),je=FV({inputs:{x:E},backend:p,attrs:{begin:ge,size:Ie}});ve=ev({inputs:{x:je},backend:p,attrs:{shape:le}}),p.disposeIntermediateTensorInfo(je)}else{const Ie=p.bufferSync(E),je=N8(xe,Ie,ye,ge);ve=p.makeTensorInfo(le,je.dtype,je.values)}return ve}const S5={kernelName:cH,backendName:"cpu",kernelFunc:S4};function S6(m){const{inputs:d,backend:p,attrs:_}=m,{x:E}=d,{reps:S}=_;Ze(E,"tile");const I=Nr(p.bufferSync(E),S);return p.makeTensorInfo(I.shape,I.dtype,I.values)}const S7={kernelName:cX,backendName:"cpu",kernelFunc:S6};function S8(m){const{inputs:d,attrs:p,backend:_}=m,{image:E,transforms:S}=d,{interpolation:I,fillMode:D,fillValue:k,outputShape:V}=p,[$,Z,te,xe]=E.shape,[le,he]=V??[Z,te],de=[$,le,he,xe],me=o6(E.shape),ge=me[0],be=me[1],ye=me[2],ve=o6(de),Ie=ve[0],je=ve[1],Me=ve[2],xt=M(E.dtype,n(de));xt.fill(k);const bt=_.data.get(E.dataId).values,gt=_.data.get(S.dataId).values;for(let Xt=0;Xt<$;++Xt){const Ut=S.shape[0]===1?gt:gt.subarray(Xt*8,Xt*8+8);for(let Ht=0;Ht<le;++Ht)for(let mi=0;mi<he;++mi)for(let gi=0;gi<xe;++gi){let Ui;const yi=Ut[6]*mi+Ut[7]*Ht+1;if(yi===0)continue;const vi=(Ut[0]*mi+Ut[1]*Ht+Ut[2])/yi,ts=(Ut[3]*mi+Ut[4]*Ht+Ut[5])/yi,us=So(vi,te,D),bi=So(ts,Z,D);switch(I){case"nearest":Ui=SL(bt,Z,te,ge,be,ye,Xt,bi,us,gi,k);break;case"bilinear":Ui=SK(bt,Z,te,ge,be,ye,Xt,bi,us,gi,k);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got "+I)}const Ri=Xt*Ie+Ht*je+mi*Me+gi;xt[Ri]=Ui}return _.makeTensorInfo(de,E.dtype,xt)}return{dataId:_.write(xt,de,E.dtype),shape:E.shape,dtype:E.dtype}}const S9={kernelName:cf,backendName:"cpu",kernelFunc:S8};function So(m,d,p){switch(p){case"reflect":return Sc(m,d);case"wrap":return SG(m,d);case"nearest":return Sz(m,d);case"constant":default:return Ss(m)}}function Sc(m,d){let p=m;if(p<0)if(d<=1)p=0;else{const _=2*d;p<_&&(p=_*Math.trunc(-p/_)+p),p=p<-d?p+_:-p-1}else if(p>d-1)if(d<=1)p=0;else{const _=2*d;p-=_*Math.trunc(p/_),p>=d&&(p=_-p-1)}return K(0,p,d-1)}function SG(m,d){let p=m;if(p<0)if(d<=1)p=0;else{const _=d-1;p+=d*(Math.trunc(-p/_)+1)}else if(p>d-1)if(d<=1)p=0;else{const _=d-1;p-=d*Math.trunc(p/_)}return K(0,p,d-1)}function Ss(m,d){return m}function Sz(m,d){return K(0,m,d-1)}function SC(m,d,p,_,E,S,I,D,k,V,$){const Z=I*_+D*E+k*S+V;return 0<=D&&D<d&&0<=k&&k<p?m[Z]:$}function SL(m,d,p,_,E,S,I,D,k,V,$){const Z=Math.round(D),te=Math.round(k);return SC(m,d,p,_,E,S,I,Z,te,V,$)}function SK(m,d,p,_,E,S,I,D,k,V,$){const Z=Math.floor(D),te=Math.floor(k),xe=Z+1,le=te+1,he=(le-k)*SC(m,d,p,_,E,S,I,Z,te,V,$)+(k-te)*SC(m,d,p,_,E,S,I,Z,le,V,$),de=(le-k)*SC(m,d,p,_,E,S,I,xe,te,V,$)+(k-te)*SC(m,d,p,_,E,S,I,xe,le,V,$);return(xe-D)*he+(D-Z)*de}function Sr(m){const{inputs:d,backend:p}=m,{x:_}=d;if(_.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(_.dtype==="complex64"){const E=ZX({inputs:{input:_},backend:p}),S=Sr({inputs:{x:E},backend:p}),I=eb({inputs:{input:_},backend:p}),D=Sr({inputs:{x:I},backend:p}),k=Zj({inputs:{real:S,imag:D},backend:p});return p.disposeIntermediateTensorInfo(E),p.disposeIntermediateTensorInfo(S),p.disposeIntermediateTensorInfo(I),p.disposeIntermediateTensorInfo(D),k}else return Ps({backend:p,attrs:{shape:_.shape,value:0,dtype:_.dtype}})}const ST={kernelName:cW,backendName:"cpu",kernelFunc:Sr};function Sq(m){const{inputs:d,backend:p,attrs:_}=m,{a:E,b:S,bias:I,preluActivationWeights:D}=d,{transposeA:k,transposeB:V,activation:$,leakyreluAlpha:Z}=_;let te,xe,le;const he=[];te=eY({inputs:{a:E,b:S},attrs:{transposeA:k,transposeB:V},backend:p}),I&&(xe=ZJ({inputs:{a:te,b:I},backend:p}),he.push(te),te=xe),$&&(le=PA(p,te,$,D,Z),he.push(te),te=le);for(const de of he)p.disposeIntermediateTensorInfo(de);return te}const SQ={kernelName:cJ,backendName:"cpu",kernelFunc:Sq};cV(Oh),cV(Dc),cV(DC),cV(DT),cV(Dk),cV(DM),cV(Dm),cV(Da),cV(n5),cV(ns),cV(nK),cV(nQ),cV(nw),cV(nF),cV(nn),cV(ne),cV(nI),cV(nR),cV(nX),cV(nd),cV(nU),cV(nh),cV(nl),cV(Oa),cV(ng),cV(i3),cV(i7),cV(iG),cV(iC),cV(iK),cV(iQ),cV(ip),cV(iA),cV(iO),cV(DN),cV(iP),cV(iI),cV(iH),cV(iE),cV(D4),cV(id),cV(it),cV(im),cV(ia),cV(Dn),cV(e1),cV(e3),cV(e7),cV(ec),cV(er),cV(eQ),cV(ew),cV(eF),cV(eD),cV(DX),cV(eP),cV(eB),cV(Dy),cV(eR),cV(eu),cV(ZI),cV(Zt),cV(eE),cV(eM),cV(et),cV(em),cV(ZE),cV(el),cV(eV),cV(P0),cV(P2),cV(P4),cV(P6),cV(P8),cV(Po),cV(PG),cV(Pz),cV(F3),cV(PF),cV(PO),cV(Pn),cV(Fo),cV(Zu),cV(Fs),cV(FL),cV(PP),cV(PB),cV(PR),cV(Pu),cV(Fk),cV(PM),cV(PJ),cV(FA),cV(FO),cV(Fi),cV(Pv),cV(PY),cV(Pl),cV(Pq),cV(Pa),cV(Py),cV(Pk),cV(Pw),cV(eh),cV(Pg),cV(S0),cV(Fb),cV(S2),cV(Fg),cV(N5),cV(S3),cV(S5),cV(NK),cV(PW),cV(S7),cV(S9),cV(FI),cV(ST),cV(SQ);var Sk={};(function(I4){var I5=I4;typeof G1<"u"&&(G1.numeric=I5),I5.version="1.2.6",I5.bench=function(m,d){var p,_,E,S;for(typeof d>"u"&&(d=15),E=.5,p=new Date;;){for(E*=2,S=E;S>3;S-=4)m(),m(),m(),m();for(;S>0;)m(),S--;if(_=new Date,_-p>d)break}for(S=E;S>3;S-=4)m(),m(),m(),m();for(;S>0;)m(),S--;return _=new Date,1e3*(3*E-1)/(_-p)},I5._myIndexOf=function(m){var d=this.length,p;for(p=0;p<d;++p)if(this[p]===m)return p;return-1},I5.myIndexOf=Array.prototype.indexOf?Array.prototype.indexOf:I5._myIndexOf,I5.Function=Function,I5.precision=4,I5.largeArray=50,I5.prettyPrint=function(m){function d(E){if(E===0)return"0";if(isNaN(E))return"NaN";if(E<0)return"-"+d(-E);if(isFinite(E)){var S=Math.floor(Math.log(E)/Math.log(10)),I=E/Math.pow(10,S),D=I.toPrecision(I5.precision);return parseFloat(D)===10&&(S++,I=1,D=I.toPrecision(I5.precision)),parseFloat(D).toString()+"e"+S.toString()}return"Infinity"}var p=[];function _(E){var S;if(typeof E>"u")return p.push(Array(I5.precision+8).join(" ")),!1;if(typeof E=="string")return p.push('"'+E+'"'),!1;if(typeof E=="boolean")return p.push(E.toString()),!1;if(typeof E=="number"){var I=d(E),D=E.toPrecision(I5.precision),k=parseFloat(E.toString()).toString(),V=[I,D,k,parseFloat(D).toString(),parseFloat(k).toString()];for(S=1;S<V.length;S++)V[S].length<I.length&&(I=V[S]);return p.push(Array(I5.precision+8-I.length).join(" ")+I),!1}if(E===null)return p.push("null"),!1;if(typeof E=="function"){p.push(E.toString());var $=!1;for(S in E)E.hasOwnProperty(S)&&($?p.push(`,
`):p.push(`
{`),$=!0,p.push(S),p.push(`: 
`),_(E[S]));return $&&p.push(`}
`),!0}if(E instanceof Array){if(E.length>I5.largeArray)return p.push("...Large Array..."),!0;var $=!1;for(p.push("["),S=0;S<E.length;S++)S>0&&(p.push(","),$&&p.push(`
 `)),$=_(E[S]);return p.push("]"),!0}p.push("{");var $=!1;for(S in E)E.hasOwnProperty(S)&&($&&p.push(`,
`),$=!0,p.push(S),p.push(`: 
`),_(E[S]));return p.push("}"),!0}return _(m),p.join("")},I5.parseDate=function(m){function d(p){if(typeof p=="string")return Date.parse(p.replace(/-/g,"/"));if(!(p instanceof Array))throw new Error("parseDate: parameter must be arrays of strings");var _=[],E;for(E=0;E<p.length;E++)_[E]=d(p[E]);return _}return d(m)},I5.parseFloat=function(m){function d(p){if(typeof p=="string")return parseFloat(p);if(!(p instanceof Array))throw new Error("parseFloat: parameter must be arrays of strings");var _=[],E;for(E=0;E<p.length;E++)_[E]=d(p[E]);return _}return d(m)},I5.parseCSV=function(m){var d=m.split(`
`),p,_,E=[],S=/(([^'",]*)|('[^']*')|("[^"]*")),/g,I=/^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/,D=function(Z){return Z.substr(0,Z.length-1)},k=0;for(_=0;_<d.length;_++){var V=(d[_]+",").match(S),$;if(V.length>0){for(E[k]=[],p=0;p<V.length;p++)$=D(V[p]),I.test($)?E[k][p]=parseFloat($):E[k][p]=$;k++}}return E},I5.toCSV=function(m){var d=I5.dim(m),p,_,E,S,I;for(E=d[0],d[1],I=[],p=0;p<E;p++){for(S=[],_=0;_<E;_++)S[_]=m[p][_].toString();I[p]=S.join(", ")}return I.join(`
`)+`
`},I5.getURL=function(m){var d=new XMLHttpRequest;return d.open("GET",m,!1),d.send(),d},I5.imageURL=function(m){function d(de){var me=de.length,ge,be,ye,ve,Ie,je,Me,xt,bt="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",gt="";for(ge=0;ge<me;ge+=3)be=de[ge],ye=de[ge+1],ve=de[ge+2],Ie=be>>2,je=((be&3)<<4)+(ye>>4),Me=((ye&15)<<2)+(ve>>6),xt=ve&63,ge+1>=me?Me=xt=64:ge+2>=me&&(xt=64),gt+=bt.charAt(Ie)+bt.charAt(je)+bt.charAt(Me)+bt.charAt(xt);return gt}function p(de,me,ge){typeof me>"u"&&(me=0),typeof ge>"u"&&(ge=de.length);var be=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],ye=-1,ve=0;de.length;var Ie;for(Ie=me;Ie<ge;Ie++)ve=(ye^de[Ie])&255,ye=ye>>>8^be[ve];return ye^-1}var _=m[0].length,E=m[0][0].length,S,I,D,k,V,$,Z,te,xe,le,he=[137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,E>>24&255,E>>16&255,E>>8&255,E&255,_>>24&255,_>>16&255,_>>8&255,_&255,8,2,0,0,0,-1,-2,-3,-4,-5,-6,-7,-8,73,68,65,84,8,29];for(le=p(he,12,29),he[29]=le>>24&255,he[30]=le>>16&255,he[31]=le>>8&255,he[32]=le&255,S=1,I=0,Z=0;Z<_;Z++){for(Z<_-1?he.push(0):he.push(1),V=3*E+1+(Z===0)&255,$=3*E+1+(Z===0)>>8&255,he.push(V),he.push($),he.push(~V&255),he.push(~$&255),Z===0&&he.push(0),te=0;te<E;te++)for(D=0;D<3;D++)V=m[D][Z][te],V>255?V=255:V<0?V=0:V=Math.round(V),S=(S+V)%65521,I=(I+S)%65521,he.push(V);he.push(0)}return xe=(I<<16)+S,he.push(xe>>24&255),he.push(xe>>16&255),he.push(xe>>8&255),he.push(xe&255),k=he.length-41,he[33]=k>>24&255,he[34]=k>>16&255,he[35]=k>>8&255,he[36]=k&255,le=p(he,37),he.push(le>>24&255),he.push(le>>16&255),he.push(le>>8&255),he.push(le&255),he.push(0),he.push(0),he.push(0),he.push(0),he.push(73),he.push(69),he.push(78),he.push(68),he.push(174),he.push(66),he.push(96),he.push(130),"data:image/png;base64,"+d(he)},I5._dim=function(m){for(var d=[];typeof m=="object";)d.push(m.length),m=m[0];return d},I5.dim=function(m){var d,p;return typeof m=="object"?(d=m[0],typeof d=="object"?(p=d[0],typeof p=="object"?I5._dim(m):[m.length,d.length]):[m.length]):[]},I5.mapreduce=function(m,d){return Function("x","accum","_s","_k",'if(typeof accum === "undefined") accum = '+d+`;
if(typeof x === "number") { var xi = x; `+m+`; return accum; }
if(typeof _s === "undefined") _s = numeric.dim(x);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i,xi;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) {
        accum = arguments.callee(x[i],accum,_s,_k+1);
    }    return accum;
}
for(i=_n-1;i>=1;i-=2) { 
    xi = x[i];
    `+m+`;
    xi = x[i-1];
    `+m+`;
}
if(i === 0) {
    xi = x[i];
    `+m+`
}
return accum;`)},I5.mapreduce2=function(m,d){return Function("x",`var n = x.length;
var i,xi;
`+d+`;
for(i=n-1;i!==-1;--i) { 
    xi = x[i];
    `+m+`;
}
return accum;`)},I5.same=function m(d,p){var _,E;if(!(d instanceof Array)||!(p instanceof Array)||(E=d.length,E!==p.length))return!1;for(_=0;_<E;_++)if(d[_]!==p[_])if(typeof d[_]=="object"){if(!m(d[_],p[_]))return!1}else return!1;return!0},I5.rep=function(m,d,p){typeof p>"u"&&(p=0);var _=m[p],E=Array(_),S;if(p===m.length-1){for(S=_-2;S>=0;S-=2)E[S+1]=d,E[S]=d;return S===-1&&(E[0]=d),E}for(S=_-1;S>=0;S--)E[S]=I5.rep(m,d,p+1);return E},I5.dotMMsmall=function(m,d){var p,_,E,S,I,D,k,V,$,Z,te;for(S=m.length,I=d.length,D=d[0].length,k=Array(S),p=S-1;p>=0;p--){for(V=Array(D),$=m[p],E=D-1;E>=0;E--){for(Z=$[I-1]*d[I-1][E],_=I-2;_>=1;_-=2)te=_-1,Z+=$[_]*d[_][E]+$[te]*d[te][E];_===0&&(Z+=$[0]*d[0][E]),V[E]=Z}k[p]=V}return k},I5._getCol=function(m,d,p){var _=m.length,E;for(E=_-1;E>0;--E)p[E]=m[E][d],--E,p[E]=m[E][d];E===0&&(p[0]=m[0][d])},I5.dotMMbig=function(m,d){var p=I5._getCol,_=d.length,E=Array(_),S=m.length,I=d[0].length,D=new Array(S),k,V=I5.dotVV,$,Z;for(--_,--S,$=S;$!==-1;--$)D[$]=Array(I);for(--I,$=I;$!==-1;--$)for(p(d,$,E),Z=S;Z!==-1;--Z)k=m[Z],D[Z][$]=V(k,E);return D},I5.dotMV=function(m,d){var p=m.length;d.length;var _,E=Array(p),S=I5.dotVV;for(_=p-1;_>=0;_--)E[_]=S(m[_],d);return E},I5.dotVM=function(m,d){var p,_,E,S,I,D,k;for(E=m.length,S=d[0].length,I=Array(S),_=S-1;_>=0;_--){for(D=m[E-1]*d[E-1][_],p=E-2;p>=1;p-=2)k=p-1,D+=m[p]*d[p][_]+m[k]*d[k][_];p===0&&(D+=m[0]*d[0][_]),I[_]=D}return I},I5.dotVV=function(m,d){var p,_=m.length,E,S=m[_-1]*d[_-1];for(p=_-2;p>=1;p-=2)E=p-1,S+=m[p]*d[p]+m[E]*d[E];return p===0&&(S+=m[0]*d[0]),S},I5.dot=function(m,d){var p=I5.dim;switch(p(m).length*1e3+p(d).length){case 2002:return d.length<10?I5.dotMMsmall(m,d):I5.dotMMbig(m,d);case 2001:return I5.dotMV(m,d);case 1002:return I5.dotVM(m,d);case 1001:return I5.dotVV(m,d);case 1e3:return I5.mulVS(m,d);case 1:return I5.mulSV(m,d);case 0:return m*d;default:throw new Error("numeric.dot only works on vectors and matrices")}},I5.diag=function(m){var d,p,_,E=m.length,S=Array(E),I;for(d=E-1;d>=0;d--){for(I=Array(E),p=d+2,_=E-1;_>=p;_-=2)I[_]=0,I[_-1]=0;for(_>d&&(I[_]=0),I[d]=m[d],_=d-1;_>=1;_-=2)I[_]=0,I[_-1]=0;_===0&&(I[0]=0),S[d]=I}return S},I5.getDiag=function(m){var d=Math.min(m.length,m[0].length),p,_=Array(d);for(p=d-1;p>=1;--p)_[p]=m[p][p],--p,_[p]=m[p][p];return p===0&&(_[0]=m[0][0]),_},I5.identity=function(m){return I5.diag(I5.rep([m],1))},I5.pointwise=function(m,d,p){typeof p>"u"&&(p="");var _=[],E,S=/\[i\]$/,I,D="",k=!1;for(E=0;E<m.length;E++)S.test(m[E])?(I=m[E].substring(0,m[E].length-3),D=I):I=m[E],I==="ret"&&(k=!0),_.push(I);return _[m.length]="_s",_[m.length+1]="_k",_[m.length+2]='if(typeof _s === "undefined") _s = numeric.dim('+D+`);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i`+(k?"":", ret = Array(_n)")+`;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(`+m.join(",")+`,_s,_k+1);
    return ret;
}
`+p+`
for(i=_n-1;i!==-1;--i) {
    `+d+`
}
return ret;`,Function.apply(null,_)},I5.pointwise2=function(m,d,p){typeof p>"u"&&(p="");var _=[],E,S=/\[i\]$/,I,D="",k=!1;for(E=0;E<m.length;E++)S.test(m[E])?(I=m[E].substring(0,m[E].length-3),D=I):I=m[E],I==="ret"&&(k=!0),_.push(I);return _[m.length]="var _n = "+D+`.length;
var i`+(k?"":", ret = Array(_n)")+`;
`+p+`
for(i=_n-1;i!==-1;--i) {
`+d+`
}
return ret;`,Function.apply(null,_)},I5._biforeach=function m(d,p,_,E,S){if(E===_.length-1){S(d,p);return}var I,D=_[E];for(I=D-1;I>=0;I--)m(typeof d=="object"?d[I]:d,typeof p=="object"?p[I]:p,_,E+1,S)},I5._biforeach2=function m(d,p,_,E,S){if(E===_.length-1)return S(d,p);var I,D=_[E],k=Array(D);for(I=D-1;I>=0;--I)k[I]=m(typeof d=="object"?d[I]:d,typeof p=="object"?p[I]:p,_,E+1,S);return k},I5._foreach=function m(d,p,_,E){if(_===p.length-1){E(d);return}var S,I=p[_];for(S=I-1;S>=0;S--)m(d[S],p,_+1,E)},I5._foreach2=function m(d,p,_,E){if(_===p.length-1)return E(d);var S,I=p[_],D=Array(I);for(S=I-1;S>=0;S--)D[S]=m(d[S],p,_+1,E);return D},I5.ops2={add:"+",sub:"-",mul:"*",div:"/",mod:"%",and:"&&",or:"||",eq:"===",neq:"!==",lt:"<",gt:">",leq:"<=",geq:">=",band:"&",bor:"|",bxor:"^",lshift:"<<",rshift:">>",rrshift:">>>"},I5.opseq={addeq:"+=",subeq:"-=",muleq:"*=",diveq:"/=",modeq:"%=",lshifteq:"<<=",rshifteq:">>=",rrshifteq:">>>=",bandeq:"&=",boreq:"|=",bxoreq:"^="},I5.mathfuns=["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan","isNaN","isFinite"],I5.mathfuns2=["atan2","pow","max","min"],I5.ops1={neg:"-",not:"!",bnot:"~",clone:""},I5.mapreducers={any:["if(xi) return true;","var accum = false;"],all:["if(!xi) return false;","var accum = true;"],sum:["accum += xi;","var accum = 0;"],prod:["accum *= xi;","var accum = 1;"],norm2Squared:["accum += xi*xi;","var accum = 0;"],norminf:["accum = max(accum,abs(xi));","var accum = 0, max = Math.max, abs = Math.abs;"],norm1:["accum += abs(xi)","var accum = 0, abs = Math.abs;"],sup:["accum = max(accum,xi);","var accum = -Infinity, max = Math.max;"],inf:["accum = min(accum,xi);","var accum = Infinity, min = Math.min;"]},function(){var m,d;for(m=0;m<I5.mathfuns2.length;++m)d=I5.mathfuns2[m],I5.ops2[d]=d;for(m in I5.ops2)if(I5.ops2.hasOwnProperty(m)){d=I5.ops2[m];var p,_,E="";I5.myIndexOf.call(I5.mathfuns2,m)!==-1?(E="var "+d+" = Math."+d+`;
`,p=function(S,I,D){return S+" = "+d+"("+I+","+D+")"},_=function(S,I){return S+" = "+d+"("+S+","+I+")"}):(p=function(S,I,D){return S+" = "+I+" "+d+" "+D},I5.opseq.hasOwnProperty(m+"eq")?_=function(S,I){return S+" "+d+"= "+I}:_=function(S,I){return S+" = "+S+" "+d+" "+I}),I5[m+"VV"]=I5.pointwise2(["x[i]","y[i]"],p("ret[i]","x[i]","y[i]"),E),I5[m+"SV"]=I5.pointwise2(["x","y[i]"],p("ret[i]","x","y[i]"),E),I5[m+"VS"]=I5.pointwise2(["x[i]","y"],p("ret[i]","x[i]","y"),E),I5[m]=Function(`var n = arguments.length, i, x = arguments[0], y;
var VV = numeric.`+m+"VV, VS = numeric."+m+"VS, SV = numeric."+m+`SV;
var dim = numeric.dim;
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof x === "object") {
      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);
      else x = numeric._biforeach2(x,y,dim(x),0,VS);
  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);
  else `+_("x","y")+`
}
return x;
`),I5[d]=I5[m],I5[m+"eqV"]=I5.pointwise2(["ret[i]","x[i]"],_("ret[i]","x[i]"),E),I5[m+"eqS"]=I5.pointwise2(["ret[i]","x"],_("ret[i]","x"),E),I5[m+"eq"]=Function(`var n = arguments.length, i, x = arguments[0], y;
var V = numeric.`+m+"eqV, S = numeric."+m+`eqS
var s = numeric.dim(x);
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);
  else numeric._biforeach(x,y,s,0,S);
}
return x;
`)}for(m=0;m<I5.mathfuns2.length;++m)d=I5.mathfuns2[m],delete I5.ops2[d];for(m=0;m<I5.mathfuns.length;++m)d=I5.mathfuns[m],I5.ops1[d]=d;for(m in I5.ops1)I5.ops1.hasOwnProperty(m)&&(E="",d=I5.ops1[m],I5.myIndexOf.call(I5.mathfuns,m)!==-1&&Math.hasOwnProperty(d)&&(E="var "+d+" = Math."+d+`;
`),I5[m+"eqV"]=I5.pointwise2(["ret[i]"],"ret[i] = "+d+"(ret[i]);",E),I5[m+"eq"]=Function("x",'if(typeof x !== "object") return '+d+`x
var i;
var V = numeric.`+m+`eqV;
var s = numeric.dim(x);
numeric._foreach(x,s,0,V);
return x;
`),I5[m+"V"]=I5.pointwise2(["x[i]"],"ret[i] = "+d+"(x[i]);",E),I5[m]=Function("x",'if(typeof x !== "object") return '+d+`(x)
var i;
var V = numeric.`+m+`V;
var s = numeric.dim(x);
return numeric._foreach2(x,s,0,V);
`));for(m=0;m<I5.mathfuns.length;++m)d=I5.mathfuns[m],delete I5.ops1[d];for(m in I5.mapreducers)I5.mapreducers.hasOwnProperty(m)&&(d=I5.mapreducers[m],I5[m+"V"]=I5.mapreduce2(d[0],d[1]),I5[m]=Function("x","s","k",d[1]+`if(typeof x !== "object") {    xi = x;
`+d[0]+`;
    return accum;
}if(typeof s === "undefined") s = numeric.dim(x);
if(typeof k === "undefined") k = 0;
if(k === s.length-1) return numeric.`+m+`V(x);
var xi;
var n = x.length, i;
for(i=n-1;i!==-1;--i) {
   xi = arguments.callee(x[i]);
`+d[0]+`;
}
return accum;
`))}(),I5.truncVV=I5.pointwise(["x[i]","y[i]"],"ret[i] = round(x[i]/y[i])*y[i];","var round = Math.round;"),I5.truncVS=I5.pointwise(["x[i]","y"],"ret[i] = round(x[i]/y)*y;","var round = Math.round;"),I5.truncSV=I5.pointwise(["x","y[i]"],"ret[i] = round(x/y[i])*y[i];","var round = Math.round;"),I5.trunc=function(m,d){return typeof m=="object"?typeof d=="object"?I5.truncVV(m,d):I5.truncVS(m,d):typeof d=="object"?I5.truncSV(m,d):Math.round(m/d)*d},I5.inv=function(le){var d=I5.dim(le),p=Math.abs,_=d[0],E=d[1],S=I5.clone(le),I,D,k=I5.identity(_),V,$,Z,te,xe,le;for(te=0;te<E;++te){var he=-1,de=-1;for(Z=te;Z!==_;++Z)xe=p(S[Z][te]),xe>de&&(he=Z,de=xe);for(D=S[he],S[he]=S[te],S[te]=D,$=k[he],k[he]=k[te],k[te]=$,le=D[te],xe=te;xe!==E;++xe)D[xe]/=le;for(xe=E-1;xe!==-1;--xe)$[xe]/=le;for(Z=_-1;Z!==-1;--Z)if(Z!==te){for(I=S[Z],V=k[Z],le=I[te],xe=te+1;xe!==E;++xe)I[xe]-=D[xe]*le;for(xe=E-1;xe>0;--xe)V[xe]-=$[xe]*le,--xe,V[xe]-=$[xe]*le;xe===0&&(V[0]-=$[0]*le)}}return k},I5.det=function(m){var d=I5.dim(m);if(d.length!==2||d[0]!==d[1])throw new Error("numeric: det() only works on square matrices");var p=d[0],_=1,E,S,I,D=I5.clone(m),k,V,$,Z,te;for(S=0;S<p-1;S++){for(I=S,E=S+1;E<p;E++)Math.abs(D[E][S])>Math.abs(D[I][S])&&(I=E);for(I!==S&&(Z=D[I],D[I]=D[S],D[S]=Z,_*=-1),k=D[S],E=S+1;E<p;E++){for(V=D[E],$=V[S]/k[S],I=S+1;I<p-1;I+=2)te=I+1,V[I]-=k[I]*$,V[te]-=k[te]*$;I!==p&&(V[I]-=k[I]*$)}if(k[S]===0)return 0;_*=k[S]}return _*D[S][S]},I5.transpose=function(m){var d,p,_=m.length,E=m[0].length,S=Array(E),I,D,k;for(p=0;p<E;p++)S[p]=Array(_);for(d=_-1;d>=1;d-=2){for(D=m[d],I=m[d-1],p=E-1;p>=1;--p)k=S[p],k[d]=D[p],k[d-1]=I[p],--p,k=S[p],k[d]=D[p],k[d-1]=I[p];p===0&&(k=S[0],k[d]=D[0],k[d-1]=I[0])}if(d===0){for(I=m[0],p=E-1;p>=1;--p)S[p][0]=I[p],--p,S[p][0]=I[p];p===0&&(S[0][0]=I[0])}return S},I5.negtranspose=function(m){var d,p,_=m.length,E=m[0].length,S=Array(E),I,D,k;for(p=0;p<E;p++)S[p]=Array(_);for(d=_-1;d>=1;d-=2){for(D=m[d],I=m[d-1],p=E-1;p>=1;--p)k=S[p],k[d]=-D[p],k[d-1]=-I[p],--p,k=S[p],k[d]=-D[p],k[d-1]=-I[p];p===0&&(k=S[0],k[d]=-D[0],k[d-1]=-I[0])}if(d===0){for(I=m[0],p=E-1;p>=1;--p)S[p][0]=-I[p],--p,S[p][0]=-I[p];p===0&&(S[0][0]=-I[0])}return S},I5._random=function m(d,p){var _,E=d[p],S=Array(E),I;if(p===d.length-1){for(I=Math.random,_=E-1;_>=1;_-=2)S[_]=I(),S[_-1]=I();return _===0&&(S[0]=I()),S}for(_=E-1;_>=0;_--)S[_]=m(d,p+1);return S},I5.random=function(m){return I5._random(m,0)},I5.norm2=function(m){return Math.sqrt(I5.norm2Squared(m))},I5.linspace=function(m,d,p){if(typeof p>"u"&&(p=Math.max(Math.round(d-m)+1,1)),p<2)return p===1?[m]:[];var _,E=Array(p);for(p--,_=p;_>=0;_--)E[_]=(_*d+(p-_)*m)/p;return E},I5.getBlock=function(m,d,p){var _=I5.dim(m);function E(S,I){var D,k=d[I],V=p[I]-k,$=Array(V);if(I===_.length-1){for(D=V;D>=0;D--)$[D]=S[D+k];return $}for(D=V;D>=0;D--)$[D]=E(S[D+k],I+1);return $}return E(m,0)},I5.setBlock=function(m,d,p,_){var E=I5.dim(m);function S(I,D,k){var V,$=d[k],Z=p[k]-$;if(k===E.length-1)for(V=Z;V>=0;V--)I[V+$]=D[V];for(V=Z;V>=0;V--)S(I[V+$],D[V],k+1)}return S(m,_,0),m},I5.getRange=function(m,d,p){var _=d.length,E=p.length,S,I,D=Array(_),k,V;for(S=_-1;S!==-1;--S)for(D[S]=Array(E),k=D[S],V=m[d[S]],I=E-1;I!==-1;--I)k[I]=V[p[I]];return D},I5.blockMatrix=function(m){var d=I5.dim(m);if(d.length<4)return I5.blockMatrix([m]);var p=d[0],_=d[1],E,S,I,D,k;for(E=0,S=0,I=0;I<p;++I)E+=m[I][0].length;for(D=0;D<_;++D)S+=m[0][D][0].length;var V=Array(E);for(I=0;I<E;++I)V[I]=Array(S);var $=0,Z,te,xe,le,he;for(I=0;I<p;++I){for(Z=S,D=_-1;D!==-1;--D)for(k=m[I][D],Z-=k[0].length,xe=k.length-1;xe!==-1;--xe)for(he=k[xe],te=V[$+xe],le=he.length-1;le!==-1;--le)te[Z+le]=he[le];$+=m[I][0].length}return V},I5.tensor=function(m,d){if(typeof m=="number"||typeof d=="number")return I5.mul(m,d);var p=I5.dim(m),_=I5.dim(d);if(p.length!==1||_.length!==1)throw new Error("numeric: tensor product is only defined for vectors");var E=p[0],S=_[0],I=Array(E),D,k,V,$;for(k=E-1;k>=0;k--){for(D=Array(S),$=m[k],V=S-1;V>=3;--V)D[V]=$*d[V],--V,D[V]=$*d[V],--V,D[V]=$*d[V],--V,D[V]=$*d[V];for(;V>=0;)D[V]=$*d[V],--V;I[k]=D}return I},I5.T=function(m,d){this.x=m,this.y=d},I5.t=function(m,d){return new I5.T(m,d)},I5.Tbinop=function(m,d,p,_,E){if(I5.indexOf,typeof E!="string"){var S;E="";for(S in I5)I5.hasOwnProperty(S)&&(m.indexOf(S)>=0||d.indexOf(S)>=0||p.indexOf(S)>=0||_.indexOf(S)>=0)&&S.length>1&&(E+="var "+S+" = numeric."+S+`;
`)}return Function(["y"],`var x = this;
if(!(y instanceof numeric.T)) { y = new numeric.T(y); }
`+E+`
if(x.y) {  if(y.y) {    return new numeric.T(`+_+`);
  }
  return new numeric.T(`+p+`);
}
if(y.y) {
  return new numeric.T(`+d+`);
}
return new numeric.T(`+m+`);
`)},I5.T.prototype.add=I5.Tbinop("add(x.x,y.x)","add(x.x,y.x),y.y","add(x.x,y.x),x.y","add(x.x,y.x),add(x.y,y.y)"),I5.T.prototype.sub=I5.Tbinop("sub(x.x,y.x)","sub(x.x,y.x),neg(y.y)","sub(x.x,y.x),x.y","sub(x.x,y.x),sub(x.y,y.y)"),I5.T.prototype.mul=I5.Tbinop("mul(x.x,y.x)","mul(x.x,y.x),mul(x.x,y.y)","mul(x.x,y.x),mul(x.y,y.x)","sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))"),I5.T.prototype.reciprocal=function(){var m=I5.mul,d=I5.div;if(this.y){var p=I5.add(m(this.x,this.x),m(this.y,this.y));return new I5.T(d(this.x,p),d(I5.neg(this.y),p))}return new T(d(1,this.x))},I5.T.prototype.div=function(m){if(m instanceof I5.T||(m=new I5.T(m)),m.y)return this.mul(m.reciprocal());var d=I5.div;return this.y?new I5.T(d(this.x,m.x),d(this.y,m.x)):new I5.T(d(this.x,m.x))},I5.T.prototype.dot=I5.Tbinop("dot(x.x,y.x)","dot(x.x,y.x),dot(x.x,y.y)","dot(x.x,y.x),dot(x.y,y.x)","sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))"),I5.T.prototype.transpose=function(){var m=I5.transpose,d=this.x,p=this.y;return p?new I5.T(m(d),m(p)):new I5.T(m(d))},I5.T.prototype.transjugate=function(){var m=I5.transpose,d=this.x,p=this.y;return p?new I5.T(m(d),I5.negtranspose(p)):new I5.T(m(d))},I5.Tunop=function(m,d,p){return typeof p!="string"&&(p=""),Function(`var x = this;
`+p+`
if(x.y) {  `+d+`;
}
`+m+`;
`)},I5.T.prototype.exp=I5.Tunop("return new numeric.T(ex)","return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))","var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;"),I5.T.prototype.conj=I5.Tunop("return new numeric.T(x.x);","return new numeric.T(x.x,numeric.neg(x.y));"),I5.T.prototype.neg=I5.Tunop("return new numeric.T(neg(x.x));","return new numeric.T(neg(x.x),neg(x.y));","var neg = numeric.neg;"),I5.T.prototype.sin=I5.Tunop("return new numeric.T(numeric.sin(x.x))","return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));"),I5.T.prototype.cos=I5.Tunop("return new numeric.T(numeric.cos(x.x))","return x.exp().add(x.neg().exp()).div(2);"),I5.T.prototype.abs=I5.Tunop("return new numeric.T(numeric.abs(x.x));","return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));","var mul = numeric.mul;"),I5.T.prototype.log=I5.Tunop("return new numeric.T(numeric.log(x.x));",`var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();
return new numeric.T(numeric.log(r.x),theta.x);`),I5.T.prototype.norm2=I5.Tunop("return numeric.norm2(x.x);",`var f = numeric.norm2Squared;
return Math.sqrt(f(x.x)+f(x.y));`),I5.T.prototype.inv=function(){var m=this;if(typeof m.y>"u")return new I5.T(I5.inv(m.x));var d=m.x.length,le,he,de,p=I5.identity(d),_=I5.rep([d,d],0),E=I5.clone(m.x),S=I5.clone(m.y),I,D,k,V,$,Z,te,xe,le,he,de,me,ge,be,ye,ve,Ie,je;for(le=0;le<d;le++){for(be=E[le][le],ye=S[le][le],me=be*be+ye*ye,de=le,he=le+1;he<d;he++)be=E[he][le],ye=S[he][le],ge=be*be+ye*ye,ge>me&&(de=he,me=ge);for(de!==le&&(je=E[le],E[le]=E[de],E[de]=je,je=S[le],S[le]=S[de],S[de]=je,je=p[le],p[le]=p[de],p[de]=je,je=_[le],_[le]=_[de],_[de]=je),I=E[le],D=S[le],$=p[le],Z=_[le],be=I[le],ye=D[le],he=le+1;he<d;he++)ve=I[he],Ie=D[he],I[he]=(ve*be+Ie*ye)/me,D[he]=(Ie*be-ve*ye)/me;for(he=0;he<d;he++)ve=$[he],Ie=Z[he],$[he]=(ve*be+Ie*ye)/me,Z[he]=(Ie*be-ve*ye)/me;for(he=le+1;he<d;he++){for(k=E[he],V=S[he],te=p[he],xe=_[he],be=k[le],ye=V[le],de=le+1;de<d;de++)ve=I[de],Ie=D[de],k[de]-=ve*be-Ie*ye,V[de]-=Ie*be+ve*ye;for(de=0;de<d;de++)ve=$[de],Ie=Z[de],te[de]-=ve*be-Ie*ye,xe[de]-=Ie*be+ve*ye}}for(le=d-1;le>0;le--)for($=p[le],Z=_[le],he=le-1;he>=0;he--)for(te=p[he],xe=_[he],be=E[he][le],ye=S[he][le],de=d-1;de>=0;de--)ve=$[de],Ie=Z[de],te[de]-=be*ve-ye*Ie,xe[de]-=be*Ie+ye*ve;return new I5.T(p,_)},I5.T.prototype.get=function(m){var d=this.x,p=this.y,_=0,E,S=m.length;if(p){for(;_<S;)E=m[_],d=d[E],p=p[E],_++;return new I5.T(d,p)}for(;_<S;)E=m[_],d=d[E],_++;return new I5.T(d)},I5.T.prototype.set=function(m,d){var p=this.x,_=this.y,E=0,S,I=m.length,D=d.x,k=d.y;if(I===0)return k?this.y=k:_&&(this.y=void 0),this.x=p,this;if(k){for(_||(_=I5.rep(I5.dim(p),0),this.y=_);E<I-1;)S=m[E],p=p[S],_=_[S],E++;return S=m[E],p[S]=D,_[S]=k,this}if(_){for(;E<I-1;)S=m[E],p=p[S],_=_[S],E++;return S=m[E],p[S]=D,D instanceof Array?_[S]=I5.rep(I5.dim(D),0):_[S]=0,this}for(;E<I-1;)S=m[E],p=p[S],E++;return S=m[E],p[S]=D,this},I5.T.prototype.getRows=function(m,d){var p=d-m+1,_,E=Array(p),S,I=this.x,D=this.y;for(_=m;_<=d;_++)E[_-m]=I[_];if(D){for(S=Array(p),_=m;_<=d;_++)S[_-m]=D[_];return new I5.T(E,S)}return new I5.T(E)},I5.T.prototype.setRows=function(m,d,p){var _,E=this.x,S=this.y,I=p.x,D=p.y;for(_=m;_<=d;_++)E[_]=I[_-m];if(D)for(S||(S=I5.rep(I5.dim(E),0),this.y=S),_=m;_<=d;_++)S[_]=D[_-m];else if(S)for(_=m;_<=d;_++)S[_]=I5.rep([I[_-m].length],0);return this},I5.T.prototype.getRow=function(m){var d=this.x,p=this.y;return p?new I5.T(d[m],p[m]):new I5.T(d[m])},I5.T.prototype.setRow=function(m,d){var p=this.x,_=this.y,E=d.x,S=d.y;return p[m]=E,S?(_||(_=I5.rep(I5.dim(p),0),this.y=_),_[m]=S):_&&(_=I5.rep([E.length],0)),this},I5.T.prototype.getBlock=function(m,d){var p=this.x,_=this.y,E=I5.getBlock;return _?new I5.T(E(p,m,d),E(_,m,d)):new I5.T(E(p,m,d))},I5.T.prototype.setBlock=function(m,d,p){p instanceof I5.T||(p=new I5.T(p));var _=this.x,E=this.y,S=I5.setBlock,I=p.x,D=p.y;if(D)return E||(this.y=I5.rep(I5.dim(this),0),E=this.y),S(_,m,d,I),S(E,m,d,D),this;S(_,m,d,I),E&&S(E,m,d,I5.rep(I5.dim(I),0))},I5.T.rep=function(m,d){var p=I5.T;d instanceof p||(d=new p(d));var _=d.x,E=d.y,S=I5.rep;return E?new p(S(m,_),S(m,E)):new p(S(m,_))},I5.T.diag=function(m){m instanceof I5.T||(m=new I5.T(m));var d=m.x,p=m.y,_=I5.diag;return p?new I5.T(_(d),_(p)):new I5.T(_(d))},I5.T.eig=function(){if(this.y)throw new Error("eig: not implemented for complex matrices.");return I5.eig(this.x)},I5.T.identity=function(m){return new I5.T(I5.identity(m))},I5.T.prototype.getDiag=function(){var m=I5,d=this.x,p=this.y;return p?new m.T(m.getDiag(d),m.getDiag(p)):new m.T(m.getDiag(d))},I5.house=function(m){var d=I5.clone(m),p=m[0]>=0?1:-1,_=p*I5.norm2(m);d[0]+=_;var E=I5.norm2(d);if(E===0)throw new Error("eig: internal error");return I5.div(d,E)},I5.toUpperHessenberg=function(m){var d=I5.dim(m);if(d.length!==2||d[0]!==d[1])throw new Error("numeric: toUpperHessenberg() only works on square matrices");var p=d[0],_,E,S,I,D,k=I5.clone(m),V,$,Z,te,xe=I5.identity(p),le;for(E=0;E<p-2;E++){for(I=Array(p-E-1),_=E+1;_<p;_++)I[_-E-1]=k[_][E];if(I5.norm2(I)>0){for(D=I5.house(I),V=I5.getBlock(k,[E+1,E],[p-1,p-1]),$=I5.tensor(D,I5.dot(D,V)),_=E+1;_<p;_++)for(Z=k[_],te=$[_-E-1],S=E;S<p;S++)Z[S]-=2*te[S-E];for(V=I5.getBlock(k,[0,E+1],[p-1,p-1]),$=I5.tensor(I5.dot(V,D),D),_=0;_<p;_++)for(Z=k[_],te=$[_],S=E+1;S<p;S++)Z[S]-=2*te[S-E-1];for(V=Array(p-E-1),_=E+1;_<p;_++)V[_-E-1]=xe[_];for($=I5.tensor(D,I5.dot(D,V)),_=E+1;_<p;_++)for(le=xe[_],te=$[_-E-1],S=0;S<p;S++)le[S]-=2*te[S]}}return{H:k,Q:xe}},I5.epsilon=2220446049250313e-31,I5.QRFrancis=function(m,d){typeof d>"u"&&(d=1e4),m=I5.clone(m),I5.clone(m);var p=I5.dim(m),_=p[0],E,S,I,D,k,V,$,Z,te,xe=I5.identity(_),le,he,de,me,ge,be,ye,ve,Ie;if(_<3)return{Q:xe,B:[[0,_-1]]};var je=I5.epsilon;for(Ie=0;Ie<d;Ie++){for(ye=0;ye<_-1;ye++)if(Math.abs(m[ye+1][ye])<je*(Math.abs(m[ye][ye])+Math.abs(m[ye+1][ye+1]))){var Me=I5.QRFrancis(I5.getBlock(m,[0,0],[ye,ye]),d),xt=I5.QRFrancis(I5.getBlock(m,[ye+1,ye+1],[_-1,_-1]),d);for(de=Array(ye+1),be=0;be<=ye;be++)de[be]=xe[be];for(me=I5.dot(Me.Q,de),be=0;be<=ye;be++)xe[be]=me[be];for(de=Array(_-ye-1),be=ye+1;be<_;be++)de[be-ye-1]=xe[be];for(me=I5.dot(xt.Q,de),be=ye+1;be<_;be++)xe[be]=me[be-ye-1];return{Q:xe,B:Me.B.concat(I5.add(xt.B,ye+1))}}if(I=m[_-2][_-2],D=m[_-2][_-1],k=m[_-1][_-2],V=m[_-1][_-1],Z=I+V,$=I*V-D*k,te=I5.getBlock(m,[0,0],[2,2]),Z*Z>=4*$){var bt,gt;bt=.5*(Z+Math.sqrt(Z*Z-4*$)),gt=.5*(Z-Math.sqrt(Z*Z-4*$)),te=I5.add(I5.sub(I5.dot(te,te),I5.mul(te,bt+gt)),I5.diag(I5.rep([3],bt*gt)))}else te=I5.add(I5.sub(I5.dot(te,te),I5.mul(te,Z)),I5.diag(I5.rep([3],$)));for(E=[te[0][0],te[1][0],te[2][0]],S=I5.house(E),de=[m[0],m[1],m[2]],me=I5.tensor(S,I5.dot(S,de)),be=0;be<3;be++)for(he=m[be],ge=me[be],ve=0;ve<_;ve++)he[ve]-=2*ge[ve];for(de=I5.getBlock(m,[0,0],[_-1,2]),me=I5.tensor(I5.dot(de,S),S),be=0;be<_;be++)for(he=m[be],ge=me[be],ve=0;ve<3;ve++)he[ve]-=2*ge[ve];for(de=[xe[0],xe[1],xe[2]],me=I5.tensor(S,I5.dot(S,de)),be=0;be<3;be++)for(le=xe[be],ge=me[be],ve=0;ve<_;ve++)le[ve]-=2*ge[ve];var Xt;for(ye=0;ye<_-2;ye++){for(ve=ye;ve<=ye+1;ve++)if(Math.abs(m[ve+1][ve])<je*(Math.abs(m[ve][ve])+Math.abs(m[ve+1][ve+1]))){var Me=I5.QRFrancis(I5.getBlock(m,[0,0],[ve,ve]),d),xt=I5.QRFrancis(I5.getBlock(m,[ve+1,ve+1],[_-1,_-1]),d);for(de=Array(ve+1),be=0;be<=ve;be++)de[be]=xe[be];for(me=I5.dot(Me.Q,de),be=0;be<=ve;be++)xe[be]=me[be];for(de=Array(_-ve-1),be=ve+1;be<_;be++)de[be-ve-1]=xe[be];for(me=I5.dot(xt.Q,de),be=ve+1;be<_;be++)xe[be]=me[be-ve-1];return{Q:xe,B:Me.B.concat(I5.add(xt.B,ve+1))}}for(Xt=Math.min(_-1,ye+3),E=Array(Xt-ye),be=ye+1;be<=Xt;be++)E[be-ye-1]=m[be][ye];for(S=I5.house(E),de=I5.getBlock(m,[ye+1,ye],[Xt,_-1]),me=I5.tensor(S,I5.dot(S,de)),be=ye+1;be<=Xt;be++)for(he=m[be],ge=me[be-ye-1],ve=ye;ve<_;ve++)he[ve]-=2*ge[ve-ye];for(de=I5.getBlock(m,[0,ye+1],[_-1,Xt]),me=I5.tensor(I5.dot(de,S),S),be=0;be<_;be++)for(he=m[be],ge=me[be],ve=ye+1;ve<=Xt;ve++)he[ve]-=2*ge[ve-ye-1];for(de=Array(Xt-ye),be=ye+1;be<=Xt;be++)de[be-ye-1]=xe[be];for(me=I5.tensor(S,I5.dot(S,de)),be=ye+1;be<=Xt;be++)for(le=xe[be],ge=me[be-ye-1],ve=0;ve<_;ve++)le[ve]-=2*ge[ve]}}throw new Error("numeric: eigenvalue iteration does not converge -- increase maxiter?")},I5.eig=function(m,d){var p=I5.toUpperHessenberg(m),_=I5.QRFrancis(p.H,d),E=I5.T,Xt=m.length,S,I,D=_.B,k=I5.dot(_.Q,I5.dot(p.H,I5.transpose(_.Q))),V=new E(I5.dot(_.Q,p.Q)),$,Z=D.length,te,xe,le,he,de,me,ge,be,ye,ve,Ie,je,Me,xt,bt=Math.sqrt;for(I=0;I<Z;I++)if(S=D[I][0],S!==D[I][1]){if(te=S+1,xe=k[S][S],le=k[S][te],he=k[te][S],de=k[te][te],le===0&&he===0)continue;me=-xe-de,ge=xe*de-le*he,be=me*me-4*ge,be>=0?(me<0?ye=-.5*(me-bt(be)):ye=-.5*(me+bt(be)),Me=(xe-ye)*(xe-ye)+le*le,xt=he*he+(de-ye)*(de-ye),Me>xt?(Me=bt(Me),Ie=(xe-ye)/Me,je=le/Me):(xt=bt(xt),Ie=he/xt,je=(de-ye)/xt),$=new E([[je,-Ie],[Ie,je]]),V.setRows(S,te,$.dot(V.getRows(S,te)))):(ye=-.5*me,ve=.5*bt(-be),Me=(xe-ye)*(xe-ye)+le*le,xt=he*he+(de-ye)*(de-ye),Me>xt?(Me=bt(Me+ve*ve),Ie=(xe-ye)/Me,je=le/Me,ye=0,ve/=Me):(xt=bt(xt+ve*ve),Ie=he/xt,je=(de-ye)/xt,ye=ve/xt,ve=0),$=new E([[je,-Ie],[Ie,je]],[[ye,ve],[ve,-ye]]),V.setRows(S,te,$.dot(V.getRows(S,te))))}var gt=V.dot(m).dot(V.transjugate()),Xt=m.length,Ut=I5.T.identity(Xt);for(te=0;te<Xt;te++)if(te>0)for(I=te-1;I>=0;I--){var Ht=gt.get([I,I]),mi=gt.get([te,te]);if(I5.neq(Ht.x,mi.x)||I5.neq(Ht.y,mi.y))ye=gt.getRow(I).getBlock([I],[te-1]),ve=Ut.getRow(te).getBlock([I],[te-1]),Ut.set([te,I],gt.get([I,te]).neg().sub(ye.dot(ve)).div(Ht.sub(mi)));else{Ut.setRow(te,Ut.getRow(I));continue}}for(te=0;te<Xt;te++)ye=Ut.getRow(te),Ut.setRow(te,ye.div(ye.norm2()));return Ut=Ut.transpose(),Ut=V.transjugate().dot(Ut),{lambda:gt.getDiag(),E:Ut}},I5.ccsSparse=function(m){var d=m.length,I,p,_,E,S=[];for(_=d-1;_!==-1;--_){p=m[_];for(E in p){for(E=parseInt(E);E>=S.length;)S[S.length]=0;p[E]!==0&&S[E]++}}var I=S.length,D=Array(I+1);for(D[0]=0,_=0;_<I;++_)D[_+1]=D[_]+S[_];var k=Array(D[I]),V=Array(D[I]);for(_=d-1;_!==-1;--_){p=m[_];for(E in p)p[E]!==0&&(S[E]--,k[D[E]+S[E]]=_,V[D[E]+S[E]]=p[E])}return[D,k,V]},I5.ccsFull=function(m){var d=m[0],p=m[1],_=m[2],E=I5.ccsDim(m),S=E[0],I=E[1],D,k,V,$,Z=I5.rep([S,I],0);for(D=0;D<I;D++)for(V=d[D],$=d[D+1],k=V;k<$;++k)Z[p[k]][D]=_[k];return Z},I5.ccsTSolve=function(m,d,p,_,E){var S=m[0],I=m[1],D=m[2],k=S.length-1,V=Math.max,$=0;typeof _>"u"&&(p=I5.rep([k],0)),typeof _>"u"&&(_=I5.linspace(0,p.length-1)),typeof E>"u"&&(E=[]);function Z(be){var ye;if(p[be]===0){for(p[be]=1,ye=S[be];ye<S[be+1];++ye)Z(I[ye]);E[$]=be,++$}}var te,xe,le,he,de,me,ge;for(te=_.length-1;te!==-1;--te)Z(_[te]);for(E.length=$,te=E.length-1;te!==-1;--te)p[E[te]]=0;for(te=_.length-1;te!==-1;--te)xe=_[te],p[xe]=d[xe];for(te=E.length-1;te!==-1;--te){for(xe=E[te],le=S[xe],he=V(S[xe+1],le),de=le;de!==he;++de)if(I[de]===xe){p[xe]/=D[de];break}for(ge=p[xe],de=le;de!==he;++de)me=I[de],me!==xe&&(p[me]-=ge*D[de])}return p},I5.ccsDFS=function(m){this.k=Array(m),this.k1=Array(m),this.j=Array(m)},I5.ccsDFS.prototype.dfs=function(m,d,p,_,E,S){var I=0,D,k=E.length,V=this.k,$=this.k1,Z=this.j,te,xe;if(_[m]===0)for(_[m]=1,Z[0]=m,V[0]=te=d[m],$[0]=xe=d[m+1];;)if(te>=xe){if(E[k]=Z[I],I===0)return;++k,--I,te=V[I],xe=$[I]}else D=S[p[te]],_[D]===0?(_[D]=1,V[I]=te,++I,Z[I]=D,te=d[D],$[I]=xe=d[D+1]):++te},I5.ccsLPSolve=function(m,d,p,_,E,S,I){var D=m[0],k=m[1],V=m[2];D.length-1;var $=d[0],Z=d[1],te=d[2],xe,le,he,de,me,ge,be,ye,ve;for(le=$[E],he=$[E+1],_.length=0,xe=le;xe<he;++xe)I.dfs(S[Z[xe]],D,k,p,_,S);for(xe=_.length-1;xe!==-1;--xe)p[_[xe]]=0;for(xe=le;xe!==he;++xe)de=S[Z[xe]],p[de]=te[xe];for(xe=_.length-1;xe!==-1;--xe){for(de=_[xe],me=D[de],ge=D[de+1],be=me;be<ge;++be)if(S[k[be]]===de){p[de]/=V[be];break}for(ve=p[de],be=me;be<ge;++be)ye=S[k[be]],ye!==de&&(p[ye]-=ve*V[be])}return p},I5.ccsLUP1=function(m,d){var p=m[0].length-1,_=[I5.rep([p+1],0),[],[]],E=[I5.rep([p+1],0),[],[]],S=_[0],I=_[1],D=_[2],k=E[0],V=E[1],$=E[2],Z=I5.rep([p],0),te=I5.rep([p],0),xe,le,he,de,me,ge,be,ye=I5.ccsLPSolve,ve=Math.abs,Ie=I5.linspace(0,p-1),je=I5.linspace(0,p-1),Me=new I5.ccsDFS(p);for(typeof d>"u"&&(d=1),xe=0;xe<p;++xe){for(ye(_,m,Z,te,xe,je,Me),de=-1,me=-1,le=te.length-1;le!==-1;--le)he=te[le],!(he<=xe)&&(ge=ve(Z[he]),ge>de&&(me=he,de=ge));for(ve(Z[xe])<d*de&&(le=Ie[xe],de=Ie[me],Ie[xe]=de,je[de]=xe,Ie[me]=le,je[le]=me,de=Z[xe],Z[xe]=Z[me],Z[me]=de),de=S[xe],me=k[xe],be=Z[xe],I[de]=Ie[xe],D[de]=1,++de,le=te.length-1;le!==-1;--le)he=te[le],ge=Z[he],te[le]=0,Z[he]=0,he<=xe?(V[me]=he,$[me]=ge,++me):(I[de]=Ie[he],D[de]=ge/be,++de);S[xe+1]=de,k[xe+1]=me}for(le=I.length-1;le!==-1;--le)I[le]=je[I[le]];return{L:_,U:E,P:Ie,Pinv:je}},I5.ccsDFS0=function(m){this.k=Array(m),this.k1=Array(m),this.j=Array(m)},I5.ccsDFS0.prototype.dfs=function(m,d,p,_,E,S,I){var D=0,k,V=E.length,$=this.k,Z=this.k1,te=this.j,xe,le;if(_[m]===0)for(_[m]=1,te[0]=m,$[0]=xe=d[S[m]],Z[0]=le=d[S[m]+1];;){if(isNaN(xe))throw new Error("Ow!");if(xe>=le){if(E[V]=S[te[D]],D===0)return;++V,--D,xe=$[D],le=Z[D]}else k=p[xe],_[k]===0?(_[k]=1,$[D]=xe,++D,te[D]=k,k=S[k],xe=d[k],Z[D]=le=d[k+1]):++xe}},I5.ccsLPSolve0=function(m,d,p,_,E,S,I,D){var k=m[0],V=m[1],$=m[2];k.length-1;var Z=d[0],te=d[1],xe=d[2],le,he,de,me,ge,be,ye,ve,Ie;for(he=Z[E],de=Z[E+1],_.length=0,le=he;le<de;++le)D.dfs(te[le],k,V,p,_,S,I);for(le=_.length-1;le!==-1;--le)me=_[le],p[I[me]]=0;for(le=he;le!==de;++le)me=te[le],p[me]=xe[le];for(le=_.length-1;le!==-1;--le){for(me=_[le],ve=I[me],ge=k[me],be=k[me+1],ye=ge;ye<be;++ye)if(V[ye]===ve){p[ve]/=$[ye];break}for(Ie=p[ve],ye=ge;ye<be;++ye)p[V[ye]]-=Ie*$[ye];p[ve]=Ie}},I5.ccsLUP0=function(m,d){var p=m[0].length-1,_=[I5.rep([p+1],0),[],[]],E=[I5.rep([p+1],0),[],[]],S=_[0],I=_[1],D=_[2],k=E[0],V=E[1],$=E[2],Z=I5.rep([p],0),te=I5.rep([p],0),xe,le,he,de,me,ge,be,ye=I5.ccsLPSolve0,ve=Math.abs,Ie=I5.linspace(0,p-1),je=I5.linspace(0,p-1),Me=new I5.ccsDFS0(p);for(typeof d>"u"&&(d=1),xe=0;xe<p;++xe){for(ye(_,m,Z,te,xe,je,Ie,Me),de=-1,me=-1,le=te.length-1;le!==-1;--le)he=te[le],!(he<=xe)&&(ge=ve(Z[Ie[he]]),ge>de&&(me=he,de=ge));for(ve(Z[Ie[xe]])<d*de&&(le=Ie[xe],de=Ie[me],Ie[xe]=de,je[de]=xe,Ie[me]=le,je[le]=me),de=S[xe],me=k[xe],be=Z[Ie[xe]],I[de]=Ie[xe],D[de]=1,++de,le=te.length-1;le!==-1;--le)he=te[le],ge=Z[Ie[he]],te[le]=0,Z[Ie[he]]=0,he<=xe?(V[me]=he,$[me]=ge,++me):(I[de]=Ie[he],D[de]=ge/be,++de);S[xe+1]=de,k[xe+1]=me}for(le=I.length-1;le!==-1;--le)I[le]=je[I[le]];return{L:_,U:E,P:Ie,Pinv:je}},I5.ccsLUP=I5.ccsLUP0,I5.ccsDim=function(m){return[I5.sup(m[1])+1,m[0].length-1]},I5.ccsGetBlock=function(m,d,p){var _=I5.ccsDim(m),E=_[0],S=_[1];typeof d>"u"?d=I5.linspace(0,E-1):typeof d=="number"&&(d=[d]),typeof p>"u"?p=I5.linspace(0,S-1):typeof p=="number"&&(p=[p]);var I,D=d.length,k,V=p.length,$,Z,te,xe=I5.rep([S],0),le=[],he=[],de=[xe,le,he],me=m[0],ge=m[1],be=m[2],ye=I5.rep([E],0),ve=0,Ie=I5.rep([E],0);for(k=0;k<V;++k){Z=p[k];var je=me[Z],Me=me[Z+1];for(I=je;I<Me;++I)$=ge[I],Ie[$]=1,ye[$]=be[I];for(I=0;I<D;++I)te=d[I],Ie[te]&&(le[ve]=I,he[ve]=ye[d[I]],++ve);for(I=je;I<Me;++I)$=ge[I],Ie[$]=0;xe[k+1]=ve}return de},I5.ccsDot=function(m,d){var p=m[0],_=m[1],E=m[2],S=d[0],I=d[1],D=d[2],k=I5.ccsDim(m),V=I5.ccsDim(d),$=k[0];k[1];var Z=V[1],te=I5.rep([$],0),xe=I5.rep([$],0),le=Array($),he=I5.rep([Z],0),de=[],me=[],ge=[he,de,me],be,ye,ve,Ie,je,Me,xt,bt,gt,Xt,Ut;for(ve=0;ve!==Z;++ve){for(Ie=S[ve],je=S[ve+1],gt=0,ye=Ie;ye<je;++ye)for(Xt=I[ye],Ut=D[ye],Me=p[Xt],xt=p[Xt+1],be=Me;be<xt;++be)bt=_[be],xe[bt]===0&&(le[gt]=bt,xe[bt]=1,gt=gt+1),te[bt]=te[bt]+E[be]*Ut;for(Ie=he[ve],je=Ie+gt,he[ve+1]=je,ye=gt-1;ye!==-1;--ye)Ut=Ie+ye,be=le[ye],de[Ut]=be,me[Ut]=te[be],xe[be]=0,te[be]=0;he[ve+1]=he[ve]+gt}return ge},I5.ccsLUPSolve=function(m,d){var p=m.L,_=m.U;m.P;var E=d[0],S=!1;typeof E!="object"&&(d=[[0,d.length],I5.linspace(0,d.length-1),d],E=d[0],S=!0);var I=d[1],D=d[2],k=p[0].length-1,V=E.length-1,$=I5.rep([k],0),Z=Array(k),te=I5.rep([k],0),xe=Array(k),le=I5.rep([V+1],0),he=[],de=[],me=I5.ccsTSolve,ge,be,ye,ve,Ie,je,Me=0;for(ge=0;ge<V;++ge){for(Ie=0,ye=E[ge],ve=E[ge+1],be=ye;be<ve;++be)je=m.Pinv[I[be]],xe[Ie]=je,te[je]=D[be],++Ie;for(xe.length=Ie,me(p,te,$,xe,Z),be=xe.length-1;be!==-1;--be)te[xe[be]]=0;if(me(_,$,te,Z,xe),S)return te;for(be=Z.length-1;be!==-1;--be)$[Z[be]]=0;for(be=xe.length-1;be!==-1;--be)je=xe[be],he[Me]=je,de[Me]=te[je],te[je]=0,++Me;le[ge+1]=Me}return[le,he,de]},I5.ccsbinop=function(m,d){return typeof d>"u"&&(d=""),Function("X","Y",`var Xi = X[0], Xj = X[1], Xv = X[2];
var Yi = Y[0], Yj = Y[1], Yv = Y[2];
var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;
var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];
var x = numeric.rep([m],0),y = numeric.rep([m],0);
var xk,yk,zk;
var i,j,j0,j1,k,p=0;
`+d+`for(i=0;i<n;++i) {
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Xj[j];
    x[k] = 1;
    Zj[p] = k;
    ++p;
  }
  j0 = Yi[i]; j1 = Yi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Yj[j];
    y[k] = Yv[j];
    if(x[k] === 0) {
      Zj[p] = k;
      ++p;
    }
  }
  Zi[i+1] = p;
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];
  j0 = Zi[i]; j1 = Zi[i+1];
  for(j=j0;j!==j1;++j) {
    k = Zj[j];
    xk = x[k];
    yk = y[k];
`+m+`
    Zv[j] = zk;
  }
  j0 = Xi[i]; j1 = Xi[i+1];
  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;
  j0 = Yi[i]; j1 = Yi[i+1];
  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;
}
return [Zi,Zj,Zv];`)},function(){var IG,Is,Iz,IC;for(IG in I5.ops2)isFinite(eval("1"+I5.ops2[IG]+"0"))?Is="[Y[0],Y[1],numeric."+IG+"(X,Y[2])]":Is="NaN",isFinite(eval("0"+I5.ops2[IG]+"1"))?Iz="[X[0],X[1],numeric."+IG+"(X[2],Y)]":Iz="NaN",isFinite(eval("1"+I5.ops2[IG]+"0"))&&isFinite(eval("0"+I5.ops2[IG]+"1"))?IC="numeric.ccs"+IG+"MM(X,Y)":IC="NaN",I5["ccs"+IG+"MM"]=I5.ccsbinop("zk = xk "+I5.ops2[IG]+"yk;"),I5["ccs"+IG]=Function("X","Y",'if(typeof X === "number") return '+Is+`;
if(typeof Y === "number") return `+Iz+`;
return `+IC+`;
`)}(),I5.ccsScatter=function m(d){var p=d[0],_=d[1],E=d[2],S=I5.sup(_)+1,I=p.length,D=I5.rep([S],0),k=Array(I),V=Array(I),$=I5.rep([S],0),Z;for(Z=0;Z<I;++Z)$[_[Z]]++;for(Z=0;Z<S;++Z)D[Z+1]=D[Z]+$[Z];var te=D.slice(0),xe,le;for(Z=0;Z<I;++Z)le=_[Z],xe=te[le],k[xe]=p[Z],V[xe]=E[Z],te[le]=te[le]+1;return[D,k,V]},I5.ccsGather=function m(d){var p=d[0],_=d[1],E=d[2],S=p.length-1,I=_.length,D=Array(I),k=Array(I),V=Array(I),$,Z,te,xe,le;for(le=0,$=0;$<S;++$)for(te=p[$],xe=p[$+1],Z=te;Z!==xe;++Z)k[le]=$,D[le]=_[Z],V[le]=E[Z],++le;return[D,k,V]},I5.sdim=function m(d,p,_){if(typeof p>"u"&&(p=[]),typeof d!="object")return p;typeof _>"u"&&(_=0),_ in p||(p[_]=0),d.length>p[_]&&(p[_]=d.length);var E;for(E in d)d.hasOwnProperty(E)&&m(d[E],p,_+1);return p},I5.sclone=function m(d,p,_){typeof p>"u"&&(p=0),typeof _>"u"&&(_=I5.sdim(d).length);var E,S=Array(d.length);if(p===_-1){for(E in d)d.hasOwnProperty(E)&&(S[E]=d[E]);return S}for(E in d)d.hasOwnProperty(E)&&(S[E]=m(d[E],p+1,_));return S},I5.sdiag=function m(d){var p=d.length,_,E=Array(p),S;for(_=p-1;_>=1;_-=2)S=_-1,E[_]=[],E[_][_]=d[_],E[S]=[],E[S][S]=d[S];return _===0&&(E[0]=[],E[0][0]=d[_]),E},I5.sidentity=function m(d){return I5.sdiag(I5.rep([d],1))},I5.stranspose=function m(d){var p=[];d.length;var _,E,S;for(_ in d)if(d.hasOwnProperty(_)){S=d[_];for(E in S)S.hasOwnProperty(E)&&(typeof p[E]!="object"&&(p[E]=[]),p[E][_]=S[E])}return p},I5.sLUP=function m(d,p){throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.")},I5.sdotMM=function m(d,p){var _=d.length;p.length;var E=I5.stranspose(p),S=E.length,I,D,k,V,$,Z,te=Array(_),xe;for(k=_-1;k>=0;k--){for(xe=[],I=d[k],$=S-1;$>=0;$--){Z=0,D=E[$];for(V in I)I.hasOwnProperty(V)&&V in D&&(Z+=I[V]*D[V]);Z&&(xe[$]=Z)}te[k]=xe}return te},I5.sdotMV=function m(d,p){var _=d.length,E,S,I,D=Array(_),k;for(S=_-1;S>=0;S--){E=d[S],k=0;for(I in E)E.hasOwnProperty(I)&&p[I]&&(k+=E[I]*p[I]);k&&(D[S]=k)}return D},I5.sdotVM=function m(d,p){var _,E,S,I,D=[];for(_ in d)if(d.hasOwnProperty(_)){S=p[_],I=d[_];for(E in S)S.hasOwnProperty(E)&&(D[E]||(D[E]=0),D[E]+=I*S[E])}return D},I5.sdotVV=function m(d,p){var _,E=0;for(_ in d)d[_]&&p[_]&&(E+=d[_]*p[_]);return E},I5.sdot=function m(d,p){var _=I5.sdim(d).length,E=I5.sdim(p).length,S=_*1e3+E;switch(S){case 0:return d*p;case 1001:return I5.sdotVV(d,p);case 2001:return I5.sdotMV(d,p);case 1002:return I5.sdotVM(d,p);case 2002:return I5.sdotMM(d,p);default:throw new Error("numeric.sdot not implemented for tensors of order "+_+" and "+E)}},I5.sscatter=function m(d){var p=d[0].length,_,E,S,I=d.length,D=[],k;for(E=p-1;E>=0;--E)if(d[I-1][E]){for(k=D,S=0;S<I-2;S++)_=d[S][E],k[_]||(k[_]=[]),k=k[_];k[d[S][E]]=d[S+1][E]}return D},I5.sgather=function m(d,p,_){typeof p>"u"&&(p=[]),typeof _>"u"&&(_=[]);var E,S,I;E=_.length;for(S in d)if(d.hasOwnProperty(S))if(_[E]=parseInt(S),I=d[S],typeof I=="number"){if(I){if(p.length===0)for(S=E+1;S>=0;--S)p[S]=[];for(S=E;S>=0;--S)p[S].push(_[S]);p[E+1].push(I)}}else m(I,p,_);return _.length>E&&_.pop(),p},I5.cLU=function m(d){var p=d[0],_=d[1],E=d[2],xt=p.length,S=0,I,D,k,V,$,Z;for(I=0;I<xt;I++)p[I]>S&&(S=p[I]);S++;var te=Array(S),xe=Array(S),le=I5.rep([S],1/0),he=I5.rep([S],-1/0),be,ye,de;for(k=0;k<xt;k++)I=p[k],D=_[k],D<le[I]&&(le[I]=D),D>he[I]&&(he[I]=D);for(I=0;I<S-1;I++)he[I]>he[I+1]&&(he[I+1]=he[I]);for(I=S-1;I>=1;I--)le[I]<le[I-1]&&(le[I-1]=le[I]);var me=0,ge=0;for(I=0;I<S;I++)xe[I]=I5.rep([he[I]-le[I]+1],0),te[I]=I5.rep([I-le[I]],0),me+=I-le[I]+1,ge+=he[I]-I+1;for(k=0;k<xt;k++)I=p[k],xe[I][_[k]-le[I]]=E[k];for(I=0;I<S-1;I++)for(V=I-le[I],be=xe[I],D=I+1;le[D]<=I&&D<S;D++)if($=I-le[D],Z=he[I]-I,ye=xe[D],de=ye[$]/be[V],de){for(k=1;k<=Z;k++)ye[k+$]-=de*be[k+V];te[D][I-le[D]]=de}var be=[],ye=[],ve=[],Ie=[],je=[],Me=[],xt,bt,gt;for(xt=0,bt=0,I=0;I<S;I++){for(V=le[I],$=he[I],gt=xe[I],D=I;D<=$;D++)gt[D-V]&&(be[xt]=I,ye[xt]=D,ve[xt]=gt[D-V],xt++);for(gt=te[I],D=V;D<I;D++)gt[D-V]&&(Ie[bt]=I,je[bt]=D,Me[bt]=gt[D-V],bt++);Ie[bt]=I,je[bt]=I,Me[bt]=1,bt++}return{U:[be,ye,ve],L:[Ie,je,Me]}},I5.cLUsolve=function m(d,p){var _=d.L,E=d.U,S=I5.clone(p),I=_[0],D=_[1],k=_[2],V=E[0],$=E[1],Z=E[2],te=V.length;I.length;var xe=S.length,le,he;for(he=0,le=0;le<xe;le++){for(;D[he]<le;)S[le]-=k[he]*S[D[he]],he++;he++}for(he=te-1,le=xe-1;le>=0;le--){for(;$[he]>le;)S[le]-=Z[he]*S[$[he]],he--;S[le]/=Z[he],he--}return S},I5.cgrid=function m(d,p){typeof d=="number"&&(d=[d,d]);var _=I5.rep(d,-1),E,S,I;if(typeof p!="function")switch(p){case"L":p=function(D,k){return D>=d[0]/2||k<d[1]/2};break;default:p=function(D,k){return!0};break}for(I=0,E=1;E<d[0]-1;E++)for(S=1;S<d[1]-1;S++)p(E,S)&&(_[E][S]=I,I++);return _},I5.cdelsq=function m(d){var p=[[-1,0],[0,-1],[0,1],[1,0]],_=I5.dim(d),E=_[0],S=_[1],I,D,k,V,$,Z=[],te=[],xe=[];for(I=1;I<E-1;I++)for(D=1;D<S-1;D++)if(!(d[I][D]<0)){for(k=0;k<4;k++)V=I+p[k][0],$=D+p[k][1],!(d[V][$]<0)&&(Z.push(d[I][D]),te.push(d[V][$]),xe.push(-1));Z.push(d[I][D]),te.push(d[I][D]),xe.push(4)}return[Z,te,xe]},I5.cdotMV=function m(d,p){var _,E=d[0],S=d[1],I=d[2],D,k=E.length,V;for(V=0,D=0;D<k;D++)E[D]>V&&(V=E[D]);for(V++,_=I5.rep([V],0),D=0;D<k;D++)_[E[D]]+=I[D]*p[S[D]];return _},I5.Spline=function m(d,p,_,E,S){this.x=d,this.yl=p,this.yr=_,this.kl=E,this.kr=S},I5.Spline.prototype._at=function m(k,p){var _=this.x,E=this.yl,S=this.yr,I=this.kl,D=this.kr,k,V,$,Z,te=I5.add,xe=I5.sub,le=I5.mul;V=xe(le(I[p],_[p+1]-_[p]),xe(S[p+1],E[p])),$=te(le(D[p+1],_[p]-_[p+1]),xe(S[p+1],E[p])),Z=(k-_[p])/(_[p+1]-_[p]);var he=Z*(1-Z);return te(te(te(le(1-Z,E[p]),le(Z,S[p+1])),le(V,he*(1-Z))),le($,he*Z))},I5.Spline.prototype.at=function m(d){if(typeof d=="number"){var p=this.x,D=p.length,_,E,S,I=Math.floor;for(_=0,E=D-1;E-_>1;)S=I((_+E)/2),p[S]<=d?_=S:E=S;return this._at(d,_)}var D=d.length,k,V=Array(D);for(k=D-1;k!==-1;--k)V[k]=this.at(d[k]);return V},I5.Spline.prototype.diff=function m(){var d=this.x,p=this.yl,_=this.yr,E=this.kl,S=this.kr,I=p.length,D,k,V,$=E,Z=S,te=Array(I),xe=Array(I),le=I5.add,he=I5.mul,de=I5.div,me=I5.sub;for(D=I-1;D!==-1;--D)k=d[D+1]-d[D],V=me(_[D+1],p[D]),te[D]=de(le(he(V,6),he(E[D],-4*k),he(S[D+1],-2*k)),k*k),xe[D+1]=de(le(he(V,-6),he(E[D],2*k),he(S[D+1],4*k)),k*k);return new I5.Spline(d,$,Z,te,xe)},I5.Spline.prototype.roots=function m(){function d(vi){return vi*vi}var de=[],p=this.x,_=this.yl,E=this.yr,S=this.kl,I=this.kr;typeof _[0]=="number"&&(_=[_],E=[E],S=[S],I=[I]);var D=_.length,k=p.length-1,V,$,Z,te,xe,le,he,de=Array(D),me,ge,be,ye,ve,Ie,je,Me,xt,bt,gt,Xt,Ut,Ht,mi,gi,Ui=Math.sqrt;for(V=0;V!==D;++V){for(te=_[V],xe=E[V],le=S[V],he=I[V],me=[],$=0;$!==k;$++){for($>0&&xe[$]*te[$]<0&&me.push(p[$]),xt=p[$+1]-p[$],p[$],ye=te[$],ve=xe[$+1],ge=le[$]/xt,be=he[$+1]/xt,Me=d(ge-be+3*(ye-ve))+12*be*ye,Ie=be+3*ye+2*ge-3*ve,je=3*(be+ge+2*(ye-ve)),Me<=0?(gt=Ie/je,gt>p[$]&&gt<p[$+1]?bt=[p[$],gt,p[$+1]]:bt=[p[$],p[$+1]]):(gt=(Ie-Ui(Me))/je,Xt=(Ie+Ui(Me))/je,bt=[p[$]],gt>p[$]&&gt<p[$+1]&&bt.push(gt),Xt>p[$]&&Xt<p[$+1]&&bt.push(Xt),bt.push(p[$+1])),Ht=bt[0],gt=this._at(Ht,$),Z=0;Z<bt.length-1;Z++){if(mi=bt[Z+1],Xt=this._at(mi,$),gt===0){me.push(Ht),Ht=mi,gt=Xt;continue}if(Xt===0||gt*Xt>0){Ht=mi,gt=Xt;continue}for(var yi=0;gi=(gt*mi-Xt*Ht)/(gt-Xt),!(gi<=Ht||gi>=mi);)if(Ut=this._at(gi,$),Ut*Xt>0)mi=gi,Xt=Ut,yi===-1&&(gt*=.5),yi=-1;else if(Ut*gt>0)Ht=gi,gt=Ut,yi===1&&(Xt*=.5),yi=1;else break;me.push(gi),Ht=bt[Z+1],gt=this._at(Ht,$)}Xt===0&&me.push(mi)}de[V]=me}return typeof this.yl[0]=="number"?de[0]:de},I5.spline=function m(d,p,_,E){var S=d.length,I=[],D=[],k=[],V,$=I5.sub,Z=I5.mul,te=I5.add;for(V=S-2;V>=0;V--)D[V]=d[V+1]-d[V],k[V]=$(p[V+1],p[V]);(typeof _=="string"||typeof E=="string")&&(_=E="periodic");var xe=[[],[],[]];switch(typeof _){case"undefined":I[0]=Z(3/(D[0]*D[0]),k[0]),xe[0].push(0,0),xe[1].push(0,1),xe[2].push(2/D[0],1/D[0]);break;case"string":I[0]=te(Z(3/(D[S-2]*D[S-2]),k[S-2]),Z(3/(D[0]*D[0]),k[0])),xe[0].push(0,0,0),xe[1].push(S-2,0,1),xe[2].push(1/D[S-2],2/D[S-2]+2/D[0],1/D[0]);break;default:I[0]=_,xe[0].push(0),xe[1].push(0),xe[2].push(1);break}for(V=1;V<S-1;V++)I[V]=te(Z(3/(D[V-1]*D[V-1]),k[V-1]),Z(3/(D[V]*D[V]),k[V])),xe[0].push(V,V,V),xe[1].push(V-1,V,V+1),xe[2].push(1/D[V-1],2/D[V-1]+2/D[V],1/D[V]);switch(typeof E){case"undefined":I[S-1]=Z(3/(D[S-2]*D[S-2]),k[S-2]),xe[0].push(S-1,S-1),xe[1].push(S-2,S-1),xe[2].push(1/D[S-2],2/D[S-2]);break;case"string":xe[1][xe[1].length-1]=0;break;default:I[S-1]=E,xe[0].push(S-1),xe[1].push(S-1),xe[2].push(1);break}typeof I[0]!="number"?I=I5.transpose(I):I=[I];var le=Array(I.length);if(typeof _=="string")for(V=le.length-1;V!==-1;--V)le[V]=I5.ccsLUPSolve(I5.ccsLUP(I5.ccsScatter(xe)),I[V]),le[V][S-1]=le[V][0];else for(V=le.length-1;V!==-1;--V)le[V]=I5.cLUsolve(I5.cLU(xe),I[V]);return typeof p[0]=="number"?le=le[0]:le=I5.transpose(le),new I5.Spline(d,p,p,le,le)},I5.fftpow2=function m(d,p){var _=d.length;if(_!==1){var E=Math.cos,S=Math.sin,I,D,k=Array(_/2),V=Array(_/2),$=Array(_/2),Z=Array(_/2);for(D=_/2,I=_-1;I!==-1;--I)--D,$[D]=d[I],Z[D]=p[I],--I,k[D]=d[I],V[D]=p[I];m(k,V),m($,Z),D=_/2;var te,xe=-6.283185307179586/_,le,he;for(I=_-1;I!==-1;--I)--D,D===-1&&(D=_/2-1),te=xe*I,le=E(te),he=S(te),d[I]=k[D]+le*$[D]-he*Z[D],p[I]=V[D]+le*Z[D]+he*$[D]}},I5._ifftpow2=function m(d,p){var _=d.length;if(_!==1){var E=Math.cos,S=Math.sin,I,D,k=Array(_/2),V=Array(_/2),$=Array(_/2),Z=Array(_/2);for(D=_/2,I=_-1;I!==-1;--I)--D,$[D]=d[I],Z[D]=p[I],--I,k[D]=d[I],V[D]=p[I];m(k,V),m($,Z),D=_/2;var te,xe=6.283185307179586/_,le,he;for(I=_-1;I!==-1;--I)--D,D===-1&&(D=_/2-1),te=xe*I,le=E(te),he=S(te),d[I]=k[D]+le*$[D]-he*Z[D],p[I]=V[D]+le*Z[D]+he*$[D]}},I5.ifftpow2=function m(d,p){I5._ifftpow2(d,p),I5.diveq(d,d.length),I5.diveq(p,p.length)},I5.convpow2=function m(d,p,_,E){I5.fftpow2(d,p),I5.fftpow2(_,E);var S,I=d.length,D,k,V,$;for(S=I-1;S!==-1;--S)D=d[S],V=p[S],k=_[S],$=E[S],d[S]=D*k-V*$,p[S]=D*$+V*k;I5.ifftpow2(d,p)},I5.T.prototype.fft=function m(){var d=this.x,p=this.y,_=d.length,E=Math.log,S=E(2),I=Math.ceil(E(2*_-1)/S),D=Math.pow(2,I),k=I5.rep([D],0),V=I5.rep([D],0),$=Math.cos,Z=Math.sin,te,xe=-3.141592653589793/_,le,he=I5.rep([D],0),de=I5.rep([D],0);for(te=0;te<_;te++)he[te]=d[te];if(typeof p<"u")for(te=0;te<_;te++)de[te]=p[te];for(k[0]=1,te=1;te<=D/2;te++)le=xe*te*te,k[te]=$(le),V[te]=Z(le),k[D-te]=$(le),V[D-te]=Z(le);var me=new I5.T(he,de),ge=new I5.T(k,V);return me=me.mul(ge),I5.convpow2(me.x,me.y,I5.clone(ge.x),I5.neg(ge.y)),me=me.mul(ge),me.x.length=_,me.y.length=_,me},I5.T.prototype.ifft=function m(){var d=this.x,p=this.y,_=d.length,E=Math.log,S=E(2),I=Math.ceil(E(2*_-1)/S),D=Math.pow(2,I),k=I5.rep([D],0),V=I5.rep([D],0),$=Math.cos,Z=Math.sin,te,xe=3.141592653589793/_,le,he=I5.rep([D],0),de=I5.rep([D],0);for(te=0;te<_;te++)he[te]=d[te];if(typeof p<"u")for(te=0;te<_;te++)de[te]=p[te];for(k[0]=1,te=1;te<=D/2;te++)le=xe*te*te,k[te]=$(le),V[te]=Z(le),k[D-te]=$(le),V[D-te]=Z(le);var me=new I5.T(he,de),ge=new I5.T(k,V);return me=me.mul(ge),I5.convpow2(me.x,me.y,I5.clone(ge.x),I5.neg(ge.y)),me=me.mul(ge),me.x.length=_,me.y.length=_,me.div(_)},I5.gradient=function m(d,p){var _=p.length,E=d(p);if(isNaN(E))throw new Error("gradient: f(x) is a NaN!");var Z=Math.max,S,I=I5.clone(p),D,k,V=Array(_);I5.div,I5.sub;var $,Z=Math.max,te=.001,xe=Math.abs,le=Math.min,he,de,me,ge=0,be,ye,ve;for(S=0;S<_;S++)for(var Ie=Z(1e-6*E,1e-8);;){if(++ge,ge>20)throw new Error("Numerical gradient fails");if(I[S]=p[S]+Ie,D=d(I),I[S]=p[S]-Ie,k=d(I),I[S]=p[S],isNaN(D)||isNaN(k)){Ie/=16;continue}if(V[S]=(D-k)/(2*Ie),he=p[S]-Ie,de=p[S],me=p[S]+Ie,be=(D-E)/Ie,ye=(E-k)/Ie,ve=Z(xe(V[S]),xe(E),xe(D),xe(k),xe(he),xe(de),xe(me),1e-8),$=le(Z(xe(be-V[S]),xe(ye-V[S]),xe(be-ye))/ve,Ie/ve),$>te)Ie/=16;else break}return V},I5.uncmin=function m(d,p,_,E,S,I,D){var k=I5.gradient;typeof D>"u"&&(D={}),typeof _>"u"&&(_=1e-8),typeof E>"u"&&(E=function(us){return k(d,us)}),typeof S>"u"&&(S=1e3),p=I5.clone(p);var V=p.length,$=d(p),Z,te;if(isNaN($))throw new Error("uncmin: f(x0) is a NaN!");var xe=Math.max,le=I5.norm2;_=xe(_,I5.epsilon);var he,de,me,ge=D.Hinv||I5.identity(V),be=I5.dot;I5.inv;var ye=I5.sub,ve=I5.add,Ie=I5.tensor,je=I5.div,Me=I5.mul,xt=I5.all,bt=I5.isFinite,gt=I5.neg,Xt=0,Ut,Ht,mi,gi,Ui,yi,vi,ts="";for(de=E(p);Xt<S;){if(typeof I=="function"&&I(Xt,p,$,de,ge)){ts="Callback returned true";break}if(!xt(bt(de))){ts="Gradient has Infinity or NaN";break}if(he=gt(be(ge,de)),!xt(bt(he))){ts="Search direction has Infinity or NaN";break}if(vi=le(he),vi<_){ts="Newton step smaller than tol";break}for(yi=1,te=be(de,he),Ht=p;Xt<S&&!(yi*vi<_);){if(Ut=Me(he,yi),Ht=ve(p,Ut),Z=d(Ht),Z-$>=.1*yi*te||isNaN(Z)){yi*=.5,++Xt;continue}break}if(yi*vi<_){ts="Line search step size smaller than tol";break}if(Xt===S){ts="maxit reached during line search";break}me=E(Ht),mi=ye(me,de),Ui=be(mi,Ut),gi=be(ge,mi),ge=ye(ve(ge,Me((Ui+be(mi,gi))/(Ui*Ui),Ie(Ut,Ut))),je(ve(Ie(gi,Ut),Ie(Ut,gi)),Ui)),p=Ht,$=Z,de=me,++Xt}return{solution:p,f:$,gradient:de,invHessian:ge,iterations:Xt,message:ts}},I5.Dopri=function m(d,p,_,E,S,I,D){this.x=d,this.y=p,this.f=_,this.ymid=E,this.iterations=S,this.events=D,this.message=I},I5.Dopri.prototype._at=function m(he,p){function _(Me){return Me*Me}var E=this,S=E.x,I=E.y,D=E.f,k=E.ymid;S.length;var V,$,Z,te,xe,le,he,de,me=.5,ge=I5.add,be=I5.mul,ye=I5.sub,ve,Ie,je;return V=S[p],$=S[p+1],te=I[p],xe=I[p+1],de=$-V,Z=V+me*de,le=k[p],ve=ye(D[p],be(te,1/(V-Z)+2/(V-$))),Ie=ye(D[p+1],be(xe,1/($-Z)+2/($-V))),je=[_(he-$)*(he-Z)/_(V-$)/(V-Z),_(he-V)*_(he-$)/_(V-Z)/_($-Z),_(he-V)*(he-Z)/_($-V)/($-Z),(he-V)*_(he-$)*(he-Z)/_(V-$)/(V-Z),(he-$)*_(he-V)*(he-Z)/_(V-$)/($-Z)],ge(ge(ge(ge(be(te,je[0]),be(le,je[1])),be(xe,je[2])),be(ve,je[3])),be(Ie,je[4]))},I5.Dopri.prototype.at=function m(d){var p,_,E,S=Math.floor;if(typeof d!="number"){var I=d.length,D=Array(I);for(p=I-1;p!==-1;--p)D[p]=this.at(d[p]);return D}var k=this.x;for(p=0,_=k.length-1;_-p>1;)E=S(.5*(p+_)),k[E]<=d?p=E:_=E;return this._at(d,p)},I5.dopri=function m(d,p,_,E,S,I,D){typeof S>"u"&&(S=1e-6),typeof I>"u"&&(I=1e3);var k=[d],V=[_],$=[E(d,_)],Z,te,xe,le,he,de,me=[],ge=1/5,be=[3/40,9/40],ye=[44/45,-56/15,32/9],ve=[19372/6561,-25360/2187,64448/6561,-212/729],Ie=[9017/3168,-355/33,46732/5247,49/176,-5103/18656],je=[35/384,0,500/1113,125/192,-2187/6784,11/84],Me=[.5*6025192743/30085553152,0,.5*51252292925/65400821598,.5*-2691868925/45128329728,.5*187940372067/1594534317056,.5*-1776094331/19743644256,.5*11237099/235043384],xt=[1/5,3/10,4/5,8/9,1,1],bt=[-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40],gt=0,Xt,Ut,Ht=(p-d)/10,mi=0,gi=I5.add,Ui=I5.mul,yi,vi,ts=Math.min,us=Math.abs,bi=I5.norminf,Ri=Math.pow,Nt=I5.any,$t=I5.lt,li=I5.and;I5.sub;var Ei,xs,Vs,ms=new I5.Dopri(k,V,$,me,-1,"");for(typeof D=="function"&&(Ei=D(d,_));d<p&&mi<I;){if(++mi,d+Ht>p&&(Ht=p-d),Z=E(d+xt[0]*Ht,gi(_,Ui(ge*Ht,$[gt]))),te=E(d+xt[1]*Ht,gi(gi(_,Ui(be[0]*Ht,$[gt])),Ui(be[1]*Ht,Z))),xe=E(d+xt[2]*Ht,gi(gi(gi(_,Ui(ye[0]*Ht,$[gt])),Ui(ye[1]*Ht,Z)),Ui(ye[2]*Ht,te))),le=E(d+xt[3]*Ht,gi(gi(gi(gi(_,Ui(ve[0]*Ht,$[gt])),Ui(ve[1]*Ht,Z)),Ui(ve[2]*Ht,te)),Ui(ve[3]*Ht,xe))),he=E(d+xt[4]*Ht,gi(gi(gi(gi(gi(_,Ui(Ie[0]*Ht,$[gt])),Ui(Ie[1]*Ht,Z)),Ui(Ie[2]*Ht,te)),Ui(Ie[3]*Ht,xe)),Ui(Ie[4]*Ht,le))),yi=gi(gi(gi(gi(gi(_,Ui($[gt],Ht*je[0])),Ui(te,Ht*je[2])),Ui(xe,Ht*je[3])),Ui(le,Ht*je[4])),Ui(he,Ht*je[5])),de=E(d+Ht,yi),Xt=gi(gi(gi(gi(gi(Ui($[gt],Ht*bt[0]),Ui(te,Ht*bt[2])),Ui(xe,Ht*bt[3])),Ui(le,Ht*bt[4])),Ui(he,Ht*bt[5])),Ui(de,Ht*bt[6])),typeof Xt=="number"?vi=us(Xt):vi=bi(Xt),vi>S){if(Ht=.2*Ht*Ri(S/vi,.25),d+Ht===d){ms.msg="Step size became too small";break}continue}if(me[gt]=gi(gi(gi(gi(gi(gi(_,Ui($[gt],Ht*Me[0])),Ui(te,Ht*Me[2])),Ui(xe,Ht*Me[3])),Ui(le,Ht*Me[4])),Ui(he,Ht*Me[5])),Ui(de,Ht*Me[6])),++gt,k[gt]=d+Ht,V[gt]=yi,$[gt]=de,typeof D=="function"){var bs,Us=d,Mr=d+.5*Ht,ar;if(xs=D(Mr,me[gt-1]),Vs=li($t(Ei,0),$t(0,xs)),Nt(Vs)||(Us=Mr,Mr=d+Ht,Ei=xs,xs=D(Mr,yi),Vs=li($t(Ei,0),$t(0,xs))),Nt(Vs)){for(var yr,jr,xn=0,dn=1,Rn=1;;){if(typeof Ei=="number")ar=(Rn*xs*Us-dn*Ei*Mr)/(Rn*xs-dn*Ei);else for(ar=Mr,Ut=Ei.length-1;Ut!==-1;--Ut)Ei[Ut]<0&&xs[Ut]>0&&(ar=ts(ar,(Rn*xs[Ut]*Us-dn*Ei[Ut]*Mr)/(Rn*xs[Ut]-dn*Ei[Ut])));if(ar<=Us||ar>=Mr)break;bs=ms._at(ar,gt-1),jr=D(ar,bs),yr=li($t(Ei,0),$t(0,jr)),Nt(yr)?(Mr=ar,xs=jr,Vs=yr,Rn=1,xn===-1?dn*=.5:dn=1,xn=-1):(Us=ar,Ei=jr,dn=1,xn===1?Rn*=.5:Rn=1,xn=1)}return yi=ms._at(.5*(d+ar),gt-1),ms.f[gt]=E(ar,bs),ms.x[gt]=ar,ms.y[gt]=bs,ms.ymid[gt-1]=yi,ms.events=Vs,ms.iterations=mi,ms}}d+=Ht,_=yi,Ei=xs,Ht=ts(.8*Ht*Ri(S/vi,.25),4*Ht)}return ms.iterations=mi,ms},I5.LU=function(m,d){d=d||!1;var p=Math.abs,_,E,S,I,D,k,V,$,Z,te=m.length,xe=te-1,le=new Array(te);for(d||(m=I5.clone(m)),S=0;S<te;++S){for(V=S,k=m[S],Z=p(k[S]),E=S+1;E<te;++E)I=p(m[E][S]),Z<I&&(Z=I,V=E);for(le[S]=V,V!=S&&(m[S]=m[V],m[V]=k,k=m[S]),D=k[S],_=S+1;_<te;++_)m[_][S]/=D;for(_=S+1;_<te;++_){for($=m[_],E=S+1;E<xe;++E)$[E]-=$[S]*k[E],++E,$[E]-=$[S]*k[E];E===xe&&($[E]-=$[S]*k[E])}}return{LU:m,P:le}},I5.LUsolve=function m(d,p){var _,E,S=d.LU,I=S.length,D=I5.clone(p),k=d.P,V,$,Z;for(_=I-1;_!==-1;--_)D[_]=p[_];for(_=0;_<I;++_)for(V=k[_],k[_]!==_&&(Z=D[_],D[_]=D[V],D[V]=Z),$=S[_],E=0;E<_;++E)D[_]-=D[E]*$[E];for(_=I-1;_>=0;--_){for($=S[_],E=_+1;E<I;++E)D[_]-=D[E]*$[E];D[_]/=$[_]}return D},I5.solve=function m(d,p,_){return I5.LUsolve(I5.LU(d,_),p)},I5.echelonize=function m(d){var p=I5.dim(d),_=p[0],E=p[1],S=I5.identity(_),I=Array(_),D,k,V,$,Z,te,xe,le,he=Math.abs,de=I5.diveq;for(d=I5.clone(d),D=0;D<_;++D){for(V=0,Z=d[D],te=S[D],k=1;k<E;++k)he(Z[V])<he(Z[k])&&(V=k);for(I[D]=V,de(te,Z[V]),de(Z,Z[V]),k=0;k<_;++k)if(k!==D){for(xe=d[k],le=xe[V],$=E-1;$!==-1;--$)xe[$]-=Z[$]*le;for(xe=S[k],$=_-1;$!==-1;--$)xe[$]-=te[$]*le}}return{I:S,A:d,P:I}},I5.__solveLP=function m(d,p,_,E,S,I,D){var k=I5.sum;I5.log;var V=I5.mul,$=I5.sub,Z=I5.dot,te=I5.div,xe=I5.add,le=d.length,he=_.length,de,me=!1,ge=0,be=1;I5.transpose(p),I5.svd;var ye=I5.transpose;I5.leq;var ve=Math.sqrt,Ie=Math.abs;I5.muleq,I5.norminf,I5.any;var je=Math.min,Me=I5.all,xt=I5.gt,bt=Array(le),gt=Array(he);I5.rep([he],1);var Xt,Ut=I5.solve,Ht=$(_,Z(p,I)),mi,gi=Z(d,d),Ui;for(mi=ge;mi<S;++mi){var yi,vi;for(yi=he-1;yi!==-1;--yi)gt[yi]=te(p[yi],Ht[yi]);var ts=ye(gt);for(yi=le-1;yi!==-1;--yi)bt[yi]=k(ts[yi]);be=.25*Ie(gi/Z(d,bt));var us=100*ve(gi/Z(bt,bt));for((!isFinite(be)||be>us)&&(be=us),Ui=xe(d,V(be,bt)),Xt=Z(ts,gt),yi=le-1;yi!==-1;--yi)Xt[yi][yi]+=1;vi=Ut(Xt,te(Ui,be),!0);var bi=te(Ht,Z(p,vi)),Ri=1;for(yi=he-1;yi!==-1;--yi)bi[yi]<0&&(Ri=je(Ri,-.999*bi[yi]));if(de=$(I,V(vi,Ri)),Ht=$(_,Z(p,de)),!Me(xt(Ht,0)))return{solution:I,message:"",iterations:mi};if(I=de,be<E)return{solution:de,message:"",iterations:mi};if(D){var Nt=Z(d,Ui),$t=Z(p,Ui);for(me=!0,yi=he-1;yi!==-1;--yi)if(Nt*$t[yi]<0){me=!1;break}}else I[le-1]>=0?me=!1:me=!0;if(me)return{solution:de,message:"Unbounded",iterations:mi}}return{solution:I,message:"maximum iteration count exceeded",iterations:mi}},I5._solveLP=function m(d,p,_,E,S){var I=d.length,D=_.length,le;I5.sum,I5.log,I5.mul;var k=I5.sub,V=I5.dot;I5.div,I5.add;var $=I5.rep([I],0).concat([1]),Z=I5.rep([D,1],-1),te=I5.blockMatrix([[p,Z]]),xe=_,le=I5.rep([I],0).concat(Math.max(0,I5.sup(I5.neg(_)))+1),he=I5.__solveLP($,te,xe,E,S,le,!1),de=I5.clone(he.solution);de.length=I;var me=I5.inf(k(_,V(p,de)));if(me<0)return{solution:NaN,message:"Infeasible",iterations:he.iterations};var ge=I5.__solveLP(d,p,_,E,S-he.iterations,de,!0);return ge.iterations+=he.iterations,ge},I5.solveLP=function m(d,p,_,E,S,I,D){if(typeof D>"u"&&(D=1e3),typeof I>"u"&&(I=I5.epsilon),typeof E>"u")return I5._solveLP(d,p,_,I,D);var k=E.length,V=E[0].length,$=p.length,Z=I5.echelonize(E),te=I5.rep([V],0),xe=Z.P,le=[],he;for(he=xe.length-1;he!==-1;--he)te[xe[he]]=1;for(he=V-1;he!==-1;--he)te[he]===0&&le.push(he);var de=I5.getRange,me=I5.linspace(0,k-1),ge=I5.linspace(0,$-1),be=de(E,me,le),ye=de(p,ge,xe),ve=de(p,ge,le),Ie=I5.dot,je=I5.sub,Me=Ie(ye,Z.I),xt=je(ve,Ie(Me,be)),bt=je(_,Ie(Me,S)),gt=Array(xe.length),Xt=Array(le.length);for(he=xe.length-1;he!==-1;--he)gt[he]=d[xe[he]];for(he=le.length-1;he!==-1;--he)Xt[he]=d[le[he]];var Ut=je(Xt,Ie(gt,Ie(Z.I,be))),Ht=I5._solveLP(Ut,xt,bt,I,D),mi=Ht.solution;if(mi!==mi)return Ht;var gi=Ie(Z.I,je(S,Ie(be,mi))),Ui=Array(d.length);for(he=xe.length-1;he!==-1;--he)Ui[xe[he]]=gi[he];for(he=le.length-1;he!==-1;--he)Ui[le[he]]=mi[he];return{solution:Ui,message:Ht.message,iterations:Ht.iterations}},I5.MPStoLP=function m(d){d instanceof String&&d.split(`
`);var p=0,_=["Initial state","NAME","ROWS","COLUMNS","RHS","BOUNDS","ENDATA"],E=d.length,S,I,D,k=0,V={},$=[],Z=0,te={},xe=0,le,he=[],de=[],me=[];function ge(je){throw new Error("MPStoLP: "+je+`
Line `+S+": "+d[S]+`
Current state: `+_[p]+`
`)}for(S=0;S<E;++S){D=d[S];var be=D.match(/\S*/g),ye=[];for(I=0;I<be.length;++I)be[I]!==""&&ye.push(be[I]);if(ye.length!==0){for(I=0;I<_.length&&D.substr(0,_[I].length)!==_[I];++I);if(I<_.length){if(p=I,I===1&&(le=ye[1]),I===6)return{name:le,c:he,A:I5.transpose(de),b:me,rows:V,vars:te};continue}switch(p){case 0:case 1:ge("Unexpected line");case 2:switch(ye[0]){case"N":k===0?k=ye[1]:ge("Two or more N rows");break;case"L":V[ye[1]]=Z,$[Z]=1,me[Z]=0,++Z;break;case"G":V[ye[1]]=Z,$[Z]=-1,me[Z]=0,++Z;break;case"E":V[ye[1]]=Z,$[Z]=0,me[Z]=0,++Z;break;default:ge("Parse error "+I5.prettyPrint(ye))}break;case 3:te.hasOwnProperty(ye[0])||(te[ye[0]]=xe,he[xe]=0,de[xe]=I5.rep([Z],0),++xe);var ve=te[ye[0]];for(I=1;I<ye.length;I+=2){if(ye[I]===k){he[ve]=parseFloat(ye[I+1]);continue}var Ie=V[ye[I]];de[ve][Ie]=($[Ie]<0?-1:1)*parseFloat(ye[I+1])}break;case 4:for(I=1;I<ye.length;I+=2)me[V[ye[I]]]=($[V[ye[I]]]<0?-1:1)*parseFloat(ye[I+1]);break;case 5:break;case 6:ge("Internal error")}}}ge("Reached end of file without ENDATA")},I5.seedrandom={pow:Math.pow,random:Math.random},function(m,d,p,_,E,S,I){d.seedrandom=function(Z,te){var xe=[],le;return Z=V(k(te?[Z,m]:arguments.length?Z:[new Date().getTime(),m,window],3),xe),le=new D(xe),V(le.S,m),d.random=function(){for(var he=le.g(_),de=I,me=0;he<E;)he=(he+me)*p,de*=p,me=le.g(1);for(;he>=S;)he/=2,de/=2,me>>>=1;return(he+me)/de},Z};function D(Z){var te,xe,le=this,he=Z.length,de=0,me=le.i=le.j=le.m=0;for(le.S=[],le.c=[],he||(Z=[he++]);de<p;)le.S[de]=de++;for(de=0;de<p;de++)te=le.S[de],me=$(me+te+Z[de%he]),xe=le.S[me],le.S[de]=xe,le.S[me]=te;le.g=function(ge){var be=le.S,ye=$(le.i+1),ve=be[ye],Ie=$(le.j+ve),je=be[Ie];be[ye]=je,be[Ie]=ve;for(var Me=be[$(ve+je)];--ge;)ye=$(ye+1),ve=be[ye],Ie=$(Ie+ve),je=be[Ie],be[ye]=je,be[Ie]=ve,Me=Me*p+be[$(ve+je)];return le.i=ye,le.j=Ie,Me},le.g(p)}function k(Z,te,xe,le,he){if(xe=[],he=typeof Z,te&&he=="object"){for(le in Z)if(le.indexOf("S")<5)try{xe.push(k(Z[le],te-1))}catch{}}return xe.length?xe:Z+(he!="string"?"\0":"")}function V(Z,te,xe,le){for(Z+="",xe=0,le=0;le<Z.length;le++)te[$(le)]=$((xe^=te[$(le)]*19)+Z.charCodeAt(le));Z="";for(le in te)Z+=String.fromCharCode(te[le]);return Z}function $(Z){return Z&p-1}I=d.pow(p,_),E=d.pow(2,E),S=E*2,V(d.random(),m)}([],I5.seedrandom,256,6,52),function(m){function d(k){if(typeof k!="object")return k;var V=[],$,Z=k.length;for($=0;$<Z;$++)V[$+1]=d(k[$]);return V}function p(k){if(typeof k!="object")return k;var V=[],$,Z=k.length;for($=1;$<Z;$++)V[$-1]=p(k[$]);return V}function _(k,V,$){var Z,te,xe,le,he;for(xe=1;xe<=$;xe=xe+1){for(k[xe][xe]=1/k[xe][xe],he=-k[xe][xe],Z=1;Z<xe;Z=Z+1)k[Z][xe]=he*k[Z][xe];if(le=xe+1,$<le)break;for(te=le;te<=$;te=te+1)for(he=k[xe][te],k[xe][te]=0,Z=1;Z<=xe;Z=Z+1)k[Z][te]=k[Z][te]+he*k[Z][xe]}}function E(k,V,$,Z){var te,xe,le,he;for(xe=1;xe<=$;xe=xe+1){for(he=0,te=1;te<xe;te=te+1)he=he+k[te][xe]*Z[te];Z[xe]=(Z[xe]-he)/k[xe][xe]}for(le=1;le<=$;le=le+1)for(xe=$+1-le,Z[xe]=Z[xe]/k[xe][xe],he=-Z[xe],te=1;te<xe;te=te+1)Z[te]=Z[te]+he*k[te][xe]}function S(k,V,$,Z){var te,xe,le,he,de,me;for(xe=1;xe<=$;xe=xe+1){if(Z[1]=xe,me=0,le=xe-1,le<1){if(me=k[xe][xe]-me,me<=0)break;k[xe][xe]=Math.sqrt(me)}else{for(he=1;he<=le;he=he+1){for(de=k[he][xe],te=1;te<he;te=te+1)de=de-k[te][xe]*k[te][he];de=de/k[he][he],k[he][xe]=de,me=me+de*de}if(me=k[xe][xe]-me,me<=0)break;k[xe][xe]=Math.sqrt(me)}Z[1]=0}}function I(k,V,$,Z,te,xe,le,he,de,me,ge,be,ye,ve,Ie,je){var Me,xt,bt,gt,Xt,Ut,Ht,mi,gi,Ui,yi,vi,ts,us,bi,Ri,Nt,$t,li,Ei,xs,Vs,ms,bs,Us,Mr,ar;ts=Math.min(Z,me),bt=2*Z+ts*(ts+5)/2+2*me+1,bs=1e-60;do bs=bs+bs,Us=1+.1*bs,Mr=1+.2*bs;while(Us<=1||Mr<=1);for(Me=1;Me<=Z;Me=Me+1)Ie[Me]=V[Me];for(Me=Z+1;Me<=bt;Me=Me+1)Ie[Me]=0;for(Me=1;Me<=me;Me=Me+1)be[Me]=0;if(Xt=[],je[1]===0){if(S(k,$,Z,Xt),Xt[1]!==0){je[1]=2;return}E(k,$,Z,V),_(k,$,Z)}else{for(xt=1;xt<=Z;xt=xt+1)for(te[xt]=0,Me=1;Me<=xt;Me=Me+1)te[xt]=te[xt]+k[Me][xt]*V[Me];for(xt=1;xt<=Z;xt=xt+1)for(V[xt]=0,Me=xt;Me<=Z;Me=Me+1)V[xt]=V[xt]+k[xt][Me]*te[Me]}for(xe[1]=0,xt=1;xt<=Z;xt=xt+1)for(te[xt]=V[xt],xe[1]=xe[1]+Ie[xt]*te[xt],Ie[xt]=0,Me=xt+1;Me<=Z;Me=Me+1)k[Me][xt]=0;for(xe[1]=-xe[1]/2,je[1]=0,Ht=Z,mi=Ht+Z,yi=mi+ts,gi=yi+ts+1,Ui=gi+ts*(ts+1)/2,us=Ui+me,Me=1;Me<=me;Me=Me+1){for(Ri=0,xt=1;xt<=Z;xt=xt+1)Ri=Ri+le[xt][Me]*le[xt][Me];Ie[us+Me]=Math.sqrt(Ri)}ye=0,ve[1]=0,ve[2]=0;function yr(){for(ve[1]=ve[1]+1,bt=Ui,Me=1;Me<=me;Me=Me+1){for(bt=bt+1,Ri=-he[Me],xt=1;xt<=Z;xt=xt+1)Ri=Ri+le[xt][Me]*te[xt];if(Math.abs(Ri)<bs&&(Ri=0),Me>ge)Ie[bt]=Ri;else if(Ie[bt]=-Math.abs(Ri),Ri>0){for(xt=1;xt<=Z;xt=xt+1)le[xt][Me]=-le[xt][Me];he[Me]=-he[Me]}}for(Me=1;Me<=ye;Me=Me+1)Ie[Ui+be[Me]]=0;for(vi=0,bi=0,Me=1;Me<=me;Me=Me+1)Ie[Ui+Me]<bi*Ie[us+Me]&&(vi=Me,bi=Ie[Ui+Me]/Ie[us+Me]);return vi===0?999:0}function jr(){for(Me=1;Me<=Z;Me=Me+1){for(Ri=0,xt=1;xt<=Z;xt=xt+1)Ri=Ri+k[xt][Me]*le[xt][vi];Ie[Me]=Ri}for(gt=Ht,Me=1;Me<=Z;Me=Me+1)Ie[gt+Me]=0;for(xt=ye+1;xt<=Z;xt=xt+1)for(Me=1;Me<=Z;Me=Me+1)Ie[gt+Me]=Ie[gt+Me]+k[Me][xt]*Ie[xt];for(Vs=!0,Me=ye;Me>=1;Me=Me-1){for(Ri=Ie[Me],bt=gi+Me*(Me+3)/2,gt=bt-Me,xt=Me+1;xt<=ye;xt=xt+1)Ri=Ri-Ie[bt]*Ie[mi+xt],bt=bt+xt;if(Ri=Ri/Ie[gt],Ie[mi+Me]=Ri,be[Me]<ge||Ri<0)break;Vs=!1,Ut=Me}if(!Vs)for(Nt=Ie[yi+Ut]/Ie[mi+Ut],Me=1;Me<=ye&&!(be[Me]<ge||Ie[mi+Me]<0);Me=Me+1)bi=Ie[yi+Me]/Ie[mi+Me],bi<Nt&&(Nt=bi,Ut=Me);for(Ri=0,Me=Ht+1;Me<=Ht+Z;Me=Me+1)Ri=Ri+Ie[Me]*Ie[Me];if(Math.abs(Ri)<=bs){if(Vs)return je[1]=1,999;for(Me=1;Me<=ye;Me=Me+1)Ie[yi+Me]=Ie[yi+Me]-Nt*Ie[mi+Me];return Ie[yi+ye+1]=Ie[yi+ye+1]+Nt,700}else{for(Ri=0,Me=1;Me<=Z;Me=Me+1)Ri=Ri+Ie[Ht+Me]*le[Me][vi];for($t=-Ie[Ui+vi]/Ri,ms=!0,Vs||Nt<$t&&($t=Nt,ms=!1),Me=1;Me<=Z;Me=Me+1)te[Me]=te[Me]+$t*Ie[Ht+Me],Math.abs(te[Me])<bs&&(te[Me]=0);for(xe[1]=xe[1]+$t*Ri*($t/2+Ie[yi+ye+1]),Me=1;Me<=ye;Me=Me+1)Ie[yi+Me]=Ie[yi+Me]-$t*Ie[mi+Me];if(Ie[yi+ye+1]=Ie[yi+ye+1]+$t,ms){for(ye=ye+1,be[ye]=vi,bt=gi+(ye-1)*ye/2+1,Me=1;Me<=ye-1;Me=Me+1)Ie[bt]=Ie[Me],bt=bt+1;if(ye===Z)Ie[bt]=Ie[Z];else{for(Me=Z;Me>=ye+1&&!(Ie[Me]===0||(li=Math.max(Math.abs(Ie[Me-1]),Math.abs(Ie[Me])),Ei=Math.min(Math.abs(Ie[Me-1]),Math.abs(Ie[Me])),Ie[Me-1]>=0?bi=Math.abs(li*Math.sqrt(1+Ei*Ei/(li*li))):bi=-Math.abs(li*Math.sqrt(1+Ei*Ei/(li*li))),li=Ie[Me-1]/bi,Ei=Ie[Me]/bi,li===1));Me=Me-1)if(li===0)for(Ie[Me-1]=Ei*bi,xt=1;xt<=Z;xt=xt+1)bi=k[xt][Me-1],k[xt][Me-1]=k[xt][Me],k[xt][Me]=bi;else for(Ie[Me-1]=bi,xs=Ei/(1+li),xt=1;xt<=Z;xt=xt+1)bi=li*k[xt][Me-1]+Ei*k[xt][Me],k[xt][Me]=xs*(k[xt][Me-1]+bi)-k[xt][Me],k[xt][Me-1]=bi;Ie[bt]=Ie[ye]}}else{for(Ri=-he[vi],xt=1;xt<=Z;xt=xt+1)Ri=Ri+te[xt]*le[xt][vi];if(vi>ge)Ie[Ui+vi]=Ri;else if(Ie[Ui+vi]=-Math.abs(Ri),Ri>0){for(xt=1;xt<=Z;xt=xt+1)le[xt][vi]=-le[xt][vi];he[vi]=-he[vi]}return 700}}return 0}function xn(){if(bt=gi+Ut*(Ut+1)/2+1,gt=bt+Ut,Ie[gt]===0||(li=Math.max(Math.abs(Ie[gt-1]),Math.abs(Ie[gt])),Ei=Math.min(Math.abs(Ie[gt-1]),Math.abs(Ie[gt])),Ie[gt-1]>=0?bi=Math.abs(li*Math.sqrt(1+Ei*Ei/(li*li))):bi=-Math.abs(li*Math.sqrt(1+Ei*Ei/(li*li))),li=Ie[gt-1]/bi,Ei=Ie[gt]/bi,li===1))return 798;if(li===0){for(Me=Ut+1;Me<=ye;Me=Me+1)bi=Ie[gt-1],Ie[gt-1]=Ie[gt],Ie[gt]=bi,gt=gt+Me;for(Me=1;Me<=Z;Me=Me+1)bi=k[Me][Ut],k[Me][Ut]=k[Me][Ut+1],k[Me][Ut+1]=bi}else{for(xs=Ei/(1+li),Me=Ut+1;Me<=ye;Me=Me+1)bi=li*Ie[gt-1]+Ei*Ie[gt],Ie[gt]=xs*(Ie[gt-1]+bi)-Ie[gt],Ie[gt-1]=bi,gt=gt+Me;for(Me=1;Me<=Z;Me=Me+1)bi=li*k[Me][Ut]+Ei*k[Me][Ut+1],k[Me][Ut+1]=xs*(k[Me][Ut]+bi)-k[Me][Ut+1],k[Me][Ut]=bi}return 0}function dn(){for(gt=bt-Ut,Me=1;Me<=Ut;Me=Me+1)Ie[gt]=Ie[bt],bt=bt+1,gt=gt+1;return Ie[yi+Ut]=Ie[yi+Ut+1],be[Ut]=be[Ut+1],Ut=Ut+1,Ut<ye?797:0}function Rn(){return Ie[yi+ye]=Ie[yi+ye+1],Ie[yi+ye+1]=0,be[ye]=0,ye=ye-1,ve[2]=ve[2]+1,0}for(ar=0;;){if(ar=yr(),ar===999)return;for(;ar=jr(),ar!==0;){if(ar===999)return;if(ar===700)if(Ut===ye)Rn();else{for(;xn(),ar=dn(),ar===797;);Rn()}}}}function D(k,V,$,Z,te,xe){k=d(k),V=d(V),$=d($);var le,he,de,me,ge,be=[],ye=[],ve=[],Ie=[],je=[],Me;if(te=te||0,xe=xe?d(xe):[void 0,0],Z=Z?d(Z):[],he=k.length-1,de=$[1].length-1,!Z)for(le=1;le<=de;le=le+1)Z[le]=0;for(le=1;le<=de;le=le+1)ye[le]=0;for(me=0,ge=Math.min(he,de),le=1;le<=he;le=le+1)ve[le]=0;for(be[1]=0,le=1;le<=2*he+ge*(ge+5)/2+2*de+1;le=le+1)Ie[le]=0;for(le=1;le<=2;le=le+1)je[le]=0;return I(k,V,he,he,ve,be,$,Z,he,de,te,ye,me,je,Ie,xe),Me="",xe[1]===1&&(Me="constraints are inconsistent, no solution!"),xe[1]===2&&(Me="matrix D in quadratic function is not positive definite!"),{solution:p(ve),value:p(be),unconstrained_solution:p(V),iterations:p(je),iact:p(ye),message:Me}}m.solveQP=D}(I5),I5.svd=function m(d){var p,_=I5.epsilon,E=1e-64/_,S=50,I=0,D=0,k=0,V=0,$=0,Z=I5.clone(d),te=Z.length,xe=Z[0].length;if(te<xe)throw"Need more rows than columns";var le=new Array(xe),he=new Array(xe);for(D=0;D<xe;D++)le[D]=he[D]=0;var de=I5.rep([xe,xe],0);function me(Xt,Ut){return Xt=Math.abs(Xt),Ut=Math.abs(Ut),Xt>Ut?Xt*Math.sqrt(1+Ut*Ut/Xt/Xt):Ut==0?Xt:Ut*Math.sqrt(1+Xt*Xt/Ut/Ut)}var ge=0,be=0,ye=0,ve=0,Ie=0,je=0,Me=0;for(D=0;D<xe;D++){for(le[D]=be,Me=0,$=D+1,k=D;k<te;k++)Me+=Z[k][D]*Z[k][D];if(Me<=E)be=0;else for(ge=Z[D][D],be=Math.sqrt(Me),ge>=0&&(be=-be),ye=ge*be-Me,Z[D][D]=ge-be,k=$;k<xe;k++){for(Me=0,V=D;V<te;V++)Me+=Z[V][D]*Z[V][k];for(ge=Me/ye,V=D;V<te;V++)Z[V][k]+=ge*Z[V][D]}for(he[D]=be,Me=0,k=$;k<xe;k++)Me=Me+Z[D][k]*Z[D][k];if(Me<=E)be=0;else{for(ge=Z[D][D+1],be=Math.sqrt(Me),ge>=0&&(be=-be),ye=ge*be-Me,Z[D][D+1]=ge-be,k=$;k<xe;k++)le[k]=Z[D][k]/ye;for(k=$;k<te;k++){for(Me=0,V=$;V<xe;V++)Me+=Z[k][V]*Z[D][V];for(V=$;V<xe;V++)Z[k][V]+=Me*le[V]}}Ie=Math.abs(he[D])+Math.abs(le[D]),Ie>ve&&(ve=Ie)}for(D=xe-1;D!=-1;D+=-1){if(be!=0){for(ye=be*Z[D][D+1],k=$;k<xe;k++)de[k][D]=Z[D][k]/ye;for(k=$;k<xe;k++){for(Me=0,V=$;V<xe;V++)Me+=Z[D][V]*de[V][k];for(V=$;V<xe;V++)de[V][k]+=Me*de[V][D]}}for(k=$;k<xe;k++)de[D][k]=0,de[k][D]=0;de[D][D]=1,be=le[D],$=D}for(D=xe-1;D!=-1;D+=-1){for($=D+1,be=he[D],k=$;k<xe;k++)Z[D][k]=0;if(be!=0){for(ye=Z[D][D]*be,k=$;k<xe;k++){for(Me=0,V=$;V<te;V++)Me+=Z[V][D]*Z[V][k];for(ge=Me/ye,V=D;V<te;V++)Z[V][k]+=ge*Z[V][D]}for(k=D;k<te;k++)Z[k][D]=Z[k][D]/be}else for(k=D;k<te;k++)Z[k][D]=0;Z[D][D]+=1}for(_=_*ve,V=xe-1;V!=-1;V+=-1)for(var xt=0;xt<S;xt++){var bt=!1;for($=V;$!=-1;$+=-1){if(Math.abs(le[$])<=_){bt=!0;break}if(Math.abs(he[$-1])<=_)break}if(!bt){I=0,Me=1;var gt=$-1;for(D=$;D<V+1&&(ge=Me*le[D],le[D]=I*le[D],!(Math.abs(ge)<=_));D++)for(be=he[D],ye=me(ge,be),he[D]=ye,I=be/ye,Me=-ge/ye,k=0;k<te;k++)Ie=Z[k][gt],je=Z[k][D],Z[k][gt]=Ie*I+je*Me,Z[k][D]=-Ie*Me+je*I}if(je=he[V],$==V){if(je<0)for(he[V]=-je,k=0;k<xe;k++)de[k][V]=-de[k][V];break}if(xt>=S-1)throw"Error: no convergence.";for(ve=he[$],Ie=he[V-1],be=le[V-1],ye=le[V],ge=((Ie-je)*(Ie+je)+(be-ye)*(be+ye))/(2*ye*Ie),be=me(ge,1),ge<0?ge=((ve-je)*(ve+je)+ye*(Ie/(ge-be)-ye))/ve:ge=((ve-je)*(ve+je)+ye*(Ie/(ge+be)-ye))/ve,I=1,Me=1,D=$+1;D<V+1;D++){for(be=le[D],Ie=he[D],ye=Me*be,be=I*be,je=me(ge,ye),le[D-1]=je,I=ge/je,Me=ye/je,ge=ve*I+be*Me,be=-ve*Me+be*I,ye=Ie*Me,Ie=Ie*I,k=0;k<xe;k++)ve=de[k][D-1],je=de[k][D],de[k][D-1]=ve*I+je*Me,de[k][D]=-ve*Me+je*I;for(je=me(ge,ye),he[D-1]=je,I=ge/je,Me=ye/je,ge=I*be+Me*Ie,ve=-Me*be+I*Ie,k=0;k<te;k++)Ie=Z[k][D-1],je=Z[k][D],Z[k][D-1]=Ie*I+je*Me,Z[k][D]=-Ie*Me+je*I}le[$]=0,le[V]=ge,he[V]=ve}for(D=0;D<he.length;D++)he[D]<_&&(he[D]=0);for(D=0;D<xe;D++)for(k=D-1;k>=0;k--)if(he[k]<he[D]){for(I=he[k],he[k]=he[D],he[D]=I,V=0;V<Z.length;V++)p=Z[V][D],Z[V][D]=Z[V][k],Z[V][k]=p;for(V=0;V<de.length;V++)p=de[V][D],de[V][D]=de[V][k],de[V][k]=p;D=k}return{U:Z,S:he,V:de}}})(Sk);class Sp{constructor(){this.bodyTracks=[],this.poseFilters=[],this.angle=.08333333333333333*Math.PI,this.ratio=1.7777777777777777,this.near=1,this.poseScore=.6,this.alignScore=.9,this.alignVisibility=.9,this.skipCount=2,this.skipMax=2}async process(d,p){var _,E;if(this.bodyTracks.length<1&&this.skipCount<this.skipMax)return this.skipCount++,[];this.skipCount=0;const S=sV(()=>{const te=CB(CY(d,3),"float32"),xe=rT(Lp(te,255*.5),1);return r0(xe,0)}),[I,D]=[S.shape[1],S.shape[2]];if(this.bodyTracks.length===0){const te=await((_=this.bodyDetector)==null?void 0:_.process(S))||[];this.bodyTracks=te.map(xe=>({center:xe.points[0],top:xe.points[1]})),this.bodyTracks.forEach(()=>this.poseFilters.push(new Qv))}const k=this.bodyTracks.length>0?((E=this.poseDetector)==null?void 0:E.process(S,this.bodyTracks))||[]:[];k.forEach((te,xe)=>{var le;if(p!==void 0){const he=D/I,de=te.top[0]-te.center[0],me=(te.top[1]-te.center[1])/he,ge=Math.sqrt(de*de+me*me)*2*(1+he)*.5;k[xe]=this.poseFilters[xe].filter(te,p,1/ge)}(le=this.poseAligner)==null||le.alignPoints(k[xe].keypoints)}),S.dispose();let V=[],$=[],Z=[];for(let te=0;te<this.bodyTracks.length;te++){const xe={center:[this.bodyTracks[te].center[0]*D,this.bodyTracks[te].center[1]*I],top:[this.bodyTracks[te].top[0]*D,this.bodyTracks[te].top[1]*I]};let le={center:[k[te].center[0]*D,k[te].center[1]*I],top:[k[te].top[0]*D,k[te].top[1]*I]};const he=[xe,le].map(de=>{const{center:me,top:ge}=de,be=[ge[0]-me[0],ge[1]-me[1]],ye=Math.sqrt(be[0]*be[0]+be[1]*be[1]);return[[me[0]-ye,me[1]-ye],[me[0]+ye,me[1]+ye]]});QY(he[0],he[1])>.5&&k[te].score>this.poseScore&&(V.push({center:[...k[te].center],top:[...k[te].top]}),$.push(this.poseFilters[te]),Z.push(k[te]))}return this.bodyTracks=V,this.poseFilters=$,Z}setCamera(d,p,_=1){var E;this.angle=d,this.ratio=p,this.near=_,(E=this.poseAligner)==null||E.setCamera(d,p,_)}async init(d,p="./",_=!1,E=!1,S="webgl"){const I=await Qb({locateFile:te=>p+te});I.Loader.prototype.promisify=function(te,...xe){return te.call(this,...xe),new Promise(le=>{const he=setInterval(()=>{if(this.ready)return clearInterval(he),le(this.status)},5)})},I.Loader.prototype.load=function(te){return this.promisify(this.loadAsync,te,_)},I.Loader.prototype.remove=function(te){return this.promisify(this.removeAsync,te)},I.DictLoader.prototype.loadDict=function(te){return this.promisify(this.loadDictAsync,d,te)};const D=new I.ParseLoader(p);if(_||(await D.remove("pose.wasm"),await D.remove("poseutils.wasm")),!await D.loadDict(["pose.wasm","poseutils.wasm"])||!await D.load("pose.wasm")||!D.parse())return;oQ().set("WEBGL_USE_SHAPES_UNIFORMS",!0),sb(),await z1(S);const k={weightUrlConverter:async te=>te,fetchFunc:async te=>{const xe=new Blob([D.file(te)]);return fetch(URL.createObjectURL(xe))}},V=await pg("bodymodel.def",k),$=await pg("posemodel.def",k);if(this.bodyDetector=new QX(V),this.poseDetector=new Qy($,E),!await D.load("poseutils.wasm"))return;const Z=await Ql({wasmBinary:D.data()});D.delete(),Z.PoseAligner.prototype.alignPoints=function(te){const xe=new Z.VectorFloat,le=new Z.VectorFloat,he=new Z.VectorFloat,de=new Z.VectorFloat;te.forEach(ge=>{xe.push_back(ge.pixel[0]),xe.push_back(ge.pixel[1]),xe.push_back(ge.pixel[2]),le.push_back(ge.metric[0]),le.push_back(ge.metric[1]),le.push_back(ge.metric[2]),he.push_back(ge.score),de.push_back(ge.visibility)});const me=this.align(xe,le,he,de);te.forEach((ge,be)=>{ge.metric=[me.get(be*3),me.get(be*3+1),me.get(be*3+2)]}),xe.delete(),le.delete(),he.delete(),de.delete(),me.delete()},this.poseModule=Z,this.poseAligner=new this.poseModule.PoseAligner,this.poseAligner.setThresh(this.alignScore,this.alignVisibility)}reset(){var d;this.bodyTracks=[],this.poseFilters=[],this.skipCount=this.skipMax,(d=this.poseDetector)==null||d.reset()}async prepare(){var d,p;oQ().set("ENGINE_COMPILE_ONLY",!0),await((d=this.bodyDetector)==null?void 0:d.prepare()),await((p=this.poseDetector)==null?void 0:p.prepare());const _=z4();_ instanceof OU&&(_.checkCompileCompletion(),_.getUniformLocations()),oQ().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var d,p,_;this.reset(),(d=this.bodyDetector)==null||d.dispose(),delete this.bodyDetector,(p=this.poseDetector)==null||p.dispose(),delete this.poseDetector,(_=this.poseAligner)==null||_.delete(),delete this.poseAligner}}function Sw(m,d){const p=2*Math.tan(.5*d.angle),_=d.ratio*p,E=m.map(k=>({pixel:[(k.pixel[0]-.5)*_,(k.pixel[1]-.5)*p],world:k.world})),S=[];E.forEach(k=>S.push([0,1,-k.pixel[1],k.world[1]-k.pixel[1]*k.world[2]],[-1,0,k.pixel[0],k.pixel[0]*k.world[2]-k.world[0]]));const{V:I}=Sk.svd(S),D=I[3][3];return[I[0][3]/D,I[1][3]/D,I[2][3]/D]}var SA=Object.defineProperty,SZ=Object.getOwnPropertySymbols,SF=Object.prototype.hasOwnProperty,SN=Object.prototype.propertyIsEnumerable,SO=(m,d,p)=>d in m?SA(m,d,{enumerable:!0,configurable:!0,writable:!0,value:p}):m[d]=p,SD=(m,d)=>{for(var p in d||(d={}))SF.call(d,p)&&SO(m,p,d[p]);if(SZ)for(var p of SZ(d))SN.call(d,p)&&SO(m,p,d[p]);return m};class Sn{constructor(d){this.model=d,this.facesMax=3,this.iouThresh=.3,this.scoreThresh=.5,this.keypointCount=6,this.model=d,this.modelSize=d.inputs[0].shape?{width:d.inputs[0].shape[2],height:d.inputs[0].shape[1]}:{width:128,height:128},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchors=TZ(this.anchorsData),this.size=TA([this.modelSize.width,this.modelSize.height])}async process(d,p){let _={x:0,y:0};const[E,S,I]=sV(()=>{const he={width:d.shape[2],height:d.shape[1]},de=he.width/he.height;let me=SD({},he),ge={x:0,y:0};de>this.modelRatio?(me.height=he.width/this.modelRatio,ge.y=Math.floor((me.height-he.height)*.5),_.y=ge.y/me.height):de<this.modelRatio&&(me.width=he.height*this.modelRatio,ge.x=Math.floor((me.width-he.width)*.5),_.x=ge.x/me.width);const be=rS(d,[[0,0],[ge.y,ge.y],[ge.x,ge.x],[0,0]],0),ye=qO.resizeBilinear(be,[this.modelSize.height,this.modelSize.width]),ve=LT(LA(ye,2),-1),Ie=Tr(this.model.execute(ve,"objects")),je=K0(Ie,[0,0],[-1,1]),Me=Tr(LV(je)),xt=this.decodeBoxes(Ie,this.anchors,this.size);return[Ie,xt,Me]}),D=await qO.nonMaxSuppressionAsync(S,I,this.facesMax,this.iouThresh,this.scoreThresh),k=await D.data();D.dispose();const V=[];for(let he=0;he<k.length;he++){const de=k[he];V.push({box:K0(S,[de,0],[1,-1]),score:K0(I,de,1),anchorI:de,points:p?K0(E,[de,5],[1,-1]):void 0})}const $=await Promise.all(V.map(async he=>{var de,me;const ge=await he.box.data(),be=await he.score.data(),ye=await((de=he.points)==null?void 0:de.data());return he.box.dispose(),he.score.dispose(),(me=he.points)==null||me.dispose(),{box:ge,score:be[0],anchorI:he.anchorI,points:ye}})),Z={width:1-2*_.x,height:1-2*_.y};_.x/=Z.width,_.y/=Z.height;const te=this.modelSize.width*Z.width,xe=this.modelSize.height*Z.height,le=[];for(let he=0;he<$.length;he++){const de=$[he].box,me=this.anchorsData[$[he].anchorI],ge=$[he].points,be=[];for(let ye=0;ye<this.keypointCount&&ge;ye++)be.push({x:(ge[ye*2+0]+me[0])/te-_.x,y:(ge[ye*2+1]+me[1])/xe-_.y});le.push({box:[[de[0]/te-_.x,de[1]/xe-_.y],[de[2]/te-_.x,de[3]/xe-_.y]],score:$[he].score,keypoints:ge&&be})}return E.dispose(),S.dispose(),I.dispose(),le}decodeBoxes(d,p,_){const E=K0(d,[0,1],[-1,2]),S=LT(E,p),I=K0(d,[0,3],[-1,2]),D=Lp(I,2),k=rT(S,D),V=LT(S,D);return KG([k,V],1)}buildAnchors(d){const p=[8,16],_=[2,6],E=[];for(let S=0;S<p.length;S++){const I=p[S],D=Math.floor((d.height+I-1)/I),k=Math.floor((d.width+I-1)/I),V=_[S];for(let $=0;$<D;$++){const Z=I*($+.5);for(let te=0;te<k;te++){const xe=I*(te+.5);for(let le=0;le<V;le++)E.push([xe,Z])}}}return E}async prepare(){const{width:d,height:p}=this.modelSize,_=rD([1,p,d,3]),E=this.model.execute(_,"objects");await E.data(),_.dispose(),E.dispose()}dispose(){this.model.dispose(),this.anchors.dispose()}}var Si=(m=>(m[m.EyeR=0]="EyeR",m[m.EyeL=1]="EyeL",m[m.Nose=2]="Nose",m[m.Mouth=3]="Mouth",m[m.EarR=4]="EarR",m[m.EarL=5]="EarL",m))(Si||{});class Se{constructor(d){this.model=d,this.boxFactor=1.5,this.symmetryPoints=[13,168],this.modelSize=d.inputs[0].shape?{width:d.inputs[0].shape[2],height:d.inputs[0].shape[1]}:{width:192,height:192},this.modelHighP=this.model.outputs.length===7}process(d,p){const _=p.map(D=>{const{box:k,symmetry:V}=D,$=.5*(this.boxFactor-1),Z={x:$*(k[1][0]-k[0][0]),y:$*(k[1][1]-k[0][1])};return{box:[[k[0][0]-Z.x,k[0][1]-Z.y],[k[1][0]+Z.x,k[1][1]+Z.y]],symmetry:V}}),[E,S]=[d.shape[1],d.shape[2]],{modelSize:I}=this;return _.map(D=>{const{box:k,symmetry:V}=D,$=Math.atan2((V[1].x-V[0].x)*S,(V[0].y-V[1].y)*E),Z=[.5*(k[0][0]+k[1][0]),.5*(k[0][1]+k[1][1])],te={width:k[1][0]-k[0][0],height:k[1][1]-k[0][1]},xe=[k[0][1]*E,k[0][0]*S,k[1][1]*E,k[1][0]*S],le=this.rotatedRect(d,xe,$,I),he=this.modelHighP?["output_mesh_identity","output_faceflag","output_lips","Identity_1:0","Identity_5:0","Identity_2:0","Identity_6:0"]:["output_mesh","output_faceflag"],[de,me,ge,be,ye,ve,Ie]=this.model.execute(le,he),je=de.dataSync(),Me=me.dataSync()[0];let xt=[];for(let vi=0;vi<je.length/3;vi++)xt.push([je[vi*3+0],je[vi*3+1],je[vi*3+2]]);if(ge){const vi=ge.dataSync();SS(xt,vi,SB)}if(be&&ye){const vi=be.dataSync(),ts=ye.dataSync();SS(xt,vi,Sj),SS(xt,ts,SR)}if(ve&&Ie){const vi=ve.dataSync(),ts=Ie.dataSync(),us=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173].map(Ri=>xt[Ri]),bi=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398].map(Ri=>xt[Ri]);for(let Ri=0;Ri<vi.length/2;Ri++){const Nt=[vi[Ri*2+0],vi[Ri*2+1]];xt.push([Nt[0],Nt[1],SI(Nt,us)])}for(let Ri=0;Ri<ts.length/2;Ri++){const Nt=[ts[Ri*2+0],ts[Ri*2+1]];xt.push([Nt[0],Nt[1],SI(Nt,bi)])}}const bt=[te.width*S/I.width,te.height*E/I.height],gt=xt.map(vi=>[(vi[0]-I.width/2)*bt[0],(vi[1]-I.height/2)*bt[1],vi[2]*bt[0]]),Xt=Math.sin($),Ut=Math.cos($),Ht=gt.map(vi=>[(vi[0]*Ut-vi[1]*Xt)/S+Z[0],(vi[0]*Xt+vi[1]*Ut)/E+Z[1],vi[2]/S]),mi=Ht.map(vi=>vi[0]),gi=Ht.map(vi=>vi[1]),Ui=[Math.min(...mi),Math.min(...gi)],yi=[Math.max(...mi),Math.max(...gi)];return le.dispose(),de.dispose(),me.dispose(),ge?.dispose(),be?.dispose(),ye?.dispose(),ve?.dispose(),Ie?.dispose(),{keypoints:Ht,score:Me,box:[[Ui[0],Ui[1]],[yi[0],yi[1]]]}})}rotatedRect(d,p,_,E){const[S,I]=[p[2]-p[0],p[3]-p[1]],[D,k]=[(p[2]+p[0])*.5,(p[3]+p[1])*.5],[V,$]=[S/E.height,I/E.width],[Z,te]=[Math.cos(_),Math.sin(_)],xe=[Z*$,-te*V,(-Z*I+te*S)*.5+k,te*$,Z*V,(-te*I-Z*S)*.5+D,0,0];return qO.transform(d,[xe],"bilinear","constant",0,[E.height,E.width])}async prepare(){const{width:d,height:p}=this.modelSize,_=rD([1,p,d,3]),E=this.model.execute(_);await Promise.all(E.map(async S=>{await S.data(),S.dispose()})),_.dispose()}dispose(){this.model.dispose()}}function SP(m,d){return m.keypoints.forEach(p=>{p[0]*=d,p[1]*=d,p[2]*=d}),m.box[0][0]*=d,m.box[0][1]*=d,m.box[1][0]*=d,m.box[1][1]*=d,m}function SS(m,d,p){for(let _=0;_<p.length;_++)m[p[_]][0]=d[_*2+0],m[p[_]][1]=d[_*2+1]}function SI(m,d){let p=0,_=Number.MAX_VALUE;for(let E=0;E<d.length;E++){const S=[d[E][0]-m[0],d[E][1]-m[1]],I=S[0]*S[0]+S[1]*S[1];I<_&&(_=I,p=E)}return d[p][2]}const SB=[61,146,91,181,84,17,314,405,321,375,291,185,40,39,37,0,267,269,270,409,78,95,88,178,87,14,317,402,318,324,308,191,80,81,82,13,312,311,310,415,76,77,90,180,85,16,315,404,320,307,306,184,74,73,72,11,302,303,304,408,62,96,89,179,86,15,316,403,319,325,292,183,42,41,38,12,268,271,272,407],Sj=[33,7,163,144,145,153,154,155,133,246,161,160,159,158,157,173,130,25,110,24,23,22,26,112,243,247,30,29,27,28,56,190,226,31,228,229,230,231,232,233,244,113,225,224,223,222,221,189,35,124,46,53,52,65,143,111,117,118,119,120,121,128,245,156,70,63,105,66,107,55,193],SR=[263,249,390,373,374,380,381,382,362,466,388,387,386,385,384,398,359,255,339,254,253,252,256,341,463,467,260,259,257,258,286,414,446,261,448,449,450,451,452,453,464,342,445,444,443,442,441,413,265,353,276,283,282,295,372,340,346,347,348,349,350,357,465,383,300,293,334,296,336,285,417];var SH=Object.defineProperty,Su=Object.getOwnPropertySymbols,SX=Object.prototype.hasOwnProperty,Sf=Object.prototype.propertyIsEnumerable,Sy=(m,d,p)=>d in m?SH(m,d,{enumerable:!0,configurable:!0,writable:!0,value:p}):m[d]=p,SE=(m,d)=>{for(var p in d||(d={}))SX.call(d,p)&&Sy(m,p,d[p]);if(Su)for(var p of Su(d))Sf.call(d,p)&&Sy(m,p,d[p]);return m};class SW{constructor(d,p=!1){this.model=d,this.modelSize=d.inputs[0].shape?{width:d.inputs[0].shape[2],height:d.inputs[0].shape[1]}:{width:256,height:256},this.modelRatio=this.modelSize.width/this.modelSize.height,p&&(this.maskFilter=new Qf(this.modelSize))}process(d,p){var _,E;const{modelSize:S}=this,I=d.shape[2]/d.shape[1],D=this.modelRatio/I,k={width:p[1][0]-p[0][0],height:p[1][1]-p[0][1]},V={x:(p[1][0]+p[0][0])*.5,y:(p[1][1]+p[0][1])*.5};k.width/k.height>D?k.height=k.width/D:k.width=k.height*D;const $=[V.y-k.height*.5,V.x-k.width*.5,V.y+k.height*.5,V.x+k.width*.5],Z=qO.cropAndResize(d,[$],[0],[S.height,S.width]),te=(_=this.model)==null?void 0:_.execute(Z),xe=K0(te,[0,0,0,1],-1),le=Tr(xe),he=((E=this.maskFilter)==null?void 0:E.process(le))||le,de=LA(he,255),me=new Uint8Array(de.dataSync());return Z.dispose(),te.dispose(),xe.dispose(),le.dispose(),de.dispose(),{buffer:me,size:SE({},this.modelSize),box:[[$[1],$[0]],[$[3],$[2]]]}}reset(){var d;(d=this.maskFilter)==null||d.reset()}async prepare(){var d;const{width:p,height:_}=this.modelSize,E=rD([1,_,p,3]),S=this.model.execute(E),I=K0(S,[0,0,0,1],-1),D=Tr(I);await(((d=this.maskFilter)==null?void 0:d.process(D))||D).data(),E.dispose(),S.dispose(),I.dispose(),D.dispose()}dispose(){var d;this.model.dispose(),(d=this.maskFilter)==null||d.dispose(),delete this.maskFilter}}var Sd=(()=>{var m=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(d={}){var p=d,_,E;p.ready=new Promise((He,Xe)=>{_=He,E=Xe});var S=Object.assign({},p),I=!0,D="";function k(He){return p.locateFile?p.locateFile(He,D):D+He}typeof document<"u"&&document.currentScript&&(D=document.currentScript.src),m&&(D=m),D.startsWith("blob:")?D="":D=D.substr(0,D.replace(/[?#].*/,"").lastIndexOf("/")+1),p.print||console.log.bind(console);var V=p.printErr||console.error.bind(console);Object.assign(p,S),S=null,p.arguments&&p.arguments,p.thisProgram&&p.thisProgram,p.quit&&p.quit;var $;p.wasmBinary&&($=p.wasmBinary);var Z,te=!1,xe,le,he,de,me,ge,be,ye;function ve(){var He=Z.buffer;p.HEAP8=xe=new Int8Array(He),p.HEAP16=he=new Int16Array(He),p.HEAPU8=le=new Uint8Array(He),p.HEAPU16=de=new Uint16Array(He),p.HEAP32=me=new Int32Array(He),p.HEAPU32=ge=new Uint32Array(He),p.HEAPF32=be=new Float32Array(He),p.HEAPF64=ye=new Float64Array(He)}var Ie=[],je=[],Me=[];function xt(){if(p.preRun)for(typeof p.preRun=="function"&&(p.preRun=[p.preRun]);p.preRun.length;)Xt(p.preRun.shift());xs(Ie)}function bt(){xs(je)}function gt(){if(p.postRun)for(typeof p.postRun=="function"&&(p.postRun=[p.postRun]);p.postRun.length;)Ht(p.postRun.shift());xs(Me)}function Xt(He){Ie.unshift(He)}function Ut(He){je.unshift(He)}function Ht(He){Me.unshift(He)}var mi=0,gi=null;function Ui(He){var Xe;mi++,(Xe=p.monitorRunDependencies)==null||Xe.call(p,mi)}function yi(He){var Xe;if(mi--,(Xe=p.monitorRunDependencies)==null||Xe.call(p,mi),mi==0&&gi){var lt=gi;gi=null,lt()}}function vi(He){var Xe;(Xe=p.onAbort)==null||Xe.call(p,He),He="Aborted("+He+")",V(He),te=!0,He+=". Build with -sASSERTIONS for more info.";var lt=new WebAssembly.RuntimeError(He);throw E(lt),lt}var ts="data:application/octet-stream;base64,",us=He=>He.startsWith(ts),bi;bi="faceutils.wasm",us(bi)||(bi=k(bi));function Ri(He){if(He==bi&&$)return new Uint8Array($);throw"both async and sync fetching of the wasm failed"}function Nt(He){return!$&&I&&typeof fetch=="function"?fetch(He,{credentials:"same-origin"}).then(Xe=>{if(!Xe.ok)throw"failed to load wasm binary file at '"+He+"'";return Xe.arrayBuffer()}).catch(()=>Ri(He)):Promise.resolve().then(()=>Ri(He))}function $t(He,Xe,lt){return Nt(He).then(yt=>WebAssembly.instantiate(yt,Xe)).then(lt,yt=>{V("failed to asynchronously prepare wasm: "+yt),vi(yt)})}function li(He,Xe,lt,yt){return!He&&typeof WebAssembly.instantiateStreaming=="function"&&!us(Xe)&&typeof fetch=="function"?fetch(Xe,{credentials:"same-origin"}).then(jt=>{var ti=WebAssembly.instantiateStreaming(jt,lt);return ti.then(yt,function(Vt){return V("wasm streaming compile failed: "+Vt),V("falling back to ArrayBuffer instantiation"),$t(Xe,lt,yt)})}):$t(Xe,lt,yt)}function Ei(){var He={a:as};function Xe(yt,jt){return Ua=yt.exports,Z=Ua.y,ve(),uo=Ua.C,Ut(Ua.z),yi(),Ua}Ui();function lt(yt){Xe(yt.instance)}if(p.instantiateWasm)try{return p.instantiateWasm(He,Xe)}catch(yt){V("Module.instantiateWasm callback failed with error: "+yt),E(yt)}return li($,bi,He,lt).catch(E),{}}var xs=He=>{for(;He.length>0;)He.shift()(p)};p.noExitRuntime;class Vs{constructor(Xe){this.excPtr=Xe,this.ptr=Xe-24}set_type(Xe){ge[this.ptr+4>>2]=Xe}get_type(){return ge[this.ptr+4>>2]}set_destructor(Xe){ge[this.ptr+8>>2]=Xe}get_destructor(){return ge[this.ptr+8>>2]}set_caught(Xe){Xe=Xe?1:0,xe[this.ptr+12]=Xe}get_caught(){return xe[this.ptr+12]!=0}set_rethrown(Xe){Xe=Xe?1:0,xe[this.ptr+13]=Xe}get_rethrown(){return xe[this.ptr+13]!=0}init(Xe,lt){this.set_adjusted_ptr(0),this.set_type(Xe),this.set_destructor(lt)}set_adjusted_ptr(Xe){ge[this.ptr+16>>2]=Xe}get_adjusted_ptr(){return ge[this.ptr+16>>2]}get_exception_ptr(){var Xe=Je(this.get_type());if(Xe)return ge[this.excPtr>>2];var lt=this.get_adjusted_ptr();return lt!==0?lt:this.excPtr}}var ms=0,bs=(He,Xe,lt)=>{var yt=new Vs(He);throw yt.init(Xe,lt),ms=He,ms},Us={},Mr=He=>{for(;He.length;){var Xe=He.pop(),lt=He.pop();lt(Xe)}};function ar(He){return this.fromWireType(ge[He>>2])}var yr={},jr={},xn={},dn,Rn=He=>{throw new dn(He)},Vn=(He,Xe,lt)=>{He.forEach(function(di){xn[di]=Xe});function yt(di){var Xi=lt(di);Xi.length!==He.length&&Rn("Mismatched type converter count");for(var hs=0;hs<He.length;++hs)t0(He[hs],Xi[hs])}var jt=new Array(Xe.length),ti=[],Vt=0;Xe.forEach((di,Xi)=>{jr.hasOwnProperty(di)?jt[Xi]=jr[di]:(ti.push(di),yr.hasOwnProperty(di)||(yr[di]=[]),yr[di].push(()=>{jt[Xi]=jr[di],++Vt,Vt===ti.length&&yt(jt)}))}),ti.length===0&&yt(jt)},Hi=He=>{var Xe=Us[He];delete Us[He];var lt=Xe.elements,yt=lt.length,jt=lt.map(di=>di.getterReturnType).concat(lt.map(di=>di.setterArgumentType)),ti=Xe.rawConstructor,Vt=Xe.rawDestructor;Vn([He],jt,di=>(lt.forEach((Xi,hs)=>{var Mi=di[hs],Ws=Xi.getter,Br=Xi.getterContext,Jr=di[hs+yt],Mn=Xi.setter,$n=Xi.setterContext;Xi.read=Hr=>Mi.fromWireType(Ws(Br,Hr)),Xi.write=(Hr,Ir)=>{var u0=[];Mn($n,Hr,Jr.toWireType(u0,Ir)),Mr(u0)}}),[{name:Xe.name,fromWireType:Xi=>{for(var hs=new Array(yt),Mi=0;Mi<yt;++Mi)hs[Mi]=lt[Mi].read(Xi);return Vt(Xi),hs},toWireType:(Xi,hs)=>{if(yt!==hs.length)throw new TypeError("Incorrect number of tuple elements for "+Xe.name+": expected="+yt+", actual="+hs.length);for(var Mi=ti(),Ws=0;Ws<yt;++Ws)lt[Ws].write(Mi,hs[Ws]);return Xi!==null&&Xi.push(Vt,Mi),Mi},argPackAdvance:y0,readValueFromPointer:ar,destructorFunction:Vt}]))},Ya={},_o=He=>{var Xe=Ya[He];delete Ya[He];var lt=Xe.rawConstructor,yt=Xe.rawDestructor,jt=Xe.fields,ti=jt.map(Vt=>Vt.getterReturnType).concat(jt.map(Vt=>Vt.setterArgumentType));Vn([He],ti,Vt=>{var di={};return jt.forEach((Xi,hs)=>{var Mi=Xi.fieldName,Ws=Vt[hs],Br=Xi.getter,Jr=Xi.getterContext,Mn=Vt[hs+jt.length],$n=Xi.setter,Hr=Xi.setterContext;di[Mi]={read:Ir=>Ws.fromWireType(Br(Jr,Ir)),write:(Ir,u0)=>{var tn=[];$n(Hr,Ir,Mn.toWireType(tn,u0)),Mr(tn)}}}),[{name:Xe.name,fromWireType:Xi=>{var hs={};for(var Mi in di)hs[Mi]=di[Mi].read(Xi);return yt(Xi),hs},toWireType:(Xi,hs)=>{for(var Mi in di)if(!(Mi in hs))throw new TypeError('Missing field: "'+Mi+'"');var Ws=lt();for(Mi in di)di[Mi].write(Ws,hs[Mi]);return Xi!==null&&Xi.push(yt,Ws),Ws},argPackAdvance:y0,readValueFromPointer:ar,destructorFunction:yt}]})},jo=(He,Xe,lt,yt,jt)=>{},aa=()=>{for(var He=new Array(256),Xe=0;Xe<256;++Xe)He[Xe]=String.fromCharCode(Xe);Ur=He},Ur,ur=He=>{for(var Xe="",lt=He;le[lt];)Xe+=Ur[le[lt++]];return Xe},Y0,vr=He=>{throw new Y0(He)};function Io(He,Xe,lt={}){var yt=Xe.name;if(He||vr('type "'+yt+'" must have a positive integer typeid pointer'),jr.hasOwnProperty(He)){if(lt.ignoreDuplicateRegistrations)return;vr("Cannot register type '"+yt+"' twice")}if(jr[He]=Xe,delete xn[He],yr.hasOwnProperty(He)){var jt=yr[He];delete yr[He],jt.forEach(ti=>ti())}}function t0(He,Xe,lt={}){if(!("argPackAdvance"in Xe))throw new TypeError("registerType registeredInstance requires argPackAdvance");return Io(He,Xe,lt)}var y0=8,v2=(He,Xe,lt,yt)=>{Xe=ur(Xe),t0(He,{name:Xe,fromWireType:function(jt){return!!jt},toWireType:function(jt,ti){return ti?lt:yt},argPackAdvance:y0,readValueFromPointer:function(jt){return this.fromWireType(le[jt])},destructorFunction:null})},bc=He=>({count:He.count,deleteScheduled:He.deleteScheduled,preservePointerOnDelete:He.preservePointerOnDelete,ptr:He.ptr,ptrType:He.ptrType,smartPtr:He.smartPtr,smartPtrType:He.smartPtrType}),Xx=He=>{function Xe(lt){return lt.$$.ptrType.registeredClass.name}vr(Xe(He)+" instance already deleted")},dl=!1,Jt=He=>{},Ec=He=>{He.smartPtr?He.smartPtrType.rawDestructor(He.smartPtr):He.ptrType.registeredClass.rawDestructor(He.ptr)},hn=He=>{He.count.value-=1;var Xe=He.count.value===0;Xe&&Ec(He)},a0=(He,Xe,lt)=>{if(Xe===lt)return He;if(lt.baseClass===void 0)return null;var yt=a0(He,Xe,lt.baseClass);return yt===null?null:lt.downcast(yt)},xa={},Uo=()=>Object.keys(Qt).length,ux=()=>{var He=[];for(var Xe in Qt)Qt.hasOwnProperty(Xe)&&He.push(Qt[Xe]);return He},U0=[],Yl=()=>{for(;U0.length;){var He=U0.pop();He.$$.deleteScheduled=!1,He.delete()}},tr,jx=He=>{tr=He,U0.length&&tr&&tr(Yl)},js=()=>{p.getInheritedInstanceCount=Uo,p.getLiveInheritedInstances=ux,p.flushPendingDeletes=Yl,p.setDelayFunction=jx},Qt={},$l=(He,Xe)=>{for(Xe===void 0&&vr("ptr should not be undefined");He.baseClass;)Xe=He.upcast(Xe),He=He.baseClass;return Xe},fh=(He,Xe)=>(Xe=$l(He,Xe),Qt[Xe]),V0=(He,Xe)=>{(!Xe.ptrType||!Xe.ptr)&&Rn("makeClassHandle requires ptr and ptrType");var lt=!!Xe.smartPtrType,yt=!!Xe.smartPtr;return lt!==yt&&Rn("Both smartPtrType and smartPtr must be specified"),Xe.count={value:1},$0(Object.create(He,{$$:{value:Xe,writable:!0}}))};function mh(He){var Xe=this.getPointee(He);if(!Xe)return this.destructor(He),null;var lt=fh(this.registeredClass,Xe);if(lt!==void 0){if(lt.$$.count.value===0)return lt.$$.ptr=Xe,lt.$$.smartPtr=He,lt.clone();var yt=lt.clone();return this.destructor(He),yt}function jt(){return this.isSmartPointer?V0(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:Xe,smartPtrType:this,smartPtr:He}):V0(this.registeredClass.instancePrototype,{ptrType:this,ptr:He})}var ti=this.registeredClass.getActualType(Xe),Vt=xa[ti];if(!Vt)return jt.call(this);var di;this.isConst?di=Vt.constPointerType:di=Vt.pointerType;var Xi=a0(Xe,this.registeredClass,di.registeredClass);return Xi===null?jt.call(this):this.isSmartPointer?V0(di.registeredClass.instancePrototype,{ptrType:di,ptr:Xi,smartPtrType:this,smartPtr:He}):V0(di.registeredClass.instancePrototype,{ptrType:di,ptr:Xi})}var $0=He=>typeof FinalizationRegistry>"u"?($0=Xe=>Xe,He):(dl=new FinalizationRegistry(Xe=>{hn(Xe.$$)}),$0=Xe=>{var lt=Xe.$$,yt=!!lt.smartPtr;if(yt){var jt={$$:lt};dl.register(Xe,jt,Xe)}return Xe},Jt=Xe=>dl.unregister(Xe),$0(He)),R2=()=>{Object.assign(fn.prototype,{isAliasOf(He){if(!(this instanceof fn)||!(He instanceof fn))return!1;var Xe=this.$$.ptrType.registeredClass,lt=this.$$.ptr;He.$$=He.$$;for(var yt=He.$$.ptrType.registeredClass,jt=He.$$.ptr;Xe.baseClass;)lt=Xe.upcast(lt),Xe=Xe.baseClass;for(;yt.baseClass;)jt=yt.upcast(jt),yt=yt.baseClass;return Xe===yt&&lt===jt},clone(){if(this.$$.ptr||Xx(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var He=$0(Object.create(Object.getPrototypeOf(this),{$$:{value:bc(this.$$)}}));return He.$$.count.value+=1,He.$$.deleteScheduled=!1,He},delete(){this.$$.ptr||Xx(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&vr("Object already scheduled for deletion"),Jt(this),hn(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||Xx(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&vr("Object already scheduled for deletion"),U0.push(this),U0.length===1&&tr&&tr(Yl),this.$$.deleteScheduled=!0,this}})};function fn(){}var dx=(He,Xe)=>Object.defineProperty(Xe,"name",{value:He}),M2=(He,Xe,lt)=>{if(He[Xe].overloadTable===void 0){var yt=He[Xe];He[Xe]=function(...jt){return He[Xe].overloadTable.hasOwnProperty(jt.length)||vr("Function '"+lt+"' called with an invalid number of arguments ("+jt.length+") - expects one of ("+He[Xe].overloadTable+")!"),He[Xe].overloadTable[jt.length].apply(this,jt)},He[Xe].overloadTable=[],He[Xe].overloadTable[yt.argCount]=yt}},gh=(He,Xe,lt)=>{p.hasOwnProperty(He)?((lt===void 0||p[He].overloadTable!==void 0&&p[He].overloadTable[lt]!==void 0)&&vr("Cannot register public name '"+He+"' twice"),M2(p,He,He),p.hasOwnProperty(lt)&&vr("Cannot register multiple overloads of a function with the same number of arguments ("+lt+")!"),p[He].overloadTable[lt]=Xe):(p[He]=Xe,lt!==void 0&&(p[He].numArguments=lt))},_h=48,_a=57,Jl=He=>{if(He===void 0)return"_unknown";He=He.replace(/[^a-zA-Z0-9_]/g,"$");var Xe=He.charCodeAt(0);return Xe>=_h&&Xe<=_a?"_"+He:He};function k2(He,Xe,lt,yt,jt,ti,Vt,di){this.name=He,this.constructor=Xe,this.instancePrototype=lt,this.rawDestructor=yt,this.baseClass=jt,this.getActualType=ti,this.upcast=Vt,this.downcast=di,this.pureVirtualFunctions=[]}var vx=(He,Xe,lt)=>{for(;Xe!==lt;)Xe.upcast||vr("Expected null or instance of "+lt.name+", got an instance of "+Xe.name),He=Xe.upcast(He),Xe=Xe.baseClass;return He};function yh(He,Xe){if(Xe===null)return this.isReference&&vr("null is not a valid "+this.name),0;Xe.$$||vr('Cannot pass "'+V2(Xe)+'" as a '+this.name),Xe.$$.ptr||vr("Cannot pass deleted object as a pointer of type "+this.name);var lt=Xe.$$.ptrType.registeredClass,yt=vx(Xe.$$.ptr,lt,this.registeredClass);return yt}function vc(He,Xe){var lt;if(Xe===null)return this.isReference&&vr("null is not a valid "+this.name),this.isSmartPointer?(lt=this.rawConstructor(),He!==null&&He.push(this.rawDestructor,lt),lt):0;(!Xe||!Xe.$$)&&vr('Cannot pass "'+V2(Xe)+'" as a '+this.name),Xe.$$.ptr||vr("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&Xe.$$.ptrType.isConst&&vr("Cannot convert argument of type "+(Xe.$$.smartPtrType?Xe.$$.smartPtrType.name:Xe.$$.ptrType.name)+" to parameter type "+this.name);var yt=Xe.$$.ptrType.registeredClass;if(lt=vx(Xe.$$.ptr,yt,this.registeredClass),this.isSmartPointer)switch(Xe.$$.smartPtr===void 0&&vr("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:Xe.$$.smartPtrType===this?lt=Xe.$$.smartPtr:vr("Cannot convert argument of type "+(Xe.$$.smartPtrType?Xe.$$.smartPtrType.name:Xe.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:lt=Xe.$$.smartPtr;break;case 2:if(Xe.$$.smartPtrType===this)lt=Xe.$$.smartPtr;else{var jt=Xe.clone();lt=this.rawShare(lt,l2.toHandle(()=>jt.delete())),He!==null&&He.push(this.rawDestructor,lt)}break;default:vr("Unsupporting sharing policy")}return lt}function fl(He,Xe){if(Xe===null)return this.isReference&&vr("null is not a valid "+this.name),0;Xe.$$||vr('Cannot pass "'+V2(Xe)+'" as a '+this.name),Xe.$$.ptr||vr("Cannot pass deleted object as a pointer of type "+this.name),Xe.$$.ptrType.isConst&&vr("Cannot convert argument of type "+Xe.$$.ptrType.name+" to parameter type "+this.name);var lt=Xe.$$.ptrType.registeredClass,yt=vx(Xe.$$.ptr,lt,this.registeredClass);return yt}var Ix=()=>{Object.assign(ho.prototype,{getPointee(He){return this.rawGetPointee&&(He=this.rawGetPointee(He)),He},destructor(He){var Xe;(Xe=this.rawDestructor)==null||Xe.call(this,He)},argPackAdvance:y0,readValueFromPointer:ar,fromWireType:mh})};function ho(He,Xe,lt,yt,jt,ti,Vt,di,Xi,hs,Mi){this.name=He,this.registeredClass=Xe,this.isReference=lt,this.isConst=yt,this.isSmartPointer=jt,this.pointeeType=ti,this.sharingPolicy=Vt,this.rawGetPointee=di,this.rawConstructor=Xi,this.rawShare=hs,this.rawDestructor=Mi,!jt&&Xe.baseClass===void 0?yt?(this.toWireType=yh,this.destructorFunction=null):(this.toWireType=fl,this.destructorFunction=null):this.toWireType=vc}var hi=(He,Xe,lt)=>{p.hasOwnProperty(He)||Rn("Replacing nonexistent public symbol"),p[He].overloadTable!==void 0&&lt!==void 0?p[He].overloadTable[lt]=Xe:(p[He]=Xe,p[He].argCount=lt)},Yn=(He,Xe,lt)=>{var yt=p["dynCall_"+He];return yt(Xe,...lt)},ml=[],uo,B2=He=>{var Xe=ml[He];return Xe||(He>=ml.length&&(ml.length=He+1),ml[He]=Xe=uo.get(He)),Xe},Ba=(He,Xe,lt=[])=>{if(He.includes("j"))return Yn(He,Xe,lt);var yt=B2(Xe)(...lt);return yt},bh=(He,Xe)=>(...lt)=>Ba(He,Xe,lt),x0=(He,Xe)=>{He=ur(He);function lt(){return He.includes("j")?bh(He,Xe):B2(Xe)}var yt=lt();return typeof yt!="function"&&vr("unknown function pointer with signature "+He+": "+Xe),yt},fo=(He,Xe)=>{var lt=dx(Xe,function(yt){this.name=Xe,this.message=yt;var jt=new Error(yt).stack;jt!==void 0&&(this.stack=this.toString()+`
`+jt.replace(/^Error(:[^\n]*)?\n/,""))});return lt.prototype=Object.create(He.prototype),lt.prototype.constructor=lt,lt.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},lt},Vo,U2=He=>{var Xe=at(He),lt=ur(Xe);return E0(Xe),lt},Wn=(He,Xe)=>{var lt=[],yt={};function jt(ti){if(!yt[ti]&&!jr[ti]){if(xn[ti]){xn[ti].forEach(jt);return}lt.push(ti),yt[ti]=!0}}throw Xe.forEach(jt),new Vo(He+": "+lt.map(U2).join([", "]))},Yx=(He,Xe,lt,yt,jt,ti,Vt,di,Xi,hs,Mi,Ws,Br)=>{Mi=ur(Mi),ti=x0(jt,ti),di&&(di=x0(Vt,di)),hs&&(hs=x0(Xi,hs)),Br=x0(Ws,Br);var Jr=Jl(Mi);gh(Jr,function(){Wn("Cannot construct "+Mi+" due to unbound types",[yt])}),Vn([He,Xe,lt],yt?[yt]:[],Mn=>{var $n;Mn=Mn[0];var Hr,Ir;yt?(Hr=Mn.registeredClass,Ir=Hr.instancePrototype):Ir=fn.prototype;var u0=dx(Mi,function(...Ee){if(Object.getPrototypeOf(this)!==tn)throw new Y0("Use 'new' to construct "+Mi);if(W0.constructor_body===void 0)throw new Y0(Mi+" has no accessible constructor");var an=W0.constructor_body[Ee.length];if(an===void 0)throw new Y0("Tried to invoke ctor of "+Mi+" with invalid number of parameters ("+Ee.length+") - expected ("+Object.keys(W0.constructor_body).toString()+") parameters instead!");return an.apply(this,Ee)}),tn=Object.create(Ir,{constructor:{value:u0}});u0.prototype=tn;var W0=new k2(Mi,u0,tn,Br,Hr,ti,di,hs);W0.baseClass&&(($n=W0.baseClass).__derivedClasses!=null||($n.__derivedClasses=[]),W0.baseClass.__derivedClasses.push(W0));var Va=new ho(Mi,W0,!0,!1,!1),R0=new ho(Mi+"*",W0,!1,!1,!1),mr=new ho(Mi+" const*",W0,!1,!0,!1);return xa[He]={pointerType:R0,constPointerType:mr},hi(Jr,u0),[Va,R0,mr]})},Yo=(He,Xe)=>{for(var lt=[],yt=0;yt<He;yt++)lt.push(ge[Xe+yt*4>>2]);return lt};function Ic(He){for(var Xe=1;Xe<He.length;++Xe)if(He[Xe]!==null&&He[Xe].destructorFunction===void 0)return!0;return!1}function Wo(He,Xe,lt,yt,jt,ti){var Vt=Xe.length;Vt<2&&vr("argTypes array size mismatch! Must at least get return value and 'this' types!");var di=Xe[1]!==null&&lt!==null,Xi=Ic(Xe),hs=Xe[0].name!=="void",Mi=Vt-2,Ws=new Array(Mi),Br=[],Jr=[],Mn=function(...$n){$n.length!==Mi&&vr("function "+He+" called with "+$n.length+" arguments, expected "+Mi),Jr.length=0;var Hr;Br.length=di?2:1,Br[0]=jt,di&&(Hr=Xe[1].toWireType(Jr,this),Br[1]=Hr);for(var Ir=0;Ir<Mi;++Ir)Ws[Ir]=Xe[Ir+2].toWireType(Jr,$n[Ir]),Br.push(Ws[Ir]);var u0=yt(...Br);function tn(W0){if(Xi)Mr(Jr);else for(var Va=di?1:2;Va<Xe.length;Va++){var R0=Va===1?Hr:Ws[Va-2];Xe[Va].destructorFunction!==null&&Xe[Va].destructorFunction(R0)}if(hs)return Xe[0].fromWireType(W0)}return tn(u0)};return dx(He,Mn)}var Eh=(He,Xe,lt,yt,jt,ti)=>{var Vt=Yo(Xe,lt);jt=x0(yt,jt),Vn([],[He],di=>{di=di[0];var Xi="constructor "+di.name;if(di.registeredClass.constructor_body===void 0&&(di.registeredClass.constructor_body=[]),di.registeredClass.constructor_body[Xe-1]!==void 0)throw new Y0("Cannot register multiple constructors with identical number of parameters ("+(Xe-1)+") for class '"+di.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return di.registeredClass.constructor_body[Xe-1]=()=>{Wn("Cannot construct "+di.name+" due to unbound types",Vt)},Vn([],Vt,hs=>(hs.splice(1,0,null),di.registeredClass.constructor_body[Xe-1]=Wo(Xi,hs,null,jt,ti),[])),[]})},Es=He=>{He=He.trim();const Xe=He.indexOf("(");return Xe!==-1?He.substr(0,Xe):He},vh=(He,Xe,lt,yt,jt,ti,Vt,di,Xi)=>{var hs=Yo(lt,yt);Xe=ur(Xe),Xe=Es(Xe),ti=x0(jt,ti),Vn([],[He],Mi=>{Mi=Mi[0];var Ws=Mi.name+"."+Xe;Xe.startsWith("@@")&&(Xe=Symbol[Xe.substring(2)]),di&&Mi.registeredClass.pureVirtualFunctions.push(Xe);function Br(){Wn("Cannot call "+Ws+" due to unbound types",hs)}var Jr=Mi.registeredClass.instancePrototype,Mn=Jr[Xe];return Mn===void 0||Mn.overloadTable===void 0&&Mn.className!==Mi.name&&Mn.argCount===lt-2?(Br.argCount=lt-2,Br.className=Mi.name,Jr[Xe]=Br):(M2(Jr,Xe,Ws),Jr[Xe].overloadTable[lt-2]=Br),Vn([],hs,$n=>{var Hr=Wo(Ws,$n,Mi,ti,Vt);return Jr[Xe].overloadTable===void 0?(Hr.argCount=lt-2,Jr[Xe]=Hr):Jr[Xe].overloadTable[lt-2]=Hr,[]}),[]})},t2=(He,Xe,lt)=>(He instanceof Object||vr(lt+' with invalid "this": '+He),He instanceof Xe.registeredClass.constructor||vr(lt+' incompatible with "this" of type '+He.constructor.name),He.$$.ptr||vr("cannot call emscripten binding method "+lt+" on deleted object"),vx(He.$$.ptr,He.$$.ptrType.registeredClass,Xe.registeredClass)),l0=(He,Xe,lt,yt,jt,ti,Vt,di,Xi,hs)=>{Xe=ur(Xe),jt=x0(yt,jt),Vn([],[He],Mi=>{Mi=Mi[0];var Ws=Mi.name+"."+Xe,Br={get(){Wn("Cannot access "+Ws+" due to unbound types",[lt,Vt])},enumerable:!0,configurable:!0};return Xi?Br.set=()=>Wn("Cannot access "+Ws+" due to unbound types",[lt,Vt]):Br.set=Jr=>vr(Ws+" is a read-only property"),Object.defineProperty(Mi.registeredClass.instancePrototype,Xe,Br),Vn([],Xi?[lt,Vt]:[lt],Jr=>{var Mn=Jr[0],$n={get(){var Ir=t2(this,Mi,Ws+" getter");return Mn.fromWireType(jt(ti,Ir))},enumerable:!0};if(Xi){Xi=x0(di,Xi);var Hr=Jr[1];$n.set=function(Ir){var u0=t2(this,Mi,Ws+" setter"),tn=[];Xi(hs,u0,Hr.toWireType(tn,Ir)),Mr(tn)}}return Object.defineProperty(Mi.registeredClass.instancePrototype,Xe,$n),[]}),[]})},a2=[],Bt=[],x2=He=>{He>9&&--Bt[He+1]===0&&(Bt[He]=void 0,a2.push(He))},Ro=()=>Bt.length/2-5-a2.length,$x=()=>{Bt.push(0,1,void 0,1,null,1,!0,1,!1,1),p.count_emval_handles=Ro},l2={toValue:He=>(He||vr("Cannot use deleted val. handle = "+He),Bt[He]),toHandle:He=>{switch(He){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const Xe=a2.pop()||Bt.length;return Bt[Xe]=He,Bt[Xe+1]=1,Xe}}}},da={name:"emscripten::val",fromWireType:He=>{var Xe=l2.toValue(He);return x2(He),Xe},toWireType:(He,Xe)=>l2.toHandle(Xe),argPackAdvance:y0,readValueFromPointer:ar,destructorFunction:null},h0=He=>t0(He,da),V2=He=>{if(He===null)return"null";var Xe=typeof He;return Xe==="object"||Xe==="array"||Xe==="function"?He.toString():""+He},Jx=(He,Xe)=>{switch(Xe){case 4:return function(lt){return this.fromWireType(be[lt>>2])};case 8:return function(lt){return this.fromWireType(ye[lt>>3])};default:throw new TypeError("invalid float width ("+Xe+"): "+He)}},Ho=(He,Xe,lt)=>{Xe=ur(Xe),t0(He,{name:Xe,fromWireType:yt=>yt,toWireType:(yt,jt)=>jt,argPackAdvance:y0,readValueFromPointer:Jx(Xe,lt),destructorFunction:null})},Xo=(He,Xe,lt)=>{switch(Xe){case 1:return lt?yt=>xe[yt]:yt=>le[yt];case 2:return lt?yt=>he[yt>>1]:yt=>de[yt>>1];case 4:return lt?yt=>me[yt>>2]:yt=>ge[yt>>2];default:throw new TypeError("invalid integer width ("+Xe+"): "+He)}},Ih=(He,Xe,lt,yt,jt)=>{Xe=ur(Xe);var ti=Mi=>Mi;if(yt===0){var Vt=32-8*lt;ti=Mi=>Mi<<Vt>>>Vt}var di=Xe.includes("unsigned"),Xi=(Mi,Ws)=>{},hs;di?hs=function(Mi,Ws){return Xi(Ws,this.name),Ws>>>0}:hs=function(Mi,Ws){return Xi(Ws,this.name),Ws},t0(He,{name:Xe,fromWireType:ti,toWireType:hs,argPackAdvance:y0,readValueFromPointer:Xo(Xe,lt,yt!==0),destructorFunction:null})},Rh=(He,Xe,lt)=>{var yt=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],jt=yt[Xe];function ti(Vt){var di=ge[Vt>>2],Xi=ge[Vt+4>>2];return new jt(xe.buffer,Xi,di)}lt=ur(lt),t0(He,{name:lt,fromWireType:ti,argPackAdvance:y0,readValueFromPointer:ti},{ignoreDuplicateRegistrations:!0})},Rc=(He,Xe,lt,yt)=>{if(!(yt>0))return 0;for(var jt=lt,ti=lt+yt-1,Vt=0;Vt<He.length;++Vt){var di=He.charCodeAt(Vt);if(di>=55296&&di<=57343){var Xi=He.charCodeAt(++Vt);di=65536+((di&1023)<<10)|Xi&1023}if(di<=127){if(lt>=ti)break;Xe[lt++]=di}else if(di<=2047){if(lt+1>=ti)break;Xe[lt++]=192|di>>6,Xe[lt++]=128|di&63}else if(di<=65535){if(lt+2>=ti)break;Xe[lt++]=224|di>>12,Xe[lt++]=128|di>>6&63,Xe[lt++]=128|di&63}else{if(lt+3>=ti)break;Xe[lt++]=240|di>>18,Xe[lt++]=128|di>>12&63,Xe[lt++]=128|di>>6&63,Xe[lt++]=128|di&63}}return Xe[lt]=0,lt-jt},h2=(He,Xe,lt)=>Rc(He,le,Xe,lt),u2=He=>{for(var Xe=0,lt=0;lt<He.length;++lt){var yt=He.charCodeAt(lt);yt<=127?Xe++:yt<=2047?Xe+=2:yt>=55296&&yt<=57343?(Xe+=4,++lt):Xe+=3}return Xe},yo=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Mh=(He,Xe,lt)=>{for(var yt=Xe+lt,jt=Xe;He[jt]&&!(jt>=yt);)++jt;if(jt-Xe>16&&He.buffer&&yo)return yo.decode(He.subarray(Xe,jt));for(var ti="";Xe<jt;){var Vt=He[Xe++];if(!(Vt&128)){ti+=String.fromCharCode(Vt);continue}var di=He[Xe++]&63;if((Vt&224)==192){ti+=String.fromCharCode((Vt&31)<<6|di);continue}var Xi=He[Xe++]&63;if((Vt&240)==224?Vt=(Vt&15)<<12|di<<6|Xi:Vt=(Vt&7)<<18|di<<12|Xi<<6|He[Xe++]&63,Vt<65536)ti+=String.fromCharCode(Vt);else{var hs=Vt-65536;ti+=String.fromCharCode(55296|hs>>10,56320|hs&1023)}}return ti},Mc=(He,Xe)=>He?Mh(le,He,Xe):"",d2=(He,Xe)=>{Xe=ur(Xe);var lt=Xe==="std::string";t0(He,{name:Xe,fromWireType(yt){var jt=ge[yt>>2],ti=yt+4,Vt;if(lt)for(var di=ti,Xi=0;Xi<=jt;++Xi){var hs=ti+Xi;if(Xi==jt||le[hs]==0){var Mi=hs-di,Ws=Mc(di,Mi);Vt===void 0?Vt=Ws:(Vt+="\0",Vt+=Ws),di=hs+1}}else{for(var Br=new Array(jt),Xi=0;Xi<jt;++Xi)Br[Xi]=String.fromCharCode(le[ti+Xi]);Vt=Br.join("")}return E0(yt),Vt},toWireType(yt,jt){jt instanceof ArrayBuffer&&(jt=new Uint8Array(jt));var ti,Vt=typeof jt=="string";Vt||jt instanceof Uint8Array||jt instanceof Uint8ClampedArray||jt instanceof Int8Array||vr("Cannot pass non-string to std::string"),lt&&Vt?ti=u2(jt):ti=jt.length;var di=v0(4+ti+1),Xi=di+4;if(ge[di>>2]=ti,lt&&Vt)h2(jt,Xi,ti+1);else if(Vt)for(var hs=0;hs<ti;++hs){var Mi=jt.charCodeAt(hs);Mi>255&&(E0(Xi),vr("String has UTF-16 code units that do not fit in 8 bits")),le[Xi+hs]=Mi}else for(var hs=0;hs<ti;++hs)le[Xi+hs]=jt[hs];return yt!==null&&yt.push(E0,di),di},argPackAdvance:y0,readValueFromPointer:ar,destructorFunction(yt){E0(yt)}})},b0=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,gl=(He,Xe)=>{for(var lt=He,yt=lt>>1,jt=yt+Xe/2;!(yt>=jt)&&de[yt];)++yt;if(lt=yt<<1,lt-He>32&&b0)return b0.decode(le.subarray(He,lt));for(var ti="",Vt=0;!(Vt>=Xe/2);++Vt){var di=he[He+Vt*2>>1];if(di==0)break;ti+=String.fromCharCode(di)}return ti},_l=(He,Xe,lt)=>{if(lt!=null||(lt=2147483647),lt<2)return 0;lt-=2;for(var yt=Xe,jt=lt<He.length*2?lt/2:He.length,ti=0;ti<jt;++ti){var Vt=He.charCodeAt(ti);he[Xe>>1]=Vt,Xe+=2}return he[Xe>>1]=0,Xe-yt},W2=He=>He.length*2,la=(He,Xe)=>{for(var lt=0,yt="";!(lt>=Xe/4);){var jt=me[He+lt*4>>2];if(jt==0)break;if(++lt,jt>=65536){var ti=jt-65536;yt+=String.fromCharCode(55296|ti>>10,56320|ti&1023)}else yt+=String.fromCharCode(jt)}return yt},Bc=(He,Xe,lt)=>{if(lt!=null||(lt=2147483647),lt<4)return 0;for(var yt=Xe,jt=yt+lt-4,ti=0;ti<He.length;++ti){var Vt=He.charCodeAt(ti);if(Vt>=55296&&Vt<=57343){var di=He.charCodeAt(++ti);Vt=65536+((Vt&1023)<<10)|di&1023}if(me[Xe>>2]=Vt,Xe+=4,Xe+4>jt)break}return me[Xe>>2]=0,Xe-yt},H2=He=>{for(var Xe=0,lt=0;lt<He.length;++lt){var yt=He.charCodeAt(lt);yt>=55296&&yt<=57343&&++lt,Xe+=4}return Xe},f2=(He,Xe,lt)=>{lt=ur(lt);var yt,jt,ti,Vt;Xe===2?(yt=gl,jt=_l,Vt=W2,ti=di=>de[di>>1]):Xe===4&&(yt=la,jt=Bc,Vt=H2,ti=di=>ge[di>>2]),t0(He,{name:lt,fromWireType:di=>{for(var Xi=ge[di>>2],hs,Mi=di+4,Ws=0;Ws<=Xi;++Ws){var Br=di+4+Ws*Xe;if(Ws==Xi||ti(Br)==0){var Jr=Br-Mi,Mn=yt(Mi,Jr);hs===void 0?hs=Mn:(hs+="\0",hs+=Mn),Mi=Br+Xe}}return E0(di),hs},toWireType:(di,Xi)=>{typeof Xi!="string"&&vr("Cannot pass non-string to C++ string type "+lt);var hs=Vt(Xi),Mi=v0(4+hs+Xe);return ge[Mi>>2]=hs/Xe,jt(Xi,Mi+4,hs+Xe),di!==null&&di.push(E0,Mi),Mi},argPackAdvance:y0,readValueFromPointer:ar,destructorFunction(di){E0(di)}})},yl=(He,Xe,lt,yt,jt,ti)=>{Us[He]={name:ur(Xe),rawConstructor:x0(lt,yt),rawDestructor:x0(jt,ti),elements:[]}},fx=(He,Xe,lt,yt,jt,ti,Vt,di,Xi)=>{Us[He].elements.push({getterReturnType:Xe,getter:x0(lt,yt),getterContext:jt,setterArgumentType:ti,setter:x0(Vt,di),setterContext:Xi})},X2=(He,Xe,lt,yt,jt,ti)=>{Ya[He]={name:ur(Xe),rawConstructor:x0(lt,yt),rawDestructor:x0(jt,ti),fields:[]}},Uc=(He,Xe,lt,yt,jt,ti,Vt,di,Xi,hs)=>{Ya[He].fields.push({fieldName:ur(Xe),getterReturnType:lt,getter:x0(yt,jt),getterContext:ti,setterArgumentType:Vt,setter:x0(di,Xi),setterContext:hs})},bl=(He,Xe)=>{Xe=ur(Xe),t0(He,{isVoid:!0,name:Xe,argPackAdvance:0,fromWireType:()=>{},toWireType:(lt,yt)=>{}})},Bh=(He,Xe)=>{var lt=jr[He];return lt===void 0&&vr(Xe+" has unknown type "+U2(He)),lt},El=(He,Xe)=>{He=Bh(He,"_emval_take_value");var lt=He.readValueFromPointer(Xe);return l2.toHandle(lt)},Vc=()=>{vi("")},Uh=(He,Xe,lt)=>le.copyWithin(He,Xe,Xe+lt),J0=()=>2147483648,mx=He=>{var Xe=Z.buffer,lt=(He-Xe.byteLength+65535)/65536;try{return Z.grow(lt),ve(),1}catch{}},m2=He=>{var Xe=le.length;He>>>=0;var lt=J0();if(He>lt)return!1;for(var yt=(Xi,hs)=>Xi+(hs-Xi%hs)%hs,jt=1;jt<=4;jt*=2){var ti=Xe*(1+.2/jt);ti=Math.min(ti,He+100663296);var Vt=Math.min(lt,yt(Math.max(He,ti),65536)),di=mx(Vt);if(di)return!0}return!1};dn=p.InternalError=class extends Error{constructor(He){super(He),this.name="InternalError"}},aa(),Y0=p.BindingError=class extends Error{constructor(He){super(He),this.name="BindingError"}},R2(),js(),Ix(),Vo=p.UnboundTypeError=fo(Error,"UnboundTypeError"),$x();var as={b:bs,h:Hi,x:_o,q:jo,v:v2,l:Yx,g:Eh,c:vh,f:l0,u:h0,n:Ho,e:Ih,a:Rh,m:d2,j:f2,i:yl,d:fx,o:X2,k:Uc,w:bl,p:El,r:Vc,t:Uh,s:m2},Ua=Ei(),E0=He=>(E0=Ua.A)(He),v0=He=>(v0=Ua.B)(He),at=He=>(at=Ua.D)(He),Je=He=>(Je=Ua.E)(He),Rt;gi=function He(){Rt||_t(),Rt||(gi=He)};function _t(){if(mi>0||(xt(),mi>0))return;function He(){Rt||(Rt=!0,p.calledRun=!0,!te&&(bt(),_(p),p.onRuntimeInitialized&&p.onRuntimeInitialized(),gt()))}p.setStatus?(p.setStatus("Running..."),setTimeout(function(){setTimeout(function(){p.setStatus("")},1),He()},1)):He()}if(p.preInit)for(typeof p.preInit=="function"&&(p.preInit=[p.preInit]);p.preInit.length>0;)p.preInit.pop()();return _t(),d.ready}})();class SM{constructor(){this.faceTracks=[],this.faceFilters=[],this.meshScore=.9}async process(d,p){var _,E,S,I,D,k;const V=sV(()=>{const he=CB(CY(d,3),"float32"),de=LA(he,1/255);return r0(de,0)});let $=[];this.faceTracks.length===0&&($=await((_=this.faceDetector)==null?void 0:_.process(V,!0))||[],$.forEach(he=>{if(!he.keypoints)return;const{box:de}=he,me=.5*.3*(he.box[1][1]-he.box[0][1]);this.faceTracks.push({box:[[de[0][0],de[0][1]-me],[de[1][0],de[1][1]+me]],symmetry:[he.keypoints[Si.Mouth],he.keypoints[Si.Nose]]}),this.faceFilters.push(new this.faceModule.FaceFilter({minCutOff:1,minCutOffD:2,beta:30},{minCutOff:1,minCutOffD:2,beta:30},1))}),(E=this.bodySegmentor)==null||E.reset());const Z=this.faceTracks.length>0?((S=this.meshDetector)==null?void 0:S.process(V,this.faceTracks))||[]:[],te=[],xe=[],le=[];for(let he=0;he<this.faceTracks.length;he++){const de=Z[he],{box:me}=de,ge=[de.keypoints[((I=this.meshDetector)==null?void 0:I.symmetryPoints[0])||0],de.keypoints[((D=this.meshDetector)==null?void 0:D.symmetryPoints[1])||0]];if(QY(this.faceTracks[he].box,me)>.5&&de.score>this.meshScore){if(le.push(de),te.push({box:me,symmetry:[{x:ge[0][0],y:ge[0][1]},{x:ge[1][0],y:ge[1][1]}]}),p===void 0)continue;const[be,ye]=[V.shape[1],V.shape[2]],[ve,Ie]=[me[1][0]-me[0][0],me[1][1]-me[0][1]],je=(ve+Ie*ye/be)*.5;this.faceFilters[he].smoothFilter(de,p,1/je),de.keypoints=this.faceFilters[he].smoothPixel(),de.box=this.faceFilters[he].smoothBox(),de.mask=(k=this.bodySegmentor)==null?void 0:k.process(V,[[me[0][0]-ve*.5,me[0][1]-Ie*.5],[me[1][0]+ve*.5,me[1][1]+Ie*.5]]),xe.push(this.faceFilters[he])}else this.faceFilters[he].delete()}return V.dispose(),this.faceTracks=te,this.faceFilters=xe,le}align(d){var p;const _=new this.faceModule.VectorFloat;return d.flat().forEach(E=>_.push_back(E)),(p=this.faceAligner)==null||p.align(_),_.delete(),this.alignTransform()}alignTransform(){if(!this.faceAligner)return;const d=this.faceAligner.rotation,p=this.faceAligner.translation,_=this.faceAligner.scale,E=this.faceAligner.shapeScale;return{rotation:[d[0],d[1],d[2],d[3]],translation:[p[0],p[1],p[2]],scale:_,shapeScale:[E[0],E[1],E[2]]}}metricPoints(){if(!this.faceAligner)return;let d=[];const p=this.faceAligner.metricPoints();for(let _=0;_<p.size();_+=3)d.push([p.get(_+0),p.get(_+1),p.get(_+2)]);return p.delete(),d}referencePoints(){if(!this.faceAligner)return;let d=[];const p=this.faceAligner.referencePoints();for(let _=0;_<p.size();_+=3)d.push([p.get(_+0),p.get(_+1),p.get(_+2)]);return p.delete(),d}backprojPoints(){if(!this.faceAligner)return;let d=[];const p=this.faceAligner.backprojPoints();for(let _=0;_<p.size();_+=3)d.push([p.get(_+0),p.get(_+1),p.get(_+2)]);return p.delete(),d}setCamera(d,p,_){var E;(E=this.faceAligner)==null||E.setCamera(d,p,_)}async init(d,p="./",_=!1,E=!1,S=!1,I="webgl"){const D=await Qb({locateFile:me=>p+me});D.Loader.prototype.promisify=function(me,...ge){return me.call(this,...ge),new Promise(be=>{const ye=setInterval(()=>{if(this.ready)return clearInterval(ye),be(this.status)},5)})},D.Loader.prototype.load=function(me){return this.promisify(this.loadAsync,me,_)},D.Loader.prototype.remove=function(me){return this.promisify(this.removeAsync,me)},D.DictLoader.prototype.loadDict=function(me){return this.promisify(this.loadDictAsync,d,me)};const k=new D.ParseLoader(p),[V,$]=S?["faceext.wasm","meshextmodel.def"]:["face.wasm","meshmodel.def"],Z=[V,"faceutils.wasm"];if(E&&Z.push("mask.wasm"),!_)for(const me of Z)await k.remove(me);if(!await k.loadDict(Z)||!await k.load(V)||!k.parse())return;oQ().set("WEBGL_USE_SHAPES_UNIFORMS",!0),sb(),await z1(I);const te={weightUrlConverter:async me=>me,fetchFunc:async me=>{const ge=new Blob([k.file(me)]);return fetch(URL.createObjectURL(ge))}},xe=await pg("facemodel.def",te),le=await pg($,te),he=E&&await k.load("mask.wasm")&&k.parse()&&await pg("maskmodel.def",te);if(this.faceDetector=new Sn(xe),this.meshDetector=new Se(le),he&&(this.bodySegmentor=new SW(he,typeof E=="object"&&E.smooth)),!await k.load("faceutils.wasm"))return;const de=await Sd({wasmBinary:k.data()});k.delete(),de.FaceFilter.prototype.smoothFilter=function(me,ge){const be=new de.VectorFloat,ye=new de.VectorFloat;me.keypoints.flat().forEach(ve=>be.push_back(ve)),me.box.flat().forEach(ve=>ye.push_back(ve)),this.filter(be,ye,me.score,ge,1),be.delete(),ye.delete()},de.FaceFilter.prototype.smoothPixel=function(){let me=[];const ge=this.pixel();for(let be=0;be<ge.size();be+=3)me.push([ge.get(be+0),ge.get(be+1),ge.get(be+2)]);return ge.delete(),me},de.FaceFilter.prototype.smoothBox=function(){const me=this.box(),ge=[[me[0],me[1]],[me[2],me[3]]];return me.delete(),ge},this.faceModule=de,this.faceAligner=new this.faceModule.FaceAligner}reset(){var d;this.faceFilters.forEach(p=>p.delete()),this.faceFilters=[],this.faceTracks=[],(d=this.bodySegmentor)==null||d.reset()}async prepare(){var d,p,_;oQ().set("ENGINE_COMPILE_ONLY",!0),await((d=this.faceDetector)==null?void 0:d.prepare()),await((p=this.meshDetector)==null?void 0:p.prepare()),await((_=this.bodySegmentor)==null?void 0:_.prepare());const E=z4();E instanceof OU&&(E.checkCompileCompletion(),E.getUniformLocations()),oQ().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var d,p,_,E;this.reset(),(d=this.faceDetector)==null||d.dispose(),(p=this.meshDetector)==null||p.dispose(),(_=this.bodySegmentor)==null||_.dispose(),(E=this.faceAligner)==null||E.delete()}}var SU=Object.defineProperty,SJ=Object.getOwnPropertySymbols,St=Object.prototype.hasOwnProperty,Sv=Object.prototype.propertyIsEnumerable,Sh=(m,d,p)=>d in m?SU(m,d,{enumerable:!0,configurable:!0,writable:!0,value:p}):m[d]=p,SY=(m,d)=>{for(var p in d||(d={}))St.call(d,p)&&Sh(m,p,d[p]);if(SJ)for(var p of SJ(d))Sv.call(d,p)&&Sh(m,p,d[p]);return m};class Sm{constructor(d){this.model=d,this.handsMax=1,this.iouThresh=.3,this.scoreThresh=.45,this.model=d,this.modelSize=d.inputs[0].shape?{width:d.inputs[0].shape[2],height:d.inputs[0].shape[1]}:{width:192,height:192},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=TA(this.anchorsData.map(p=>p.x)),this.anchorsY=TA(this.anchorsData.map(p=>p.y))}async process(d){let p={x:0,y:0};const[_,E]=sV(()=>{const V={width:d.shape[2],height:d.shape[1]},$=V.width/V.height;let Z=SY({},V),te={x:0,y:0};$>this.modelRatio?(Z.height=d.shape[2]/this.modelRatio,te.y=Math.floor((Z.height-d.shape[1])*.5),p.y=te.y/Z.height):$<this.modelRatio&&(Z.width=d.shape[1]*this.modelRatio,te.x=Math.floor((Z.width-d.shape[2])*.5),p.x=te.x/Z.width);const xe=rS(d,[[0,0],[te.y,te.y],[te.x,te.x],[0,0]],0),le=qO.resizeBilinear(xe,[this.modelSize.height,this.modelSize.width]),he=this.model.execute(le,"palm"),de=Tr(K0(he,[0,0,1],[1,-1,-1])),me=Tr(K0(he,[0,0,0],[1,-1,1])),ge=LV(Ko(me,-100,100));return[this.decodeBoxes(de,[this.anchorsX,this.anchorsY],this.modelSize),ge]}),S=await _.data(),I=await E.data();let D=[];for(let V=0;V<I.length;V++){if(I[V]<this.scoreThresh)continue;const $=S[V*18+2]-S[V*18+0],Z=S[V*18+3]-S[V*18+1];$<0||Z<0||D.push({box:[[S[V*18+0],S[V*18+1]],[S[V*18+2],S[V*18+3]]],points:[[S[V*18+4],S[V*18+5]],[S[V*18+6],S[V*18+7]],[S[V*18+8],S[V*18+9]],[S[V*18+10],S[V*18+11]],[S[V*18+12],S[V*18+13]],[S[V*18+14],S[V*18+15]],[S[V*18+16],S[V*18+17]]],score:I[V]})}if(_.dispose(),E.dispose(),D.length<1)return[];if(D.length>1){const V=TZ(D.map(le=>[le.box[0][1],le.box[0][0],le.box[1][1],le.box[1][0]])),$=TA(D.map(le=>le.score)),Z=await qO.nonMaxSuppressionAsync(V,$,this.handsMax,this.iouThresh,this.scoreThresh),te=await Z.data();Z.dispose();const xe=[];for(let le=0;le<te.length;le++)xe.push(D[te[le]]);D=xe}if(D.length<1)return[];const k={width:1-2*p.x,height:1-2*p.y};return D.map(V=>({points:V.points.map($=>[($[0]-p.x)/k.width,($[1]-p.y)/k.height]),box:V.box.map($=>[($[0]-p.x)/k.width,($[1]-p.y)/k.height]),score:V.score}))}decodeBoxes(d,p,_){let E=Tr(K0(d,[0,0],[-1,1])),S=Tr(K0(d,[0,1],[-1,1])),I=Tr(K0(d,[0,2],[-1,1])),D=Tr(K0(d,[0,3],[-1,1]));E=LT(Lp(E,_.width),p[0]),S=LT(Lp(S,_.height),p[1]),I=Lp(I,_.width*2),D=Lp(D,_.height*2);const k=Lv(rT(E,I),[2016,1]),V=Lv(rT(S,D),[2016,1]),$=Lv(LT(E,I),[2016,1]),Z=Lv(LT(S,D),[2016,1]);let te=KG([k,V,$,Z],1);for(let xe=0;xe<7;xe++){let le=Tr(K0(d,[0,4+xe*2],[-1,1])),he=Tr(K0(d,[0,4+xe*2+1],[-1,1]));le=Lv(LT(Lp(le,_.width),p[0]),[2016,1]),he=Lv(LT(Lp(he,_.height),p[1]),[2016,1]),te=KG([te,le,he],1)}return te}buildAnchors(d){const p=[8,16,16,16],_=[];let E=0;for(;E<4;){let S=0,I=E;for(;I<p.length&&p[I]===p[E];)S+=2,I++;const D=p[E],k=Math.ceil(d.height/D),V=Math.ceil(d.width/D);for(let $=0;$<k;++$)for(let Z=0;Z<V;++Z)for(let te=0;te<S;++te)_.push({x:(Z+.5)/V,y:($+.5)/k});E=I}return _}async prepare(){const{width:d,height:p}=this.modelSize,_=rD([1,p,d,3]),E=this.model.execute(_,"palm");await E.data(),_.dispose(),E.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}var Sx;(m=>(m.add=(d,p)=>[d[0]+p[0],d[1]+p[1],d[2]+p[2]],m.sub=(d,p)=>[d[0]-p[0],d[1]-p[1],d[2]-p[2]],m.cross=(d,p)=>[d[1]*p[2]-d[2]*p[1],d[2]*p[0]-d[0]*p[2],d[0]*p[1]-d[1]*p[0]],m.lerp=(d,p,_)=>[d[0]+(p[0]-d[0])*_,d[1]+(p[1]-d[1])*_,d[2]+(p[2]-d[2])*_],m.scale=(d,p)=>[d[0]*p,d[1]*p,d[2]*p],m.negate=d=>[-d[0],-d[1],-d[2]],m.normalize=d=>(0,m.scale)(d,1/(0,m.length)(d)),m.normalizeToLen=(d,p)=>(0,m.scale)(d,p/(0,m.length)(d)),m.dot=(d,p)=>d[0]*p[0]+d[1]*p[1]+d[2]*p[2],m.lengthSqr=d=>d[0]**2+d[1]**2+d[2]**2,m.length=d=>Math.sqrt(d[0]**2+d[1]**2+d[2]**2)))(Sx||(Sx={}));class Sl{constructor(d,p=!0){this.model=d,this.wrist=p,this.localMaxSize={width:256,height:256},this.circlePoints=[],this.colorWeights=[.5,1,.8],this.colorThresh=.05,this.edgeThresh=.003,this.edgeStop=.01,this.model=d,this.modelSize=d.inputs[0].shape?{width:d.inputs[0].shape[2],height:d.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.buildCircle(31)}process(d,p){const[_,E]=[d.shape[1],d.shape[2]],{modelSize:S,modelRatio:I,localMaxSize:D}=this;return p.map(k=>{const V=[k.start[0]*E,k.start[1]*_],$=[k.end[0]*E,k.end[1]*_];let[Z,te]=[$[0]-V[0],V[1]-$[1]];const xe=Math.sqrt(Z**2+te**2);Z/=xe,te/=xe;const le=Math.atan2(Z,te),he=[.5*(k.box[0][0]+k.box[1][0])*E,.5*(k.box[0][1]+k.box[1][1])*_];let de=.5*(k.box[1][0]-k.box[0][0])*E,me=.5*(k.box[1][1]-k.box[0][1])*_;const ge=de/me/I;ge>1?de*=ge:me/=ge;const be=[he[1]-me,he[0]-de,he[1]+me,he[0]+de],ye=sV(()=>this.rotatedRect(d,be,le,!1,S)),ve=["Identity_2:0","Identity_1:0","Identity:0","Identity_3:0"],[Ie,je,Me,xt]=this.model.execute(ye,ve),bt=Ie.dataSync(),gt=xt.dataSync(),Xt=je.dataSync()[0],Ut=2*Me.dataSync()[0]-1;let Ht=[];for(let Nt=0;Nt<21;Nt++)Ht.push([bt[3*Nt+0]/S.width,bt[3*Nt+1]/S.height,bt[3*Nt+2]/S.width/.4]);const mi=[Ht[0][0],Ht[0][1]];let gi=mi[0],Ui=mi[1];gi=(gi-.5)*2*de,Ui=(Ui-.5)*2*me,mi[0]=gi*te-Ui*Z+he[0],mi[1]=gi*Z+Ui*te+he[1];const yi=[mi[1]-me,mi[0]-de,mi[1]+me,mi[0]+de],vi=this.wrist?sV(()=>this.rotatedRect(d,yi,le,!0,D)):void 0;let ts=[],us=[];const bi=vi?sV(()=>{const Nt=Tr(vi,[0]),$t=CR(Nt,[[.299,-.14713,.615],[.587,-.28886,-.51499],[.114,.436,-.10001]]),li=[[[[-.25],[-.25],[-.25]],[[0],[0],[0]],[[.25],[.25],[.25]]],[[[-.5],[-.5],[-.5]],[[0],[0],[0]],[[.5],[.5],[.5]]],[[[-.25],[-.25],[-.25]],[[0],[0],[0]],[[.25],[.25],[.25]]]],Ei=[[[[-.25],[-.25],[-.25]],[[-.5],[-.5],[-.5]],[[-.25],[-.25],[-.25]]],[[[0],[0],[0]],[[0],[0],[0]],[[0],[0],[0]]],[[[.25],[.25],[.25]],[[.5],[.5],[.5]],[[.25],[.25],[.25]]]],xs=KZ($t,li,1,"same"),Vs=KZ($t,Ei,1,"same"),ms=Km(Kh(xs),2,!0),bs=Km(Kh(Vs),2,!0),Us=Km(LA(xs,Vs),2,!0),Mr=LT(ms,bs),ar=Kt(LT(Kh(rT(ms,bs)),LA(Kh(Us),4))),yr=LA(LT(Mr,ar),.5);let jr=Kz([rT(yr,bs),Us],2);jr=Lp(jr,KV(jr,2,!0));let xn=ar;if(this.backend&&this.localMaxProg){const vr=this.backend.compileAndRun(this.localMaxProg,[xn,jr]);xn=sa().makeTensorFromTensorInfo(vr)}const dn=LA(LY($t,4,4,"valid"),this.colorWeights),Rn=dn.shape,Vn=[Rn[0]/2,Rn[1]/2],Hi=Lv(dn,[Rn[0],Rn[1],1,3]),Ya=Tz(dn,[Vn[0]-3,Vn[1]-4,0],[7,9,3]),_o=KW(KV(rT(Hi,Lv(Ya,[-1,3])),3,!1),2,!0),jo=Tz(dn,[Vn[0]-4,8,0],[2,8,3]),aa=Tz(dn,[Vn[0]-4,Rn[1]-16,0],[2,8,3]),Ur=Lb([Lv(jo,[-1,3]),Lv(aa,[-1,3])],0),ur=KW(KV(rT(Hi,Ur),3,!1),2,!0),Y0=ru(rp(rz(_o,ur),rz(_o,[this.colorThresh])),9,"max","same");return{yuv:$t,rgb:Nt,edgeVal:xn,edgeXY:jr,fg:Y0}}):void 0,Ri=bi?sV(()=>{const Nt=rA(bi.edgeVal,4,4,"valid");let $t=LY(bi.edgeXY,4,4,"valid");$t=Lp($t,KV($t,2,!0));const li=Nt.dataSync(),Ei=$t.dataSync(),xs=bi.fg.dataSync(),Vs=this.circlePoints.map(yr=>this.evaluateLine([64/2,64/2],yr,li,Ei,xs));let ms=0,bs=0,Us=-1;for(let yr=0;yr<Vs.length;yr++){const jr=Vs[yr].strengthL;for(let xn=yr;xn<yr+12&&xn<Vs.length;xn++){const dn=jr+Vs[xn].strengthR;dn>=Us&&(Us=dn,ms=yr,bs=xn)}}ts.push([...this.circlePoints[Math.round(.5*(ms+bs))]]);const Mr=Vs[ms].anchorsL.map(yr=>[yr[0],yr[1]]),ar=Vs[bs].anchorsR.map(yr=>[yr[0],yr[1]]);ts.push(...Mr),ts.push(...ar),us.push(this.fitLine(Mr)),us.push(this.fitLine(ar))}):void 0;return ye.dispose(),Ie.dispose(),xt.dispose(),je.dispose(),Me.dispose(),vi?.dispose(),bi?.yuv.dispose(),bi?.rgb.dispose(),bi?.edgeVal.dispose(),bi?.edgeXY.dispose(),{points:Ht,metricData:gt,score:Xt,handedness:Ut,radiusX:de,radiusY:me,angle:le,anchors:ts,lines:us,center:he,wristCenter:mi,wristDebug:Ri}}).map((k,V)=>{const{points:$,metricData:Z,score:te,handedness:xe,radiusX:le,radiusY:he,angle:de,anchors:me,lines:ge,center:be,wristCenter:ye,wristDebug:ve}=k,Ie=$.map((gt,Xt)=>({pixel:gt,metric:[Z[3*Xt+0],Z[3*Xt+1],Z[3*Xt+2]]}));Ie.forEach(gt=>{gt.pixel[0]=(gt.pixel[0]-.5)*2*le,gt.pixel[1]=(gt.pixel[1]-.5)*2*he,gt.pixel[2]*=2*le});const je=Math.sin(de),Me=Math.cos(de);Ie.forEach(gt=>{const Xt=gt.pixel[0],Ut=gt.pixel[1];gt.pixel[0]=(Xt*Me-Ut*je+be[0])/E,gt.pixel[1]=(Xt*je+Ut*Me+be[1])/_,gt.pixel[2]/=E;const Ht=gt.metric[0],mi=gt.metric[1];gt.metric[0]=Ht*Me-mi*je,gt.metric[1]=Ht*je+mi*Me});const xt=this.circlePoints.map(gt=>[gt[0]/64,gt[1]/64]);me.forEach(gt=>{gt[0]=(gt[0]+.5)/64,gt[1]=(gt[1]+.5)/64}),me.forEach(gt=>{const Xt=(gt[0]-.5)*2*le,Ut=(gt[1]-.5)*2*he;gt[0]=(Xt*Me-Ut*je+ye[0])/E,gt[1]=(Xt*je+Ut*Me+ye[1])/_}),ge.forEach(gt=>{gt.point[0]=(gt.point[0]+.5)/64,gt.point[1]=(gt.point[1]+.5)/64});const bt=this.normalizeLines(ge[0],ge[1],[.5,.5]);return bt.forEach(gt=>{const Xt=(gt.point[0]-.5)*2*le,Ut=(gt.point[1]-.5)*2*he;gt.point[0]=(Xt*Me-Ut*je+ye[0])/E,gt.point[1]=(Xt*je+Ut*Me+ye[1])/_;const Ht=gt.vector[0],mi=gt.vector[1];gt.vector[0]=Ht*Me-mi*je,gt.vector[1]=Ht*je+mi*Me}),{keypoints:Ie,score:te,handedness:xe,wrist:{lines:bt},debug:{box:p[V],anchors:me,circle:xt,tensors:ve}}})}evaluateLine(d,p,_,E,S){const I=[p[0]-d[0],p[1]-d[1]],D=this.buildLine(I[0],I[1]).slice(0,24),k=D.map(be=>[be[1],-be[0]]),V=Math.sqrt(I[0]**2+I[1]**2);I[0]/=V,I[1]/=V;const $=[I[1],-I[0]];D.forEach(be=>{be[0]+=d[0],be[1]+=d[1]});let Z=[],te=[];const xe=new Array(16).fill(0),le=new Array(16).fill(0);for(let be=6;be<D.length;be++){const ye=D[be];let ve=2,Ie=[0,0],je=-1,Me=-1,xt=[0,0];for(ve=2;ve<16;ve++){Ie=[ye[0]+k[ve][0],ye[1]+k[ve][1]];const bt=Ie[1]*64+Ie[0];if(S[bt]<.5)break;if(_[bt]<this.edgeThresh)continue;const gt=E[2*bt],Xt=E[2*bt+1];if(!(Math.abs(gt*$[0]+Xt*$[1])<.95)){if(_[bt]>this.edgeStop){Me=ve,xt=Ie,je=_[bt];break}_[bt]>je&&(Me=ve,xt=Ie,je=_[bt])}}for(Me<16&&Me>3&&(Z.push([...xt,Me]),xe[Me]++),ve=2,je=-1,Me=-1,xt=[0,0],ve=2;ve<16;ve++){Ie=[ye[0]-k[ve][0],ye[1]-k[ve][1]];const bt=Ie[1]*64+Ie[0];if(S[bt]<.5)break;if(_[bt]<this.edgeThresh)continue;const gt=E[2*bt],Xt=E[2*bt+1];if(!(Math.abs(gt*$[0]+Xt*$[1])<.95)){if(_[bt]>this.edgeStop){Me=ve,xt=Ie,je=_[bt];break}_[bt]>je&&(Me=ve,xt=Ie,je=_[bt])}}Me<16&&Me>3&&(te.push([...xt,Me]),le[Me]++)}let he=0,de=0,me=0,ge=0;for(let be=1;be<16;be++){const ye=.5*xe[be-1]+xe[be]+.5*xe[be+1],ve=.5*le[be-1]+le[be]+.5*le[be+1];ye>he&&(he=ye,me=be),ve>de&&(de=ve,ge=be)}return Z=Z.filter(be=>Math.abs(be[2]-me)<=1),te=te.filter(be=>Math.abs(be[2]-ge)<=1),{anchorsL:Z,anchorsR:te,strengthL:he,strengthR:de}}fitLine(d){const p=d.reduce((D,k)=>[D[0]+k[0],D[1]+k[1]],[0,0]);p[0]/=d.length,p[1]/=d.length;const _=d.reduce((D,k)=>{const V=[k[0]-p[0],k[1]-p[1]];return[D[0]+V[0]**2-V[1]**2,D[1]+2*V[0]*V[1]]},[0,0]),E=Math.sqrt(_[0]**2+_[1]**2),S=[Math.sqrt(.5*(E+_[0])),Math.sqrt(.5*(E-_[0]))],I=Math.sqrt(S[0]**2+S[1]**2);return S[0]/=I,S[1]/=I,_[1]<0&&(S[0]=-S[0]),{point:p,vector:S}}normalizeLines(d,p,_){const E=Ie=>[Ie[0]/Ie[2],Ie[1]/Ie[2],1],S=[...d.point,1],I=[...p.point,1],D=[...d.vector,0],k=[...p.vector,0],V=Sx.lerp(D,k,.5),$=[V[1],-V[0],0],Z=Sx.cross(S,Sx.add(S,D)),te=Sx.cross(I,Sx.add(I,k)),xe=Sx.cross(S,Sx.add(S,$)),le=E(Sx.cross(xe,te)),he=Sx.lerp(S,le,.5),de=[..._,1],me=Sx.add(he,Sx.scale(V,Sx.dot(V,Sx.sub(de,he)))),ge=Sx.add(me,Sx.scale(V,.15)),be=Sx.cross(ge,Sx.add(ge,$)),ye=E(Sx.cross(Z,be)),ve=E(Sx.cross(te,be));return[{point:[ye[0],ye[1]],vector:d.vector},{point:[ve[0],ve[1]],vector:p.vector},{point:ge,vector:V}]}buildLine(d,p){let[_,E]=[Math.abs(d),Math.abs(p)],S=!1;_<E&&([_,E]=[E,_],S=!0);let I=[],D=0,k=0,V=2*E,$=V-_;for(;D<_-2;D++)I.push([D,k]),$+=V,$>=0&&(k++,$-=2*_);return S&&(I=I.map(Z=>[Z[1],Z[0]])),d<0&&I.forEach(Z=>{Z[0]*=-1}),p<0&&I.forEach(Z=>{Z[1]*=-1}),I}buildCircle(d){let p=d,_=0,E=3-2*d;for(;_<p;)this.circlePoints.push([p,_]),_++,E>0?(p--,E=E+4*(_-p)+10):E=E+4*_+6;_--;for(let S=_;S>=0;S--){const I=this.circlePoints[S];this.circlePoints.push([I[1],I[0]])}for(let S=2*_;S>=0;S--){const I=this.circlePoints[S];this.circlePoints.push([-I[0],I[1]])}this.circlePoints.forEach(S=>{S[0]+=32,S[1]+=32})}rotatedRect(d,p,_,E,S){const[I,D]=[p[2]-p[0],p[3]-p[1]],[k,V]=[(p[2]+p[0])*.5,(p[3]+p[1])*.5],[$,Z]=[I/S.height,D/S.width],[te,xe]=[Math.cos(_),Math.sin(_)],le=[te*Z,-xe*$,(-te*D+xe*I)*.5+V,xe*Z,te*$,(-xe*D-te*I)*.5+k,0,0];return qO.transform(d,[le],"bilinear",E?"reflect":"constant",0,[S.height,S.width])}async prepare(){const{width:d,height:p}=this.modelSize,_=rD([1,p,d,3]),E=this.model.execute(_);if(await Promise.all(E.map(async S=>{await S.data(),S.dispose()})),_.dispose(),z2()==="webgl"){const{width:S,height:I}=this.localMaxSize;this.backend=z4(),this.localMaxProg={variableNames:["val","dir"],outputShape:[I,S,1],userCode:`
                    void main() {
                        ivec3 c = getOutputCoords();
                        float dx = getDir(c[0], c[1], 0);
                        float dy = getDir(c[0], c[1], 1);
                        vec2 d = vec2(dx, dy) / max(abs(dx), abs(dy));
                        vec2 cf = vec2(c[1], c[0]);
                        float v0 = getVal(round(cf.y - 2.0 * d.y),
                                          round(cf.x - 2.0 * d.x), 0);
                        float v1 = getVal(round(cf.y - d.y),
                                          round(cf.x - d.x), 0);
                        float v2 = getVal(round(cf.y), round(cf.x), 0);
                        float v3 = getVal(round(cf.x + d.y),
                                          round(cf.x + d.x), 0);
                        float v4 = getVal(round(cf.y + 2.0 * d.y),
                                          round(cf.x + 2.0 * d.x), 0);
                        float vmax = max(max(v0, v1), max(v3, v4));
                        setOutput(v2 >= vmax ? v2 : 0.0);
                    }
            `};const D=rD([I,S,1]),k=this.backend.compileAndRun(this.localMaxProg,[D,D]),V=sa().makeTensorFromTensorInfo(k);D.dispose(),V.dispose()}}async dispose(){var d;(d=this.model)==null||d.dispose()}}class Sb{constructor(){this.freq=30,this.pixelParams={minCutOff:2,minCutOffD:4,beta:50},this.metricParams={minCutOff:.1,minCutOffD:1,beta:20},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(d,p,_=1){if(this.time>=p)return d;if(this.time!==0&&(this.freq=1/(p-this.time)),this.time=p,!this.raw||!this.smooth||!this.der)return this.raw=this.clonePose(d),this.smooth=this.clonePose(d),this.der={keypoints:d.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0]})),score:0,handedness:.5,wrist:{lines:d.wrist.lines.map(()=>({point:[0,0],vector:[0,0]}))}},this.clonePose(this.smooth);const E=[...this.smooth.keypoints[0].pixel];this.filterKeypoints(d.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,_);const S=[...this.smooth.keypoints[0].pixel],{raw:I,smooth:D,der:k}=this;for(let $=0;$<d.wrist.lines.length;$++){const Z=d.wrist.lines[$],te=I.wrist.lines[$],xe=k.wrist.lines[$],le=D.wrist.lines[$];if(isNaN(le.point[0])||isNaN(le.point[0])||isNaN(le.vector[0])||isNaN(le.vector[0])){le.point=[...Z.point],le.vector=[...Z.vector];continue}if(isNaN(Z.point[0])||isNaN(Z.point[0])||isNaN(Z.vector[0])||isNaN(Z.vector[0])){le.point[0]+=S[0]-E[0],le.point[1]+=S[1]-E[1];continue}this.filterCoord2D(Z.point,te.point,xe.point,le.point,_,{minCutOff:.5,minCutOffD:4,beta:75}),this.filterCoord2D(Z.vector,te.vector,xe.vector,le.vector,_,{minCutOff:.1,minCutOffD:.5,beta:10});const he=Math.sqrt(le.vector[0]**2+le.vector[1]**2);le.vector[0]/=he,le.vector[1]/=he}const V=this.alpha(this.scoreCutOff);return this.smooth.score=this.smooth.score+V*(d.score-this.smooth.score),this.smooth.debug=d.debug&&{box:{box:[[...d.debug.box.box[0]],[...d.debug.box.box[1]]],points:d.debug.box.points.map($=>[...$]),start:[...d.debug.box.start],end:[...d.debug.box.end]},circle:d.debug.circle,anchors:d.debug.anchors,tensors:d.debug.tensors},this.clonePose(this.smooth)}filterKeypoints(d,p,_,E,S){for(let I=0;I<d.length;I++)this.filterCoord3D(d[I].pixel,p[I].pixel,_[I].pixel,E[I].pixel,S,this.pixelParams),this.filterCoord3D(d[I].metric,p[I].metric,_[I].metric,E[I].metric,S,this.metricParams)}filterCoord3D(d,p,_,E,S,I){const D=[(d[0]-E[0])*S*this.freq,(d[1]-E[1])*S*this.freq,(d[2]-E[2])*S*this.freq],k=this.alpha(I.minCutOffD);_[0]=_[0]+k*(D[0]-_[0]),_[1]=_[1]+k*(D[1]-_[1]),_[2]=_[2]+k*(D[2]-_[2]);const V=[this.alpha(I.minCutOff+I.beta*Math.abs(_[0])),this.alpha(I.minCutOff+I.beta*Math.abs(_[1])),this.alpha(I.minCutOff+I.beta*Math.abs(_[2]))];E[0]=E[0]+V[0]*(d[0]-E[0]),E[1]=E[1]+V[1]*(d[1]-E[1]),E[2]=E[2]+V[2]*(d[2]-E[2]),p[0]=d[0],p[1]=d[1],p[2]=d[2]}filterCoord2D(d,p,_,E,S,I){const D=[(d[0]-E[0])*S*this.freq,(d[1]-E[1])*S*this.freq],k=this.alpha(I.minCutOffD);_[0]=_[0]+k*(D[0]-_[0]),_[1]=_[1]+k*(D[1]-_[1]);const V=[this.alpha(I.minCutOff+I.beta*Math.abs(_[0])),this.alpha(I.minCutOff+I.beta*Math.abs(_[1]))];E[0]=E[0]+V[0]*(d[0]-E[0]),E[1]=E[1]+V[1]*(d[1]-E[1]),p[0]=d[0],p[1]=d[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(d){return 1/(1+this.freq/(2*Math.PI*d))}clonePose(d){return{keypoints:d.keypoints.map(p=>({pixel:[...p.pixel],metric:[...p.metric]})),score:d.score,handedness:d.handedness,wrist:{lines:d.wrist.lines.map(p=>({point:[...p.point],vector:[...p.vector]}))},debug:d.debug&&{box:{box:[[...d.debug.box.box[0]],[...d.debug.box.box[1]]],points:d.debug.box.points.map(p=>[...p]),start:[...d.debug.box.start],end:[...d.debug.box.end]},circle:d.debug.circle.map(p=>[...p]),anchors:d.debug.anchors.map(p=>[...p]),tensors:d.debug.tensors}}}}class Sa{constructor(){this.handTracks=[],this.handFilters=[],this.angle=.05555555555555555*Math.PI,this.ratio=1.7777777777777777,this.near=1,this.handScore=.55}async process(d,p){var _,E;const S=sV(()=>{const le=CB(CY(d,3),"float32"),he=Lp(le,255);return r0(he,0)}),[I,D]=[S.shape[1],S.shape[2]],k=(le,he)=>{const de=[le[0]*D,le[1]*I],me=[he[0]*D,he[1]*I];let[ge,be]=[me[0]-de[0],de[1]-me[1]];const ye=Math.sqrt(ge**2+be**2);return ge/=ye,be/=ye,[ge,be]},V=(le,he,de,me,ge,be)=>{const ye=[.5*(le[0][0]+le[1][0])*D,.5*(le[0][1]+le[1][1])*I],ve={width:(le[1][0]-le[0][0])*D,height:(le[1][1]-le[0][1])*I},[Ie,je]=k(he,de),Me=[ge*ve.width,be*ve.height];ye[0]+=Me[0]*je-Me[1]*Ie,ye[1]+=Me[0]*Ie+Me[1]*je,ye[0]/=D,ye[1]/=I;const xt=.5*me*Math.max(ve.width,ve.height);let bt=xt/D,gt=xt/I;return[[ye[0]-bt,ye[1]-gt],[ye[0]+bt,ye[1]+gt]]};if(this.handTracks.length===0){const le=await((_=this.palmDetector)==null?void 0:_.process(S))||[];this.handTracks=le.map(he=>({box:V(he.box,he.points[0],he.points[2],2.6,0,-.5),points:he.points,start:he.points[0],end:he.points[2]})),this.handTracks.forEach(()=>this.handFilters.push(new Sb))}const $=this.handTracks.length>0?((E=this.handDetector)==null?void 0:E.process(S,this.handTracks))||[]:[];$.forEach((le,he)=>{if(p===void 0)return;const de=D/I,me=this.handTracks[he].box[1][0]-this.handTracks[he].box[0][0],ge=(this.handTracks[he].box[1][1]-this.handTracks[he].box[0][1])/de,be=Math.sqrt(me*me+ge*ge)*(1+de);$[he]=this.handFilters[he].filter(le,p,1/be)}),S.dispose();const Z=[],te=[],xe=[];for(let le=0;le<$.length;le++){const he=$[le],{keypoints:de,score:me}=he;if(me<this.handScore)continue;const ge=[de[0].pixel[0],de[0].pixel[1]],be=[de[5].pixel[0],de[5].pixel[1]],ye=[de[10].pixel[0],de[10].pixel[1]],ve=[de[14].pixel[0],de[14].pixel[1]],Ie=[.25*be[0]+.5*ye[0]+.25*ve[0],.25*be[1]+.5*ye[1]+.25*ve[1]],[je,Me]=k(ge,Ie),[xt,bt]=[-je,Me],gt=[...de.slice(0,4),...de.slice(5,7),...de.slice(9,11),...de.slice(13,15),...de.slice(17,19)].map(ts=>[ts.pixel[0],ts.pixel[1]]),Xt=[[10,10],[-10,-10]];for(let ts=0;ts<gt.length;ts++)Xt[0][0]=Math.min(Xt[0][0],gt[ts][0]),Xt[0][1]=Math.min(Xt[0][1],gt[ts][1]),Xt[1][0]=Math.max(Xt[1][0],gt[ts][0]),Xt[1][1]=Math.max(Xt[1][1],gt[ts][1]);const Ut=[(Xt[0][0]+Xt[1][0])*.5,(Xt[0][1]+Xt[1][1])*.5],Ht=[[10,10],[-10,-10]];for(let ts=0;ts<gt.length;ts++){const us=[(gt[ts][0]-Ut[0])*D,(gt[ts][1]-Ut[1])*I],bi=[bt*us[0]-xt*us[1],xt*us[0]+bt*us[1]];Ht[0][0]=Math.min(Ht[0][0],bi[0]),Ht[0][1]=Math.min(Ht[0][1],bi[1]),Ht[1][0]=Math.max(Ht[1][0],bi[0]),Ht[1][1]=Math.max(Ht[1][1],bi[1])}const mi=[(Ht[0][0]+Ht[1][0])*.5,(Ht[0][1]+Ht[1][1])*.5],gi=[(Me*mi[0]-je*mi[1])/D+Ut[0],(je*mi[0]+Me*mi[1])/I+Ut[1]],Ui=.5*(Ht[1][0]-Ht[0][0])/D,yi=.5*(Ht[1][1]-Ht[0][1])/I,vi=V([[gi[0]-Ui,Ut[1]-yi],[gi[0]+Ui,Ut[1]+yi]],ge,Ie,2,0,-.1);QY(vi,this.handTracks[le].box)<.5||(this.align($[le].keypoints),Z.push({box:vi,start:ge,end:Ie,points:[]}),te.push(this.handFilters[le]),xe.push($[le]))}return this.handTracks=Z,this.handFilters=te,xe}align(d){const p=2*Math.tan(.5*this.angle),_=this.ratio*p,E=d.map(V=>{const $=[(V.pixel[0]-.5)*_,(V.pixel[1]-.5)*p],Z=[...V.metric];return{pixel:$,world:Z}}),S=[];E.forEach(V=>{S.push([0,1,-V.pixel[1],V.world[1]-V.pixel[1]*V.world[2]],[-1,0,V.pixel[0],V.pixel[0]*V.world[2]-V.world[0]])});const{V:I}=Sk.svd(S),D=I[3][3],k=[I[0][3]/D,I[1][3]/D,I[2][3]/D];d.forEach(V=>{V.metric[0]+=k[0],V.metric[1]+=k[1],V.metric[2]+=k[2]}),d.forEach(V=>{const $=[(V.pixel[0]-.5)*_,(V.pixel[1]-.5)*p],Z=V.metric;Z[0]=$[0]*Z[2],Z[1]=$[1]*Z[2],V.metric[1]=-V.metric[1],V.metric[2]=-V.metric[2]})}setCamera(d,p,_=1){this.angle=d,this.ratio=p,this.near=_}async init(d,p="./",_=!1,E="webgl"){const S=await Qb({locateFile:$=>p+$});S.Loader.prototype.promisify=function($,...Z){return $.call(this,...Z),new Promise(te=>{const xe=setInterval(()=>{if(this.ready)return clearInterval(xe),te(this.status)},5)})},S.Loader.prototype.load=function($){return this.promisify(this.loadAsync,$,_)},S.Loader.prototype.remove=function($){return this.promisify(this.removeAsync,$)},S.DictLoader.prototype.loadDict=function($){return this.promisify(this.loadDictAsync,d,$)};const I=new S.ParseLoader(p);if(_||await I.remove("hand.wasm"),!await I.loadDict(["hand.wasm"])||!await I.load("hand.wasm")||!I.parse())return;oQ().set("WEBGL_USE_SHAPES_UNIFORMS",!0),sb(),await z1(E);const D={weightUrlConverter:async $=>$,fetchFunc:async $=>{const Z=new Blob([I.file($)]);return fetch(URL.createObjectURL(Z))}},k=await pg("palmmodel.def",D),V=await pg("handmodel.def",D);this.palmDetector=new Sm(k),this.handDetector=new Sl(V)}reset(){this.handTracks=[],this.handFilters=[]}async prepare(){var d,p;oQ().set("ENGINE_COMPILE_ONLY",!0),await((d=this.palmDetector)==null?void 0:d.prepare()),await((p=this.handDetector)==null?void 0:p.prepare());const _=z4();_ instanceof OU&&(_.checkCompileCompletion(),_.getUniformLocations()),oQ().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var d;this.reset(),(d=this.palmDetector)==null||d.dispose()}}class SV{async process(d,p){var _;const E=sV(()=>{const I=CB(CY(d,3),"float32"),D=LA(I,1/255);return r0(D,0)}),S=(_=this.segmentor)==null?void 0:_.process(E,[[0,0],[1,1]]);return E.dispose(),S?[S]:[]}async init(d,p="./",_=!1,E=!1,S="webgl"){const I=await Qb({locateFile:V=>p+V});I.Loader.prototype.promisify=function(V,...$){return V.call(this,...$),new Promise(Z=>{const te=setInterval(()=>{if(this.ready)return clearInterval(te),Z(this.status)},5)})},I.Loader.prototype.load=function(V){return this.promisify(this.loadAsync,V,_)},I.Loader.prototype.remove=function(V){return this.promisify(this.removeAsync,V)},I.DictLoader.prototype.loadDict=function(V){return this.promisify(this.loadDictAsync,d,V)};const D=new I.ParseLoader(p);if(_||await D.remove("mask.wasm"),!await D.loadDict(["mask.wasm"])||!await D.load("mask.wasm")||!D.parse())return;oQ().set("WEBGL_USE_SHAPES_UNIFORMS",!0),sb(),await z1(S);const k=await pg("maskmodel.def",{weightUrlConverter:async V=>V,fetchFunc:async V=>{const $=new Blob([D.file(V)]);return fetch(URL.createObjectURL($))}});this.segmentor=new SW(k,E)}reset(){var d;(d=this.segmentor)==null||d.reset()}async prepare(){var d;oQ().set("ENGINE_COMPILE_ONLY",!0),await((d=this.segmentor)==null?void 0:d.prepare());const p=z4();p instanceof OU&&(p.checkCompileCompletion(),p.getUniformLocations()),oQ().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var d;(d=this.segmentor)==null||d.dispose(),delete this.segmentor}}const Sg={lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyebrowUpper:[156,70,63,105,66,107,55],rightEyebrowLower:[124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyebrowUpper:[383,300,293,334,296,336,285],leftEyebrowLower:[353,276,283,282,295],leftEyeIris:[468,469,470,471,472]},I0=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255],I1=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]],I2=[[0,-.03406405,.05979506],[0,-.01126867,.07475604],[0,-.02089025,.06058267],[-.00463928,.00955356,.06633583],[0,-.00463172,.0758658],[0,.00365668,.0724287],[0,.02473254,.05788627],[-.04253081,.02577645,.03279702],[0,.04019041,.05284765],[0,.04885978,.05385259],[0,.08261777,.04481537],[0,-.03706812,.05864923],[0,-.03918302,.05569429],[0,-.03994437,.05219482],[0,-.04542401,.05404753],[0,-.04745578,.05529456],[0,-.05019568,.05601447],[0,-.05365124,.0553544],[0,-.06149625,.05071371],[0,-.01501096,.07112196],[-.00416106,-.0146645,.06447657],[-.0708796,.05434801,99621e-8],[-.02628638,.02035898,.03848121],[-.03198363,.01985814,.03796952],[-.03775151,.02039402,.03646194],[-.04465819,.02422949,.03155169],[-.02164288,.02189867,.03851822],[-.03208229,.03223925,.04115823],[-.02673803,.03205336,.04092203],[-.03745193,.03165285,.03972409],[-.04161018,.03059068,.03719554],[-.05062005,.01934418,.02776093],[-.02266659,-.07425769,.04389811],[-.04445859,.0266399,.03173422],[-.0721453,.02263009,7315e-7],[-.05799793,.02349546,.02204059],[-.02844939,-.00720869,.0443313],[-.00711452,-.03329356,.05877044],[-.00606033,-.03924563,.05444922],[-.01431615,-.03500954,.05496188],[-.0191491,-.03803147,.05028929],[-.01131043,-.03973938,.05189647],[-.01563548,-.04082763,.04842262],[-.02650112,-.05003649,.04188482],[-.00427049,-.01094135,.07360528],[-.00496396,-.0047566,.07440358],[-.05253307,.03881582,.0336316],[-.01718698,.00974608,.04558359],[-.01608635,-.00942517,.05814193],[-.01651267,-.00610869,.05581319],[-.04765501,-.00701555,.03534632],[-.00478306,.00295764,.07101013],[-.03734964,.04508229,.04550455],[-.04588603,.04302036,.04048485],[-.06279331,.06615427,.01425851],[-.01220941,.04142164,.05106035],[-.02193489,.03100317,.04000575],[-.03102642,-.04352985,.04095904],[-.06719682,-.04788644,-.01745402],[-.01193824,-.01306796,.05737746],[-.00729766,-.01593713,.05833207],[-.02456206,-.04342622,.04283883],[-.02204823,-.04304509,.04162498],[-.04985894,.0480246,.03751978],[-.01592294,-.0125771,.05456949],[-.02644548,.04524653,.0492156],[-.02760292,.0510097,.05015991],[-.03523964,.08005974,.03729165],[-.05599763,.05715469,.0272426],[-.03063932,.06566143,.04529982],[-.05720968,.04254583,.02830853],[-.06374393,.04785589,.01591692],[-.00672728,-.03688017,.05737803],[-.0126256,-.03787692,.05417778],[-.01732553,-.03952768,.05000578],[-.01043625,-.01464974,.05662455],[-.02321234,-.0432907,.04258155],[-.02056846,-.04477672,.04520882],[-.02153084,-.04276323,.04038092],[-.00946874,-.0103525,.06512274],[-.01469132,-.04036351,.04604907],[-.0102434,-.03989852,.04926693],[-.00533422,-.03993222,.05138201],[-.0076972,-.06095395,.04985882],[-.00699606,-.05291851,.05448303],[-.00669687,-.0494977,.05509611],[-.00630947,-.04695102,.0544937],[-.00583218,-.04517983,.05339869],[-.0153717,-.04423207,.04745469],[-.016156,-.04475943,.04813631],[-.01729053,-.0461868,.04854462],[-.01838624,-.04828747,.04823736],[-.0236825,-.03106238,.04868095],[-.07542244,-.01049282,-.02431321],[0,-.01724004,.0660139],[-.01826614,-.04399532,.0439902],[-.01929558,-.04411831,.04497051],[-.00597442,-.02013687,.05866456],[-.01405627,-.01714197,.05241086],[-.00662449,-.01819322,.05863759],[-.02342339,.00572221,.04294303],[-.03327324,.00104862,.0411386],[-.01726175,-.00919166,.05273354],[-.05133204,.07485601,.02660443],[-.04538641,.06319907,.03683425],[-.03986562,.05109486,.04466315],[-.02169681,-.05440434,.04455873],[-.01395634,.05011962,.05316032],[-.016195,.06599216,.04921107],[-.01891399,.08236376,.04274999],[-.04195832,.02235205,.03375099],[-.05733342,.01411738,.02431726],[-.01859888,.02355756,.03843182],[-.04988612,.03074653,.03083858],[-.01303263,.01416452,.04831091],[-.01305757,-.0067278,.06415959],[-.0646517,.00937119,.01689873],[-.05258659,.00945811,.02974312],[-.04432338,.00722095,.03522615],[-.03300681,.0086164,.03872784],[-.02430178,.01131491,.04039035],[-.01820731,.01467953,.04224124],[-.00563221,.02307693,.05566789],[-.06338145,-.00529279,.01881175],[-.05587698,.03208071,.0268784],[-.00242624,-.01462858,.07071491],[-.01611251,.00339325,.0489542],[-.07743095,.02364999,-.02005167],[-.01391142,.01851047,.04448999],[-.01785794,-.00978285,.0485047],[-.04670959,.0266446,.03084075],[-.0133397,-.00283762,.06097047],[-.07270896,-.02890916,-.02252455],[-.01856432,.02585245,.03757904],[-.00923388,73075e-8,.06671944],[-.05000589,-.06135128,.01892522],[-.05085276,-.0717859,.0071471],[-.07159291,-.0081182,-72044e-8],[-.05843051,-.05248023,.0092409],[-.06847258,.03662916,.00724696],[-.02412942,-.08258854,.04119211],[-.00179909,-.01689865,.06573301],[-.02103655,-.00163946,.04566119],[-.06407571,.02236021,.01560843],[-.03670075,.02360153,.0363523],[-.03177186,.02294264,.03775705],[-.02196121,-.04598323,.04479785],[-.06234883,-.0194443,.01663542],[-.01292924,-.09295921,.04094062],[-.03210651,-.08533278,.02802],[-.04068926,-.07993109,.01925118],[0,.06545389,.05027312],[0,-.09403378,.0426449],[-.02724032,.02315802,.03777151],[-.0228846,.0239889,.03697603],[-.01998311,.02496546,.03689148],[-.0613004,.03399261,.02038516],[-.0228846,.02886503,.03775031],[-.02724032,.02961809,.03871767],[-.03177186,.02964135,.03876973],[-.03670075,.02927713,.03724325],[-.04018389,.02857356,.03482983],[-.07555811,.04106811,-.00991916],[-.04018389,.02483694,.03440898],[0,-.02521946,.05932265],[-.01776217,-.02683947,.05213116],[-.01222237,-.01182445,.05952464],[-.00731493,-.02536684,.05815343],[0,.03271026,.05236015],[-.04135272,-.06996639,.02671969],[-.03311811,-.07660816,.03382962],[-.01313701,-.08639995,.04702454],[-.05940524,-.06223629,-.00631469],[-.01998311,.02743837,.0374403],[-.00901447,.01236991,.05754256],[0,-.08765243,.04891439],[-.02308977,-.08974197,.03609069],[-.06954154,-.02439843,-.00131163],[-.01098819,-.04458788,.05120726],[-.01181124,-.04579997,.05189563],[-.01255818,-.04787901,.0523705],[-.01325085,-.05106508,.05205009],[-.01546388,-.05819392,.04757892],[-.01953754,-.04183893,.04431712],[-.02117802,-.04137093,.04555095],[-.02285339,-.04051196,.04582437],[-.0285016,-.03665721,.04484993],[-.05278538,-.02238942,.02861224],[-.00946709,.01907627,.0519678],[-.01314173,.03104912,.04231405],[-.0178,.02859999,.03881555],[-.0184511,-.0409888,.04247263],[-.05436186,-.04030482,.02109851],[-.00766444,.0318213,.04861453],[-.01938616,-.06614411,.04521083],[0,.01059412,.06774605],[-.00516573,.01583571,.06148363],[0,.01728368,.0631675],[-.01246815,.00230296,.05681035],[0,-.07942194,.05181172],[0,-.069915,.05153477],[-.00997827,-.06930922,.04979575],[-.03288807,-.05382515,.03795751],[-.02311631,-.01566238,.04590084],[-.0268025,-.06111567,.04096151],[-.03832928,-.01537327,.04137731],[-.0296186,-.02274216,.04440943],[-.04386901,-.02683286,.03643886],[-.01217295,-.07834466,.04969285],[-.01542374,-.00136843,.05201008],[-.03878377,-.06041764,.03311078],[-.03084037,-.06809843,.03814194],[-.03747321,-.04503546,.03726452],[-.06094129,-.03205992,.01473481],[-.04588995,-.04728726,.0298322],[-.06583231,-.03941269,70267e-8],[-.0349258,-.03195821,.04130198],[-.01255543,.0080234,.05307551],[-.01126122,-.00933603,.06538785],[-.01443109,-.01142775,.05905127],[-.00923043,-.00529043,.07003423],[-.01755386,.03529116,.04327697],[-.02632589,.03713828,.0436463],[-.03388062,.03721975,.04309029],[-.04075766,.03675412,.04076063],[-.0462291,.0347469,.03646322],[-.05171755,.02535752,.02670867],[-.0729733,.00763172,-48769e-8],[-.04706828,.01651,.03109532],[-.04071712,.01476821,.03476944],[-.03269817,.01470658,.03731945],[-.02527572,.0161731,.03865444],[-.01970894,.01858504,.03961782],[-.01579543,.0209794,.04084997],[-.07664182,.00673132,-.02435867],[-.01397041,-.0134014,.05630378],[-.00884838,.00658739,.06233231],[-.00767097,-.00968036,.07077932],[-.00460213,-.01334107,.06787448],[-.00748618,-.01067995,.06798303],[-.01236408,-.01585569,.05480489],[-.00387306,-.01409991,.06957705],[-.00319925,-.01607932,.06508676],[-.01639633,.02556297,.03863737],[-.01255645,.02467143,.042038],[-.01031362,.02382662,.04615849],[-.04253081,.02772296,.03315305],[-.0453,.0291,.03339685],[.00463928,.00955356,.06633583],[.04253081,.02577645,.03279702],[.00416106,-.0146645,.06447657],[.0708796,.05434801,99621e-8],[.02628638,.02035898,.03848121],[.03198363,.01985814,.03796952],[.03775151,.02039402,.03646194],[.04465819,.02422949,.03155169],[.02164288,.02189867,.03851822],[.03208229,.03223925,.04115823],[.02673803,.03205336,.04092203],[.03745193,.03165285,.03972409],[.04161018,.03059068,.03719554],[.05062005,.01934418,.02776093],[.02266659,-.07425769,.04389811],[.04445859,.0266399,.03173422],[.0721453,.02263009,7315e-7],[.05799793,.02349546,.02204059],[.02844939,-.00720869,.0443313],[.00711452,-.03329356,.05877044],[.00606033,-.03924563,.05444922],[.01431615,-.03500954,.05496188],[.0191491,-.03803147,.05028929],[.01131043,-.03973938,.05189647],[.01563548,-.04082763,.04842262],[.02650112,-.05003649,.04188482],[.00427049,-.01094135,.07360528],[.00496396,-.0047566,.07440358],[.05253307,.03881582,.0336316],[.01718698,.00974608,.04558359],[.01608635,-.00942517,.05814193],[.01651267,-.00610869,.05581319],[.04765501,-.00701555,.03534632],[.00478306,.00295764,.07101013],[.03734964,.04508229,.04550455],[.04588603,.04302036,.04048485],[.06279331,.06615427,.01425851],[.01220941,.04142164,.05106035],[.02193489,.03100317,.04000575],[.03102642,-.04352985,.04095904],[.06719682,-.04788644,-.01745402],[.01193824,-.01306796,.05737746],[.00729766,-.01593713,.05833207],[.02456206,-.04342622,.04283883],[.02204823,-.04304509,.04162498],[.04985894,.0480246,.03751978],[.01592294,-.0125771,.05456949],[.02644548,.04524653,.0492156],[.02760292,.0510097,.05015991],[.03523964,.08005974,.03729165],[.05599763,.05715469,.0272426],[.03063932,.06566143,.04529982],[.05720968,.04254583,.02830853],[.06374393,.04785589,.01591692],[.00672728,-.03688017,.05737803],[.0126256,-.03787692,.05417778],[.01732553,-.03952768,.05000578],[.01043625,-.01464974,.05662455],[.02321234,-.0432907,.04258155],[.02056846,-.04477672,.04520882],[.02153084,-.04276323,.04038092],[.00946874,-.0103525,.06512274],[.01469132,-.04036351,.04604907],[.0102434,-.03989852,.04926693],[.00533422,-.03993222,.05138201],[.0076972,-.06095395,.04985882],[.00699606,-.05291851,.05448303],[.00669687,-.0494977,.05509611],[.00630947,-.04695102,.0544937],[.00583218,-.04517983,.05339869],[.0153717,-.04423207,.04745469],[.016156,-.04475943,.04813631],[.01729053,-.0461868,.04854462],[.01838624,-.04828747,.04823736],[.0236825,-.03106238,.04868095],[.07542244,-.01049282,-.02431321],[.01826614,-.04399532,.0439902],[.01929558,-.04411831,.04497051],[.00597442,-.02013687,.05866456],[.01405627,-.01714197,.05241086],[.00662449,-.01819322,.05863759],[.02342339,.00572221,.04294303],[.03327324,.00104862,.0411386],[.01726175,-.00919166,.05273354],[.05133204,.07485601,.02660443],[.04538641,.06319907,.03683425],[.03986562,.05109486,.04466315],[.02169681,-.05440434,.04455873],[.01395634,.05011962,.05316032],[.016195,.06599216,.04921107],[.01891399,.08236376,.04274999],[.04195832,.02235205,.03375099],[.05733342,.01411738,.02431726],[.01859888,.02355756,.03843182],[.04988612,.03074653,.03083858],[.01303263,.01416452,.04831091],[.01305757,-.0067278,.06415959],[.0646517,.00937119,.01689873],[.05258659,.00945811,.02974312],[.04432338,.00722095,.03522615],[.03300681,.0086164,.03872784],[.02430178,.01131491,.04039035],[.01820731,.01467953,.04224124],[.00563221,.02307693,.05566789],[.06338145,-.00529279,.01881175],[.05587698,.03208071,.0268784],[.00242624,-.01462858,.07071491],[.01611251,.00339325,.0489542],[.07743095,.02364999,-.02005167],[.01391142,.01851047,.04448999],[.01785794,-.00978285,.0485047],[.04670959,.0266446,.03084075],[.0133397,-.00283762,.06097047],[.07270896,-.02890916,-.02252455],[.01856432,.02585245,.03757904],[.00923388,73075e-8,.06671944],[.05000589,-.06135128,.01892522],[.05085276,-.0717859,.0071471],[.07159291,-.0081182,-72044e-8],[.05843051,-.05248023,.0092409],[.06847258,.03662916,.00724696],[.02412942,-.08258854,.04119211],[.00179909,-.01689865,.06573301],[.02103655,-.00163946,.04566119],[.06407571,.02236021,.01560843],[.03670075,.02360153,.0363523],[.03177186,.02294264,.03775705],[.02196121,-.04598323,.04479785],[.06234883,-.0194443,.01663542],[.01292924,-.09295921,.04094062],[.03210651,-.08533278,.02802],[.04068926,-.07993109,.01925118],[.02724032,.02315802,.03777151],[.0228846,.0239889,.03697603],[.01998311,.02496546,.03689148],[.0613004,.03399261,.02038516],[.0228846,.02886503,.03775031],[.02724032,.02961809,.03871767],[.03177186,.02964135,.03876973],[.03670075,.02927713,.03724325],[.04018389,.02857356,.03482983],[.07555811,.04106811,-.00991916],[.04018389,.02483694,.03440898],[.01776217,-.02683947,.05213116],[.01222237,-.01182445,.05952464],[.00731493,-.02536684,.05815343],[.04135272,-.06996639,.02671969],[.03311811,-.07660816,.03382962],[.01313701,-.08639995,.04702454],[.05940524,-.06223629,-.00631469],[.01998311,.02743837,.0374403],[.00901447,.01236991,.05754256],[.02308977,-.08974197,.03609069],[.06954154,-.02439843,-.00131163],[.01098819,-.04458788,.05120726],[.01181124,-.04579997,.05189563],[.01255818,-.04787901,.0523705],[.01325085,-.05106508,.05205009],[.01546388,-.05819392,.04757892],[.01953754,-.04183893,.04431712],[.02117802,-.04137093,.04555095],[.02285339,-.04051196,.04582437],[.0285016,-.03665721,.04484993],[.05278538,-.02238942,.02861224],[.00946709,.01907627,.0519678],[.01314173,.03104912,.04231405],[.0178,.02859999,.03881555],[.0184511,-.0409888,.04247263],[.05436186,-.04030482,.02109851],[.00766444,.0318213,.04861453],[.01938616,-.06614411,.04521083],[.00516573,.01583571,.06148363],[.01246815,.00230296,.05681035],[.00997827,-.06930922,.04979575],[.03288807,-.05382515,.03795751],[.02311631,-.01566238,.04590084],[.0268025,-.06111567,.04096151],[.03832928,-.01537327,.04137731],[.0296186,-.02274216,.04440943],[.04386901,-.02683286,.03643886],[.01217295,-.07834466,.04969285],[.01542374,-.00136843,.05201008],[.03878377,-.06041764,.03311078],[.03084037,-.06809843,.03814194],[.03747321,-.04503546,.03726452],[.06094129,-.03205992,.01473481],[.04588995,-.04728726,.0298322],[.06583231,-.03941269,70267e-8],[.0349258,-.03195821,.04130198],[.01255543,.0080234,.05307551],[.01126122,-.00933603,.06538785],[.01443109,-.01142775,.05905127],[.00923043,-.00529043,.07003423],[.01755386,.03529116,.04327697],[.02632589,.03713828,.0436463],[.03388062,.03721975,.04309029],[.04075766,.03675412,.04076063],[.0462291,.0347469,.03646322],[.05171755,.02535752,.02670867],[.0729733,.00763172,-48769e-8],[.04706828,.01651,.03109532],[.04071712,.01476821,.03476944],[.03269817,.01470658,.03731945],[.02527572,.0161731,.03865444],[.01970894,.01858504,.03961782],[.01579543,.0209794,.04084997],[.07664182,.00673132,-.02435867],[.01397041,-.0134014,.05630378],[.00884838,.00658739,.06233231],[.00767097,-.00968036,.07077932],[.00460213,-.01334107,.06787448],[.00748618,-.01067995,.06798303],[.01236408,-.01585569,.05480489],[.00387306,-.01409991,.06957705],[.00319925,-.01607932,.06508676],[.01639633,.02556297,.03863737],[.01255645,.02467143,.042038],[.01031362,.02382662,.04615849],[.04253081,.02772296,.03315305],[.0453,.0291,.03339685]];class I3{constructor(){this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.meancolor",this.canvas.hidden=!0,this.canvas.width=1,this.canvas.height=1,this.context=this.canvas.getContext("2d",{alpha:!1,desynchronized:!0})}mean(d){if(!this.context)return;this.context.drawImage(d,0,0,1,1);const p=this.context.getImageData(0,0,1,1);return[p.data[0],p.data[1],p.data[2]]}brightness(d){const p=this.mean(d);return p?(.2989*p[0]+.587*p[1]+.1141*p[2])/255:void 0}dispose(){this.context=null,this.canvas&&document.removeChild(this.canvas),delete this.canvas}}},75:(m,d,p)=>{"use strict";var _=p(453),E=p(487),S=E(_("String.prototype.indexOf"));m.exports=function(D,k){var V=_(D,!!k);return typeof V=="function"&&S(D,".prototype.")>-1?E(V):V}},487:(m,d,p)=>{"use strict";var _=p(743),E=p(453),S=p(897),I=p(675),D=E("%Function.prototype.apply%"),k=E("%Function.prototype.call%"),V=E("%Reflect.apply%",!0)||_.call(k,D),$=p(655),Z=E("%Math.max%");m.exports=function(le){if(typeof le!="function")throw new I("a function is required");var he=V(_,k,arguments);return S(he,1+Z(0,le.length-(arguments.length-1)),!0)};var te=function(){return V(_,D,arguments)};$?$(m.exports,"apply",{value:te}):m.exports.apply=te},41:(m,d,p)=>{"use strict";var _=p(655),E=p(68),S=p(675),I=p(795);m.exports=function(k,V,$){if(!k||typeof k!="object"&&typeof k!="function")throw new S("`obj` must be an object or a function`");if(typeof V!="string"&&typeof V!="symbol")throw new S("`property` must be a string or a symbol`");if(arguments.length>3&&typeof arguments[3]!="boolean"&&arguments[3]!==null)throw new S("`nonEnumerable`, if provided, must be a boolean or null");if(arguments.length>4&&typeof arguments[4]!="boolean"&&arguments[4]!==null)throw new S("`nonWritable`, if provided, must be a boolean or null");if(arguments.length>5&&typeof arguments[5]!="boolean"&&arguments[5]!==null)throw new S("`nonConfigurable`, if provided, must be a boolean or null");if(arguments.length>6&&typeof arguments[6]!="boolean")throw new S("`loose`, if provided, must be a boolean");var Z=arguments.length>3?arguments[3]:null,te=arguments.length>4?arguments[4]:null,xe=arguments.length>5?arguments[5]:null,le=arguments.length>6?arguments[6]:!1,he=!!I&&I(k,V);if(_)_(k,V,{configurable:xe===null&&he?he.configurable:!xe,enumerable:Z===null&&he?he.enumerable:!Z,value:$,writable:te===null&&he?he.writable:!te});else if(le||!Z&&!te&&!xe)k[V]=$;else throw new E("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")}},655:(m,d,p)=>{"use strict";var _=p(453),E=_("%Object.defineProperty%",!0)||!1;if(E)try{E({},"a",{value:1})}catch{E=!1}m.exports=E},237:m=>{"use strict";m.exports=EvalError},383:m=>{"use strict";m.exports=Error},290:m=>{"use strict";m.exports=RangeError},538:m=>{"use strict";m.exports=ReferenceError},68:m=>{"use strict";m.exports=SyntaxError},675:m=>{"use strict";m.exports=TypeError},345:m=>{"use strict";m.exports=URIError},7:m=>{"use strict";var d=typeof Reflect=="object"?Reflect:null,p=d&&typeof d.apply=="function"?d.apply:function(Ie,je,Me){return Function.prototype.apply.call(Ie,je,Me)},_;d&&typeof d.ownKeys=="function"?_=d.ownKeys:Object.getOwnPropertySymbols?_=function(Ie){return Object.getOwnPropertyNames(Ie).concat(Object.getOwnPropertySymbols(Ie))}:_=function(Ie){return Object.getOwnPropertyNames(Ie)};function E(ve){console&&console.warn&&console.warn(ve)}var S=Number.isNaN||function(Ie){return Ie!==Ie};function I(){I.init.call(this)}m.exports=I,m.exports.once=ge,I.EventEmitter=I,I.prototype._events=void 0,I.prototype._eventsCount=0,I.prototype._maxListeners=void 0;var D=10;function k(ve){if(typeof ve!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof ve)}Object.defineProperty(I,"defaultMaxListeners",{enumerable:!0,get:function(){return D},set:function(ve){if(typeof ve!="number"||ve<0||S(ve))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+ve+".");D=ve}}),I.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},I.prototype.setMaxListeners=function(Ie){if(typeof Ie!="number"||Ie<0||S(Ie))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+Ie+".");return this._maxListeners=Ie,this};function V(ve){return ve._maxListeners===void 0?I.defaultMaxListeners:ve._maxListeners}I.prototype.getMaxListeners=function(){return V(this)},I.prototype.emit=function(Ie){for(var je=[],Me=1;Me<arguments.length;Me++)je.push(arguments[Me]);var xt=Ie==="error",bt=this._events;if(bt!==void 0)xt=xt&&bt.error===void 0;else if(!xt)return!1;if(xt){var gt;if(je.length>0&&(gt=je[0]),gt instanceof Error)throw gt;var Xt=new Error("Unhandled error."+(gt?" ("+gt.message+")":""));throw Xt.context=gt,Xt}var Ut=bt[Ie];if(Ut===void 0)return!1;if(typeof Ut=="function")p(Ut,this,je);else for(var Ht=Ut.length,mi=he(Ut,Ht),Me=0;Me<Ht;++Me)p(mi[Me],this,je);return!0};function $(ve,Ie,je,Me){var xt,bt,gt;if(k(je),bt=ve._events,bt===void 0?(bt=ve._events=Object.create(null),ve._eventsCount=0):(bt.newListener!==void 0&&(ve.emit("newListener",Ie,je.listener?je.listener:je),bt=ve._events),gt=bt[Ie]),gt===void 0)gt=bt[Ie]=je,++ve._eventsCount;else if(typeof gt=="function"?gt=bt[Ie]=Me?[je,gt]:[gt,je]:Me?gt.unshift(je):gt.push(je),xt=V(ve),xt>0&&gt.length>xt&&!gt.warned){gt.warned=!0;var Xt=new Error("Possible EventEmitter memory leak detected. "+gt.length+" "+String(Ie)+" listeners added. Use emitter.setMaxListeners() to increase limit");Xt.name="MaxListenersExceededWarning",Xt.emitter=ve,Xt.type=Ie,Xt.count=gt.length,E(Xt)}return ve}I.prototype.addListener=function(Ie,je){return $(this,Ie,je,!1)},I.prototype.on=I.prototype.addListener,I.prototype.prependListener=function(Ie,je){return $(this,Ie,je,!0)};function Z(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function te(ve,Ie,je){var Me={fired:!1,wrapFn:void 0,target:ve,type:Ie,listener:je},xt=Z.bind(Me);return xt.listener=je,Me.wrapFn=xt,xt}I.prototype.once=function(Ie,je){return k(je),this.on(Ie,te(this,Ie,je)),this},I.prototype.prependOnceListener=function(Ie,je){return k(je),this.prependListener(Ie,te(this,Ie,je)),this},I.prototype.removeListener=function(Ie,je){var Me,xt,bt,gt,Xt;if(k(je),xt=this._events,xt===void 0)return this;if(Me=xt[Ie],Me===void 0)return this;if(Me===je||Me.listener===je)--this._eventsCount===0?this._events=Object.create(null):(delete xt[Ie],xt.removeListener&&this.emit("removeListener",Ie,Me.listener||je));else if(typeof Me!="function"){for(bt=-1,gt=Me.length-1;gt>=0;gt--)if(Me[gt]===je||Me[gt].listener===je){Xt=Me[gt].listener,bt=gt;break}if(bt<0)return this;bt===0?Me.shift():de(Me,bt),Me.length===1&&(xt[Ie]=Me[0]),xt.removeListener!==void 0&&this.emit("removeListener",Ie,Xt||je)}return this},I.prototype.off=I.prototype.removeListener,I.prototype.removeAllListeners=function(Ie){var je,Me,xt;if(Me=this._events,Me===void 0)return this;if(Me.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):Me[Ie]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete Me[Ie]),this;if(arguments.length===0){var bt=Object.keys(Me),gt;for(xt=0;xt<bt.length;++xt)gt=bt[xt],gt!=="removeListener"&&this.removeAllListeners(gt);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(je=Me[Ie],typeof je=="function")this.removeListener(Ie,je);else if(je!==void 0)for(xt=je.length-1;xt>=0;xt--)this.removeListener(Ie,je[xt]);return this};function xe(ve,Ie,je){var Me=ve._events;if(Me===void 0)return[];var xt=Me[Ie];return xt===void 0?[]:typeof xt=="function"?je?[xt.listener||xt]:[xt]:je?me(xt):he(xt,xt.length)}I.prototype.listeners=function(Ie){return xe(this,Ie,!0)},I.prototype.rawListeners=function(Ie){return xe(this,Ie,!1)},I.listenerCount=function(ve,Ie){return typeof ve.listenerCount=="function"?ve.listenerCount(Ie):le.call(ve,Ie)},I.prototype.listenerCount=le;function le(ve){var Ie=this._events;if(Ie!==void 0){var je=Ie[ve];if(typeof je=="function")return 1;if(je!==void 0)return je.length}return 0}I.prototype.eventNames=function(){return this._eventsCount>0?_(this._events):[]};function he(ve,Ie){for(var je=new Array(Ie),Me=0;Me<Ie;++Me)je[Me]=ve[Me];return je}function de(ve,Ie){for(;Ie+1<ve.length;Ie++)ve[Ie]=ve[Ie+1];ve.pop()}function me(ve){for(var Ie=new Array(ve.length),je=0;je<Ie.length;++je)Ie[je]=ve[je].listener||ve[je];return Ie}function ge(ve,Ie){return new Promise(function(je,Me){function xt(gt){ve.removeListener(Ie,bt),Me(gt)}function bt(){typeof ve.removeListener=="function"&&ve.removeListener("error",xt),je([].slice.call(arguments))}ye(ve,Ie,bt,{once:!0}),Ie!=="error"&&be(ve,xt,{once:!0})})}function be(ve,Ie,je){typeof ve.on=="function"&&ye(ve,"error",Ie,je)}function ye(ve,Ie,je,Me){if(typeof ve.on=="function")Me.once?ve.once(Ie,je):ve.on(Ie,je);else if(typeof ve.addEventListener=="function")ve.addEventListener(Ie,function xt(bt){Me.once&&ve.removeEventListener(Ie,xt),je(bt)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof ve)}},682:(m,d,p)=>{"use strict";var _=p(600),E=Object.prototype.toString,S=Object.prototype.hasOwnProperty,I=function(Z,te,xe){for(var le=0,he=Z.length;le<he;le++)S.call(Z,le)&&(xe==null?te(Z[le],le,Z):te.call(xe,Z[le],le,Z))},D=function(Z,te,xe){for(var le=0,he=Z.length;le<he;le++)xe==null?te(Z.charAt(le),le,Z):te.call(xe,Z.charAt(le),le,Z)},k=function(Z,te,xe){for(var le in Z)S.call(Z,le)&&(xe==null?te(Z[le],le,Z):te.call(xe,Z[le],le,Z))},V=function(Z,te,xe){if(!_(te))throw new TypeError("iterator must be a function");var le;arguments.length>=3&&(le=xe),E.call(Z)==="[object Array]"?I(Z,te,le):typeof Z=="string"?D(Z,te,le):k(Z,te,le)};m.exports=V},353:m=>{"use strict";var d="Function.prototype.bind called on incompatible ",p=Object.prototype.toString,_=Math.max,E="[object Function]",S=function(V,$){for(var Z=[],te=0;te<V.length;te+=1)Z[te]=V[te];for(var xe=0;xe<$.length;xe+=1)Z[xe+V.length]=$[xe];return Z},I=function(V,$){for(var Z=[],te=$||0,xe=0;te<V.length;te+=1,xe+=1)Z[xe]=V[te];return Z},D=function(k,V){for(var $="",Z=0;Z<k.length;Z+=1)$+=k[Z],Z+1<k.length&&($+=V);return $};m.exports=function(V){var $=this;if(typeof $!="function"||p.apply($)!==E)throw new TypeError(d+$);for(var Z=I(arguments,1),te,xe=function(){if(this instanceof te){var ge=$.apply(this,S(Z,arguments));return Object(ge)===ge?ge:this}return $.apply(V,S(Z,arguments))},le=_(0,$.length-Z.length),he=[],de=0;de<le;de++)he[de]="$"+de;if(te=Function("binder","return function ("+D(he,",")+"){ return binder.apply(this,arguments); }")(xe),$.prototype){var me=function(){};me.prototype=$.prototype,te.prototype=new me,me.prototype=null}return te}},743:(m,d,p)=>{"use strict";var _=p(353);m.exports=Function.prototype.bind||_},453:(m,d,p)=>{"use strict";var _,E=p(383),S=p(237),I=p(290),D=p(538),k=p(68),V=p(675),$=p(345),Z=Function,te=function(ts){try{return Z('"use strict"; return ('+ts+").constructor;")()}catch{}},xe=Object.getOwnPropertyDescriptor;if(xe)try{xe({},"")}catch{xe=null}var le=function(){throw new V},he=xe?function(){try{return arguments.callee,le}catch{try{return xe(arguments,"callee").get}catch{return le}}}():le,de=p(39)(),me=p(24)(),ge=Object.getPrototypeOf||(me?function(ts){return ts.__proto__}:null),be={},ye=typeof Uint8Array>"u"||!ge?_:ge(Uint8Array),ve={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?_:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?_:ArrayBuffer,"%ArrayIteratorPrototype%":de&&ge?ge([][Symbol.iterator]()):_,"%AsyncFromSyncIteratorPrototype%":_,"%AsyncFunction%":be,"%AsyncGenerator%":be,"%AsyncGeneratorFunction%":be,"%AsyncIteratorPrototype%":be,"%Atomics%":typeof Atomics>"u"?_:Atomics,"%BigInt%":typeof BigInt>"u"?_:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?_:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?_:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?_:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":E,"%eval%":eval,"%EvalError%":S,"%Float32Array%":typeof Float32Array>"u"?_:Float32Array,"%Float64Array%":typeof Float64Array>"u"?_:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?_:FinalizationRegistry,"%Function%":Z,"%GeneratorFunction%":be,"%Int8Array%":typeof Int8Array>"u"?_:Int8Array,"%Int16Array%":typeof Int16Array>"u"?_:Int16Array,"%Int32Array%":typeof Int32Array>"u"?_:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":de&&ge?ge(ge([][Symbol.iterator]())):_,"%JSON%":typeof JSON=="object"?JSON:_,"%Map%":typeof Map>"u"?_:Map,"%MapIteratorPrototype%":typeof Map>"u"||!de||!ge?_:ge(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?_:Promise,"%Proxy%":typeof Proxy>"u"?_:Proxy,"%RangeError%":I,"%ReferenceError%":D,"%Reflect%":typeof Reflect>"u"?_:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?_:Set,"%SetIteratorPrototype%":typeof Set>"u"||!de||!ge?_:ge(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?_:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":de&&ge?ge(""[Symbol.iterator]()):_,"%Symbol%":de?Symbol:_,"%SyntaxError%":k,"%ThrowTypeError%":he,"%TypedArray%":ye,"%TypeError%":V,"%Uint8Array%":typeof Uint8Array>"u"?_:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?_:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?_:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?_:Uint32Array,"%URIError%":$,"%WeakMap%":typeof WeakMap>"u"?_:WeakMap,"%WeakRef%":typeof WeakRef>"u"?_:WeakRef,"%WeakSet%":typeof WeakSet>"u"?_:WeakSet};if(ge)try{null.error}catch(ts){var Ie=ge(ge(ts));ve["%Error.prototype%"]=Ie}var je=function ts(us){var bi;if(us==="%AsyncFunction%")bi=te("async function () {}");else if(us==="%GeneratorFunction%")bi=te("function* () {}");else if(us==="%AsyncGeneratorFunction%")bi=te("async function* () {}");else if(us==="%AsyncGenerator%"){var Ri=ts("%AsyncGeneratorFunction%");Ri&&(bi=Ri.prototype)}else if(us==="%AsyncIteratorPrototype%"){var Nt=ts("%AsyncGenerator%");Nt&&ge&&(bi=ge(Nt.prototype))}return ve[us]=bi,bi},Me={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},xt=p(743),bt=p(957),gt=xt.call(Function.call,Array.prototype.concat),Xt=xt.call(Function.apply,Array.prototype.splice),Ut=xt.call(Function.call,String.prototype.replace),Ht=xt.call(Function.call,String.prototype.slice),mi=xt.call(Function.call,RegExp.prototype.exec),gi=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,Ui=/\\(\\)?/g,yi=function(us){var bi=Ht(us,0,1),Ri=Ht(us,-1);if(bi==="%"&&Ri!=="%")throw new k("invalid intrinsic syntax, expected closing `%`");if(Ri==="%"&&bi!=="%")throw new k("invalid intrinsic syntax, expected opening `%`");var Nt=[];return Ut(us,gi,function($t,li,Ei,xs){Nt[Nt.length]=Ei?Ut(xs,Ui,"$1"):li||$t}),Nt},vi=function(us,bi){var Ri=us,Nt;if(bt(Me,Ri)&&(Nt=Me[Ri],Ri="%"+Nt[0]+"%"),bt(ve,Ri)){var $t=ve[Ri];if($t===be&&($t=je(Ri)),typeof $t>"u"&&!bi)throw new V("intrinsic "+us+" exists, but is not available. Please file an issue!");return{alias:Nt,name:Ri,value:$t}}throw new k("intrinsic "+us+" does not exist!")};m.exports=function(us,bi){if(typeof us!="string"||us.length===0)throw new V("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof bi!="boolean")throw new V('"allowMissing" argument must be a boolean');if(mi(/^%?[^%]*%?$/,us)===null)throw new k("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var Ri=yi(us),Nt=Ri.length>0?Ri[0]:"",$t=vi("%"+Nt+"%",bi),li=$t.name,Ei=$t.value,xs=!1,Vs=$t.alias;Vs&&(Nt=Vs[0],Xt(Ri,gt([0,1],Vs)));for(var ms=1,bs=!0;ms<Ri.length;ms+=1){var Us=Ri[ms],Mr=Ht(Us,0,1),ar=Ht(Us,-1);if((Mr==='"'||Mr==="'"||Mr==="`"||ar==='"'||ar==="'"||ar==="`")&&Mr!==ar)throw new k("property names with quotes must have matching quotes");if((Us==="constructor"||!bs)&&(xs=!0),Nt+="."+Us,li="%"+Nt+"%",bt(ve,li))Ei=ve[li];else if(Ei!=null){if(!(Us in Ei)){if(!bi)throw new V("base intrinsic for "+us+" exists, but the property is not available.");return}if(xe&&ms+1>=Ri.length){var yr=xe(Ei,Us);bs=!!yr,bs&&"get"in yr&&!("originalValue"in yr.get)?Ei=yr.get:Ei=Ei[Us]}else bs=bt(Ei,Us),Ei=Ei[Us];bs&&!xs&&(ve[li]=Ei)}}return Ei}},795:(m,d,p)=>{"use strict";var _=p(453),E=_("%Object.getOwnPropertyDescriptor%",!0);if(E)try{E([],"length")}catch{E=null}m.exports=E},592:(m,d,p)=>{"use strict";var _=p(655),E=function(){return!!_};E.hasArrayLengthDefineBug=function(){if(!_)return null;try{return _([],"length",{value:1}).length!==1}catch{return!0}},m.exports=E},24:m=>{"use strict";var d={__proto__:null,foo:{}},p=Object;m.exports=function(){return{__proto__:d}.foo===d.foo&&!(d instanceof p)}},39:(m,d,p)=>{"use strict";var _=typeof Symbol<"u"&&Symbol,E=p(333);m.exports=function(){return typeof _!="function"||typeof Symbol!="function"||typeof _("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:E()}},333:m=>{"use strict";m.exports=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var p={},_=Symbol("test"),E=Object(_);if(typeof _=="string"||Object.prototype.toString.call(_)!=="[object Symbol]"||Object.prototype.toString.call(E)!=="[object Symbol]")return!1;var S=42;p[_]=S;for(_ in p)return!1;if(typeof Object.keys=="function"&&Object.keys(p).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(p).length!==0)return!1;var I=Object.getOwnPropertySymbols(p);if(I.length!==1||I[0]!==_||!Object.prototype.propertyIsEnumerable.call(p,_))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var D=Object.getOwnPropertyDescriptor(p,_);if(D.value!==S||D.enumerable!==!0)return!1}return!0}},711:(m,d,p)=>{"use strict";var _=p(333);m.exports=function(){return _()&&!!Symbol.toStringTag}},957:(m,d,p)=>{"use strict";var _=Function.prototype.call,E=Object.prototype.hasOwnProperty,S=p(743);m.exports=S.call(_,E)},698:m=>{typeof Object.create=="function"?m.exports=function(p,_){_&&(p.super_=_,p.prototype=Object.create(_.prototype,{constructor:{value:p,enumerable:!1,writable:!0,configurable:!0}}))}:m.exports=function(p,_){if(_){p.super_=_;var E=function(){};E.prototype=_.prototype,p.prototype=new E,p.prototype.constructor=p}}},244:(m,d,p)=>{"use strict";var _=p(711)(),E=p(75),S=E("Object.prototype.toString"),I=function($){return _&&$&&typeof $=="object"&&Symbol.toStringTag in $?!1:S($)==="[object Arguments]"},D=function($){return I($)?!0:$!==null&&typeof $=="object"&&typeof $.length=="number"&&$.length>=0&&S($)!=="[object Array]"&&S($.callee)==="[object Function]"},k=function(){return I(arguments)}();I.isLegacyArguments=D,m.exports=k?I:D},600:m=>{"use strict";var d=Function.prototype.toString,p=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,_,E;if(typeof p=="function"&&typeof Object.defineProperty=="function")try{_=Object.defineProperty({},"length",{get:function(){throw E}}),E={},p(function(){throw 42},null,_)}catch(be){be!==E&&(p=null)}else p=null;var S=/^\s*class\b/,I=function(ye){try{var ve=d.call(ye);return S.test(ve)}catch{return!1}},D=function(ye){try{return I(ye)?!1:(d.call(ye),!0)}catch{return!1}},k=Object.prototype.toString,V="[object Object]",$="[object Function]",Z="[object GeneratorFunction]",te="[object HTMLAllCollection]",xe="[object HTML document.all class]",le="[object HTMLCollection]",he=typeof Symbol=="function"&&!!Symbol.toStringTag,de=!(0 in[,]),me=function(){return!1};if(typeof document=="object"){var ge=document.all;k.call(ge)===k.call(document.all)&&(me=function(ye){if((de||!ye)&&(typeof ye>"u"||typeof ye=="object"))try{var ve=k.call(ye);return(ve===te||ve===xe||ve===le||ve===V)&&ye("")==null}catch{}return!1})}m.exports=p?function(ye){if(me(ye))return!0;if(!ye||typeof ye!="function"&&typeof ye!="object")return!1;try{p(ye,null,_)}catch(ve){if(ve!==E)return!1}return!I(ye)&&D(ye)}:function(ye){if(me(ye))return!0;if(!ye||typeof ye!="function"&&typeof ye!="object")return!1;if(he)return D(ye);if(I(ye))return!1;var ve=k.call(ye);return ve!==$&&ve!==Z&&!/^\[object HTML/.test(ve)?!1:D(ye)}},184:(m,d,p)=>{"use strict";var _=Object.prototype.toString,E=Function.prototype.toString,S=/^\s*(?:function)?\*/,I=p(711)(),D=Object.getPrototypeOf,k=function(){if(!I)return!1;try{return Function("return function*() {}")()}catch{}},V;m.exports=function(Z){if(typeof Z!="function")return!1;if(S.test(E.call(Z)))return!0;if(!I){var te=_.call(Z);return te==="[object GeneratorFunction]"}if(!D)return!1;if(typeof V>"u"){var xe=k();V=xe?D(xe):!1}return D(Z)===V}},680:(m,d,p)=>{"use strict";var _=p(767);m.exports=function(S){return!!_(S)}},92:(m,d,p)=>{"use strict";var _=function(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof p.g<"u")return p.g;throw new Error("unable to locate global object")},E=_();m.exports=d=E.fetch,E.fetch&&(d.default=E.fetch.bind(E)),d.Headers=E.Headers,d.Request=E.Request,d.Response=E.Response},578:m=>{"use strict";m.exports=["Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array"]},897:(m,d,p)=>{"use strict";var _=p(453),E=p(41),S=p(592)(),I=p(795),D=p(675),k=_("%Math.floor%");m.exports=function($,Z){if(typeof $!="function")throw new D("`fn` is not a function");if(typeof Z!="number"||Z<0||Z>4294967295||k(Z)!==Z)throw new D("`length` must be a positive 32-bit integer");var te=arguments.length>2&&!!arguments[2],xe=!0,le=!0;if("length"in $&&I){var he=I($,"length");he&&!he.configurable&&(xe=!1),he&&!he.writable&&(le=!1)}return(xe||le||!te)&&(S?E($,"length",Z,!0,!0):E($,"length",Z)),$}},135:m=>{m.exports=function(p){return p&&typeof p=="object"&&typeof p.copy=="function"&&typeof p.fill=="function"&&typeof p.readUInt8=="function"}},32:(m,d,p)=>{"use strict";var _=p(244),E=p(184),S=p(767),I=p(680);function D(Hi){return Hi.call.bind(Hi)}var k=typeof BigInt<"u",V=typeof Symbol<"u",$=D(Object.prototype.toString),Z=D(Number.prototype.valueOf),te=D(String.prototype.valueOf),xe=D(Boolean.prototype.valueOf);if(k)var le=D(BigInt.prototype.valueOf);if(V)var he=D(Symbol.prototype.valueOf);function de(Hi,Ya){if(typeof Hi!="object")return!1;try{return Ya(Hi),!0}catch{return!1}}d.isArgumentsObject=_,d.isGeneratorFunction=E,d.isTypedArray=I;function me(Hi){return typeof Promise<"u"&&Hi instanceof Promise||Hi!==null&&typeof Hi=="object"&&typeof Hi.then=="function"&&typeof Hi.catch=="function"}d.isPromise=me;function ge(Hi){return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?ArrayBuffer.isView(Hi):I(Hi)||$t(Hi)}d.isArrayBufferView=ge;function be(Hi){return S(Hi)==="Uint8Array"}d.isUint8Array=be;function ye(Hi){return S(Hi)==="Uint8ClampedArray"}d.isUint8ClampedArray=ye;function ve(Hi){return S(Hi)==="Uint16Array"}d.isUint16Array=ve;function Ie(Hi){return S(Hi)==="Uint32Array"}d.isUint32Array=Ie;function je(Hi){return S(Hi)==="Int8Array"}d.isInt8Array=je;function Me(Hi){return S(Hi)==="Int16Array"}d.isInt16Array=Me;function xt(Hi){return S(Hi)==="Int32Array"}d.isInt32Array=xt;function bt(Hi){return S(Hi)==="Float32Array"}d.isFloat32Array=bt;function gt(Hi){return S(Hi)==="Float64Array"}d.isFloat64Array=gt;function Xt(Hi){return S(Hi)==="BigInt64Array"}d.isBigInt64Array=Xt;function Ut(Hi){return S(Hi)==="BigUint64Array"}d.isBigUint64Array=Ut;function Ht(Hi){return $(Hi)==="[object Map]"}Ht.working=typeof Map<"u"&&Ht(new Map);function mi(Hi){return typeof Map>"u"?!1:Ht.working?Ht(Hi):Hi instanceof Map}d.isMap=mi;function gi(Hi){return $(Hi)==="[object Set]"}gi.working=typeof Set<"u"&&gi(new Set);function Ui(Hi){return typeof Set>"u"?!1:gi.working?gi(Hi):Hi instanceof Set}d.isSet=Ui;function yi(Hi){return $(Hi)==="[object WeakMap]"}yi.working=typeof WeakMap<"u"&&yi(new WeakMap);function vi(Hi){return typeof WeakMap>"u"?!1:yi.working?yi(Hi):Hi instanceof WeakMap}d.isWeakMap=vi;function ts(Hi){return $(Hi)==="[object WeakSet]"}ts.working=typeof WeakSet<"u"&&ts(new WeakSet);function us(Hi){return ts(Hi)}d.isWeakSet=us;function bi(Hi){return $(Hi)==="[object ArrayBuffer]"}bi.working=typeof ArrayBuffer<"u"&&bi(new ArrayBuffer);function Ri(Hi){return typeof ArrayBuffer>"u"?!1:bi.working?bi(Hi):Hi instanceof ArrayBuffer}d.isArrayBuffer=Ri;function Nt(Hi){return $(Hi)==="[object DataView]"}Nt.working=typeof ArrayBuffer<"u"&&typeof DataView<"u"&&Nt(new DataView(new ArrayBuffer(1),0,1));function $t(Hi){return typeof DataView>"u"?!1:Nt.working?Nt(Hi):Hi instanceof DataView}d.isDataView=$t;var li=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:void 0;function Ei(Hi){return $(Hi)==="[object SharedArrayBuffer]"}function xs(Hi){return typeof li>"u"?!1:(typeof Ei.working>"u"&&(Ei.working=Ei(new li)),Ei.working?Ei(Hi):Hi instanceof li)}d.isSharedArrayBuffer=xs;function Vs(Hi){return $(Hi)==="[object AsyncFunction]"}d.isAsyncFunction=Vs;function ms(Hi){return $(Hi)==="[object Map Iterator]"}d.isMapIterator=ms;function bs(Hi){return $(Hi)==="[object Set Iterator]"}d.isSetIterator=bs;function Us(Hi){return $(Hi)==="[object Generator]"}d.isGeneratorObject=Us;function Mr(Hi){return $(Hi)==="[object WebAssembly.Module]"}d.isWebAssemblyCompiledModule=Mr;function ar(Hi){return de(Hi,Z)}d.isNumberObject=ar;function yr(Hi){return de(Hi,te)}d.isStringObject=yr;function jr(Hi){return de(Hi,xe)}d.isBooleanObject=jr;function xn(Hi){return k&&de(Hi,le)}d.isBigIntObject=xn;function dn(Hi){return V&&de(Hi,he)}d.isSymbolObject=dn;function Rn(Hi){return ar(Hi)||yr(Hi)||jr(Hi)||xn(Hi)||dn(Hi)}d.isBoxedPrimitive=Rn;function Vn(Hi){return typeof Uint8Array<"u"&&(Ri(Hi)||xs(Hi))}d.isAnyArrayBuffer=Vn,["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(Hi){Object.defineProperty(d,Hi,{enumerable:!1,value:function(){throw new Error(Hi+" is not supported in userland")}})})},537:(m,d,p)=>{var _=Object.getOwnPropertyDescriptors||function($t){for(var li=Object.keys($t),Ei={},xs=0;xs<li.length;xs++)Ei[li[xs]]=Object.getOwnPropertyDescriptor($t,li[xs]);return Ei},E=/%[sdj%]/g;d.format=function(Nt){if(!je(Nt)){for(var $t=[],li=0;li<arguments.length;li++)$t.push(k(arguments[li]));return $t.join(" ")}for(var li=1,Ei=arguments,xs=Ei.length,Vs=String(Nt).replace(E,function(bs){if(bs==="%%")return"%";if(li>=xs)return bs;switch(bs){case"%s":return String(Ei[li++]);case"%d":return Number(Ei[li++]);case"%j":try{return JSON.stringify(Ei[li++])}catch{return"[Circular]"}default:return bs}}),ms=Ei[li];li<xs;ms=Ei[++li])ye(ms)||!gt(ms)?Vs+=" "+ms:Vs+=" "+k(ms);return Vs},d.deprecate=function(Nt,$t){if(typeof process<"u"&&process.noDeprecation===!0)return Nt;if(typeof process>"u")return function(){return d.deprecate(Nt,$t).apply(this,arguments)};var li=!1;function Ei(){if(!li){if(process.throwDeprecation)throw new Error($t);process.traceDeprecation?console.trace($t):console.error($t),li=!0}return Nt.apply(this,arguments)}return Ei};var S={},I=/^$/;if(process.env.NODE_DEBUG){var D=process.env.NODE_DEBUG;D=D.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),I=new RegExp("^"+D+"$","i")}d.debuglog=function(Nt){if(Nt=Nt.toUpperCase(),!S[Nt])if(I.test(Nt)){var $t=process.pid;S[Nt]=function(){var li=d.format.apply(d,arguments);console.error("%s %d: %s",Nt,$t,li)}}else S[Nt]=function(){};return S[Nt]};function k(Nt,$t){var li={seen:[],stylize:$};return arguments.length>=3&&(li.depth=arguments[2]),arguments.length>=4&&(li.colors=arguments[3]),be($t)?li.showHidden=$t:$t&&d._extend(li,$t),xt(li.showHidden)&&(li.showHidden=!1),xt(li.depth)&&(li.depth=2),xt(li.colors)&&(li.colors=!1),xt(li.customInspect)&&(li.customInspect=!0),li.colors&&(li.stylize=V),te(li,Nt,li.depth)}d.inspect=k,k.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},k.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};function V(Nt,$t){var li=k.styles[$t];return li?"\x1B["+k.colors[li][0]+"m"+Nt+"\x1B["+k.colors[li][1]+"m":Nt}function $(Nt,$t){return Nt}function Z(Nt){var $t={};return Nt.forEach(function(li,Ei){$t[li]=!0}),$t}function te(Nt,$t,li){if(Nt.customInspect&&$t&&Ht($t.inspect)&&$t.inspect!==d.inspect&&!($t.constructor&&$t.constructor.prototype===$t)){var Ei=$t.inspect(li,Nt);return je(Ei)||(Ei=te(Nt,Ei,li)),Ei}var xs=xe(Nt,$t);if(xs)return xs;var Vs=Object.keys($t),ms=Z(Vs);if(Nt.showHidden&&(Vs=Object.getOwnPropertyNames($t)),Ut($t)&&(Vs.indexOf("message")>=0||Vs.indexOf("description")>=0))return le($t);if(Vs.length===0){if(Ht($t)){var bs=$t.name?": "+$t.name:"";return Nt.stylize("[Function"+bs+"]","special")}if(bt($t))return Nt.stylize(RegExp.prototype.toString.call($t),"regexp");if(Xt($t))return Nt.stylize(Date.prototype.toString.call($t),"date");if(Ut($t))return le($t)}var Us="",Mr=!1,ar=["{","}"];if(ge($t)&&(Mr=!0,ar=["[","]"]),Ht($t)){var yr=$t.name?": "+$t.name:"";Us=" [Function"+yr+"]"}if(bt($t)&&(Us=" "+RegExp.prototype.toString.call($t)),Xt($t)&&(Us=" "+Date.prototype.toUTCString.call($t)),Ut($t)&&(Us=" "+le($t)),Vs.length===0&&(!Mr||$t.length==0))return ar[0]+Us+ar[1];if(li<0)return bt($t)?Nt.stylize(RegExp.prototype.toString.call($t),"regexp"):Nt.stylize("[Object]","special");Nt.seen.push($t);var jr;return Mr?jr=he(Nt,$t,li,ms,Vs):jr=Vs.map(function(xn){return de(Nt,$t,li,ms,xn,Mr)}),Nt.seen.pop(),me(jr,Us,ar)}function xe(Nt,$t){if(xt($t))return Nt.stylize("undefined","undefined");if(je($t)){var li="'"+JSON.stringify($t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return Nt.stylize(li,"string")}if(Ie($t))return Nt.stylize(""+$t,"number");if(be($t))return Nt.stylize(""+$t,"boolean");if(ye($t))return Nt.stylize("null","null")}function le(Nt){return"["+Error.prototype.toString.call(Nt)+"]"}function he(Nt,$t,li,Ei,xs){for(var Vs=[],ms=0,bs=$t.length;ms<bs;++ms)ts($t,String(ms))?Vs.push(de(Nt,$t,li,Ei,String(ms),!0)):Vs.push("");return xs.forEach(function(Us){Us.match(/^\d+$/)||Vs.push(de(Nt,$t,li,Ei,Us,!0))}),Vs}function de(Nt,$t,li,Ei,xs,Vs){var ms,bs,Us;if(Us=Object.getOwnPropertyDescriptor($t,xs)||{value:$t[xs]},Us.get?Us.set?bs=Nt.stylize("[Getter/Setter]","special"):bs=Nt.stylize("[Getter]","special"):Us.set&&(bs=Nt.stylize("[Setter]","special")),ts(Ei,xs)||(ms="["+xs+"]"),bs||(Nt.seen.indexOf(Us.value)<0?(ye(li)?bs=te(Nt,Us.value,null):bs=te(Nt,Us.value,li-1),bs.indexOf(`
`)>-1&&(Vs?bs=bs.split(`
`).map(function(Mr){return"  "+Mr}).join(`
`).slice(2):bs=`
`+bs.split(`
`).map(function(Mr){return"   "+Mr}).join(`
`))):bs=Nt.stylize("[Circular]","special")),xt(ms)){if(Vs&&xs.match(/^\d+$/))return bs;ms=JSON.stringify(""+xs),ms.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(ms=ms.slice(1,-1),ms=Nt.stylize(ms,"name")):(ms=ms.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),ms=Nt.stylize(ms,"string"))}return ms+": "+bs}function me(Nt,$t,li){var Ei=0,xs=Nt.reduce(function(Vs,ms){return Ei++,ms.indexOf(`
`)>=0&&Ei++,Vs+ms.replace(/\u001b\[\d\d?m/g,"").length+1},0);return xs>60?li[0]+($t===""?"":$t+`
 `)+" "+Nt.join(`,
  `)+" "+li[1]:li[0]+$t+" "+Nt.join(", ")+" "+li[1]}d.types=p(32);function ge(Nt){return Array.isArray(Nt)}d.isArray=ge;function be(Nt){return typeof Nt=="boolean"}d.isBoolean=be;function ye(Nt){return Nt===null}d.isNull=ye;function ve(Nt){return Nt==null}d.isNullOrUndefined=ve;function Ie(Nt){return typeof Nt=="number"}d.isNumber=Ie;function je(Nt){return typeof Nt=="string"}d.isString=je;function Me(Nt){return typeof Nt=="symbol"}d.isSymbol=Me;function xt(Nt){return Nt===void 0}d.isUndefined=xt;function bt(Nt){return gt(Nt)&&gi(Nt)==="[object RegExp]"}d.isRegExp=bt,d.types.isRegExp=bt;function gt(Nt){return typeof Nt=="object"&&Nt!==null}d.isObject=gt;function Xt(Nt){return gt(Nt)&&gi(Nt)==="[object Date]"}d.isDate=Xt,d.types.isDate=Xt;function Ut(Nt){return gt(Nt)&&(gi(Nt)==="[object Error]"||Nt instanceof Error)}d.isError=Ut,d.types.isNativeError=Ut;function Ht(Nt){return typeof Nt=="function"}d.isFunction=Ht;function mi(Nt){return Nt===null||typeof Nt=="boolean"||typeof Nt=="number"||typeof Nt=="string"||typeof Nt=="symbol"||typeof Nt>"u"}d.isPrimitive=mi,d.isBuffer=p(135);function gi(Nt){return Object.prototype.toString.call(Nt)}function Ui(Nt){return Nt<10?"0"+Nt.toString(10):Nt.toString(10)}var yi=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function vi(){var Nt=new Date,$t=[Ui(Nt.getHours()),Ui(Nt.getMinutes()),Ui(Nt.getSeconds())].join(":");return[Nt.getDate(),yi[Nt.getMonth()],$t].join(" ")}d.log=function(){console.log("%s - %s",vi(),d.format.apply(d,arguments))},d.inherits=p(698),d._extend=function(Nt,$t){if(!$t||!gt($t))return Nt;for(var li=Object.keys($t),Ei=li.length;Ei--;)Nt[li[Ei]]=$t[li[Ei]];return Nt};function ts(Nt,$t){return Object.prototype.hasOwnProperty.call(Nt,$t)}var us=typeof Symbol<"u"?Symbol("util.promisify.custom"):void 0;d.promisify=function($t){if(typeof $t!="function")throw new TypeError('The "original" argument must be of type Function');if(us&&$t[us]){var li=$t[us];if(typeof li!="function")throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(li,us,{value:li,enumerable:!1,writable:!1,configurable:!0}),li}function li(){for(var Ei,xs,Vs=new Promise(function(Us,Mr){Ei=Us,xs=Mr}),ms=[],bs=0;bs<arguments.length;bs++)ms.push(arguments[bs]);ms.push(function(Us,Mr){Us?xs(Us):Ei(Mr)});try{$t.apply(this,ms)}catch(Us){xs(Us)}return Vs}return Object.setPrototypeOf(li,Object.getPrototypeOf($t)),us&&Object.defineProperty(li,us,{value:li,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(li,_($t))},d.promisify.custom=us;function bi(Nt,$t){if(!Nt){var li=new Error("Promise was rejected with a falsy value");li.reason=Nt,Nt=li}return $t(Nt)}function Ri(Nt){if(typeof Nt!="function")throw new TypeError('The "original" argument must be of type Function');function $t(){for(var li=[],Ei=0;Ei<arguments.length;Ei++)li.push(arguments[Ei]);var xs=li.pop();if(typeof xs!="function")throw new TypeError("The last argument must be of type Function");var Vs=this,ms=function(){return xs.apply(Vs,arguments)};Nt.apply(this,li).then(function(bs){process.nextTick(ms.bind(null,null,bs))},function(bs){process.nextTick(bi.bind(null,bs,ms))})}return Object.setPrototypeOf($t,Object.getPrototypeOf(Nt)),Object.defineProperties($t,_(Nt)),$t}d.callbackify=Ri},767:(m,d,p)=>{"use strict";var _=p(682),E=p(209),S=p(487),I=p(75),D=p(795),k=I("Object.prototype.toString"),V=p(711)(),$=typeof globalThis>"u"?p.g:globalThis,Z=E(),te=I("String.prototype.slice"),xe=Object.getPrototypeOf,le=I("Array.prototype.indexOf",!0)||function(be,ye){for(var ve=0;ve<be.length;ve+=1)if(be[ve]===ye)return ve;return-1},he={__proto__:null};V&&D&&xe?_(Z,function(ge){var be=new $[ge];if(Symbol.toStringTag in be){var ye=xe(be),ve=D(ye,Symbol.toStringTag);if(!ve){var Ie=xe(ye);ve=D(Ie,Symbol.toStringTag)}he["$"+ge]=S(ve.get)}}):_(Z,function(ge){var be=new $[ge],ye=be.slice||be.set;ye&&(he["$"+ge]=S(ye))});var de=function(be){var ye=!1;return _(he,function(ve,Ie){if(!ye)try{"$"+ve(be)===Ie&&(ye=te(Ie,1))}catch{}}),ye},me=function(be){var ye=!1;return _(he,function(ve,Ie){if(!ye)try{ve(be),ye=te(Ie,1)}catch{}}),ye};m.exports=function(be){if(!be||typeof be!="object")return!1;if(!V){var ye=te(k(be),8,-1);return le(Z,ye)>-1?ye:ye!=="Object"?!1:me(be)}return D?de(be):null}},742:()=>{},209:(m,d,p)=>{"use strict";var _=p(578),E=typeof globalThis>"u"?p.g:globalThis;m.exports=function(){for(var I=[],D=0;D<_.length;D++)typeof E[_[D]]=="function"&&(I[I.length]=_[D]);return I}}},__webpack_module_cache__={};function __webpack_require__(m){var d=__webpack_module_cache__[m];if(d!==void 0)return d.exports;var p=__webpack_module_cache__[m]={exports:{}};return __webpack_modules__[m](p,p.exports,__webpack_require__),p.exports}__webpack_require__.d=(m,d)=>{for(var p in d)__webpack_require__.o(d,p)&&!__webpack_require__.o(m,p)&&Object.defineProperty(m,p,{enumerable:!0,get:d[p]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(m,d)=>Object.prototype.hasOwnProperty.call(m,d);var __webpack_exports__={};(()=>{"use strict";var m=__webpack_require__(786),d=__webpack_require__(7);class p extends d.EventEmitter{}var _=Object.defineProperty,E=Object.getOwnPropertySymbols,S=Object.prototype.hasOwnProperty,I=Object.prototype.propertyIsEnumerable,D=(F,a,x)=>a in F?_(F,a,{enumerable:!0,configurable:!0,writable:!0,value:x}):F[a]=x,k=(F,a)=>{for(var x in a||(a={}))S.call(a,x)&&D(F,x,a[x]);if(E)for(var x of E(a))I.call(a,x)&&D(F,x,a[x]);return F};class V{constructor(a="canvas"){this.size={width:0,height:0},this.transpose=!1,this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.capture."+a,this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}capture(a){const{context:x,clipPix:c,transpose:u}=this;if(!x)return!1;let{width:g,height:y}=this.size;return u&&([g,y]=[y,g]),u&&x.setTransform(0,1,1,0,0,0),c?x.drawImage(a,c.left,c.top,c.width,c.height,0,0,g,y):x.drawImage(a,0,0,g,y),u&&x.resetTransform(),!0}fill(){const{context:a}=this;if(!a)return;let{width:x,height:c}=this.size;a.fillStyle="rgba(255, 255, 255, 1)",a.fillRect(0,0,x,c)}data(){const{context:a}=this;if(!a)return;const{width:x,height:c}=this.size;return a.getImageData(0,0,x,c)}setSize(a){let{width:x,height:c}=a;this.transpose&&([x,c]=[c,x]),this.size={width:x,height:c},this.canvas.width=x,this.canvas.height=c,this.setClip(this.clip)}setClip(a){let{width:x,height:c}=this.size;this.transpose&&([x,c]=[c,x]),this.clip=a,this.clipPix=a&&{left:a.left*x,top:a.top*c,width:a.width*x,height:a.height*c}}setTranspose(a){if(a==this.transpose)return;let{width:x,height:c}=this.size;this.transpose&&([x,c]=[c,x]),this.transpose=a,this.setSize({width:x,height:c})}dispose(){this.context=null,this.canvas.remove()}}class $ extends p{constructor(){super(),this.buffer=new V("capture"),this.captureTime=0}async setup(a){const x=a&&(c=>typeof c!="string"&&"size"in c)(a)&&a.size||{width:1920,height:1080};return this.updateSize(x),this.buffer.fill(),!0}dispose(){this.reset(),this.buffer.dispose()}async start(){this.captureTime=0,this.timer=Date.now()}pause(){}reset(){this.pause(),delete this.timer}capture(){return this.timer===void 0?!1:(this.captureTime=(Date.now()-this.timer)*1e3,!0)}size(){return k({},this.buffer.size)}ratio(){const a=this.buffer.size;return a.width/a.height}updateSize(a){let{width:x,height:c}=a;const{sizeMax:u,clipRect:g,transpose:y}=this;if(u&&(x>u||c>u)){const v=x/c;v>1?(x=u,c=u/v):(c=u,x=v*u),a={width:x,height:c}}this.buffer.setSize(a),this.buffer.setClip(g),this.buffer.setTranspose(!!y),this.emit("resize",this.buffer.size)}}class Z extends ${constructor(){super(),this.timeShift=0,this.videoRef=document.createElement("video"),this.videoRef.id="engeenee.capture.source",this.videoRef.muted=!0,this.videoRef.loop=!0,this.videoRef.playsInline=!0}async setup(a){const x=w=>typeof w=="string"||"url"in w&&typeof w.url=="string",c=w=>x(w)||"getVideoTracks"in w,u=w=>x(w)&&typeof w!="string"?(this.sizeMax=w.sizeMax,w.url):w,g=w=>{var B,W;return w?(ae=>"video"in ae)(w)?w:(this.clipRect=w.clip,this.transpose=w.transpose,{video:{facingMode:w.rear?"environment":"user",width:(B=w.size)==null?void 0:B.width,height:(W=w.size)==null?void 0:W.height,frameRate:w.fps},audio:!1}):{video:!0,audio:!1}};delete this.sizeMax,delete this.clipRect,delete this.transpose;const y=a!==void 0&&c(a)?u(a):await navigator.mediaDevices.getUserMedia(g(a)).catch(()=>{});if(!y)return!1;const{videoRef:v}=this;return new Promise(w=>{v.onloadedmetadata=()=>{this.updateSize({width:v.videoWidth,height:v.videoHeight}),v.onresize=()=>{this.updateSize({width:v.videoWidth,height:v.videoHeight})},v.onseeked=()=>{this.timeShift=this.captureTime,this.captureTime=0},w(!0)},typeof y=="string"?v.src=y:v.srcObject=y})}dispose(){super.dispose(),this.videoRef.remove()}async start(){this.captureTime=0,this.timeShift=0,(this.videoRef.srcObject||this.videoRef.src)&&await this.videoRef.play()}pause(){this.videoRef.pause()}reset(){this.pause(),this.videoRef.srcObject&&(this.videoRef.srcObject.getTracks().forEach(a=>a.stop()),this.videoRef.srcObject=null)}capture(){const{videoRef:a,buffer:x}=this,c=a.currentTime+this.timeShift;return c<=this.captureTime?!1:(this.captureTime=c,x.capture(a))}}class te extends p{constructor(a,x,c=Z){super(),this.engineParams=x,this.renderers=[],this.videoRatio=1920/1080,this.streamSize={width:1920,height:1080},this.processSize={width:1920,height:1080},this.resizeEnabled=!1,this.loopState=!1,this.init=async u=>{const g=await this.setupProcessor(u);return this.emit("init",g),g},this.setup=async u=>{this.pause();const g=await this.setupVideo(u);return this.emit("setup",g),g},this.start=async()=>{await this.video.start(),this.loopState=!0,this.emit("start"),this.enqueue()},this.pause=()=>{this.loopState=!1,this.loopId&&(window.cancelAnimationFrame(this.loopId),delete this.loopId),this.video.pause(),this.emit("pause")},this.reset=()=>{this.pause(),this.video.reset(),delete this.streamCanvas,delete this.processCanvas,this.processor.reset()},this.iterate=async()=>{var u;const{video:g,streamCanvas:y,processCanvas:v}=this;if(!g.capture()||!y||!v)return this.enqueue();this.resizeEnabled&&((u=this.resizeBuffer)==null||u.capture(g.buffer.canvas));const w=await this.processor.process(v,g.captureTime);w&&await Promise.all(this.renderers.map(B=>B.update(w,y))),this.enqueue()},this.processor=typeof a=="function"?new a:a,this.video=typeof c=="function"?new c:c,this.video.on("resize",this.resizeVideo.bind(this))}async addRenderer(a){this.renderers.push(a),await a.load(),a.setupVideo(this.video.size(),this.video.ratio()),a.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle)}removeRenderer(a){const{renderers:x}=this,c=x.indexOf(a);c<0||(x[c].dispose(),x.splice(c,1))}enqueue(){this.loopId=this.loopState?window.requestAnimationFrame(this.iterate):void 0}async setupProcessor(a){var x;const c=this.resizeEnabled&&((x=this.resizeBuffer)==null?void 0:x.size)||this.video.size();return this.processor.init(a,c,this.video.ratio())}async setupVideo(a){return this.video.reset(),await this.video.setup(a)?(this.setupSize(this.video.size()),!0):!1}async setupSize(a){var x,c;const{width:u,height:g}=a;this.videoRatio=u/g;const y=Math.max(u,g),v=((x=this.engineParams)==null?void 0:x.max)||this.processor.optimalSize;if(this.resizeEnabled=!1,v<y){this.resizeEnabled=!0;const w=y/v;this.resizeBuffer||(this.resizeBuffer=new V("resize")),this.resizeBuffer.setSize({width:u/w,height:g/w})}this.resizeEnabled&&this.resizeBuffer?(this.processCanvas=this.resizeBuffer.canvas,this.processSize=this.resizeBuffer.size):(this.processCanvas=this.video.buffer.canvas,this.processSize=this.video.size()),((c=this.engineParams)==null?void 0:c.orig)!==!1?(this.streamCanvas=this.video.buffer.canvas,this.streamSize=this.video.size()):(this.streamCanvas=this.processCanvas,this.streamSize=this.streamSize)}resizeVideo(a){this.setupSize(a),this.processor.setupVideo(this.processSize,this.videoRatio),this.renderers.forEach(x=>x.setupVideo(this.streamSize,this.videoRatio)),this.renderers.forEach(x=>x.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle))}}var xe=Object.defineProperty,le=Object.getOwnPropertySymbols,he=Object.prototype.hasOwnProperty,de=Object.prototype.propertyIsEnumerable,me=(F,a,x)=>a in F?xe(F,a,{enumerable:!0,configurable:!0,writable:!0,value:x}):F[a]=x,ge=(F,a)=>{for(var x in a||(a={}))he.call(a,x)&&me(F,x,a[x]);if(le)for(var x of le(a))de.call(a,x)&&me(F,x,a[x]);return F};class be extends p{constructor(){super(),this.params={},this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.optimalSize=1024,this.cameraRatio=this.videoRatio,this.cameraAngle=60/180*Math.PI}async process(a,x){return{}}async init(a,x,c){return this.params=a,!c&&x&&(c=x.width/x.height),this.setupVideo(x||this.videoSize,c||this.videoRatio),this.emit("init",!0),!0}reset(){this.emit("reset")}dispose(){}setupVideo(a,x){x=x||a.width/a.height,this.videoSize=ge({},a),this.videoRatio=x,this.cameraRatio=x}}class ye extends p{constructor(a,x="crop",c=1,u=!1,g=1){super(),this.container=a,this.mode=x,this.layerCount=c,this.mirror=u,this.aspectRatio=g,this.layers=[],this.padsSize=[1,1],this.setAspectRatio=y=>{this.aspectRatio=y,this.updateSizes(this.container.clientWidth/this.container.clientHeight)},this.setMirror=y=>{this.mirror=y,this.layers.forEach(v=>{v.style.transform=y?"scaleX(-1)":""})},this.setMode=y=>{if(this.mode=y,this.mode==="pad"&&!this.pads){this.pads=[document.createElement("canvas"),document.createElement("canvas")];const v=-10*(this.layerCount+1)+"";for(let w=0;w<2;w++)this.pads[w].id="engeenee.canvas.pad"+w,this.pads[w].style.position="absolute",this.pads[w].style.zIndex=v,this.container.appendChild(this.pads[w])}this.mode!=="pad"&&this.pads&&(this.pads.forEach(v=>v.remove()),delete this.pads),this.setAspectRatio(this.aspectRatio)},this.dispose=()=>{var y,v;(y=this.observer)==null||y.disconnect(),delete this.observer,(v=this.pads)==null||v.forEach(w=>w.remove()),delete this.pads,this.layers.forEach(w=>w.remove()),this.layers=[]},this.updateSizes=y=>{let v=1,w=1;y>this.aspectRatio?this.mode==="crop"?w=y/this.aspectRatio:v=this.aspectRatio/y:this.mode==="crop"?v=this.aspectRatio/y:w=y/this.aspectRatio;const B=(1-v)/2,W=(1-w)/2,ae=v*100+"%",ue=w*100+"%",fe=B*100+"%",Re=W*100+"%";for(const _e of this.layers)_e.style.width=ae,_e.style.height=ue,_e.style.left=fe,_e.style.top=Re;if(this.pads){this.padsSize=B>0?[B,1]:[1,W];const _e=10,{clientWidth:Be,clientHeight:tt}=this.container,$e=[2*_e/Be,2*_e/tt],Et=(this.padsSize[0]+2*$e[0])*100+"%",ft=(this.padsSize[1]+2*$e[1])*100+"%";this.pads[0].style.width=Et,this.pads[0].style.height=ft,this.pads[1].style.width=Et,this.pads[1].style.height=ft;const dt=-$e[0]*100+"%",ut=-$e[1]*100+"%";this.pads[0].style.top=ut,this.pads[1].style.bottom=ut,this.pads[0].style.left="unset",this.pads[0].style.right="unset",this.pads[1].style.left="unset",this.pads[1].style.right="unset",this.pads[this.mirror?1:0].style.left=dt,this.pads[this.mirror?0:1].style.right=dt;const Mt=B>0?this.mirror?"":"scaleX(-1)":"scaleY(-1) "+(this.mirror?"scaleX(-1)":"");this.pads[0].style.transform=Mt,this.pads[1].style.transform=Mt;const ai="blur("+_e+"px)";this.pads[0].style.filter=ai,this.pads[1].style.filter=ai}this.emit("resize")},this.handleResize=y=>{if(y.length<1)return;const v=y[0].contentRect;this.updateSizes(v.width/v.height)};for(let y=0;y<c;y++){const v=document.createElement("canvas");v.id="engeenee.canvas.layer"+y,v.style.position="absolute",v.style.zIndex=-10*(c-y)+"",this.mirror&&(v.style.transform="scaleX(-1)"),this.container.appendChild(v),this.layers.push(v)}this.setMode(x),this.observer=new ResizeObserver(this.handleResize),this.observer.observe(this.container),this.container.style.overflow="hidden"}}var ve=Object.defineProperty,Ie=Object.getOwnPropertySymbols,je=Object.prototype.hasOwnProperty,Me=Object.prototype.propertyIsEnumerable,xt=(F,a,x)=>a in F?ve(F,a,{enumerable:!0,configurable:!0,writable:!0,value:x}):F[a]=x,bt=(F,a)=>{for(var x in a||(a={}))je.call(a,x)&&xt(F,x,a[x]);if(Ie)for(var x of Ie(a))Me.call(a,x)&&xt(F,x,a[x]);return F};class gt extends p{constructor(){super(),this.loaded=!1,this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.cameraRatio=this.videoRatio,this.cameraAngle=10/180*Math.PI}async load(){this.loaded||(this.loaded=!0,this.emit("load"))}unload(){this.loaded&&(this.loaded=!1)}async update(a,x){this.loaded&&(this.updateVideo(x),this.updateScene(),this.emit("render"))}updateVideo(a){}updateScene(){}dispose(){this.unload()}setupVideo(a,x){this.videoSize=bt({},a),this.videoRatio=x||a.width/a.height,this.emit("resize",this.videoSize,this.videoRatio)}setupCamera(a,x){this.cameraRatio=a,this.cameraAngle=x}}class Xt extends gt{constructor(){super(...arguments),this.plugins=[]}async load(){if(!this.loaded)return await Promise.all(this.plugins.map(a=>a.load(this))),super.load()}unload(){this.plugins.forEach(a=>a.unload()),super.unload()}async update(a,x){if(this.loaded)return await this.updatePlugins(a,x),super.update(a,x)}async updatePlugins(a,x){for(let c of this.plugins)c.loaded&&await c.update(a,x)}dispose(){this.plugins.forEach(a=>a.dispose()),this.plugins=[],super.dispose()}async addPlugin(a){const{plugins:x}=this;this.loaded&&!a.loaded&&await a.load(this),x.push(a),x.sort((c,u)=>c.ordinal-u.ordinal)}removePlugin(a){const{plugins:x}=this,c=x.indexOf(a);c<0||(x[c].dispose(),x.splice(c,1))}removeAllPlugins(){this.plugins.forEach(a=>a.dispose()),this.plugins=[]}setupVideo(a,x){super.setupVideo(a,x),this.plugins.forEach(c=>c.setupVideo(a))}setupCamera(a,x){super.setupCamera(a,x),this.plugins.forEach(c=>c.setupCamera(a,x))}}class Ut extends Xt{constructor(a){super(),this.padCtx=[null,null],this.setupPadding=()=>{if(!this.canvas.pads)return;const{width:x,height:c}=this.videoSize,{padsSize:u}=this.canvas,g=x*u[0]/(u[0]<.5?1-2*u[0]:1),y=c*u[1]/(u[1]<.5?1-2*u[1]:1);this.canvas.pads[0].width=g,this.canvas.pads[0].height=y,this.canvas.pads[1].width=g,this.canvas.pads[1].height=y},this.canvas=new ye(a.container,a.mode,a.layerCount,a.mirror,a.aspectRatio),this.canvas.pads&&(this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]),this.canvas.addListener("resize",this.setupPadding)}updateVideo(a){super.updateVideo(a),this.updatePads(a)}dispose(){this.padCtx=[null,null],this.canvas.dispose(),super.dispose()}setupVideo(a,x){super.setupVideo(a,x),this.canvas.setAspectRatio(this.videoRatio)}setMirror(a){this.canvas.setMirror(a)}setMode(a){this.canvas.setMode(a),this.canvas.pads?this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]:this.padCtx=[null,null]}updatePads(a){if(!this.padCtx[0]||!this.padCtx[1]||!this.canvas.pads)return;const{videoSize:{width:x,height:c}}=this,{width:u,height:g}=this.canvas.pads[0];this.padCtx[0].clearRect(0,0,u,g),this.padCtx[0].drawImage(a,0,0,u,g,0,0,u,g),this.padCtx[1].clearRect(0,0,u,g),this.padCtx[1].drawImage(a,x-u,c-g,u,g,0,0,u,g)}}class Ht extends Ut{constructor(a){super(a),this.videoCtx=null;const x=this.canvas.layers[0];this.videoCtx=x.getContext("2d")}updateVideo(a){const{videoCtx:x}=this;if(!x)return;const{width:c,height:u}=this.videoSize;x.clearRect(0,0,c,u),x.drawImage(a,0,0),super.updateVideo(a)}setupVideo(a,x){super.setupVideo(a,x);const{width:c,height:u}=this.videoSize;this.canvas.layers[0].width=c,this.canvas.layers[0].height=u}}class mi{constructor(a,x={width:1920,height:1080},c=!1,u=!1){this.gl=a,this.size=x,this.grayscale=c,this.linear=u,this.buffer=null,this.resize(x)}update(a){const{gl:x,size:{width:c,height:u}}=this,g=x.getParameter(x.TEXTURE_BINDING_2D),y=x.getParameter(x.UNPACK_FLIP_Y_WEBGL);return x.bindTexture(x.TEXTURE_2D,this.buffer),x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL,!1),a instanceof Float32Array?x.texSubImage2D(x.TEXTURE_2D,0,0,0,c,u,this.grayscale?x.RED:x.RGBA,x.FLOAT,a):a instanceof Uint8Array?x.texSubImage2D(x.TEXTURE_2D,0,0,0,c,u,this.grayscale?x.RED:x.RGBA,x.UNSIGNED_BYTE,a):x.texSubImage2D(x.TEXTURE_2D,0,0,0,c,u,this.grayscale?x.RED:x.RGBA,x.UNSIGNED_BYTE,a),x.bindTexture(x.TEXTURE_2D,g),x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL,y),this.buffer}resize(a){const{width:x,height:c}=a;if(x===this.size.width&&c===this.size.height&&this.buffer)return!0;const{gl:u}=this;if(u.deleteTexture(this.buffer),this.buffer=null,(x>0||c>0)&&(this.buffer=u.createTexture()),!this.buffer)return!1;const g=this.linear?u.LINEAR:u.NEAREST,y=u.getParameter(u.TEXTURE_BINDING_2D),v=u.getParameter(u.UNPACK_FLIP_Y_WEBGL);return u.bindTexture(u.TEXTURE_2D,this.buffer),u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL,!1),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_R,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MIN_FILTER,g),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MAG_FILTER,g),this.size={width:x,height:c},u.texStorage2D(u.TEXTURE_2D,1,this.grayscale?u.R8:u.RGBA8,x,c),u.bindTexture(u.TEXTURE_2D,y),u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL,v),!0}dispose(){this.gl.deleteTexture(this.buffer),this.buffer=null}texture(){return this.buffer}valid(){return!!this.buffer}}var gi=Object.defineProperty,Ui=Object.getOwnPropertySymbols,yi=Object.prototype.hasOwnProperty,vi=Object.prototype.propertyIsEnumerable,ts=(F,a,x)=>a in F?gi(F,a,{enumerable:!0,configurable:!0,writable:!0,value:x}):F[a]=x,us=(F,a)=>{for(var x in a||(a={}))yi.call(a,x)&&ts(F,x,a[x]);if(Ui)for(var x of Ui(a))vi.call(a,x)&&ts(F,x,a[x]);return F};class bi{constructor(a,x={width:1920,height:1080},c=["image"],u={},g=Nt,y=Ri,v=!1){this.gl=a,this.size=x,this.inputs=c,this.uniforms=u,this.vertShader=null,this.fragShader=null,this.shaderProgram=null,this.vertBuffer=null,this.vertAttrs=null,this.uniformsLoc={},this.frameBuffer=null,g.includes("uniform vec2 wh;")&&!u.wh&&(u.wh="2f"),y.includes("uniform float flip;")&&!u.flip&&(u.flip="1f"),this.outputTexture=new mi(a,x,!1,v),this.compile(g,y),this.resize(x)}process(a,x={}){const{gl:c,outputTexture:u}=this;if(!c||!u||a.length!==this.inputs.length)return null;const g=u.texture();if(!g)return null;const y=this.save(c);return c.bindFramebuffer(c.FRAMEBUFFER,this.frameBuffer),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,g,0),x=us({flip:[-1]},x),this.prepare(c,a,x),c.drawArrays(c.TRIANGLES,0,6),this.restore(c,y),g}render(a,x={}){const{gl:c,outputTexture:u}=this;if(!c||!u||a.length!==this.inputs.length)return;const g=this.save(c);c.bindFramebuffer(c.FRAMEBUFFER,null),x=us({flip:[1]},x),this.prepare(c,a,x),c.drawArrays(c.TRIANGLES,0,6),this.restore(c,g)}output(){var a;return((a=this.outputTexture)==null?void 0:a.texture())||null}program(){return this.shaderProgram}resize(a){var x;const{gl:c}=this;this.size={width:a.width,height:a.height},(x=this.outputTexture)==null||x.resize(a);const u=c.getParameter(c.CURRENT_PROGRAM);c.useProgram(this.shaderProgram),this.uniformsLoc.wh&&c.uniform2f(this.uniformsLoc.wh,a.width,a.height),c.useProgram(u)}dispose(){var a;const{gl:x}=this;x.deleteBuffer(this.vertBuffer),this.vertBuffer=null,x.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,x.deleteShader(this.vertShader),this.vertShader=null,x.deleteShader(this.fragShader),this.fragShader=null,x.deleteProgram(this.shaderProgram),this.shaderProgram=null,(a=this.outputTexture)==null||a.dispose(),delete this.outputTexture}compile(a,x){const{gl:c}=this,u=this.save(c);if(this.vertBuffer=c.createBuffer(),this.vertAttrs=c.createVertexArray(),this.frameBuffer=c.createFramebuffer(),!this.vertBuffer||!this.frameBuffer||!this.vertAttrs){c.deleteBuffer(this.vertBuffer),this.vertBuffer=null,c.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,c.deleteVertexArray(this.vertAttrs),this.vertAttrs=null;return}if(this.vertShader=c.createShader(c.VERTEX_SHADER),this.fragShader=c.createShader(c.FRAGMENT_SHADER),this.shaderProgram=c.createProgram(),!this.vertShader||!this.fragShader||!this.shaderProgram){c.deleteBuffer(this.vertBuffer),this.vertBuffer=null,c.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,c.deleteShader(this.vertShader),this.vertShader=null,c.deleteShader(this.fragShader),this.fragShader=null,c.deleteProgram(this.shaderProgram),this.shaderProgram=null;return}c.shaderSource(this.vertShader,x),c.shaderSource(this.fragShader,a),c.compileShader(this.vertShader),c.compileShader(this.fragShader),c.attachShader(this.shaderProgram,this.vertShader),c.attachShader(this.shaderProgram,this.fragShader),c.linkProgram(this.shaderProgram),c.useProgram(this.shaderProgram),c.bindBuffer(c.ARRAY_BUFFER,this.vertBuffer),c.bufferData(c.ARRAY_BUFFER,new Float32Array([-1,-1,1,1,-1,1,-1,-1,1,-1,1,1]),c.STATIC_DRAW),c.bindVertexArray(this.vertAttrs);const g=c.getAttribLocation(this.shaderProgram,"pos");c.vertexAttribPointer(g,2,c.FLOAT,!1,0,0),c.enableVertexAttribArray(g),this.uniformsLoc={};for(let y in this.uniforms)this.uniformsLoc[y]=c.getUniformLocation(this.shaderProgram,y);for(let y=0;y<this.inputs.length;y++)c.uniform1i(c.getUniformLocation(this.shaderProgram,this.inputs[y]),y);this.restore(c,u)}prepare(a,x,c={}){const{size:{width:u,height:g}}=this;for(let y=0;y<x.length;y++)a.activeTexture(a.TEXTURE0+y),a.bindTexture(a.TEXTURE_2D,x[y]);a.useProgram(this.shaderProgram),a.bindVertexArray(this.vertAttrs);for(let y in c)switch(this.uniforms[y]){case"1f":this.uniformsLoc[y]&&c[y].length===1&&a.uniform1f(this.uniformsLoc[y],c[y][0]);break;case"2f":this.uniformsLoc[y]&&c[y].length===2&&a.uniform2f(this.uniformsLoc[y],c[y][0],c[y][1]);break;case"3f":this.uniformsLoc[y]&&c[y].length===3&&a.uniform3f(this.uniformsLoc[y],c[y][0],c[y][1],c[y][2]);break;case"4f":this.uniformsLoc[y]&&c[y].length===4&&a.uniform4f(this.uniformsLoc[y],c[y][0],c[y][1],c[y][2],c[y][3]);break}a.disable(a.CULL_FACE),a.colorMask(!0,!0,!0,!0),a.viewport(0,0,u,g),a.scissor(0,0,u,g),a.clear(a.COLOR_BUFFER_BIT)}save(a){return{program:a.getParameter(a.CURRENT_PROGRAM),arrayBuffer:a.getParameter(a.ARRAY_BUFFER_BINDING),framebuffer:a.getParameter(a.FRAMEBUFFER_BINDING),vertexArray:a.getParameter(a.VERTEX_ARRAY_BINDING),viewport:a.getParameter(a.VIEWPORT),scissor:a.getParameter(a.SCISSOR_BOX),colorMask:a.getParameter(a.COLOR_WRITEMASK),cullFace:a.getParameter(a.CULL_FACE),activeTexture:a.getParameter(a.ACTIVE_TEXTURE),textures:this.inputs.map((x,c)=>(a.activeTexture(a.TEXTURE0+c),a.getParameter(a.TEXTURE_BINDING_2D)))}}restore(a,x){a.useProgram(x.program),a.bindBuffer(a.ARRAY_BUFFER,x.arrayBuffer),a.bindFramebuffer(a.FRAMEBUFFER,x.framebuffer),a.bindVertexArray(x.vertexArray),a.viewport(x.viewport[0],x.viewport[1],x.viewport[2],x.viewport[3]),a.scissor(x.scissor[0],x.scissor[1],x.scissor[2],x.scissor[3]),a.colorMask(x.colorMask[0],x.colorMask[1],x.colorMask[2],x.colorMask[3]);for(let c=0;c<x.textures.length;c++)a.activeTexture(a.TEXTURE0+c),a.bindTexture(a.TEXTURE_2D,x.textures[c]);a.activeTexture(x.activeTexture),x.cullFace?a.enable(a.CULL_FACE):a.disable(a.CULL_FACE)}}const Ri=`
    attribute vec2 pos;
    uniform float flip;
    varying vec2 xy;
    void main() {
        xy = (vec2(pos.x, -pos.y) + 1.0) * 0.5;
        gl_Position = vec4(pos.x, pos.y * flip, 0, 1.0);
    }
`,Nt=`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform sampler2D image;
    void main() {
        gl_FragColor = texture2D(image, xy);
    }
`;class $t extends Ut{constructor(a){super(a),this.shaderCtx=null,this.current=null;const x=this.canvas.layers[0];this.shaderCtx=x.getContext("webgl2",{alpha:!0,preserveDrawingBuffer:!0})}async load(){if(this.loaded)return;const{shaderCtx:a,videoSize:x}=this;if(a)return this.shader=new bi(a,x),this.input=new mi(a,x),super.load()}unload(){var a,x;(a=this.input)==null||a.dispose(),delete this.input,(x=this.shader)==null||x.dispose(),delete this.shader,super.unload()}async update(a,x){if(!this.loaded)return;const{input:c}=this,u=c?.texture();if(!(!c||!u))return c?.update(x),this.current=u,super.update(a,x)}updateVideo(a){this.shader&&(this.shader.render([this.current]),super.updateVideo(a))}setupVideo(a,x){var c,u;super.setupVideo(a,x);const{width:g,height:y}=this.videoSize;this.canvas.layers[0].width=g,this.canvas.layers[0].height=y,(c=this.input)==null||c.resize({width:g,height:y}),(u=this.shader)==null||u.resize({width:g,height:y})}}class li extends $t{dispose(){delete this.scene,super.dispose()}}class Ei{constructor(){this.loaded=!1,this.ordinal=800}async load(a){this.loaded||(this.renderer=a,this.loaded=!0)}unload(){this.loaded&&(this.loaded=!1)}async update(a,x){this.loaded}dispose(){this.unload()}setupVideo(a){}setupCamera(a,x){}}var xs=(F=>(F[F.PreProcess=100]="PreProcess",F[F.Process=200]="Process",F[F.PostProcess=300]="PostProcess",F[F.PreRender=700]="PreRender",F[F.Render=800]="Render",F[F.PostRender=900]="PostRender",F))(xs||{});class Vs extends Ei{constructor(){super(),this.ordinal=xs.PreRender}async load(a){if(!(this.loaded||!(a instanceof Ht)||!a.videoCtx))return this.videoCtx=a.videoCtx,super.load(a)}unload(){this.loaded&&(delete this.videoCtx,super.unload())}}var ms=Object.defineProperty,bs=Object.getOwnPropertySymbols,Us=Object.prototype.hasOwnProperty,Mr=Object.prototype.propertyIsEnumerable,ar=(F,a,x)=>a in F?ms(F,a,{enumerable:!0,configurable:!0,writable:!0,value:x}):F[a]=x,yr=(F,a)=>{for(var x in a||(a={}))Us.call(a,x)&&ar(F,x,a[x]);if(bs)for(var x of bs(a))Mr.call(a,x)&&ar(F,x,a[x]);return F};class jr extends Ei{constructor(a,x,c,u){super(),this.inputs=a,this.uniforms=x,this.fragSrc=c,this.vertSrc=u,this.size={width:0,height:0},this.ordinal=xs.PreRender}async load(a){if(!(this.loaded||!(a instanceof $t)||!a.shaderCtx))return this.shader=new bi(a.shaderCtx,this.size,this.inputs,this.uniforms,this.fragSrc,this.vertSrc),super.load(a)}unload(){var a;this.loaded&&((a=this.shader)==null||a.dispose(),delete this.shader,super.unload())}async update(a,x){var c;const{renderer:u}=this;if(!this.loaded||!(u instanceof $t)||!u.current)return;const g=await this.process(a,u.current)&&((c=this.shader)==null?void 0:c.output());g&&(u.current=g)}async process(a,x){var c;return(c=this.shader)==null||c.process([x]),!0}setupVideo(a){var x;this.size=yr({},a),(x=this.shader)==null||x.resize(a)}}class xn extends Ei{constructor(){super(),this.ordinal=xs.Render}async load(a){if(!(this.loaded||!(a instanceof li)||!a.scene))return this.scene=a.scene,super.load(a)}unload(){this.loaded&&(delete this.scene,super.unload())}}class dn{constructor(a,x=!1,c="video",u){this.renderer=a,this.mirror=x,this.sizeMode=c,this.sizeMax=u}async snapshot(){return new Promise(a=>{this.renderer.once("render",()=>{const{renderer:x}=this,{layers:c}=x.canvas;let{width:u,height:g}=x.canvas.layers[0];this.sizeMode==="max"?(u=Math.max(...c.map(B=>B.width)),g=Math.max(...c.map(B=>B.height))):this.sizeMode==="min"&&(u=Math.min(...c.map(B=>B.width)),g=Math.min(...c.map(B=>B.height)));const y=document.createElement("canvas");y.id="engeenee.snapshot",y.hidden=!0,y.width=u,y.height=g;const v=y.getContext("2d",{alpha:!0});if(!v)return;this.mirror&&(v.translate(u,0),v.scale(-1,1)),c.forEach(B=>v.drawImage(B,0,0,u,g));const w=v.getImageData(0,0,u,g);y.remove(),a(w)})})}async snapshotLayers(){return new Promise(a=>{this.renderer.once("render",()=>{const x=document.createElement("canvas");x.id="engeenee.snapshot",x.hidden=!0;const c=x.getContext("2d",{alpha:!0});if(!c)return;const u=this.renderer.canvas.layers.map(g=>{const{width:y,height:v}=g;return x.width=y,x.height=v,c.resetTransform(),this.mirror&&(c.translate(y,0),c.scale(-1,1)),c.drawImage(g,0,0),c.getImageData(0,0,y,v)});x.remove(),a(u)})})}}class Rn{constructor(a,x="video/webm",c=!1,u="video",g,y){this.renderer=a,this.type=x,this.mirror=c,this.sizeMode=u,this.sizeMax=g,this.bitRate=y,this.context=null,this.records=[],this.frame=()=>{var v;const{renderer:w,context:B,stream:W}=this,{width:ae,height:ue}=this.canvas;!W||!B||(w.canvas.layers.map(fe=>B.drawImage(fe,0,0,ae,ue)),(v=W.getVideoTracks()[0])==null||v.requestFrame())},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:a,context:x,renderer:c}=this;if(!a||!x)return!1;const{layers:u}=c.canvas;let{width:g,height:y}=u[0];this.sizeMode==="max"?(g=Math.max(...u.map(w=>w.width)),y=Math.max(...u.map(w=>w.height))):this.sizeMode==="min"&&(g=Math.min(...u.map(w=>w.width)),y=Math.min(...u.map(w=>w.height)));const v=Math.max(g,y);if(this.sizeMax&&v>this.sizeMax){const w=this.sizeMax/v;g*=w,y*=w}return a.width=g,a.height=y,x.resetTransform(),this.mirror&&(x.translate(g,0),x.scale(-1,1)),c.on("render",this.frame),this.records=[],this.stream=a.captureStream(0),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=w=>this.records.push(w.data),this.recorder.start(),!0}async stop(){const{recorder:a}=this;if(!(!a||a.state!="recording"))return new Promise(x=>{a.onstop=()=>{var c;x(new Blob(this.records,{type:this.type})),this.records=[],(c=this.stream)==null||c.getVideoTracks().forEach(u=>u.stop()),this.renderer.removeListener("render",this.frame),delete this.stream,delete this.recorder},a.stop()})}dispose(){this.canvas.remove()}}class Vn{constructor(a,x=0,c="video/webm",u){this.renderer=a,this.layer=x,this.type=c,this.bitRate=u,this.records=[]}start(){const{renderer:a}=this,x=a.canvas.layers[this.layer];return this.records=[],this.stream=x.captureStream(),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=c=>this.records.push(c.data),this.recorder.start(),!0}async stop(){const{recorder:a}=this;if(!(!a||a.state!="recording"))return new Promise(x=>{a.onstop=()=>{var c;x(new Blob(this.records,{type:this.type})),this.records=[],(c=this.stream)==null||c.getVideoTracks().forEach(u=>u.stop()),delete this.stream,delete this.recorder},a.stop()})}}class Hi{constructor(a,x=!1,c="video",u){this.renderer=a,this.mirror=x,this.sizeMode=c,this.sizeMax=u,this.context=null,this.render=()=>{const{canvas:g,context:y}=this;!g||!y||this.renderer.canvas.layers.map(v=>y.drawImage(v,0,0,g.width,g.height))},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.mirror&&(this.canvas.style.transform="scaleX(-1)"),this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:a,context:x,renderer:c}=this;if(!a||!x)return!1;const{layers:u}=c.canvas;let{width:g,height:y}=u[0];this.sizeMode==="max"?(g=Math.max(...u.map(w=>w.width)),y=Math.max(...u.map(w=>w.height))):this.sizeMode==="min"&&(g=Math.min(...u.map(w=>w.width)),y=Math.min(...u.map(w=>w.height)));const v=Math.max(g,y);if(this.sizeMax&&v>this.sizeMax){const w=this.sizeMax/v;g*=w,y*=w}return a.width=g,a.height=y,x.resetTransform(),this.mirror&&(x.translate(g,0),x.scale(-1,1)),this.renderer.on("render",this.render),this.stream=a.captureStream(),!0}pause(){this.renderer.removeListener("render",this.render)}mediaStream(){return this.stream}}class Ya extends be{constructor(){super(...arguments),this.faceTracker=new m.sf,this.cameraAngleBase=10/180*Math.PI}async init(a,x,c){return await this.faceTracker.init(a.token,a.root,a.cache,a.mask,a.highp),await this.faceTracker.prepare(),super.init(a,x,c)}reset(){this.faceTracker.reset(),super.reset()}dispose(){this.faceTracker.dispose()}async process(a,x){return{faces:(await this.faceTracker.process(a,x)).map(c=>{const{keypoints:u,mask:g,score:y}=c,v=c&&this.params.transform?this.faceTracker.align(c.keypoints):void 0,w=v&&this.params.metric?this.faceTracker.metricPoints():void 0,B=v&&this.params.backproj?this.faceTracker.backprojPoints():void 0;return{pixel:u,metric:w,backproj:B,transform:v,mask:g,score:y}})}}setupVideo(a,x){super.setupVideo(a,x),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.faceTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.faceTracker.reset()}}class _o extends te{constructor(a,x=Z){super(Ya,a,x)}}class jo extends be{constructor(){super(),this.poseTracker=new m.cX,this.cameraAngleBase=15/180*Math.PI;const a=/iPhone|iPad|iPod/i.test(navigator.userAgent);this.optimalSize=a?512:1024}async init(a,x,c){return await this.poseTracker.init(a.token,a.root,a.cache,a.mask),await this.poseTracker.prepare(),super.init(a,x,c)}reset(){return this.poseTracker.reset(),super.reset()}dispose(){this.poseTracker.dispose()}async process(a,x){return{poses:(await this.poseTracker.process(a,x)).map(c=>({points:vr(u=>c.keypoints[Io[u]]),score:c.score,mask:c.mask,timestamp:x,debug:c.debug}))}}setupVideo(a,x){super.setupVideo(a,x),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.poseTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.poseTracker.reset()}}class aa extends te{constructor(a,x=Z){super(jo,a,x)}}const Ur=["nose","eyeInnerL","eyeL","eyeOutterL","eyeInnerR","eyeR","eyeOutterR","earL","earR","mouthL","mouthR","shoulderL","shoulderR","elbowL","elbowR","wristL","wristR","pinkyL","pinkyR","indexL","indexR","thumbL","thumbR","hipL","hipR","kneeL","kneeR","ankleL","ankleR","heelL","heelR","footIndexL","footIndexR"];function ur(F,a){return Object.fromEntries(a.map(x=>[x,F(x)]))}const Y0=(F,a)=>ur(F,a),vr=F=>ur(F,Ur),Io=vr(F=>Ur.indexOf(F));class t0 extends be{constructor(){super(...arguments),this.handTracker=new m.qo,this.cameraAngleBase=10/180*Math.PI}async init(a,x,c){return await this.handTracker.init(a.token,a.root,a.cache),await this.handTracker.prepare(),super.init(a,x,c)}reset(){this.handTracker.reset(),super.reset()}dispose(){this.handTracker.dispose()}async process(a,x){return{hands:(await this.handTracker.process(a,x)).map(c=>({points:c.keypoints,score:c.score,handedness:c.handedness,wrist:c.wrist}))}}setupVideo(a,x){super.setupVideo(a,x),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.handTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.handTracker.reset()}}class y0 extends te{constructor(a,x=Z){super(t0,a,x)}}class v2 extends be{constructor(){super(...arguments),this.maskTracker=new m.Vr}async init(a,x,c){return await this.maskTracker.init(a.token,a.root,a.cache,a.smooth),await this.maskTracker.prepare(),super.init(a,x,c)}reset(){this.maskTracker.reset(),super.reset()}dispose(){this.maskTracker.dispose()}async process(a,x){return{masks:(await this.maskTracker.process(a,x)).map(c=>({mask:c}))}}}class bc extends te{constructor(a,x=Z){super(v2,a,x)}}class Xx{constructor(a,x=!1,c,u){this.initialize(a,x,c,u)}initialize(a,x=!1,c,u){return this.mask=a,this.skipNextObservers=x,this.target=c,this.currentTarget=u,this}}class dl{constructor(a,x,c=null){this.callback=a,this.mask=x,this.scope=c,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(){this._remove&&this._remove()}}class Jt{static FromPromise(a,x){const c=new Jt;return a.then(u=>{c.notifyObservers(u)}).catch(u=>{if(x)x.notifyObservers(u);else throw u}),c}get observers(){return this._observers}constructor(a,x=!1){this.notifyIfTriggered=x,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new Xx(0),a&&(this._onObserverAdded=a)}add(a,x=-1,c=!1,u=null,g=!1){if(!a)return null;const y=new dl(a,x,u);return y.unregisterOnNextCall=g,c?this._observers.unshift(y):this._observers.push(y),this._onObserverAdded&&this._onObserverAdded(y),this._hasNotified&&this.notifyIfTriggered&&this._lastNotifiedValue!==void 0&&this.notifyObserver(y,this._lastNotifiedValue),y._remove=()=>{this.remove(y)},y}addOnce(a){return this.add(a,void 0,void 0,void 0,!0)}remove(a){return a?(a._remove=null,this._observers.indexOf(a)!==-1?(this._deferUnregister(a),!0):!1):!1}removeCallback(a,x){for(let c=0;c<this._observers.length;c++){const u=this._observers[c];if(!u._willBeUnregistered&&u.callback===a&&(!x||x===u.scope))return this._deferUnregister(u),!0}return!1}_deferUnregister(a){a._willBeUnregistered||(this._numObserversMarkedAsDeleted++,a.unregisterOnNextCall=!1,a._willBeUnregistered=!0,setTimeout(()=>{this._remove(a)},0))}_remove(a,x=!0){if(!a)return!1;const c=this._observers.indexOf(a);return c!==-1?(x&&this._numObserversMarkedAsDeleted--,this._observers.splice(c,1),!0):!1}makeObserverTopPriority(a){this._remove(a,!1),this._observers.unshift(a)}makeObserverBottomPriority(a){this._remove(a,!1),this._observers.push(a)}notifyObservers(a,x=-1,c,u,g){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=a),!this._observers.length)return!0;const y=this._eventState;y.mask=x,y.target=c,y.currentTarget=u,y.skipNextObservers=!1,y.lastReturnValue=a,y.userInfo=g;for(const v of this._observers)if(!v._willBeUnregistered&&(v.mask&x&&(v.unregisterOnNextCall&&this._deferUnregister(v),v.scope?y.lastReturnValue=v.callback.apply(v.scope,[a,y]):y.lastReturnValue=v.callback(a,y)),y.skipNextObservers))return!1;return!0}notifyObserver(a,x,c=-1){if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=x),a._willBeUnregistered)return;const u=this._eventState;u.mask=c,u.skipNextObservers=!1,a.unregisterOnNextCall&&this._deferUnregister(a),a.callback(x,u)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const a=this._observers.pop();a&&(a._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const a=new Jt;return a._observers=this._observers.slice(0),a}hasSpecificMask(a=-1){for(const x of this._observers)if(x.mask&a||x.mask===a)return!0;return!1}}class Ec{get wrapU(){return this._cachedWrapU}set wrapU(a){this._cachedWrapU=a}get wrapV(){return this._cachedWrapV}set wrapV(a){this._cachedWrapV=a}get wrapR(){return this._cachedWrapR}set wrapR(a){this._cachedWrapR=a}get anisotropicFilteringLevel(){return this._cachedAnisotropicFilteringLevel}set anisotropicFilteringLevel(a){this._cachedAnisotropicFilteringLevel=a}get comparisonFunction(){return this._comparisonFunction}set comparisonFunction(a){this._comparisonFunction=a}get useMipMaps(){return this._useMipMaps}set useMipMaps(a){this._useMipMaps=a}constructor(){this.samplingMode=-1,this._useMipMaps=!0,this._cachedWrapU=null,this._cachedWrapV=null,this._cachedWrapR=null,this._cachedAnisotropicFilteringLevel=null,this._comparisonFunction=0}setParameters(a=1,x=1,c=1,u=1,g=2,y=0){return this._cachedWrapU=a,this._cachedWrapV=x,this._cachedWrapR=c,this._cachedAnisotropicFilteringLevel=u,this.samplingMode=g,this._comparisonFunction=y,this}compareSampler(a){return this._cachedWrapU===a._cachedWrapU&&this._cachedWrapV===a._cachedWrapV&&this._cachedWrapR===a._cachedWrapR&&this._cachedAnisotropicFilteringLevel===a._cachedAnisotropicFilteringLevel&&this.samplingMode===a.samplingMode&&this._comparisonFunction===a._comparisonFunction&&this._useMipMaps===a._useMipMaps}}var hn;(function(F){F[F.Unknown=0]="Unknown",F[F.Url=1]="Url",F[F.Temp=2]="Temp",F[F.Raw=3]="Raw",F[F.Dynamic=4]="Dynamic",F[F.RenderTarget=5]="RenderTarget",F[F.MultiRenderTarget=6]="MultiRenderTarget",F[F.Cube=7]="Cube",F[F.CubeRaw=8]="CubeRaw",F[F.CubePrefiltered=9]="CubePrefiltered",F[F.Raw3D=10]="Raw3D",F[F.Raw2DArray=11]="Raw2DArray",F[F.DepthStencil=12]="DepthStencil",F[F.CubeRawRGBD=13]="CubeRawRGBD",F[F.Depth=14]="Depth"})(hn||(hn={}));class a0 extends Ec{get useMipMaps(){return this.generateMipMaps}set useMipMaps(a){this.generateMipMaps=a}get uniqueId(){return this._uniqueId}_setUniqueId(a){this._uniqueId=a}getEngine(){return this._engine}get source(){return this._source}constructor(a,x,c=!1){super(),this.isReady=!1,this.isCube=!1,this.is3D=!1,this.is2DArray=!1,this.isMultiview=!1,this.url="",this.generateMipMaps=!1,this.samples=0,this.type=-1,this.format=-1,this.onLoadedObservable=new Jt,this.onErrorObservable=new Jt,this.onRebuildCallback=null,this.width=0,this.height=0,this.depth=0,this.baseWidth=0,this.baseHeight=0,this.baseDepth=0,this.invertY=!1,this._invertVScale=!1,this._associatedChannel=-1,this._source=hn.Unknown,this._buffer=null,this._bufferView=null,this._bufferViewArray=null,this._bufferViewArrayArray=null,this._size=0,this._extension="",this._files=null,this._workingCanvas=null,this._workingContext=null,this._cachedCoordinatesMode=null,this._isDisabled=!1,this._compression=null,this._sphericalPolynomial=null,this._sphericalPolynomialPromise=null,this._sphericalPolynomialComputed=!1,this._lodGenerationScale=0,this._lodGenerationOffset=0,this._useSRGBBuffer=!1,this._creationFlags=0,this._lodTextureHigh=null,this._lodTextureMid=null,this._lodTextureLow=null,this._isRGBD=!1,this._linearSpecularLOD=!1,this._irradianceTexture=null,this._hardwareTexture=null,this._maxLodLevel=null,this._references=1,this._gammaSpace=null,this._premulAlpha=!1,this._dynamicTextureSource=null,this._engine=a,this._source=x,this._uniqueId=a0._Counter++,c||(this._hardwareTexture=a._createHardwareTexture())}incrementReferences(){this._references++}updateSize(a,x,c=1){this._engine.updateTextureDimensions(this,a,x,c),this.width=a,this.height=x,this.depth=c,this.baseWidth=a,this.baseHeight=x,this.baseDepth=c,this._size=a*x*c}_rebuild(){if(this.isReady=!1,this._cachedCoordinatesMode=null,this._cachedWrapU=null,this._cachedWrapV=null,this._cachedWrapR=null,this._cachedAnisotropicFilteringLevel=null,this.onRebuildCallback){const x=this.onRebuildCallback(this),c=u=>{u._swapAndDie(this,!1),this.isReady=x.isReady};x.isAsync?x.proxy.then(c):c(x.proxy);return}let a;switch(this.source){case hn.Temp:break;case hn.Url:a=this._engine.createTexture(this._originalUrl??this.url,!this.generateMipMaps,this.invertY,null,this.samplingMode,x=>{x._swapAndDie(this,!1),this.isReady=!0},null,this._buffer,void 0,this.format,this._extension,void 0,void 0,void 0,this._useSRGBBuffer);return;case hn.Raw:a=this._engine.createRawTexture(this._bufferView,this.baseWidth,this.baseHeight,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type,this._creationFlags,this._useSRGBBuffer),a._swapAndDie(this,!1),this.isReady=!0;break;case hn.Raw3D:a=this._engine.createRawTexture3D(this._bufferView,this.baseWidth,this.baseHeight,this.baseDepth,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type),a._swapAndDie(this,!1),this.isReady=!0;break;case hn.Raw2DArray:a=this._engine.createRawTexture2DArray(this._bufferView,this.baseWidth,this.baseHeight,this.baseDepth,this.format,this.generateMipMaps,this.invertY,this.samplingMode,this._compression,this.type),a._swapAndDie(this,!1),this.isReady=!0;break;case hn.Dynamic:a=this._engine.createDynamicTexture(this.baseWidth,this.baseHeight,this.generateMipMaps,this.samplingMode),a._swapAndDie(this,!1),this._dynamicTextureSource&&this._engine.updateDynamicTexture(this,this._dynamicTextureSource,this.invertY,this._premulAlpha,this.format,!0);break;case hn.Cube:a=this._engine.createCubeTexture(this.url,null,this._files,!this.generateMipMaps,()=>{a._swapAndDie(this,!1),this.isReady=!0},null,this.format,this._extension,!1,0,0,null,void 0,this._useSRGBBuffer);return;case hn.CubeRaw:a=this._engine.createRawCubeTexture(this._bufferViewArray,this.width,this._originalFormat??this.format,this.type,this.generateMipMaps,this.invertY,this.samplingMode,this._compression),a._swapAndDie(this,!1),this.isReady=!0;break;case hn.CubeRawRGBD:return;case hn.CubePrefiltered:a=this._engine.createPrefilteredCubeTexture(this.url,null,this._lodGenerationScale,this._lodGenerationOffset,x=>{x&&x._swapAndDie(this,!1),this.isReady=!0},null,this.format,this._extension),a._sphericalPolynomial=this._sphericalPolynomial;return;case hn.DepthStencil:case hn.Depth:break}}_swapAndDie(a,x=!0){this._hardwareTexture?.setUsage(a._source,this.generateMipMaps,this.is2DArray,this.isCube,this.is3D,this.width,this.height,this.depth),a._hardwareTexture=this._hardwareTexture,x&&(a._isRGBD=this._isRGBD),this._lodTextureHigh&&(a._lodTextureHigh&&a._lodTextureHigh.dispose(),a._lodTextureHigh=this._lodTextureHigh),this._lodTextureMid&&(a._lodTextureMid&&a._lodTextureMid.dispose(),a._lodTextureMid=this._lodTextureMid),this._lodTextureLow&&(a._lodTextureLow&&a._lodTextureLow.dispose(),a._lodTextureLow=this._lodTextureLow),this._irradianceTexture&&(a._irradianceTexture&&a._irradianceTexture.dispose(),a._irradianceTexture=this._irradianceTexture);const c=this._engine.getLoadedTexturesCache();let u=c.indexOf(this);u!==-1&&c.splice(u,1),u=c.indexOf(a),u===-1&&c.push(a)}dispose(){this._references--,this.onLoadedObservable.clear(),this.onErrorObservable.clear(),this._references===0&&(this._engine._releaseTexture(this),this._hardwareTexture=null,this._dynamicTextureSource=null)}}a0._Counter=0;function xa(){return typeof window<"u"}function Uo(){return typeof navigator<"u"}function ux(){return typeof document<"u"}function U0(F){let a="",x=F.firstChild;for(;x;)x.nodeType===3&&(a+=x.textContent),x=x.nextSibling;return a}const Yl={IsWindowObjectExist:xa,IsNavigatorAvailable:Uo,IsDocumentAvailable:ux,GetDOMTextContent:U0};class tr{static get LastCreatedEngine(){return this.Instances.length===0?null:this.Instances[this.Instances.length-1]}static get LastCreatedScene(){return this._LastCreatedScene}}tr.Instances=[],tr.OnEnginesDisposedObservable=new Jt,tr._LastCreatedScene=null,tr.UseFallbackTexture=!0,tr.FallbackTexture="";const jx={};function js(F,a=!1){if(!(a&&jx[F]))return jx[F]=!0,`${F} needs to be imported before as it contains a side-effect required by your code.`}class Qt{static _CheckLimit(a,x){let c=Qt._LogLimitOutputs[a];return c?c.current++:(c={limit:x,current:1},Qt._LogLimitOutputs[a]=c),c.current<=c.limit}static _GenerateLimitMessage(a,x=1){const c=Qt._LogLimitOutputs[a];if(!c||!Qt.MessageLimitReached)return;const u=this._Levels[x];c.current===c.limit&&Qt[u.name](Qt.MessageLimitReached.replace(/%LIMIT%/g,""+c.limit).replace(/%TYPE%/g,u.name??""))}static _AddLogEntry(a){Qt._LogCache=a+Qt._LogCache,Qt.OnNewCacheEntry&&Qt.OnNewCacheEntry(a)}static _FormatMessage(a){const x=u=>u<10?"0"+u:""+u,c=new Date;return"["+x(c.getHours())+":"+x(c.getMinutes())+":"+x(c.getSeconds())+"]: "+a}static _LogDisabled(a,x){}static _LogEnabled(a=1,x,c){const u=Array.isArray(x)?x[0]:x;if(c!==void 0&&!Qt._CheckLimit(u,c))return;const g=Qt._FormatMessage(u),y=this._Levels[a],v=Array.isArray(x)?x.slice(1):[];y.logFunc&&y.logFunc("BJS - "+g,...v);const w=`<div style='color:${y.color}'>${g}</div><br>`;Qt._AddLogEntry(w),Qt._GenerateLimitMessage(u,a)}static get LogCache(){return Qt._LogCache}static ClearLogCache(){Qt._LogCache="",Qt._LogLimitOutputs={},Qt.errorsCount=0}static set LogLevels(a){Qt.Log=Qt._LogDisabled,Qt.Warn=Qt._LogDisabled,Qt.Error=Qt._LogDisabled,[Qt.MessageLogLevel,Qt.WarningLogLevel,Qt.ErrorLogLevel].forEach(x=>{if((a&x)===x){const c=this._Levels[x];Qt[c.name]=Qt._LogEnabled.bind(Qt,x)}})}}Qt.NoneLogLevel=0,Qt.MessageLogLevel=1,Qt.WarningLogLevel=2,Qt.ErrorLogLevel=4,Qt.AllLogLevel=7,Qt.MessageLimitReached="Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.",Qt._LogCache="",Qt._LogLimitOutputs={},Qt._Levels=[{},{color:"white",logFunc:console.log,name:"Log"},{color:"orange",logFunc:console.warn,name:"Warn"},{},{color:"red",logFunc:console.error,name:"Error"}],Qt.errorsCount=0,Qt.Log=Qt._LogEnabled.bind(Qt,Qt.MessageLogLevel),Qt.Warn=Qt._LogEnabled.bind(Qt,Qt.WarningLogLevel),Qt.Error=Qt._LogEnabled.bind(Qt,Qt.ErrorLogLevel);const $l="attribute",fh="varying";class V0{constructor(){this.children=[]}isValid(a){return!0}process(a,x){let c="";if(this.line){let u=this.line;const g=x.processor;if(g){g.lineProcessor&&(u=g.lineProcessor(u,x.isFragment,x.processingContext));const y=x.processor?.attributeKeywordName??$l,v=x.isFragment&&x.processor?.varyingFragmentKeywordName?x.processor?.varyingFragmentKeywordName:!x.isFragment&&x.processor?.varyingVertexKeywordName?x.processor?.varyingVertexKeywordName:fh;!x.isFragment&&g.attributeProcessor&&this.line.startsWith(y)?u=g.attributeProcessor(this.line,a,x.processingContext):g.varyingProcessor&&(g.varyingCheck?.(this.line,x.isFragment)||!g.varyingCheck&&this.line.startsWith(v))?u=g.varyingProcessor(this.line,x.isFragment,a,x.processingContext):g.uniformProcessor&&g.uniformRegexp&&g.uniformRegexp.test(this.line)?x.lookForClosingBracketForUniformBuffer||(u=g.uniformProcessor(this.line,x.isFragment,a,x.processingContext)):g.uniformBufferProcessor&&g.uniformBufferRegexp&&g.uniformBufferRegexp.test(this.line)?x.lookForClosingBracketForUniformBuffer||(u=g.uniformBufferProcessor(this.line,x.isFragment,x.processingContext),x.lookForClosingBracketForUniformBuffer=!0):g.textureProcessor&&g.textureRegexp&&g.textureRegexp.test(this.line)?u=g.textureProcessor(this.line,x.isFragment,a,x.processingContext):(g.uniformProcessor||g.uniformBufferProcessor)&&this.line.startsWith("uniform")&&!x.lookForClosingBracketForUniformBuffer&&(/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line)?g.uniformProcessor&&(u=g.uniformProcessor(this.line,x.isFragment,a,x.processingContext)):g.uniformBufferProcessor&&(u=g.uniformBufferProcessor(this.line,x.isFragment,x.processingContext),x.lookForClosingBracketForUniformBuffer=!0)),x.lookForClosingBracketForUniformBuffer&&this.line.indexOf("}")!==-1&&(x.lookForClosingBracketForUniformBuffer=!1,g.endOfUniformBufferProcessor&&(u=g.endOfUniformBufferProcessor(this.line,x.isFragment,x.processingContext)))}c+=u+`
`}return this.children.forEach(u=>{c+=u.process(a,x)}),this.additionalDefineKey&&(a[this.additionalDefineKey]=this.additionalDefineValue||"true"),c}}class mh{constructor(){this._lines=[]}get currentLine(){return this._lines[this.lineIndex]}get canRead(){return this.lineIndex<this._lines.length-1}set lines(a){this._lines.length=0;for(const x of a){if(!x||x==="\r")continue;if(x[0]==="#"){this._lines.push(x);continue}const c=x.trim();if(!c)continue;if(c.startsWith("//")){this._lines.push(x);continue}const u=c.indexOf(";");if(u===-1)this._lines.push(c);else if(u===c.length-1)c.length>1&&this._lines.push(c);else{const g=x.split(";");for(let y=0;y<g.length;y++){let v=g[y];v&&(v=v.trim(),v&&this._lines.push(v+(y!==g.length-1?";":"")))}}}}}class $0 extends V0{process(a,x){for(let c=0;c<this.children.length;c++){const u=this.children[c];if(u.isValid(a))return u.process(a,x)}return""}}class R2 extends V0{isValid(a){return this.testExpression.isTrue(a)}}class fn{isTrue(a){return!0}static postfixToInfix(a){const x=[];for(const c of a)if(fn._OperatorPriority[c]===void 0)x.push(c);else{const u=x[x.length-1],g=x[x.length-2];x.length-=2,x.push(`(${g}${c}${u})`)}return x[x.length-1]}static infixToPostfix(a){const x=fn._InfixToPostfixCache.get(a);if(x)return x.accessTime=Date.now(),x.result;if(!a.includes("&&")&&!a.includes("||")&&!a.includes(")")&&!a.includes("("))return[a];const c=[];let u=-1;const g=()=>{W=W.trim(),W!==""&&(c.push(W),W="")},y=ae=>{u<fn._Stack.length-1&&(fn._Stack[++u]=ae)},v=()=>fn._Stack[u],w=()=>u===-1?"!!INVALID EXPRESSION!!":fn._Stack[u--];let B=0,W="";for(;B<a.length;){const ae=a.charAt(B),ue=B<a.length-1?a.substr(B,2):"";if(ae==="(")W="",y(ae);else if(ae===")"){for(g();u!==-1&&v()!=="(";)c.push(w());w()}else if(fn._OperatorPriority[ue]>1){for(g();u!==-1&&fn._OperatorPriority[v()]>=fn._OperatorPriority[ue];)c.push(w());y(ue),B++}else W+=ae;B++}for(g();u!==-1;)v()==="("?w():c.push(w());return fn._InfixToPostfixCache.size>=fn.InfixToPostfixCacheLimitSize&&fn.ClearCache(),fn._InfixToPostfixCache.set(a,{result:c,accessTime:Date.now()}),c}static ClearCache(){const a=Array.from(fn._InfixToPostfixCache.entries()).sort((x,c)=>x[1].accessTime-c[1].accessTime);for(let x=0;x<fn.InfixToPostfixCacheCleanupSize;x++)fn._InfixToPostfixCache.delete(a[x][0])}}fn.InfixToPostfixCacheLimitSize=5e4,fn.InfixToPostfixCacheCleanupSize=25e3,fn._InfixToPostfixCache=new Map,fn._OperatorPriority={")":0,"(":1,"||":2,"&&":3},fn._Stack=["","","","","","","","","","","","","","","","","","","",""];class dx extends fn{constructor(a,x=!1){super(),this.define=a,this.not=x}isTrue(a){let x=a[this.define]!==void 0;return this.not&&(x=!x),x}}class M2 extends fn{isTrue(a){return this.leftOperand.isTrue(a)||this.rightOperand.isTrue(a)}}class gh extends fn{isTrue(a){return this.leftOperand.isTrue(a)&&this.rightOperand.isTrue(a)}}class _h extends fn{constructor(a,x,c){super(),this.define=a,this.operand=x,this.testValue=c}isTrue(a){let x=a[this.define];x===void 0&&(x=this.define);let c=!1;const u=parseInt(x),g=parseInt(this.testValue);switch(this.operand){case">":c=u>g;break;case"<":c=u<g;break;case"<=":c=u<=g;break;case">=":c=u>=g;break;case"==":c=u===g;break;case"!=":c=u!==g;break}return c}}var _a;(function(F){F[F.GLSL=0]="GLSL",F[F.WGSL=1]="WGSL"})(_a||(_a={}));const Jl=/defined\s*?\((.+?)\)/g,k2=/defined\s*?\[(.+?)\]/g,vx=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,yh=/__decl__/,vc=/light\{X\}.(\w*)/g,fl=/\{X\}/g,Ix=[];class ho{static Initialize(a){a.processor&&a.processor.initializeShaders&&a.processor.initializeShaders(a.processingContext)}static Process(a,x,c,u){x.processor?.preProcessShaderCode&&(a=x.processor.preProcessShaderCode(a,x.isFragment)),this._ProcessIncludes(a,x,g=>{x.processCodeAfterIncludes&&(g=x.processCodeAfterIncludes(x.isFragment?"fragment":"vertex",g));const y=this._ProcessShaderConversion(g,x,u);c(y,g)})}static PreProcess(a,x,c,u){x.processor?.preProcessShaderCode&&(a=x.processor.preProcessShaderCode(a,x.isFragment)),this._ProcessIncludes(a,x,g=>{x.processCodeAfterIncludes&&(g=x.processCodeAfterIncludes(x.isFragment?"fragment":"vertex",g));const y=this._ApplyPreProcessing(g,x,u);c(y,g)})}static Finalize(a,x,c){return!c.processor||!c.processor.finalizeShaders?{vertexCode:a,fragmentCode:x}:c.processor.finalizeShaders(a,x,c.processingContext)}static _ProcessPrecision(a,x){if(x.processor?.noPrecision)return a;const c=x.shouldUseHighPrecisionShader;return a.indexOf("precision highp float")===-1?c?a=`precision highp float;
`+a:a=`precision mediump float;
`+a:c||(a=a.replace("precision highp float","precision mediump float")),a}static _ExtractOperation(a){const c=/defined\((.+)\)/.exec(a);if(c&&c.length)return new dx(c[1].trim(),a[0]==="!");const u=["==","!=",">=","<=","<",">"];let g="",y=0;for(g of u)if(y=a.indexOf(g),y>-1)break;if(y===-1)return new dx(a);const v=a.substring(0,y).trim(),w=a.substring(y+g.length).trim();return new _h(v,g,w)}static _BuildSubExpression(a){a=a.replace(Jl,"defined[$1]");const x=fn.infixToPostfix(a),c=[];for(const g of x)if(g!=="||"&&g!=="&&")c.push(g);else if(c.length>=2){let y=c[c.length-1],v=c[c.length-2];c.length-=2;const w=g=="&&"?new gh:new M2;typeof y=="string"&&(y=y.replace(k2,"defined($1)")),typeof v=="string"&&(v=v.replace(k2,"defined($1)")),w.leftOperand=typeof v=="string"?this._ExtractOperation(v):v,w.rightOperand=typeof y=="string"?this._ExtractOperation(y):y,c.push(w)}let u=c[c.length-1];return typeof u=="string"&&(u=u.replace(k2,"defined($1)")),typeof u=="string"?this._ExtractOperation(u):u}static _BuildExpression(a,x){const c=new R2,u=a.substring(0,x);let g=a.substring(x);return g=g.substring(0,(g.indexOf("//")+1||g.length+1)-1).trim(),u==="#ifdef"?c.testExpression=new dx(g):u==="#ifndef"?c.testExpression=new dx(g,!0):c.testExpression=this._BuildSubExpression(g),c}static _MoveCursorWithinIf(a,x,c){let u=a.currentLine;for(;this._MoveCursor(a,c);){u=a.currentLine;const g=u.substring(0,5).toLowerCase();if(g==="#else"){const y=new V0;x.children.push(y),this._MoveCursor(a,y);return}else if(g==="#elif"){const y=this._BuildExpression(u,5);x.children.push(y),c=y}}}static _MoveCursor(a,x){for(;a.canRead;){a.lineIndex++;const c=a.currentLine;if(c.indexOf("#")>=0){const g=ho._MoveCursorRegex.exec(c);if(g&&g.length){switch(g[0]){case"#ifdef":{const v=new $0;x.children.push(v);const w=this._BuildExpression(c,6);v.children.push(w),this._MoveCursorWithinIf(a,v,w);break}case"#else":case"#elif":return!0;case"#endif":return!1;case"#ifndef":{const v=new $0;x.children.push(v);const w=this._BuildExpression(c,7);v.children.push(w),this._MoveCursorWithinIf(a,v,w);break}case"#if":{const v=new $0,w=this._BuildExpression(c,3);x.children.push(v),v.children.push(w),this._MoveCursorWithinIf(a,v,w);break}}continue}}const u=new V0;if(u.line=c,x.children.push(u),c[0]==="#"&&c[1]==="d"){const g=c.replace(";","").split(" ");u.additionalDefineKey=g[1],g.length===3&&(u.additionalDefineValue=g[2])}}return!1}static _EvaluatePreProcessors(a,x,c){const u=new V0,g=new mh;return g.lineIndex=-1,g.lines=a.split(`
`),this._MoveCursor(g,u),u.process(x,c)}static _PreparePreProcessors(a,x){const c=a.defines,u={};for(const g of c){const v=g.replace("#define","").replace(";","").trim().split(" ");u[v[0]]=v.length>1?v[1]:""}return a.processor?.shaderLanguage===_a.GLSL&&(u.GL_ES="true"),u.__VERSION__=a.version,u[a.platformName]="true",x._getGlobalDefines(u),u}static _ProcessShaderConversion(a,x,c){let u=this._ProcessPrecision(a,x);if(!x.processor||x.processor.shaderLanguage===_a.GLSL&&u.indexOf("#version 3")!==-1&&(u=u.replace("#version 300 es",""),!x.processor.parseGLES3))return u;const g=x.defines,y=this._PreparePreProcessors(x,c);return x.processor.preProcessor&&(u=x.processor.preProcessor(u,g,x.isFragment,x.processingContext)),u=this._EvaluatePreProcessors(u,y,x),x.processor.postProcessor&&(u=x.processor.postProcessor(u,g,x.isFragment,x.processingContext,c)),c._features.needShaderCodeInlining&&(u=c.inlineShaderCode(u)),u}static _ApplyPreProcessing(a,x,c){let u=a;const g=x.defines,y=this._PreparePreProcessors(x,c);return x.processor?.preProcessor&&(u=x.processor.preProcessor(u,g,x.isFragment,x.processingContext)),u=this._EvaluatePreProcessors(u,y,x),x.processor?.postProcessor&&(u=x.processor.postProcessor(u,g,x.isFragment,x.processingContext,c)),c._features.needShaderCodeInlining&&(u=c.inlineShaderCode(u)),u}static _ProcessIncludes(a,x,c){Ix.length=0;let u;for(;(u=vx.exec(a))!==null;)Ix.push(u);let g=String(a),y=[a],v=!1;for(const w of Ix){let B=w[1];if(B.indexOf("__decl__")!==-1&&(B=B.replace(yh,""),x.supportsUniformBuffers&&(B=B.replace("Vertex","Ubo").replace("Fragment","Ubo")),B=B+"Declaration"),x.includesShadersStore[B]){let W=x.includesShadersStore[B];if(w[2]){const ue=w[3].split(",");for(let fe=0;fe<ue.length;fe+=2){const Re=new RegExp(ue[fe],"g"),_e=ue[fe+1];W=W.replace(Re,_e)}}if(w[4]){const ue=w[5];if(ue.indexOf("..")!==-1){const fe=ue.split(".."),Re=parseInt(fe[0]);let _e=parseInt(fe[1]),Be=W.slice(0);W="",isNaN(_e)&&(_e=x.indexParameters[fe[1]]);for(let tt=Re;tt<_e;tt++)x.supportsUniformBuffers||(Be=Be.replace(vc,($e,Et)=>Et+"{X}")),W+=Be.replace(fl,tt.toString())+`
`}else x.supportsUniformBuffers||(W=W.replace(vc,(fe,Re)=>Re+"{X}")),W=W.replace(fl,ue)}const ae=[];for(const ue of y){const fe=ue.split(w[0]);for(let Re=0;Re<fe.length-1;Re++)ae.push(fe[Re]),ae.push(W);ae.push(fe[fe.length-1])}y=ae,v=v||W.indexOf("#include<")>=0||W.indexOf("#include <")>=0}else{const W=x.shadersRepository+"ShadersInclude/"+B+".fx";ho._FileToolsLoadFile(W,ae=>{x.includesShadersStore[B]=ae,this._ProcessIncludes(y.join(""),x,c)});return}}Ix.length=0,g=y.join(""),v?this._ProcessIncludes(g.toString(),x,c):c(g)}static _FileToolsLoadFile(a,x,c,u,g,y){throw js("FileTools")}}ho._MoveCursorRegex=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;class hi{static GetShadersRepository(a=_a.GLSL){return a===_a.GLSL?hi.ShadersRepository:hi.ShadersRepositoryWGSL}static GetShadersStore(a=_a.GLSL){return a===_a.GLSL?hi.ShadersStore:hi.ShadersStoreWGSL}static GetIncludesShadersStore(a=_a.GLSL){return a===_a.GLSL?hi.IncludesShadersStore:hi.IncludesShadersStoreWGSL}}hi.ShadersRepository="src/Shaders/",hi.ShadersStore={},hi.IncludesShadersStore={},hi.ShadersRepositoryWGSL="src/ShadersWGSL/",hi.ShadersStoreWGSL={},hi.IncludesShadersStoreWGSL={};class Yn{static get ShadersRepository(){return hi.ShadersRepository}static set ShadersRepository(a){hi.ShadersRepository=a}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new Jt),this._onBindObservable}get shaderLanguage(){return this._shaderLanguage}constructor(a,x,c,u=null,g,y=null,v=null,w=null,B=null,W,ae="",ue=_a.GLSL){if(this.name=null,this.defines="",this.onCompiled=null,this.onError=null,this.onBind=null,this.uniqueId=0,this.onCompileObservable=new Jt,this.onErrorObservable=new Jt,this._onBindObservable=null,this._isDisposed=!1,this._bonesComputationForcedToCPU=!1,this._uniformBuffersNames={},this._multiTarget=!1,this._samplers={},this._isReady=!1,this._compilationError="",this._allFallbacksProcessed=!1,this._uniforms={},this._key="",this._fallbacks=null,this._vertexSourceCodeOverride="",this._fragmentSourceCodeOverride="",this._transformFeedbackVaryings=null,this._pipelineContext=null,this._vertexSourceCode="",this._fragmentSourceCode="",this._vertexSourceCodeBeforeMigration="",this._fragmentSourceCodeBeforeMigration="",this._rawVertexSourceCode="",this._rawFragmentSourceCode="",this._processCodeAfterIncludes=void 0,this._processFinalCode=null,this.name=a,this._key=ae,x.attributes){const fe=x;if(this._engine=c,this._attributesNames=fe.attributes,this._uniformsNames=fe.uniformsNames.concat(fe.samplers),this._samplerList=fe.samplers.slice(),this.defines=fe.defines,this.onError=fe.onError,this.onCompiled=fe.onCompiled,this._fallbacks=fe.fallbacks,this._indexParameters=fe.indexParameters,this._transformFeedbackVaryings=fe.transformFeedbackVaryings||null,this._multiTarget=!!fe.multiTarget,this._shaderLanguage=fe.shaderLanguage??_a.GLSL,fe.uniformBuffersNames){this._uniformBuffersNamesList=fe.uniformBuffersNames.slice();for(let Re=0;Re<fe.uniformBuffersNames.length;Re++)this._uniformBuffersNames[fe.uniformBuffersNames[Re]]=Re}this._processFinalCode=fe.processFinalCode??null,this._processCodeAfterIncludes=fe.processCodeAfterIncludes??void 0}else this._engine=g,this.defines=y??"",this._uniformsNames=c.concat(u),this._samplerList=u?u.slice():[],this._attributesNames=x,this._uniformBuffersNamesList=[],this._shaderLanguage=ue,this.onError=B,this.onCompiled=w,this._indexParameters=W,this._fallbacks=v;this._attributeLocationByName={},this.uniqueId=Yn._UniqueIdSeed++,this._processShaderCode()}_processShaderCode(a=null,x=!1){let c,u;const g=this.name,y=xa()?this._engine.getHostDocument():null;g.vertexSource?c="source:"+g.vertexSource:g.vertexElement?(c=y?y.getElementById(g.vertexElement):null,c||(c=g.vertexElement)):c=g.vertex||g,g.fragmentSource?u="source:"+g.fragmentSource:g.fragmentElement?(u=y?y.getElementById(g.fragmentElement):null,u||(u=g.fragmentElement)):u=g.fragment||g,this._processingContext=this._engine._getShaderProcessingContext(this._shaderLanguage);let v={defines:this.defines.split(`
`),indexParameters:this._indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:a??this._engine._getShaderProcessor(this._shaderLanguage),supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:hi.GetShadersRepository(this._shaderLanguage),includesShadersStore:hi.GetIncludesShadersStore(this._shaderLanguage),version:(this._engine.version*100).toString(),platformName:this._engine.shaderPlatformName,processingContext:this._processingContext,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:this._processCodeAfterIncludes};const w=[void 0,void 0],B=()=>{if(w[0]&&w[1]){v.isFragment=!0;const[W,ae]=w;ho.Process(ae,v,(ue,fe)=>{this._fragmentSourceCodeBeforeMigration=fe,this._processFinalCode&&(ue=this._processFinalCode("fragment",ue));const Re=ho.Finalize(W,ue,v);v=null,this._useFinalCode(Re.vertexCode,Re.fragmentCode,g,x)},this._engine)}};this._loadShader(c,"Vertex","",W=>{ho.Initialize(v),ho.Process(W,v,(ae,ue)=>{this._rawVertexSourceCode=W,this._vertexSourceCodeBeforeMigration=ue,this._processFinalCode&&(ae=this._processFinalCode("vertex",ae)),w[0]=ae,B()},this._engine)}),this._loadShader(u,"Fragment","Pixel",W=>{this._rawFragmentSourceCode=W,w[1]=W,B()})}_useFinalCode(a,x,c,u=!1){if(c){const g=c.vertexElement||c.vertex||c.spectorName||c,y=c.fragmentElement||c.fragment||c.spectorName||c;this._vertexSourceCode=(this._shaderLanguage===_a.WGSL?"//":"")+"#define SHADER_NAME vertex:"+g+`
`+a,this._fragmentSourceCode=(this._shaderLanguage===_a.WGSL?"//":"")+"#define SHADER_NAME fragment:"+y+`
`+x}else this._vertexSourceCode=a,this._fragmentSourceCode=x;this._prepareEffect(u)}get key(){return this._key}isReady(){try{return this._isReadyInternal()}catch{return!1}}_isReadyInternal(){return this._isReady?!0:this._pipelineContext?this._pipelineContext.isReady:!1}getEngine(){return this._engine}getPipelineContext(){return this._pipelineContext}getAttributesNames(){return this._attributesNames}getAttributeLocation(a){return this._attributes[a]}getAttributeLocationByName(a){return this._attributeLocationByName[a]}getAttributesCount(){return this._attributes.length}getUniformIndex(a){return this._uniformsNames.indexOf(a)}getUniform(a){return this._uniforms[a]}getSamplers(){return this._samplerList}getUniformNames(){return this._uniformsNames}getUniformBuffersNames(){return this._uniformBuffersNamesList}getIndexParameters(){return this._indexParameters}getCompilationError(){return this._compilationError}allFallbacksProcessed(){return this._allFallbacksProcessed}executeWhenCompiled(a){if(this.isReady()){a(this);return}this.onCompileObservable.add(x=>{a(x)}),(!this._pipelineContext||this._pipelineContext.isAsync)&&setTimeout(()=>{this._checkIsReady(null)},16)}_checkIsReady(a){try{if(this._isReadyInternal())return}catch(x){this._processCompilationErrors(x,a);return}this._isDisposed||setTimeout(()=>{this._checkIsReady(a)},16)}_loadShader(a,x,c,u){if(typeof HTMLElement<"u"&&a instanceof HTMLElement){const v=U0(a);u(v);return}if(a.substr(0,7)==="source:"){u(a.substr(7));return}if(a.substr(0,7)==="base64:"){const v=window.atob(a.substr(7));u(v);return}const g=hi.GetShadersStore(this._shaderLanguage);if(g[a+x+"Shader"]){u(g[a+x+"Shader"]);return}if(c&&g[a+c+"Shader"]){u(g[a+c+"Shader"]);return}let y;a[0]==="."||a[0]==="/"||a.indexOf("http")>-1?y=a:y=hi.GetShadersRepository(this._shaderLanguage)+a,this._engine._loadFile(y+"."+x.toLowerCase()+".fx",u)}get vertexSourceCode(){return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._vertexSourceCodeOverride:this._pipelineContext?._getVertexShaderCode()??this._vertexSourceCode}get fragmentSourceCode(){return this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?this._fragmentSourceCodeOverride:this._pipelineContext?._getFragmentShaderCode()??this._fragmentSourceCode}get vertexSourceCodeBeforeMigration(){return this._vertexSourceCodeBeforeMigration}get fragmentSourceCodeBeforeMigration(){return this._fragmentSourceCodeBeforeMigration}get rawVertexSourceCode(){return this._rawVertexSourceCode}get rawFragmentSourceCode(){return this._rawFragmentSourceCode}_rebuildProgram(a,x,c,u){this._isReady=!1,this._vertexSourceCodeOverride=a,this._fragmentSourceCodeOverride=x,this.onError=(g,y)=>{u&&u(y)},this.onCompiled=()=>{const g=this.getEngine().scenes;if(g)for(let y=0;y<g.length;y++)g[y].markAllMaterialsAsDirty(63);this._pipelineContext._handlesSpectorRebuildCallback?.(c)},this._fallbacks=null,this._prepareEffect()}_prepareEffect(a=!1){const x=this._attributesNames,c=this.defines,u=this._pipelineContext;this._isReady=!1;try{const g=this._engine;this._pipelineContext=(a?u:void 0)??g.createPipelineContext(this._processingContext),this._pipelineContext._name=this._key.replace(/\r/g,"").replace(/\n/g,"|");const y=(v,w,B,W)=>this._rebuildProgram(v,w,B,W);this._vertexSourceCodeOverride&&this._fragmentSourceCodeOverride?g._preparePipelineContext(this._pipelineContext,this._vertexSourceCodeOverride,this._fragmentSourceCodeOverride,!0,this._rawVertexSourceCode,this._rawFragmentSourceCode,y,null,this._transformFeedbackVaryings,this._key):g._preparePipelineContext(this._pipelineContext,this._vertexSourceCode,this._fragmentSourceCode,!1,this._rawVertexSourceCode,this._rawFragmentSourceCode,y,c,this._transformFeedbackVaryings,this._key),g._executeWhenRenderingStateIsCompiled(this._pipelineContext,()=>{if(this._attributes=[],this._pipelineContext._fillEffectInformation(this,this._uniformBuffersNames,this._uniformsNames,this._uniforms,this._samplerList,this._samplers,x,this._attributes),x)for(let v=0;v<x.length;v++){const w=x[v];this._attributeLocationByName[w]=this._attributes[v]}g.bindSamplers(this),this._compilationError="",this._isReady=!0,this.onCompiled&&this.onCompiled(this),this.onCompileObservable.notifyObservers(this),this.onCompileObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh(),u&&!a&&this.getEngine()._deletePipelineContext(u)}),this._pipelineContext.isAsync&&this._checkIsReady(u)}catch(g){this._processCompilationErrors(g,u)}}_getShaderCodeAndErrorLine(a,x,c){const u=c?/FRAGMENT SHADER ERROR: 0:(\d+?):/:/VERTEX SHADER ERROR: 0:(\d+?):/;let g=null;if(x&&a){const y=x.match(u);if(y&&y.length===2){const v=parseInt(y[1]),w=a.split(`
`,-1);w.length>=v&&(g=`Offending line [${v}] in ${c?"fragment":"vertex"} code: ${w[v-1]}`)}}return[a,g]}_processCompilationErrors(a,x=null){this._compilationError=a.message;const c=this._attributesNames,u=this._fallbacks;if(Qt.Error("Unable to compile effect:"),Qt.Error("Uniforms: "+this._uniformsNames.map(function(y){return" "+y})),Qt.Error("Attributes: "+c.map(function(y){return" "+y})),Qt.Error(`Defines:
`+this.defines),Yn.LogShaderCodeOnCompilationError){let y=null,v=null,w=null;this._pipelineContext?._getVertexShaderCode()&&([w,y]=this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(),this._compilationError,!1),w&&(Qt.Error("Vertex code:"),Qt.Error(w))),this._pipelineContext?._getFragmentShaderCode()&&([w,v]=this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(),this._compilationError,!0),w&&(Qt.Error("Fragment code:"),Qt.Error(w))),y&&Qt.Error(y),v&&Qt.Error(v)}Qt.Error("Error: "+this._compilationError);const g=()=>{this.onError&&this.onError(this,this._compilationError),this.onErrorObservable.notifyObservers(this)};x&&(this._pipelineContext=x,this._isReady=!0,g()),u?(this._pipelineContext=null,u.hasMoreFallbacks?(this._allFallbacksProcessed=!1,Qt.Error("Trying next fallback."),this.defines=u.reduce(this.defines,this),this._prepareEffect()):(this._allFallbacksProcessed=!0,g(),this.onErrorObservable.clear(),this._fallbacks&&this._fallbacks.unBindMesh())):(this._allFallbacksProcessed=!0,x||g())}get isSupported(){return this._compilationError===""}_bindTexture(a,x){this._engine._bindTexture(this._samplers[a],x,a)}setTexture(a,x){this._engine.setTexture(this._samplers[a],this._uniforms[a],x,a)}setDepthStencilTexture(a,x){this._engine.setDepthStencilTexture(this._samplers[a],this._uniforms[a],x,a)}setTextureArray(a,x){const c=a+"Ex";if(this._samplerList.indexOf(c+"0")===-1){const u=this._samplerList.indexOf(a);for(let y=1;y<x.length;y++){const v=c+(y-1).toString();this._samplerList.splice(u+y,0,v)}let g=0;for(const y of this._samplerList)this._samplers[y]=g,g+=1}this._engine.setTextureArray(this._samplers[a],this._uniforms[a],x,a)}setTextureFromPostProcess(a,x){this._engine.setTextureFromPostProcess(this._samplers[a],x,a)}setTextureFromPostProcessOutput(a,x){this._engine.setTextureFromPostProcessOutput(this._samplers[a],x,a)}bindUniformBuffer(a,x){const c=this._uniformBuffersNames[x];c===void 0||Yn._BaseCache[c]===a&&this._engine._features.useUBOBindingCache||(Yn._BaseCache[c]=a,this._engine.bindUniformBufferBase(a,c,x))}bindUniformBlock(a,x){this._engine.bindUniformBlock(this._pipelineContext,a,x)}setInt(a,x){return this._pipelineContext.setInt(a,x),this}setInt2(a,x,c){return this._pipelineContext.setInt2(a,x,c),this}setInt3(a,x,c,u){return this._pipelineContext.setInt3(a,x,c,u),this}setInt4(a,x,c,u,g){return this._pipelineContext.setInt4(a,x,c,u,g),this}setIntArray(a,x){return this._pipelineContext.setIntArray(a,x),this}setIntArray2(a,x){return this._pipelineContext.setIntArray2(a,x),this}setIntArray3(a,x){return this._pipelineContext.setIntArray3(a,x),this}setIntArray4(a,x){return this._pipelineContext.setIntArray4(a,x),this}setUInt(a,x){return this._pipelineContext.setUInt(a,x),this}setUInt2(a,x,c){return this._pipelineContext.setUInt2(a,x,c),this}setUInt3(a,x,c,u){return this._pipelineContext.setUInt3(a,x,c,u),this}setUInt4(a,x,c,u,g){return this._pipelineContext.setUInt4(a,x,c,u,g),this}setUIntArray(a,x){return this._pipelineContext.setUIntArray(a,x),this}setUIntArray2(a,x){return this._pipelineContext.setUIntArray2(a,x),this}setUIntArray3(a,x){return this._pipelineContext.setUIntArray3(a,x),this}setUIntArray4(a,x){return this._pipelineContext.setUIntArray4(a,x),this}setFloatArray(a,x){return this._pipelineContext.setArray(a,x),this}setFloatArray2(a,x){return this._pipelineContext.setArray2(a,x),this}setFloatArray3(a,x){return this._pipelineContext.setArray3(a,x),this}setFloatArray4(a,x){return this._pipelineContext.setArray4(a,x),this}setArray(a,x){return this._pipelineContext.setArray(a,x),this}setArray2(a,x){return this._pipelineContext.setArray2(a,x),this}setArray3(a,x){return this._pipelineContext.setArray3(a,x),this}setArray4(a,x){return this._pipelineContext.setArray4(a,x),this}setMatrices(a,x){return this._pipelineContext.setMatrices(a,x),this}setMatrix(a,x){return this._pipelineContext.setMatrix(a,x),this}setMatrix3x3(a,x){return this._pipelineContext.setMatrix3x3(a,x),this}setMatrix2x2(a,x){return this._pipelineContext.setMatrix2x2(a,x),this}setFloat(a,x){return this._pipelineContext.setFloat(a,x),this}setBool(a,x){return this._pipelineContext.setInt(a,x?1:0),this}setVector2(a,x){return this._pipelineContext.setVector2(a,x),this}setFloat2(a,x,c){return this._pipelineContext.setFloat2(a,x,c),this}setVector3(a,x){return this._pipelineContext.setVector3(a,x),this}setFloat3(a,x,c,u){return this._pipelineContext.setFloat3(a,x,c,u),this}setVector4(a,x){return this._pipelineContext.setVector4(a,x),this}setQuaternion(a,x){return this._pipelineContext.setQuaternion(a,x),this}setFloat4(a,x,c,u,g){return this._pipelineContext.setFloat4(a,x,c,u,g),this}setColor3(a,x){return this._pipelineContext.setColor3(a,x),this}setColor4(a,x,c){return this._pipelineContext.setColor4(a,x,c),this}setDirectColor4(a,x){return this._pipelineContext.setDirectColor4(a,x),this}dispose(){this._pipelineContext&&this._pipelineContext.dispose(),this._engine._releaseEffect(this),this._isDisposed=!0}static RegisterShader(a,x,c,u=_a.GLSL){x&&(hi.GetShadersStore(u)[`${a}PixelShader`]=x),c&&(hi.GetShadersStore(u)[`${a}VertexShader`]=c)}static ResetCache(){Yn._BaseCache={}}}Yn.LogShaderCodeOnCompilationError=!0,Yn._UniqueIdSeed=0,Yn._BaseCache={},Yn.ShadersStore=hi.ShadersStore,Yn.IncludesShadersStore=hi.IncludesShadersStore;class ml{constructor(a=!0){this._isDepthTestDirty=!1,this._isDepthMaskDirty=!1,this._isDepthFuncDirty=!1,this._isCullFaceDirty=!1,this._isCullDirty=!1,this._isZOffsetDirty=!1,this._isFrontFaceDirty=!1,a&&this.reset()}get isDirty(){return this._isDepthFuncDirty||this._isDepthTestDirty||this._isDepthMaskDirty||this._isCullFaceDirty||this._isCullDirty||this._isZOffsetDirty||this._isFrontFaceDirty}get zOffset(){return this._zOffset}set zOffset(a){this._zOffset!==a&&(this._zOffset=a,this._isZOffsetDirty=!0)}get zOffsetUnits(){return this._zOffsetUnits}set zOffsetUnits(a){this._zOffsetUnits!==a&&(this._zOffsetUnits=a,this._isZOffsetDirty=!0)}get cullFace(){return this._cullFace}set cullFace(a){this._cullFace!==a&&(this._cullFace=a,this._isCullFaceDirty=!0)}get cull(){return this._cull}set cull(a){this._cull!==a&&(this._cull=a,this._isCullDirty=!0)}get depthFunc(){return this._depthFunc}set depthFunc(a){this._depthFunc!==a&&(this._depthFunc=a,this._isDepthFuncDirty=!0)}get depthMask(){return this._depthMask}set depthMask(a){this._depthMask!==a&&(this._depthMask=a,this._isDepthMaskDirty=!0)}get depthTest(){return this._depthTest}set depthTest(a){this._depthTest!==a&&(this._depthTest=a,this._isDepthTestDirty=!0)}get frontFace(){return this._frontFace}set frontFace(a){this._frontFace!==a&&(this._frontFace=a,this._isFrontFaceDirty=!0)}reset(){this._depthMask=!0,this._depthTest=!0,this._depthFunc=null,this._cullFace=null,this._cull=null,this._zOffset=0,this._zOffsetUnits=0,this._frontFace=null,this._isDepthTestDirty=!0,this._isDepthMaskDirty=!0,this._isDepthFuncDirty=!1,this._isCullFaceDirty=!1,this._isCullDirty=!1,this._isZOffsetDirty=!0,this._isFrontFaceDirty=!1}apply(a){this.isDirty&&(this._isCullDirty&&(this.cull?a.enable(a.CULL_FACE):a.disable(a.CULL_FACE),this._isCullDirty=!1),this._isCullFaceDirty&&(a.cullFace(this.cullFace),this._isCullFaceDirty=!1),this._isDepthMaskDirty&&(a.depthMask(this.depthMask),this._isDepthMaskDirty=!1),this._isDepthTestDirty&&(this.depthTest?a.enable(a.DEPTH_TEST):a.disable(a.DEPTH_TEST),this._isDepthTestDirty=!1),this._isDepthFuncDirty&&(a.depthFunc(this.depthFunc),this._isDepthFuncDirty=!1),this._isZOffsetDirty&&(this.zOffset||this.zOffsetUnits?(a.enable(a.POLYGON_OFFSET_FILL),a.polygonOffset(this.zOffset,this.zOffsetUnits)):a.disable(a.POLYGON_OFFSET_FILL),this._isZOffsetDirty=!1),this._isFrontFaceDirty&&(a.frontFace(this.frontFace),this._isFrontFaceDirty=!1))}}class uo{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.func=uo.ALWAYS,this.funcRef=1,this.funcMask=255,this.opStencilFail=uo.KEEP,this.opDepthFail=uo.KEEP,this.opStencilDepthPass=uo.REPLACE}get stencilFunc(){return this.func}set stencilFunc(a){this.func=a}get stencilFuncRef(){return this.funcRef}set stencilFuncRef(a){this.funcRef=a}get stencilFuncMask(){return this.funcMask}set stencilFuncMask(a){this.funcMask=a}get stencilOpStencilFail(){return this.opStencilFail}set stencilOpStencilFail(a){this.opStencilFail=a}get stencilOpDepthFail(){return this.opDepthFail}set stencilOpDepthFail(a){this.opDepthFail=a}get stencilOpStencilDepthPass(){return this.opStencilDepthPass}set stencilOpStencilDepthPass(a){this.opStencilDepthPass=a}get stencilMask(){return this.mask}set stencilMask(a){this.mask=a}get stencilTest(){return this.enabled}set stencilTest(a){this.enabled=a}}uo.ALWAYS=519,uo.KEEP=7680,uo.REPLACE=7681;class B2{constructor(){this._blendFunctionParameters=new Array(4),this._blendEquationParameters=new Array(2),this._blendConstants=new Array(4),this._isBlendConstantsDirty=!1,this._alphaBlend=!1,this._isAlphaBlendDirty=!1,this._isBlendFunctionParametersDirty=!1,this._isBlendEquationParametersDirty=!1,this.reset()}get isDirty(){return this._isAlphaBlendDirty||this._isBlendFunctionParametersDirty||this._isBlendEquationParametersDirty}get alphaBlend(){return this._alphaBlend}set alphaBlend(a){this._alphaBlend!==a&&(this._alphaBlend=a,this._isAlphaBlendDirty=!0)}setAlphaBlendConstants(a,x,c,u){this._blendConstants[0]===a&&this._blendConstants[1]===x&&this._blendConstants[2]===c&&this._blendConstants[3]===u||(this._blendConstants[0]=a,this._blendConstants[1]=x,this._blendConstants[2]=c,this._blendConstants[3]=u,this._isBlendConstantsDirty=!0)}setAlphaBlendFunctionParameters(a,x,c,u){this._blendFunctionParameters[0]===a&&this._blendFunctionParameters[1]===x&&this._blendFunctionParameters[2]===c&&this._blendFunctionParameters[3]===u||(this._blendFunctionParameters[0]=a,this._blendFunctionParameters[1]=x,this._blendFunctionParameters[2]=c,this._blendFunctionParameters[3]=u,this._isBlendFunctionParametersDirty=!0)}setAlphaEquationParameters(a,x){this._blendEquationParameters[0]===a&&this._blendEquationParameters[1]===x||(this._blendEquationParameters[0]=a,this._blendEquationParameters[1]=x,this._isBlendEquationParametersDirty=!0)}reset(){this._alphaBlend=!1,this._blendFunctionParameters[0]=null,this._blendFunctionParameters[1]=null,this._blendFunctionParameters[2]=null,this._blendFunctionParameters[3]=null,this._blendEquationParameters[0]=null,this._blendEquationParameters[1]=null,this._blendConstants[0]=null,this._blendConstants[1]=null,this._blendConstants[2]=null,this._blendConstants[3]=null,this._isAlphaBlendDirty=!0,this._isBlendFunctionParametersDirty=!1,this._isBlendEquationParametersDirty=!1,this._isBlendConstantsDirty=!1}apply(a){this.isDirty&&(this._isAlphaBlendDirty&&(this._alphaBlend?a.enable(a.BLEND):a.disable(a.BLEND),this._isAlphaBlendDirty=!1),this._isBlendFunctionParametersDirty&&(a.blendFuncSeparate(this._blendFunctionParameters[0],this._blendFunctionParameters[1],this._blendFunctionParameters[2],this._blendFunctionParameters[3]),this._isBlendFunctionParametersDirty=!1),this._isBlendEquationParametersDirty&&(a.blendEquationSeparate(this._blendEquationParameters[0],this._blendEquationParameters[1]),this._isBlendEquationParametersDirty=!1),this._isBlendConstantsDirty&&(a.blendColor(this._blendConstants[0],this._blendConstants[1],this._blendConstants[2],this._blendConstants[3]),this._isBlendConstantsDirty=!1))}}class Ba{constructor(){this.shaderLanguage=_a.GLSL}postProcessor(a,x,c,u,g){if(!g.getCaps().drawBuffersExtension){const y=/#extension.+GL_EXT_draw_buffers.+(enable|require)/g;a=a.replace(y,"")}return a}}const bh=/(flat\s)?\s*varying\s*.*/;class x0{constructor(){this.shaderLanguage=_a.GLSL}attributeProcessor(a){return a.replace("attribute","in")}varyingCheck(a,x){return bh.test(a)}varyingProcessor(a,x){return a.replace("varying",x?"in":"out")}postProcessor(a,x,c){const u=a.search(/#extension.+GL_EXT_draw_buffers.+require/)!==-1,g=/#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;if(a=a.replace(g,""),a=a.replace(/texture2D\s*\(/g,"texture("),c){const y=a.search(/layout *\(location *= *0\) *out/g)!==-1;a=a.replace(/texture2DLodEXT\s*\(/g,"textureLod("),a=a.replace(/textureCubeLodEXT\s*\(/g,"textureLod("),a=a.replace(/textureCube\s*\(/g,"texture("),a=a.replace(/gl_FragDepthEXT/g,"gl_FragDepth"),a=a.replace(/gl_FragColor/g,"glFragColor"),a=a.replace(/gl_FragData/g,"glFragData"),a=a.replace(/void\s+?main\s*\(/g,(u||y?"":`layout(location = 0) out vec4 glFragColor;
`)+"void main(")}else if(x.indexOf("#define MULTIVIEW")!==-1)return`#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
`+a;return a}}class fo{get underlyingResource(){return null}constructor(){this.references=0,this.capacity=0,this.is32Bits=!1,this.uniqueId=fo._Counter++}}fo._Counter=0;class Vo extends fo{constructor(a){super(),this._buffer=a}get underlyingResource(){return this._buffer}}class U2{constructor(){this._valueCache={},this.vertexCompilationError=null,this.fragmentCompilationError=null,this.programLinkError=null,this.programValidationError=null,this._isDisposed=!1}get isAsync(){return this.isParallelCompiled}get isReady(){return this.program?this.isParallelCompiled?this.engine._isRenderingStateCompiled(this):!0:!1}_handlesSpectorRebuildCallback(a){a&&this.program&&a(this.program)}_fillEffectInformation(a,x,c,u,g,y,v,w){const B=this.engine;if(B.supportsUniformBuffers)for(const ue in x)a.bindUniformBlock(ue,x[ue]);this.engine.getUniforms(this,c).forEach((ue,fe)=>{u[c[fe]]=ue}),this._uniforms=u;let ae;for(ae=0;ae<g.length;ae++)a.getUniform(g[ae])==null&&(g.splice(ae,1),ae--);g.forEach((ue,fe)=>{y[ue]=fe});for(const ue of B.getAttributes(this,v))w.push(ue)}dispose(){this._uniforms={},this._isDisposed=!0}_cacheMatrix(a,x){const c=this._valueCache[a],u=x.updateFlag;return c!==void 0&&c===u?!1:(this._valueCache[a]=u,!0)}_cacheFloat2(a,x,c){let u=this._valueCache[a];if(!u||u.length!==2)return u=[x,c],this._valueCache[a]=u,!0;let g=!1;return u[0]!==x&&(u[0]=x,g=!0),u[1]!==c&&(u[1]=c,g=!0),g}_cacheFloat3(a,x,c,u){let g=this._valueCache[a];if(!g||g.length!==3)return g=[x,c,u],this._valueCache[a]=g,!0;let y=!1;return g[0]!==x&&(g[0]=x,y=!0),g[1]!==c&&(g[1]=c,y=!0),g[2]!==u&&(g[2]=u,y=!0),y}_cacheFloat4(a,x,c,u,g){let y=this._valueCache[a];if(!y||y.length!==4)return y=[x,c,u,g],this._valueCache[a]=y,!0;let v=!1;return y[0]!==x&&(y[0]=x,v=!0),y[1]!==c&&(y[1]=c,v=!0),y[2]!==u&&(y[2]=u,v=!0),y[3]!==g&&(y[3]=g,v=!0),v}setInt(a,x){const c=this._valueCache[a];c!==void 0&&c===x||this.engine.setInt(this._uniforms[a],x)&&(this._valueCache[a]=x)}setInt2(a,x,c){this._cacheFloat2(a,x,c)&&(this.engine.setInt2(this._uniforms[a],x,c)||(this._valueCache[a]=null))}setInt3(a,x,c,u){this._cacheFloat3(a,x,c,u)&&(this.engine.setInt3(this._uniforms[a],x,c,u)||(this._valueCache[a]=null))}setInt4(a,x,c,u,g){this._cacheFloat4(a,x,c,u,g)&&(this.engine.setInt4(this._uniforms[a],x,c,u,g)||(this._valueCache[a]=null))}setIntArray(a,x){this._valueCache[a]=null,this.engine.setIntArray(this._uniforms[a],x)}setIntArray2(a,x){this._valueCache[a]=null,this.engine.setIntArray2(this._uniforms[a],x)}setIntArray3(a,x){this._valueCache[a]=null,this.engine.setIntArray3(this._uniforms[a],x)}setIntArray4(a,x){this._valueCache[a]=null,this.engine.setIntArray4(this._uniforms[a],x)}setUInt(a,x){const c=this._valueCache[a];c!==void 0&&c===x||this.engine.setUInt(this._uniforms[a],x)&&(this._valueCache[a]=x)}setUInt2(a,x,c){this._cacheFloat2(a,x,c)&&(this.engine.setUInt2(this._uniforms[a],x,c)||(this._valueCache[a]=null))}setUInt3(a,x,c,u){this._cacheFloat3(a,x,c,u)&&(this.engine.setUInt3(this._uniforms[a],x,c,u)||(this._valueCache[a]=null))}setUInt4(a,x,c,u,g){this._cacheFloat4(a,x,c,u,g)&&(this.engine.setUInt4(this._uniforms[a],x,c,u,g)||(this._valueCache[a]=null))}setUIntArray(a,x){this._valueCache[a]=null,this.engine.setUIntArray(this._uniforms[a],x)}setUIntArray2(a,x){this._valueCache[a]=null,this.engine.setUIntArray2(this._uniforms[a],x)}setUIntArray3(a,x){this._valueCache[a]=null,this.engine.setUIntArray3(this._uniforms[a],x)}setUIntArray4(a,x){this._valueCache[a]=null,this.engine.setUIntArray4(this._uniforms[a],x)}setArray(a,x){this._valueCache[a]=null,this.engine.setArray(this._uniforms[a],x)}setArray2(a,x){this._valueCache[a]=null,this.engine.setArray2(this._uniforms[a],x)}setArray3(a,x){this._valueCache[a]=null,this.engine.setArray3(this._uniforms[a],x)}setArray4(a,x){this._valueCache[a]=null,this.engine.setArray4(this._uniforms[a],x)}setMatrices(a,x){x&&(this._valueCache[a]=null,this.engine.setMatrices(this._uniforms[a],x))}setMatrix(a,x){this._cacheMatrix(a,x)&&(this.engine.setMatrices(this._uniforms[a],x.asArray())||(this._valueCache[a]=null))}setMatrix3x3(a,x){this._valueCache[a]=null,this.engine.setMatrix3x3(this._uniforms[a],x)}setMatrix2x2(a,x){this._valueCache[a]=null,this.engine.setMatrix2x2(this._uniforms[a],x)}setFloat(a,x){const c=this._valueCache[a];c!==void 0&&c===x||this.engine.setFloat(this._uniforms[a],x)&&(this._valueCache[a]=x)}setVector2(a,x){this._cacheFloat2(a,x.x,x.y)&&(this.engine.setFloat2(this._uniforms[a],x.x,x.y)||(this._valueCache[a]=null))}setFloat2(a,x,c){this._cacheFloat2(a,x,c)&&(this.engine.setFloat2(this._uniforms[a],x,c)||(this._valueCache[a]=null))}setVector3(a,x){this._cacheFloat3(a,x.x,x.y,x.z)&&(this.engine.setFloat3(this._uniforms[a],x.x,x.y,x.z)||(this._valueCache[a]=null))}setFloat3(a,x,c,u){this._cacheFloat3(a,x,c,u)&&(this.engine.setFloat3(this._uniforms[a],x,c,u)||(this._valueCache[a]=null))}setVector4(a,x){this._cacheFloat4(a,x.x,x.y,x.z,x.w)&&(this.engine.setFloat4(this._uniforms[a],x.x,x.y,x.z,x.w)||(this._valueCache[a]=null))}setQuaternion(a,x){this._cacheFloat4(a,x.x,x.y,x.z,x.w)&&(this.engine.setFloat4(this._uniforms[a],x.x,x.y,x.z,x.w)||(this._valueCache[a]=null))}setFloat4(a,x,c,u,g){this._cacheFloat4(a,x,c,u,g)&&(this.engine.setFloat4(this._uniforms[a],x,c,u,g)||(this._valueCache[a]=null))}setColor3(a,x){this._cacheFloat3(a,x.r,x.g,x.b)&&(this.engine.setFloat3(this._uniforms[a],x.r,x.g,x.b)||(this._valueCache[a]=null))}setColor4(a,x,c){this._cacheFloat4(a,x.r,x.g,x.b,c)&&(this.engine.setFloat4(this._uniforms[a],x.r,x.g,x.b,c)||(this._valueCache[a]=null))}setDirectColor4(a,x){this._cacheFloat4(a,x.r,x.g,x.b,x.a)&&(this.engine.setFloat4(this._uniforms[a],x.r,x.g,x.b,x.a)||(this._valueCache[a]=null))}_getVertexShaderCode(){return this.vertexShader?this.engine._getShaderSource(this.vertexShader):null}_getFragmentShaderCode(){return this.fragmentShader?this.engine._getShaderSource(this.fragmentShader):null}}class Wn{static SetMatrixPrecision(a){if(Wn.MatrixTrackPrecisionChange=!1,a&&!Wn.MatrixUse64Bits&&Wn.MatrixTrackedMatrices)for(let x=0;x<Wn.MatrixTrackedMatrices.length;++x){const c=Wn.MatrixTrackedMatrices[x],u=c._m;c._m=new Array(16);for(let g=0;g<16;++g)c._m[g]=u[g]}Wn.MatrixUse64Bits=a,Wn.MatrixCurrentType=Wn.MatrixUse64Bits?Array:Float32Array,Wn.MatrixTrackedMatrices=null}}Wn.MatrixUse64Bits=!1,Wn.MatrixTrackPrecisionChange=!0,Wn.MatrixCurrentType=Float32Array,Wn.MatrixTrackedMatrices=[];class Yx{get underlyingResource(){return this._webGLTexture}constructor(a=null,x){if(this._MSAARenderBuffers=null,this._context=x,!a&&(a=x.createTexture(),!a))throw new Error("Unable to create webGL texture");this.set(a)}setUsage(){}set(a){this._webGLTexture=a}reset(){this._webGLTexture=null,this._MSAARenderBuffers=null}addMSAARenderBuffer(a){this._MSAARenderBuffers||(this._MSAARenderBuffers=[]),this._MSAARenderBuffers.push(a)}releaseMSAARenderBuffers(){if(this._MSAARenderBuffers){for(const a of this._MSAARenderBuffers)this._context.deleteRenderbuffer(a);this._MSAARenderBuffers=null}}getMSAARenderBuffer(a=0){return this._MSAARenderBuffers?.[a]??null}release(){this.releaseMSAARenderBuffers(),this._webGLTexture&&this._context.deleteTexture(this._webGLTexture),this.reset()}}class Yo{static IsWrapper(a){return a.getPipelineContext===void 0}static GetEffect(a){return a.getPipelineContext===void 0?a.effect:a}constructor(a,x=!0){this._wasPreviouslyReady=!1,this._forceRebindOnNextCall=!0,this._wasPreviouslyUsingInstances=null,this.effect=null,this.defines=null,this.drawContext=a.createDrawContext(),x&&(this.materialContext=a.createMaterialContext())}setEffect(a,x,c=!0){this.effect=a,x!==void 0&&(this.defines=x),c&&this.drawContext?.reset()}dispose(){this.drawContext?.dispose()}}class Ic{get isDirty(){return this._isStencilTestDirty||this._isStencilMaskDirty||this._isStencilFuncDirty||this._isStencilOpDirty}get func(){return this._func}set func(a){this._func!==a&&(this._func=a,this._isStencilFuncDirty=!0)}get funcRef(){return this._funcRef}set funcRef(a){this._funcRef!==a&&(this._funcRef=a,this._isStencilFuncDirty=!0)}get funcMask(){return this._funcMask}set funcMask(a){this._funcMask!==a&&(this._funcMask=a,this._isStencilFuncDirty=!0)}get opStencilFail(){return this._opStencilFail}set opStencilFail(a){this._opStencilFail!==a&&(this._opStencilFail=a,this._isStencilOpDirty=!0)}get opDepthFail(){return this._opDepthFail}set opDepthFail(a){this._opDepthFail!==a&&(this._opDepthFail=a,this._isStencilOpDirty=!0)}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(a){this._opStencilDepthPass!==a&&(this._opStencilDepthPass=a,this._isStencilOpDirty=!0)}get mask(){return this._mask}set mask(a){this._mask!==a&&(this._mask=a,this._isStencilMaskDirty=!0)}get enabled(){return this._enabled}set enabled(a){this._enabled!==a&&(this._enabled=a,this._isStencilTestDirty=!0)}constructor(a=!0){this._isStencilTestDirty=!1,this._isStencilMaskDirty=!1,this._isStencilFuncDirty=!1,this._isStencilOpDirty=!1,this.useStencilGlobalOnly=!1,a&&this.reset()}reset(){this.stencilMaterial=void 0,this.stencilGlobal?.reset(),this._isStencilTestDirty=!0,this._isStencilMaskDirty=!0,this._isStencilFuncDirty=!0,this._isStencilOpDirty=!0}apply(a){if(!a)return;const x=!this.useStencilGlobalOnly&&!!this.stencilMaterial?.enabled;this.enabled=x?this.stencilMaterial.enabled:this.stencilGlobal.enabled,this.func=x?this.stencilMaterial.func:this.stencilGlobal.func,this.funcRef=x?this.stencilMaterial.funcRef:this.stencilGlobal.funcRef,this.funcMask=x?this.stencilMaterial.funcMask:this.stencilGlobal.funcMask,this.opStencilFail=x?this.stencilMaterial.opStencilFail:this.stencilGlobal.opStencilFail,this.opDepthFail=x?this.stencilMaterial.opDepthFail:this.stencilGlobal.opDepthFail,this.opStencilDepthPass=x?this.stencilMaterial.opStencilDepthPass:this.stencilGlobal.opStencilDepthPass,this.mask=x?this.stencilMaterial.mask:this.stencilGlobal.mask,this.isDirty&&(this._isStencilTestDirty&&(this.enabled?a.enable(a.STENCIL_TEST):a.disable(a.STENCIL_TEST),this._isStencilTestDirty=!1),this._isStencilMaskDirty&&(a.stencilMask(this.mask),this._isStencilMaskDirty=!1),this._isStencilFuncDirty&&(a.stencilFunc(this.func,this.funcRef,this.funcMask),this._isStencilFuncDirty=!1),this._isStencilOpDirty&&(a.stencilOp(this.opStencilFail,this.opDepthFail,this.opStencilDepthPass),this._isStencilOpDirty=!1))}}class Wo{static get Now(){return xa()&&window.performance&&window.performance.now?window.performance.now():Date.now()}}class Eh{}class Es{static get NpmPackage(){return"babylonjs@6.49.0"}static get Version(){return"6.49.0"}get description(){let a=this.name+this.webGLVersion;return this._caps.parallelShaderCompile&&(a+=" - Parallel shader compilation"),a}get name(){return this._name}set name(a){this._name=a}get version(){return this._webGLVersion}get isDisposed(){return this._isDisposed}static get ShadersRepository(){return Yn.ShadersRepository}static set ShadersRepository(a){Yn.ShadersRepository=a}_getShaderProcessor(a){return this._shaderProcessor}get useReverseDepthBuffer(){return this._useReverseDepthBuffer}set useReverseDepthBuffer(a){a!==this._useReverseDepthBuffer&&(this._useReverseDepthBuffer=a,a?this._depthCullingState.depthFunc=518:this._depthCullingState.depthFunc=515)}get frameId(){return this._frameId}get supportsUniformBuffers(){return this.webGLVersion>1&&!this.disableUniformBuffers}getCreationOptions(){return this._creationOptions}get _shouldUseHighPrecisionShader(){return!!(this._caps.highPrecisionShaderSupported&&this._highPrecisionShadersAllowed)}get needPOTTextures(){return this._webGLVersion<2||this.forcePOTTextures}get activeRenderLoops(){return this._activeRenderLoops}get doNotHandleContextLost(){return this._doNotHandleContextLost}set doNotHandleContextLost(a){this._doNotHandleContextLost=a}get _supportsHardwareTextureRescaling(){return!1}set framebufferDimensionsObject(a){this._framebufferDimensionsObject=a}get currentViewport(){return this._cachedViewport}get emptyTexture(){return this._emptyTexture||(this._emptyTexture=this.createRawTexture(new Uint8Array(4),1,1,5,!1,!1,1)),this._emptyTexture}get emptyTexture3D(){return this._emptyTexture3D||(this._emptyTexture3D=this.createRawTexture3D(new Uint8Array(4),1,1,1,5,!1,!1,1)),this._emptyTexture3D}get emptyTexture2DArray(){return this._emptyTexture2DArray||(this._emptyTexture2DArray=this.createRawTexture2DArray(new Uint8Array(4),1,1,1,5,!1,!1,1)),this._emptyTexture2DArray}get emptyCubeTexture(){if(!this._emptyCubeTexture){const a=new Uint8Array(4),x=[a,a,a,a,a,a];this._emptyCubeTexture=this.createRawCubeTexture(x,1,5,0,!1,!1,1)}return this._emptyCubeTexture}get isWebGPU(){return this._isWebGPU}get shaderPlatformName(){return this._shaderPlatformName}get snapshotRendering(){return!1}set snapshotRendering(a){}get snapshotRenderingMode(){return this._snapshotRenderingMode}set snapshotRenderingMode(a){this._snapshotRenderingMode=a}snapshotRenderingReset(){this.snapshotRendering=!1}static _CreateCanvas(a,x){if(typeof document>"u")return new OffscreenCanvas(a,x);const c=document.createElement("canvas");return c.width=a,c.height=x,c}createCanvas(a,x){return Es._CreateCanvas(a,x)}createCanvasImage(){return document.createElement("img")}constructor(a,x,c,u){this._name="WebGL",this._isDisposed=!1,this.forcePOTTextures=!1,this.isFullscreen=!1,this.cullBackFaces=null,this.renderEvenInBackground=!0,this.preventCacheWipeBetweenFrames=!1,this.validateShaderPrograms=!1,this._useReverseDepthBuffer=!1,this.isNDCHalfZRange=!1,this.hasOriginBottomLeft=!0,this.disableUniformBuffers=!1,this.onDisposeObservable=new Jt,this._frameId=0,this._uniformBuffers=new Array,this._storageBuffers=new Array,this._webGLVersion=1,this._windowIsBackground=!1,this._highPrecisionShadersAllowed=!0,this._badOS=!1,this._badDesktopOS=!1,this._activeRenderLoops=new Array,this.onContextLostObservable=new Jt,this.onContextRestoredObservable=new Jt,this._contextWasLost=!1,this._doNotHandleContextLost=!1,this.disableVertexArrayObjects=!1,this._colorWrite=!0,this._colorWriteChanged=!0,this._depthCullingState=new ml,this._stencilStateComposer=new Ic,this._stencilState=new uo,this._alphaState=new B2,this._alphaMode=1,this._alphaEquation=0,this._internalTexturesCache=new Array,this._renderTargetWrapperCache=new Array,this._activeChannel=0,this._currentTextureChannel=-1,this._boundTexturesCache={},this._compiledEffects={},this._vertexAttribArraysEnabled=[],this._currentRenderTarget=null,this._uintIndicesCurrentlySet=!1,this._currentBoundBuffer=new Array,this._currentFramebuffer=null,this._dummyFramebuffer=null,this._currentBufferPointers=new Array,this._currentInstanceLocations=new Array,this._currentInstanceBuffers=new Array,this._boundRenderFunction=()=>this._renderLoop(),this._vaoRecordInProgress=!1,this._mustWipeVertexAttributes=!1,this._frameHandler=0,this._nextFreeTextureSlots=new Array,this._maxSimultaneousTextures=0,this._maxMSAASamplesOverride=null,this._activeRequests=new Array,this.adaptToDeviceRatio=!1,this._lastDevicePixelRatio=1,this._transformTextureUrl=null,this.hostInformation={isMobile:!1},this.premultipliedAlpha=!0,this.onBeforeTextureInitObservable=new Jt,this._isWebGPU=!1,this._snapshotRenderingMode=0,this._viewportCached={x:0,y:0,z:0,w:0},this._unpackFlipYCached=null,this.enableUnpackFlipYCached=!0,this._boundUniforms={},this.startTime=Wo.Now;let g=null;c=c||{},this._creationOptions=c,this.adaptToDeviceRatio=u??!1,this._stencilStateComposer.stencilGlobal=this._stencilState,Wn.SetMatrixPrecision(!!c.useHighPrecisionMatrix),c.antialias=x??c.antialias,c.deterministicLockstep=c.deterministicLockstep??!1,c.lockstepMaxSteps=c.lockstepMaxSteps??4,c.timeStep=c.timeStep??1/60,c.audioEngine=c.audioEngine??!0,c.stencil=c.stencil??!0,this._audioContext=c.audioEngineOptions?.audioContext??null,this._audioDestination=c.audioEngineOptions?.audioDestination??null,this.premultipliedAlpha=c.premultipliedAlpha??!0,this.useExactSrgbConversions=c.useExactSrgbConversions??!1,this._doNotHandleContextLost=!!c.doNotHandleContextLost,this._isStencilEnable=!!c.stencil,u=u||c.adaptToDeviceRatio||!1;const y=xa()&&window.devicePixelRatio||1,v=c.limitDeviceRatio||y;if(this._hardwareScalingLevel=u?1/Math.min(v,y):1,this._lastDevicePixelRatio=y,!a)return;if(a.getContext){if(g=a,this._renderingCanvas=g,c.preserveDrawingBuffer===void 0&&(c.preserveDrawingBuffer=!1),c.xrCompatible===void 0&&(c.xrCompatible=!0),navigator&&navigator.userAgent){this._setupMobileChecks();const B=navigator.userAgent;for(const W of Es.ExceptionList){const ae=W.key,ue=W.targets;if(new RegExp(ae).test(B)){if(W.capture&&W.captureConstraint){const Re=W.capture,_e=W.captureConstraint,tt=new RegExp(Re).exec(B);if(tt&&tt.length>0&&parseInt(tt[tt.length-1])>=_e)continue}for(const Re of ue)switch(Re){case"uniformBuffer":this.disableUniformBuffers=!0;break;case"vao":this.disableVertexArrayObjects=!0;break;case"antialias":c.antialias=!1;break;case"maxMSAASamples":this._maxMSAASamplesOverride=1;break}}}}if(this._doNotHandleContextLost||(this._onContextLost=B=>{B.preventDefault(),this._contextWasLost=!0,Qt.Warn("WebGL context lost."),this.onContextLostObservable.notifyObservers(this)},this._onContextRestored=()=>{this._restoreEngineAfterContextLost(()=>this._initGLContext())},g.addEventListener("webglcontextlost",this._onContextLost,!1),g.addEventListener("webglcontextrestored",this._onContextRestored,!1),c.powerPreference=c.powerPreference||"high-performance"),this._badDesktopOS=/^((?!chrome|android).)*safari/i.test(navigator.userAgent),this._badDesktopOS&&(c.xrCompatible=!1),!c.disableWebGL2Support)try{this._gl=g.getContext("webgl2",c)||g.getContext("experimental-webgl2",c),this._gl&&(this._webGLVersion=2,this._shaderPlatformName="WEBGL2",this._gl.deleteQuery||(this._webGLVersion=1,this._shaderPlatformName="WEBGL1"))}catch{}if(!this._gl){if(!g)throw new Error("The provided canvas is null or undefined.");try{this._gl=g.getContext("webgl",c)||g.getContext("experimental-webgl",c)}catch{throw new Error("WebGL not supported")}}if(!this._gl)throw new Error("WebGL not supported")}else{this._gl=a,this._renderingCanvas=this._gl.canvas,this._gl.renderbufferStorageMultisample?(this._webGLVersion=2,this._shaderPlatformName="WEBGL2"):this._shaderPlatformName="WEBGL1";const B=this._gl.getContextAttributes();B&&(c.stencil=B.stencil)}this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,this._gl.NONE),c.useHighPrecisionFloats!==void 0&&(this._highPrecisionShadersAllowed=c.useHighPrecisionFloats),this.resize(),this._initGLContext(),this._initFeatures();for(let B=0;B<this._caps.maxVertexAttribs;B++)this._currentBufferPointers[B]=new Eh;this._shaderProcessor=this.webGLVersion>1?new x0:new Ba,this._badOS=/iPad/i.test(navigator.userAgent)||/iPhone/i.test(navigator.userAgent);const w=`Babylon.js v${Es.Version}`;Qt.Log(w+` - ${this.description}`),this._renderingCanvas&&this._renderingCanvas.setAttribute&&this._renderingCanvas.setAttribute("data-engine",w)}_setupMobileChecks(){navigator&&navigator.userAgent&&(this._checkForMobile=()=>{const a=navigator.userAgent;this.hostInformation.isMobile=a.indexOf("Mobile")!==-1||a.indexOf("Mac")!==-1&&ux()&&"ontouchend"in document},this._checkForMobile(),xa()&&window.addEventListener("resize",this._checkForMobile))}_clearEmptyResources(){this._dummyFramebuffer=null,this._emptyTexture=null,this._emptyCubeTexture=null,this._emptyTexture3D=null,this._emptyTexture2DArray=null}_rebuildGraphicsResources(){this.wipeCaches(!0),this._rebuildEffects(),this._rebuildComputeEffects?.(),this._rebuildBuffers(),this._rebuildInternalTextures(),this._rebuildTextures(),this._rebuildRenderTargetWrappers(),this.wipeCaches(!0)}_flagContextRestored(){Qt.Warn(this.name+" context successfully restored."),this.onContextRestoredObservable.notifyObservers(this),this._contextWasLost=!1}_restoreEngineAfterContextLost(a){setTimeout(async()=>{this._clearEmptyResources();const x=this._depthCullingState.depthTest,c=this._depthCullingState.depthFunc,u=this._depthCullingState.depthMask,g=this._stencilState.stencilTest;await a(),this._rebuildGraphicsResources(),this._depthCullingState.depthTest=x,this._depthCullingState.depthFunc=c,this._depthCullingState.depthMask=u,this._stencilState.stencilTest=g,this._flagContextRestored()},0)}_sharedInit(a){this._renderingCanvas=a}_getShaderProcessingContext(a){return null}_rebuildInternalTextures(){const a=this._internalTexturesCache.slice();for(const x of a)x._rebuild()}_rebuildRenderTargetWrappers(){const a=this._renderTargetWrapperCache.slice();for(const x of a)x._rebuild()}_rebuildEffects(){for(const a in this._compiledEffects){const x=this._compiledEffects[a];x._pipelineContext=null,x._prepareEffect()}Yn.ResetCache()}areAllEffectsReady(){for(const a in this._compiledEffects)if(!this._compiledEffects[a].isReady())return!1;return!0}_rebuildBuffers(){for(const a of this._uniformBuffers)a._rebuildAfterContextLost()}_rebuildTextures(){}_initGLContext(){this._caps={maxTexturesImageUnits:this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),maxCombinedTexturesImageUnits:this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),maxVertexTextureImageUnits:this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),maxTextureSize:this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),maxSamples:this._webGLVersion>1?this._gl.getParameter(this._gl.MAX_SAMPLES):1,maxCubemapTextureSize:this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),maxRenderTextureSize:this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),maxVertexAttribs:this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),maxVaryingVectors:this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),maxFragmentUniformVectors:this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),maxVertexUniformVectors:this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),parallelShaderCompile:this._gl.getExtension("KHR_parallel_shader_compile")||void 0,standardDerivatives:this._webGLVersion>1||this._gl.getExtension("OES_standard_derivatives")!==null,maxAnisotropy:1,astc:this._gl.getExtension("WEBGL_compressed_texture_astc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),bptc:this._gl.getExtension("EXT_texture_compression_bptc")||this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),s3tc:this._gl.getExtension("WEBGL_compressed_texture_s3tc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),s3tc_srgb:this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),pvrtc:this._gl.getExtension("WEBGL_compressed_texture_pvrtc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),etc1:this._gl.getExtension("WEBGL_compressed_texture_etc1")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),etc2:this._gl.getExtension("WEBGL_compressed_texture_etc")||this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc")||this._gl.getExtension("WEBGL_compressed_texture_es3_0"),textureAnisotropicFilterExtension:this._gl.getExtension("EXT_texture_filter_anisotropic")||this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),uintIndices:this._webGLVersion>1||this._gl.getExtension("OES_element_index_uint")!==null,fragmentDepthSupported:this._webGLVersion>1||this._gl.getExtension("EXT_frag_depth")!==null,highPrecisionShaderSupported:!1,timerQuery:this._gl.getExtension("EXT_disjoint_timer_query_webgl2")||this._gl.getExtension("EXT_disjoint_timer_query"),supportOcclusionQuery:this._webGLVersion>1,canUseTimestampForTimerQuery:!1,drawBuffersExtension:!1,maxMSAASamples:1,colorBufferFloat:!!(this._webGLVersion>1&&this._gl.getExtension("EXT_color_buffer_float")),supportFloatTexturesResolve:!1,rg11b10ufColorRenderable:!1,colorBufferHalfFloat:!!(this._webGLVersion>1&&this._gl.getExtension("EXT_color_buffer_half_float")),textureFloat:!!(this._webGLVersion>1||this._gl.getExtension("OES_texture_float")),textureHalfFloat:!!(this._webGLVersion>1||this._gl.getExtension("OES_texture_half_float")),textureHalfFloatRender:!1,textureFloatLinearFiltering:!1,textureFloatRender:!1,textureHalfFloatLinearFiltering:!1,vertexArrayObject:!1,instancedArrays:!1,textureLOD:!!(this._webGLVersion>1||this._gl.getExtension("EXT_shader_texture_lod")),texelFetch:this._webGLVersion!==1,blendMinMax:!1,multiview:this._gl.getExtension("OVR_multiview2"),oculusMultiview:this._gl.getExtension("OCULUS_multiview"),depthTextureExtension:!1,canUseGLInstanceID:this._webGLVersion>1,canUseGLVertexID:this._webGLVersion>1,supportComputeShaders:!1,supportSRGBBuffers:!1,supportTransformFeedbacks:this._webGLVersion>1,textureMaxLevel:this._webGLVersion>1,texture2DArrayMaxLayerCount:this._webGLVersion>1?this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS):128,disableMorphTargetTexture:!1},this._caps.supportFloatTexturesResolve=this._caps.colorBufferFloat,this._caps.rg11b10ufColorRenderable=this._caps.colorBufferFloat,this._glVersion=this._gl.getParameter(this._gl.VERSION);const a=this._gl.getExtension("WEBGL_debug_renderer_info");if(a!=null&&(this._glRenderer=this._gl.getParameter(a.UNMASKED_RENDERER_WEBGL),this._glVendor=this._gl.getParameter(a.UNMASKED_VENDOR_WEBGL)),this._glVendor||(this._glVendor=this._gl.getParameter(this._gl.VENDOR)||"Unknown vendor"),this._glRenderer||(this._glRenderer=this._gl.getParameter(this._gl.RENDERER)||"Unknown renderer"),this._gl.HALF_FLOAT_OES!==36193&&(this._gl.HALF_FLOAT_OES=36193),this._gl.RGBA16F!==34842&&(this._gl.RGBA16F=34842),this._gl.RGBA32F!==34836&&(this._gl.RGBA32F=34836),this._gl.DEPTH24_STENCIL8!==35056&&(this._gl.DEPTH24_STENCIL8=35056),this._caps.timerQuery&&(this._webGLVersion===1&&(this._gl.getQuery=this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)),this._caps.canUseTimestampForTimerQuery=(this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT,this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)??0)>0),this._caps.maxAnisotropy=this._caps.textureAnisotropicFilterExtension?this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,this._caps.textureFloatLinearFiltering=!!(this._caps.textureFloat&&this._gl.getExtension("OES_texture_float_linear")),this._caps.textureFloatRender=!!(this._caps.textureFloat&&this._canRenderToFloatFramebuffer()),this._caps.textureHalfFloatLinearFiltering=!!(this._webGLVersion>1||this._caps.textureHalfFloat&&this._gl.getExtension("OES_texture_half_float_linear")),this._caps.astc&&(this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR),this._caps.bptc&&(this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT=this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT),this._caps.s3tc_srgb&&(this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT,this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT),this._caps.etc2&&(this._gl.COMPRESSED_SRGB8_ETC2=this._caps.etc2.COMPRESSED_SRGB8_ETC2,this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC),this._webGLVersion>1&&this._gl.HALF_FLOAT_OES!==5131&&(this._gl.HALF_FLOAT_OES=5131),this._caps.textureHalfFloatRender=this._caps.textureHalfFloat&&this._canRenderToHalfFloatFramebuffer(),this._webGLVersion>1)this._caps.drawBuffersExtension=!0,this._caps.maxMSAASamples=this._maxMSAASamplesOverride!==null?this._maxMSAASamplesOverride:this._gl.getParameter(this._gl.MAX_SAMPLES);else{const x=this._gl.getExtension("WEBGL_draw_buffers");if(x!==null){this._caps.drawBuffersExtension=!0,this._gl.drawBuffers=x.drawBuffersWEBGL.bind(x),this._gl.DRAW_FRAMEBUFFER=this._gl.FRAMEBUFFER;for(let c=0;c<16;c++)this._gl["COLOR_ATTACHMENT"+c+"_WEBGL"]=x["COLOR_ATTACHMENT"+c+"_WEBGL"]}}if(this._webGLVersion>1)this._caps.depthTextureExtension=!0;else{const x=this._gl.getExtension("WEBGL_depth_texture");x!=null&&(this._caps.depthTextureExtension=!0,this._gl.UNSIGNED_INT_24_8=x.UNSIGNED_INT_24_8_WEBGL)}if(this.disableVertexArrayObjects)this._caps.vertexArrayObject=!1;else if(this._webGLVersion>1)this._caps.vertexArrayObject=!0;else{const x=this._gl.getExtension("OES_vertex_array_object");x!=null&&(this._caps.vertexArrayObject=!0,this._gl.createVertexArray=x.createVertexArrayOES.bind(x),this._gl.bindVertexArray=x.bindVertexArrayOES.bind(x),this._gl.deleteVertexArray=x.deleteVertexArrayOES.bind(x))}if(this._webGLVersion>1)this._caps.instancedArrays=!0;else{const x=this._gl.getExtension("ANGLE_instanced_arrays");x!=null?(this._caps.instancedArrays=!0,this._gl.drawArraysInstanced=x.drawArraysInstancedANGLE.bind(x),this._gl.drawElementsInstanced=x.drawElementsInstancedANGLE.bind(x),this._gl.vertexAttribDivisor=x.vertexAttribDivisorANGLE.bind(x)):this._caps.instancedArrays=!1}if(this._gl.getShaderPrecisionFormat){const x=this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER,this._gl.HIGH_FLOAT),c=this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER,this._gl.HIGH_FLOAT);x&&c&&(this._caps.highPrecisionShaderSupported=x.precision!==0&&c.precision!==0)}if(this._webGLVersion>1)this._caps.blendMinMax=!0;else{const x=this._gl.getExtension("EXT_blend_minmax");x!=null&&(this._caps.blendMinMax=!0,this._gl.MAX=x.MAX_EXT,this._gl.MIN=x.MIN_EXT)}if(!this._caps.supportSRGBBuffers){if(this._webGLVersion>1)this._caps.supportSRGBBuffers=!0,this._glSRGBExtensionValues={SRGB:WebGL2RenderingContext.SRGB,SRGB8:WebGL2RenderingContext.SRGB8,SRGB8_ALPHA8:WebGL2RenderingContext.SRGB8_ALPHA8};else{const x=this._gl.getExtension("EXT_sRGB");x!=null&&(this._caps.supportSRGBBuffers=!0,this._glSRGBExtensionValues={SRGB:x.SRGB_EXT,SRGB8:x.SRGB_ALPHA_EXT,SRGB8_ALPHA8:x.SRGB_ALPHA_EXT})}this._caps.supportSRGBBuffers=this._caps.supportSRGBBuffers&&!!(this._creationOptions&&this._creationOptions.forceSRGBBufferSupportState)}this._depthCullingState.depthTest=!0,this._depthCullingState.depthFunc=this._gl.LEQUAL,this._depthCullingState.depthMask=!0,this._maxSimultaneousTextures=this._caps.maxCombinedTexturesImageUnits;for(let x=0;x<this._maxSimultaneousTextures;x++)this._nextFreeTextureSlots.push(x);this._glRenderer==="Mali-G72"&&(this._caps.disableMorphTargetTexture=!0)}_initFeatures(){this._features={forceBitmapOverHTMLImageElement:typeof HTMLImageElement>"u",supportRenderAndCopyToLodForFloatTextures:this._webGLVersion!==1,supportDepthStencilTexture:this._webGLVersion!==1,supportShadowSamplers:this._webGLVersion!==1,uniformBufferHardCheckMatrix:!1,allowTexturePrefiltering:this._webGLVersion!==1,trackUbosInFrame:!1,checkUbosContentBeforeUpload:!1,supportCSM:this._webGLVersion!==1,basisNeedsPOT:this._webGLVersion===1,support3DTextures:this._webGLVersion!==1,needTypeSuffixInShaderConstants:this._webGLVersion!==1,supportMSAA:this._webGLVersion!==1,supportSSAO2:this._webGLVersion!==1,supportExtendedTextureFormats:this._webGLVersion!==1,supportSwitchCaseInShader:this._webGLVersion!==1,supportSyncTextureRead:!0,needsInvertingBitmap:!0,useUBOBindingCache:!0,needShaderCodeInlining:!1,needToAlwaysBindUniformBuffers:!1,supportRenderPasses:!1,supportSpriteInstancing:!0,forceVertexBufferStrideAndOffsetMultiple4Bytes:!1,_collectUbosUpdatedInFrame:!1}}get webGLVersion(){return this._webGLVersion}getClassName(){return"ThinEngine"}get isStencilEnable(){return this._isStencilEnable}_prepareWorkingCanvas(){if(this._workingCanvas)return;this._workingCanvas=this.createCanvas(1,1);const a=this._workingCanvas.getContext("2d");a&&(this._workingContext=a)}resetTextureCache(){for(const a in this._boundTexturesCache)Object.prototype.hasOwnProperty.call(this._boundTexturesCache,a)&&(this._boundTexturesCache[a]=null);this._currentTextureChannel=-1}getInfo(){return this.getGlInfo()}getGlInfo(){return{vendor:this._glVendor,renderer:this._glRenderer,version:this._glVersion}}setHardwareScalingLevel(a){this._hardwareScalingLevel=a,this.resize()}getHardwareScalingLevel(){return this._hardwareScalingLevel}getLoadedTexturesCache(){return this._internalTexturesCache}getCaps(){return this._caps}stopRenderLoop(a){if(!a){this._activeRenderLoops.length=0,this._cancelFrame();return}const x=this._activeRenderLoops.indexOf(a);x>=0&&(this._activeRenderLoops.splice(x,1),this._activeRenderLoops.length==0&&this._cancelFrame())}_cancelFrame(){if(this._frameHandler!==0){const a=this._frameHandler;if(this._frameHandler=0,xa()){const{cancelAnimationFrame:x}=this.getHostWindow()||window;if(typeof x=="function")return x(a)}else if(typeof cancelAnimationFrame=="function")return cancelAnimationFrame(a);return clearTimeout(a)}}_renderLoop(){if(this._frameHandler=0,!this._contextWasLost){let a=!0;if((this._isDisposed||!this.renderEvenInBackground&&this._windowIsBackground)&&(a=!1),a){this.beginFrame();for(let x=0;x<this._activeRenderLoops.length;x++){const c=this._activeRenderLoops[x];c()}this.endFrame()}}this._frameHandler===0&&(this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow()))}getRenderingCanvas(){return this._renderingCanvas}getAudioContext(){return this._audioContext}getAudioDestination(){return this._audioDestination}getHostWindow(){return xa()?this._renderingCanvas&&this._renderingCanvas.ownerDocument&&this._renderingCanvas.ownerDocument.defaultView?this._renderingCanvas.ownerDocument.defaultView:window:null}getRenderWidth(a=!1){return!a&&this._currentRenderTarget?this._currentRenderTarget.width:this._framebufferDimensionsObject?this._framebufferDimensionsObject.framebufferWidth:this._gl.drawingBufferWidth}getRenderHeight(a=!1){return!a&&this._currentRenderTarget?this._currentRenderTarget.height:this._framebufferDimensionsObject?this._framebufferDimensionsObject.framebufferHeight:this._gl.drawingBufferHeight}_queueNewFrame(a,x){return Es.QueueNewFrame(a,x)}runRenderLoop(a){this._activeRenderLoops.indexOf(a)===-1&&(this._activeRenderLoops.push(a),this._activeRenderLoops.length===1&&this._frameHandler===0&&(this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow())))}clear(a,x,c,u=!1){const g=this.stencilStateComposer.useStencilGlobalOnly;this.stencilStateComposer.useStencilGlobalOnly=!0,this.applyStates(),this.stencilStateComposer.useStencilGlobalOnly=g;let y=0;if(x&&a){let v=!0;if(this._currentRenderTarget){const w=this._currentRenderTarget.texture?.format;if(w===8||w===9||w===10||w===11){const B=this._currentRenderTarget.texture?.type;B===7||B===5?(Es._TempClearColorUint32[0]=a.r*255,Es._TempClearColorUint32[1]=a.g*255,Es._TempClearColorUint32[2]=a.b*255,Es._TempClearColorUint32[3]=a.a*255,this._gl.clearBufferuiv(this._gl.COLOR,0,Es._TempClearColorUint32),v=!1):(Es._TempClearColorInt32[0]=a.r*255,Es._TempClearColorInt32[1]=a.g*255,Es._TempClearColorInt32[2]=a.b*255,Es._TempClearColorInt32[3]=a.a*255,this._gl.clearBufferiv(this._gl.COLOR,0,Es._TempClearColorInt32),v=!1)}}v&&(this._gl.clearColor(a.r,a.g,a.b,a.a!==void 0?a.a:1),y|=this._gl.COLOR_BUFFER_BIT)}c&&(this.useReverseDepthBuffer?(this._depthCullingState.depthFunc=this._gl.GEQUAL,this._gl.clearDepth(0)):this._gl.clearDepth(1),y|=this._gl.DEPTH_BUFFER_BIT),u&&(this._gl.clearStencil(0),y|=this._gl.STENCIL_BUFFER_BIT),this._gl.clear(y)}_viewport(a,x,c,u){(a!==this._viewportCached.x||x!==this._viewportCached.y||c!==this._viewportCached.z||u!==this._viewportCached.w)&&(this._viewportCached.x=a,this._viewportCached.y=x,this._viewportCached.z=c,this._viewportCached.w=u,this._gl.viewport(a,x,c,u))}setViewport(a,x,c){const u=x||this.getRenderWidth(),g=c||this.getRenderHeight(),y=a.x||0,v=a.y||0;this._cachedViewport=a,this._viewport(y*u,v*g,u*a.width,g*a.height)}beginFrame(){}endFrame(){this._badOS&&this.flushFramebuffer(),this._frameId++}resize(a=!1){let x,c;if(this.adaptToDeviceRatio){const u=xa()&&window.devicePixelRatio||1,g=this._lastDevicePixelRatio/u;this._lastDevicePixelRatio=u,this._hardwareScalingLevel*=g}if(xa()&&ux())if(this._renderingCanvas){const u=this._renderingCanvas.getBoundingClientRect?this._renderingCanvas.getBoundingClientRect():{width:this._renderingCanvas.width*this._hardwareScalingLevel,height:this._renderingCanvas.height*this._hardwareScalingLevel};x=this._renderingCanvas.clientWidth||u.width||this._renderingCanvas.width||100,c=this._renderingCanvas.clientHeight||u.height||this._renderingCanvas.height||100}else x=window.innerWidth,c=window.innerHeight;else x=this._renderingCanvas?this._renderingCanvas.width:100,c=this._renderingCanvas?this._renderingCanvas.height:100;this.setSize(x/this._hardwareScalingLevel,c/this._hardwareScalingLevel,a)}setSize(a,x,c=!1){return!this._renderingCanvas||(a=a|0,x=x|0,!c&&this._renderingCanvas.width===a&&this._renderingCanvas.height===x)?!1:(this._renderingCanvas.width=a,this._renderingCanvas.height=x,!0)}bindFramebuffer(a,x=0,c,u,g,y=0,v=0){const w=a;this._currentRenderTarget&&this.unBindFramebuffer(this._currentRenderTarget),this._currentRenderTarget=a,this._bindUnboundFramebuffer(w._MSAAFramebuffer?w._MSAAFramebuffer:w._framebuffer);const B=this._gl;a.isMulti||(a.is2DArray?B.framebufferTextureLayer(B.FRAMEBUFFER,B.COLOR_ATTACHMENT0,a.texture._hardwareTexture?.underlyingResource,y,v):a.isCube?B.framebufferTexture2D(B.FRAMEBUFFER,B.COLOR_ATTACHMENT0,B.TEXTURE_CUBE_MAP_POSITIVE_X+x,a.texture._hardwareTexture?.underlyingResource,y):w._currentLOD!==y&&(B.framebufferTexture2D(B.FRAMEBUFFER,B.COLOR_ATTACHMENT0,B.TEXTURE_2D,a.texture._hardwareTexture?.underlyingResource,y),w._currentLOD=y));const W=a._depthStencilTexture;if(W){const ae=a._depthStencilTextureWithStencil?B.DEPTH_STENCIL_ATTACHMENT:B.DEPTH_ATTACHMENT;a.is2DArray?B.framebufferTextureLayer(B.FRAMEBUFFER,ae,W._hardwareTexture?.underlyingResource,y,v):a.isCube?B.framebufferTexture2D(B.FRAMEBUFFER,ae,B.TEXTURE_CUBE_MAP_POSITIVE_X+x,W._hardwareTexture?.underlyingResource,y):B.framebufferTexture2D(B.FRAMEBUFFER,ae,B.TEXTURE_2D,W._hardwareTexture?.underlyingResource,y)}this._cachedViewport&&!g?this.setViewport(this._cachedViewport,c,u):(c||(c=a.width,y&&(c=c/Math.pow(2,y))),u||(u=a.height,y&&(u=u/Math.pow(2,y))),this._viewport(0,0,c,u)),this.wipeCaches()}setState(a,x=0,c,u=!1,g,y,v=0){(this._depthCullingState.cull!==a||c)&&(this._depthCullingState.cull=a);const w=this.cullBackFaces??g??!0?this._gl.BACK:this._gl.FRONT;(this._depthCullingState.cullFace!==w||c)&&(this._depthCullingState.cullFace=w),this.setZOffset(x),this.setZOffsetUnits(v);const B=u?this._gl.CW:this._gl.CCW;(this._depthCullingState.frontFace!==B||c)&&(this._depthCullingState.frontFace=B),this._stencilStateComposer.stencilMaterial=y}getDepthBuffer(){return this._depthCullingState.depthTest}setDepthBuffer(a){this._depthCullingState.depthTest=a}setZOffset(a){this._depthCullingState.zOffset=this.useReverseDepthBuffer?-a:a}getZOffset(){const a=this._depthCullingState.zOffset;return this.useReverseDepthBuffer?-a:a}setZOffsetUnits(a){this._depthCullingState.zOffsetUnits=this.useReverseDepthBuffer?-a:a}getZOffsetUnits(){const a=this._depthCullingState.zOffsetUnits;return this.useReverseDepthBuffer?-a:a}_bindUnboundFramebuffer(a){this._currentFramebuffer!==a&&(this._gl.bindFramebuffer(this._gl.FRAMEBUFFER,a),this._currentFramebuffer=a)}_currentFrameBufferIsDefaultFrameBuffer(){return this._currentFramebuffer===null}generateMipmaps(a){this._bindTextureDirectly(this._gl.TEXTURE_2D,a,!0),this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null)}unBindFramebuffer(a,x=!1,c){const u=a;this._currentRenderTarget=null;const g=this._gl;if(u._MSAAFramebuffer){if(a.isMulti){this.unBindMultiColorAttachmentFramebuffer(a,x,c);return}g.bindFramebuffer(g.READ_FRAMEBUFFER,u._MSAAFramebuffer),g.bindFramebuffer(g.DRAW_FRAMEBUFFER,u._framebuffer),g.blitFramebuffer(0,0,a.width,a.height,0,0,a.width,a.height,g.COLOR_BUFFER_BIT,g.NEAREST)}a.texture?.generateMipMaps&&!x&&!a.isCube&&this.generateMipmaps(a.texture),c&&(u._MSAAFramebuffer&&this._bindUnboundFramebuffer(u._framebuffer),c()),this._bindUnboundFramebuffer(null)}flushFramebuffer(){this._gl.flush()}restoreDefaultFramebuffer(){this._currentRenderTarget?this.unBindFramebuffer(this._currentRenderTarget):this._bindUnboundFramebuffer(null),this._cachedViewport&&this.setViewport(this._cachedViewport),this.wipeCaches()}_resetVertexBufferBinding(){this.bindArrayBuffer(null),this._cachedVertexBuffers=null}createVertexBuffer(a,x,c){return this._createVertexBuffer(a,this._gl.STATIC_DRAW)}_createVertexBuffer(a,x){const c=this._gl.createBuffer();if(!c)throw new Error("Unable to create vertex buffer");const u=new Vo(c);return this.bindArrayBuffer(u),typeof a!="number"?a instanceof Array?(this._gl.bufferData(this._gl.ARRAY_BUFFER,new Float32Array(a),x),u.capacity=a.length*4):(this._gl.bufferData(this._gl.ARRAY_BUFFER,a,x),u.capacity=a.byteLength):(this._gl.bufferData(this._gl.ARRAY_BUFFER,new Uint8Array(a),x),u.capacity=a),this._resetVertexBufferBinding(),u.references=1,u}createDynamicVertexBuffer(a,x){return this._createVertexBuffer(a,this._gl.DYNAMIC_DRAW)}_resetIndexBufferBinding(){this.bindIndexBuffer(null),this._cachedIndexBuffer=null}createIndexBuffer(a,x,c){const u=this._gl.createBuffer(),g=new Vo(u);if(!u)throw new Error("Unable to create index buffer");this.bindIndexBuffer(g);const y=this._normalizeIndexData(a);return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,y,x?this._gl.DYNAMIC_DRAW:this._gl.STATIC_DRAW),this._resetIndexBufferBinding(),g.references=1,g.is32Bits=y.BYTES_PER_ELEMENT===4,g}_normalizeIndexData(a){if(a.BYTES_PER_ELEMENT===2)return a;if(this._caps.uintIndices){if(a instanceof Uint32Array)return a;for(let c=0;c<a.length;c++)if(a[c]>=65535)return new Uint32Array(a);return new Uint16Array(a)}return new Uint16Array(a)}bindArrayBuffer(a){this._vaoRecordInProgress||this._unbindVertexArrayObject(),this._bindBuffer(a,this._gl.ARRAY_BUFFER)}bindUniformBlock(a,x,c){const u=a.program,g=this._gl.getUniformBlockIndex(u,x);this._gl.uniformBlockBinding(u,g,c)}bindIndexBuffer(a){this._vaoRecordInProgress||this._unbindVertexArrayObject(),this._bindBuffer(a,this._gl.ELEMENT_ARRAY_BUFFER)}_bindBuffer(a,x){(this._vaoRecordInProgress||this._currentBoundBuffer[x]!==a)&&(this._gl.bindBuffer(x,a?a.underlyingResource:null),this._currentBoundBuffer[x]=a)}updateArrayBuffer(a){this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,a)}_vertexAttribPointer(a,x,c,u,g,y,v){const w=this._currentBufferPointers[x];if(!w)return;let B=!1;w.active?(w.buffer!==a&&(w.buffer=a,B=!0),w.size!==c&&(w.size=c,B=!0),w.type!==u&&(w.type=u,B=!0),w.normalized!==g&&(w.normalized=g,B=!0),w.stride!==y&&(w.stride=y,B=!0),w.offset!==v&&(w.offset=v,B=!0)):(B=!0,w.active=!0,w.index=x,w.size=c,w.type=u,w.normalized=g,w.stride=y,w.offset=v,w.buffer=a),(B||this._vaoRecordInProgress)&&(this.bindArrayBuffer(a),u===this._gl.UNSIGNED_INT||u===this._gl.INT?this._gl.vertexAttribIPointer(x,c,u,y,v):this._gl.vertexAttribPointer(x,c,u,g,y,v))}_bindIndexBufferWithCache(a){a!=null&&this._cachedIndexBuffer!==a&&(this._cachedIndexBuffer=a,this.bindIndexBuffer(a),this._uintIndicesCurrentlySet=a.is32Bits)}_bindVertexBuffersAttributes(a,x,c){const u=x.getAttributesNames();this._vaoRecordInProgress||this._unbindVertexArrayObject(),this.unbindAllAttributes();for(let g=0;g<u.length;g++){const y=x.getAttributeLocation(g);if(y>=0){const v=u[g];let w=null;if(c&&(w=c[v]),w||(w=a[v]),!w)continue;this._gl.enableVertexAttribArray(y),this._vaoRecordInProgress||(this._vertexAttribArraysEnabled[y]=!0);const B=w.getBuffer();B&&(this._vertexAttribPointer(B,y,w.getSize(),w.type,w.normalized,w.byteStride,w.byteOffset),w.getIsInstanced()&&(this._gl.vertexAttribDivisor(y,w.getInstanceDivisor()),this._vaoRecordInProgress||(this._currentInstanceLocations.push(y),this._currentInstanceBuffers.push(B))))}}}recordVertexArrayObject(a,x,c,u){const g=this._gl.createVertexArray();if(!g)throw new Error("Unable to create VAO");return this._vaoRecordInProgress=!0,this._gl.bindVertexArray(g),this._mustWipeVertexAttributes=!0,this._bindVertexBuffersAttributes(a,c,u),this.bindIndexBuffer(x),this._vaoRecordInProgress=!1,this._gl.bindVertexArray(null),g}bindVertexArrayObject(a,x){this._cachedVertexArrayObject!==a&&(this._cachedVertexArrayObject=a,this._gl.bindVertexArray(a),this._cachedVertexBuffers=null,this._cachedIndexBuffer=null,this._uintIndicesCurrentlySet=x!=null&&x.is32Bits,this._mustWipeVertexAttributes=!0)}bindBuffersDirectly(a,x,c,u,g){if(this._cachedVertexBuffers!==a||this._cachedEffectForVertexBuffers!==g){this._cachedVertexBuffers=a,this._cachedEffectForVertexBuffers=g;const y=g.getAttributesCount();this._unbindVertexArrayObject(),this.unbindAllAttributes();let v=0;for(let w=0;w<y;w++)if(w<c.length){const B=g.getAttributeLocation(w);B>=0&&(this._gl.enableVertexAttribArray(B),this._vertexAttribArraysEnabled[B]=!0,this._vertexAttribPointer(a,B,c[w],this._gl.FLOAT,!1,u,v)),v+=c[w]*4}}this._bindIndexBufferWithCache(x)}_unbindVertexArrayObject(){this._cachedVertexArrayObject&&(this._cachedVertexArrayObject=null,this._gl.bindVertexArray(null))}bindBuffers(a,x,c,u){(this._cachedVertexBuffers!==a||this._cachedEffectForVertexBuffers!==c)&&(this._cachedVertexBuffers=a,this._cachedEffectForVertexBuffers=c,this._bindVertexBuffersAttributes(a,c,u)),this._bindIndexBufferWithCache(x)}unbindInstanceAttributes(){let a;for(let x=0,c=this._currentInstanceLocations.length;x<c;x++){const u=this._currentInstanceBuffers[x];a!=u&&u.references&&(a=u,this.bindArrayBuffer(u));const g=this._currentInstanceLocations[x];this._gl.vertexAttribDivisor(g,0)}this._currentInstanceBuffers.length=0,this._currentInstanceLocations.length=0}releaseVertexArrayObject(a){this._gl.deleteVertexArray(a)}_releaseBuffer(a){return a.references--,a.references===0?(this._deleteBuffer(a),!0):!1}_deleteBuffer(a){this._gl.deleteBuffer(a.underlyingResource)}updateAndBindInstancesBuffer(a,x,c){if(this.bindArrayBuffer(a),x&&this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,x),c[0].index!==void 0)this.bindInstancesBuffer(a,c,!0);else for(let u=0;u<4;u++){const g=c[u];this._vertexAttribArraysEnabled[g]||(this._gl.enableVertexAttribArray(g),this._vertexAttribArraysEnabled[g]=!0),this._vertexAttribPointer(a,g,4,this._gl.FLOAT,!1,64,u*16),this._gl.vertexAttribDivisor(g,1),this._currentInstanceLocations.push(g),this._currentInstanceBuffers.push(a)}}bindInstancesBuffer(a,x,c=!0){this.bindArrayBuffer(a);let u=0;if(c)for(let g=0;g<x.length;g++){const y=x[g];u+=y.attributeSize*4}for(let g=0;g<x.length;g++){const y=x[g];y.index===void 0&&(y.index=this._currentEffect.getAttributeLocationByName(y.attributeName)),!(y.index<0)&&(this._vertexAttribArraysEnabled[y.index]||(this._gl.enableVertexAttribArray(y.index),this._vertexAttribArraysEnabled[y.index]=!0),this._vertexAttribPointer(a,y.index,y.attributeSize,y.attributeType||this._gl.FLOAT,y.normalized||!1,u,y.offset),this._gl.vertexAttribDivisor(y.index,y.divisor===void 0?1:y.divisor),this._currentInstanceLocations.push(y.index),this._currentInstanceBuffers.push(a))}}disableInstanceAttributeByName(a){if(!this._currentEffect)return;const x=this._currentEffect.getAttributeLocationByName(a);this.disableInstanceAttribute(x)}disableInstanceAttribute(a){let x=!1,c;for(;(c=this._currentInstanceLocations.indexOf(a))!==-1;)this._currentInstanceLocations.splice(c,1),this._currentInstanceBuffers.splice(c,1),x=!0,c=this._currentInstanceLocations.indexOf(a);x&&(this._gl.vertexAttribDivisor(a,0),this.disableAttributeByIndex(a))}disableAttributeByIndex(a){this._gl.disableVertexAttribArray(a),this._vertexAttribArraysEnabled[a]=!1,this._currentBufferPointers[a].active=!1}draw(a,x,c,u){this.drawElementsType(a?0:1,x,c,u)}drawPointClouds(a,x,c){this.drawArraysType(2,a,x,c)}drawUnIndexed(a,x,c,u){this.drawArraysType(a?0:1,x,c,u)}drawElementsType(a,x,c,u){this.applyStates(),this._reportDrawCall();const g=this._drawMode(a),y=this._uintIndicesCurrentlySet?this._gl.UNSIGNED_INT:this._gl.UNSIGNED_SHORT,v=this._uintIndicesCurrentlySet?4:2;u?this._gl.drawElementsInstanced(g,c,y,x*v,u):this._gl.drawElements(g,c,y,x*v)}drawArraysType(a,x,c,u){this.applyStates(),this._reportDrawCall();const g=this._drawMode(a);u?this._gl.drawArraysInstanced(g,x,c,u):this._gl.drawArrays(g,x,c)}_drawMode(a){switch(a){case 0:return this._gl.TRIANGLES;case 2:return this._gl.POINTS;case 1:return this._gl.LINES;case 3:return this._gl.POINTS;case 4:return this._gl.LINES;case 5:return this._gl.LINE_LOOP;case 6:return this._gl.LINE_STRIP;case 7:return this._gl.TRIANGLE_STRIP;case 8:return this._gl.TRIANGLE_FAN;default:return this._gl.TRIANGLES}}_reportDrawCall(){}_releaseEffect(a){this._compiledEffects[a._key]&&delete this._compiledEffects[a._key];const x=a.getPipelineContext();x&&this._deletePipelineContext(x)}_deletePipelineContext(a){const x=a;x&&x.program&&(x.program.__SPECTOR_rebuildProgram=null,this._gl.deleteProgram(x.program))}_getGlobalDefines(a){if(a){this.isNDCHalfZRange?a.IS_NDC_HALF_ZRANGE="":delete a.IS_NDC_HALF_ZRANGE,this.useReverseDepthBuffer?a.USE_REVERSE_DEPTHBUFFER="":delete a.USE_REVERSE_DEPTHBUFFER,this.useExactSrgbConversions?a.USE_EXACT_SRGB_CONVERSIONS="":delete a.USE_EXACT_SRGB_CONVERSIONS;return}else{let x="";return this.isNDCHalfZRange&&(x+="#define IS_NDC_HALF_ZRANGE"),this.useReverseDepthBuffer&&(x&&(x+=`
`),x+="#define USE_REVERSE_DEPTHBUFFER"),this.useExactSrgbConversions&&(x&&(x+=`
`),x+="#define USE_EXACT_SRGB_CONVERSIONS"),x}}createEffect(a,x,c,u,g,y,v,w,B,W=_a.GLSL){const ae=a.vertexElement||a.vertex||a.vertexToken||a.vertexSource||a,ue=a.fragmentElement||a.fragment||a.fragmentToken||a.fragmentSource||a,fe=this._getGlobalDefines();let Re=g??x.defines??"";fe&&(Re+=fe);const _e=ae+"+"+ue+"@"+Re;if(this._compiledEffects[_e]){const tt=this._compiledEffects[_e];return v&&tt.isReady()&&v(tt),tt}const Be=new Yn(a,x,c,u,this,g,y,v,w,B,_e,W);return this._compiledEffects[_e]=Be,Be}static _ConcatenateShader(a,x,c=""){return c+(x?x+`
`:"")+a}_compileShader(a,x,c,u){return this._compileRawShader(Es._ConcatenateShader(a,c,u),x)}_compileRawShader(a,x){const c=this._gl,u=c.createShader(x==="vertex"?c.VERTEX_SHADER:c.FRAGMENT_SHADER);if(!u){let g=c.NO_ERROR,y=c.NO_ERROR;for(;(y=c.getError())!==c.NO_ERROR;)g=y;throw new Error(`Something went wrong while creating a gl ${x} shader object. gl error=${g}, gl isContextLost=${c.isContextLost()}, _contextWasLost=${this._contextWasLost}`)}return c.shaderSource(u,a),c.compileShader(u),u}_getShaderSource(a){return this._gl.getShaderSource(a)}createRawShaderProgram(a,x,c,u,g=null){u=u||this._gl;const y=this._compileRawShader(x,"vertex"),v=this._compileRawShader(c,"fragment");return this._createShaderProgram(a,y,v,u,g)}createShaderProgram(a,x,c,u,g,y=null){g=g||this._gl;const v=this._webGLVersion>1?`#version 300 es
#define WEBGL2 
`:"",w=this._compileShader(x,"vertex",u,v),B=this._compileShader(c,"fragment",u,v);return this._createShaderProgram(a,w,B,g,y)}inlineShaderCode(a){return a}createPipelineContext(a){const x=new U2;return x.engine=this,this._caps.parallelShaderCompile&&(x.isParallelCompiled=!0),x}createMaterialContext(){}createDrawContext(){}_createShaderProgram(a,x,c,u,g=null){const y=u.createProgram();if(a.program=y,!y)throw new Error("Unable to create program");return u.attachShader(y,x),u.attachShader(y,c),u.linkProgram(y),a.context=u,a.vertexShader=x,a.fragmentShader=c,a.isParallelCompiled||this._finalizePipelineContext(a),y}_finalizePipelineContext(a){const x=a.context,c=a.vertexShader,u=a.fragmentShader,g=a.program;if(!x.getProgramParameter(g,x.LINK_STATUS)){if(!this._gl.getShaderParameter(c,this._gl.COMPILE_STATUS)){const w=this._gl.getShaderInfoLog(c);if(w)throw a.vertexCompilationError=w,new Error("VERTEX SHADER "+w)}if(!this._gl.getShaderParameter(u,this._gl.COMPILE_STATUS)){const w=this._gl.getShaderInfoLog(u);if(w)throw a.fragmentCompilationError=w,new Error("FRAGMENT SHADER "+w)}const v=x.getProgramInfoLog(g);if(v)throw a.programLinkError=v,new Error(v)}if(this.validateShaderPrograms&&(x.validateProgram(g),!x.getProgramParameter(g,x.VALIDATE_STATUS))){const w=x.getProgramInfoLog(g);if(w)throw a.programValidationError=w,new Error(w)}x.deleteShader(c),x.deleteShader(u),a.vertexShader=void 0,a.fragmentShader=void 0,a.onCompiled&&(a.onCompiled(),a.onCompiled=void 0)}_preparePipelineContext(a,x,c,u,g,y,v,w,B,W){const ae=a;u?ae.program=this.createRawShaderProgram(ae,x,c,void 0,B):ae.program=this.createShaderProgram(ae,x,c,w,void 0,B),ae.program.__SPECTOR_rebuildProgram=v}_isRenderingStateCompiled(a){const x=a;return this._isDisposed||x._isDisposed?!1:this._gl.getProgramParameter(x.program,this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)?(this._finalizePipelineContext(x),!0):!1}_executeWhenRenderingStateIsCompiled(a,x){const c=a;if(!c.isParallelCompiled){x();return}const u=c.onCompiled;u?c.onCompiled=()=>{u(),x()}:c.onCompiled=x}getUniforms(a,x){const c=new Array,u=a;for(let g=0;g<x.length;g++)c.push(this._gl.getUniformLocation(u.program,x[g]));return c}getAttributes(a,x){const c=[],u=a;for(let g=0;g<x.length;g++)try{c.push(this._gl.getAttribLocation(u.program,x[g]))}catch{c.push(-1)}return c}enableEffect(a){a=a!==null&&Yo.IsWrapper(a)?a.effect:a,!(!a||a===this._currentEffect)&&(this._stencilStateComposer.stencilMaterial=void 0,a=a,this.bindSamplers(a),this._currentEffect=a,a.onBind&&a.onBind(a),a._onBindObservable&&a._onBindObservable.notifyObservers(a))}setInt(a,x){return a?(this._gl.uniform1i(a,x),!0):!1}setInt2(a,x,c){return a?(this._gl.uniform2i(a,x,c),!0):!1}setInt3(a,x,c,u){return a?(this._gl.uniform3i(a,x,c,u),!0):!1}setInt4(a,x,c,u,g){return a?(this._gl.uniform4i(a,x,c,u,g),!0):!1}setIntArray(a,x){return a?(this._gl.uniform1iv(a,x),!0):!1}setIntArray2(a,x){return!a||x.length%2!==0?!1:(this._gl.uniform2iv(a,x),!0)}setIntArray3(a,x){return!a||x.length%3!==0?!1:(this._gl.uniform3iv(a,x),!0)}setIntArray4(a,x){return!a||x.length%4!==0?!1:(this._gl.uniform4iv(a,x),!0)}setUInt(a,x){return a?(this._gl.uniform1ui(a,x),!0):!1}setUInt2(a,x,c){return a?(this._gl.uniform2ui(a,x,c),!0):!1}setUInt3(a,x,c,u){return a?(this._gl.uniform3ui(a,x,c,u),!0):!1}setUInt4(a,x,c,u,g){return a?(this._gl.uniform4ui(a,x,c,u,g),!0):!1}setUIntArray(a,x){return a?(this._gl.uniform1uiv(a,x),!0):!1}setUIntArray2(a,x){return!a||x.length%2!==0?!1:(this._gl.uniform2uiv(a,x),!0)}setUIntArray3(a,x){return!a||x.length%3!==0?!1:(this._gl.uniform3uiv(a,x),!0)}setUIntArray4(a,x){return!a||x.length%4!==0?!1:(this._gl.uniform4uiv(a,x),!0)}setArray(a,x){return!a||x.length<1?!1:(this._gl.uniform1fv(a,x),!0)}setArray2(a,x){return!a||x.length%2!==0?!1:(this._gl.uniform2fv(a,x),!0)}setArray3(a,x){return!a||x.length%3!==0?!1:(this._gl.uniform3fv(a,x),!0)}setArray4(a,x){return!a||x.length%4!==0?!1:(this._gl.uniform4fv(a,x),!0)}setMatrices(a,x){return a?(this._gl.uniformMatrix4fv(a,!1,x),!0):!1}setMatrix3x3(a,x){return a?(this._gl.uniformMatrix3fv(a,!1,x),!0):!1}setMatrix2x2(a,x){return a?(this._gl.uniformMatrix2fv(a,!1,x),!0):!1}setFloat(a,x){return a?(this._gl.uniform1f(a,x),!0):!1}setFloat2(a,x,c){return a?(this._gl.uniform2f(a,x,c),!0):!1}setFloat3(a,x,c,u){return a?(this._gl.uniform3f(a,x,c,u),!0):!1}setFloat4(a,x,c,u,g){return a?(this._gl.uniform4f(a,x,c,u,g),!0):!1}applyStates(){if(this._depthCullingState.apply(this._gl),this._stencilStateComposer.apply(this._gl),this._alphaState.apply(this._gl),this._colorWriteChanged){this._colorWriteChanged=!1;const a=this._colorWrite;this._gl.colorMask(a,a,a,a)}}setColorWrite(a){a!==this._colorWrite&&(this._colorWriteChanged=!0,this._colorWrite=a)}getColorWrite(){return this._colorWrite}get depthCullingState(){return this._depthCullingState}get alphaState(){return this._alphaState}get stencilState(){return this._stencilState}get stencilStateComposer(){return this._stencilStateComposer}clearInternalTexturesCache(){this._internalTexturesCache.length=0}wipeCaches(a){this.preventCacheWipeBetweenFrames&&!a||(this._currentEffect=null,this._viewportCached.x=0,this._viewportCached.y=0,this._viewportCached.z=0,this._viewportCached.w=0,this._unbindVertexArrayObject(),a&&(this._currentProgram=null,this.resetTextureCache(),this._stencilStateComposer.reset(),this._depthCullingState.reset(),this._depthCullingState.depthFunc=this._gl.LEQUAL,this._alphaState.reset(),this._alphaMode=1,this._alphaEquation=0,this._colorWrite=!0,this._colorWriteChanged=!0,this._unpackFlipYCached=null,this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,this._gl.NONE),this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,0),this._mustWipeVertexAttributes=!0,this.unbindAllAttributes()),this._resetVertexBufferBinding(),this._cachedIndexBuffer=null,this._cachedEffectForVertexBuffers=null,this.bindIndexBuffer(null))}_getSamplingParameters(a,x){const c=this._gl;let u=c.NEAREST,g=c.NEAREST;switch(a){case 11:u=c.LINEAR,x?g=c.LINEAR_MIPMAP_NEAREST:g=c.LINEAR;break;case 3:u=c.LINEAR,x?g=c.LINEAR_MIPMAP_LINEAR:g=c.LINEAR;break;case 8:u=c.NEAREST,x?g=c.NEAREST_MIPMAP_LINEAR:g=c.NEAREST;break;case 4:u=c.NEAREST,x?g=c.NEAREST_MIPMAP_NEAREST:g=c.NEAREST;break;case 5:u=c.NEAREST,x?g=c.LINEAR_MIPMAP_NEAREST:g=c.LINEAR;break;case 6:u=c.NEAREST,x?g=c.LINEAR_MIPMAP_LINEAR:g=c.LINEAR;break;case 7:u=c.NEAREST,g=c.LINEAR;break;case 1:u=c.NEAREST,g=c.NEAREST;break;case 9:u=c.LINEAR,x?g=c.NEAREST_MIPMAP_NEAREST:g=c.NEAREST;break;case 10:u=c.LINEAR,x?g=c.NEAREST_MIPMAP_LINEAR:g=c.NEAREST;break;case 2:u=c.LINEAR,g=c.LINEAR;break;case 12:u=c.LINEAR,g=c.NEAREST;break}return{min:g,mag:u}}_createTexture(){const a=this._gl.createTexture();if(!a)throw new Error("Unable to create texture");return a}_createHardwareTexture(){return new Yx(this._createTexture(),this._gl)}_createInternalTexture(a,x,c=!0,u=hn.Unknown){let g=!1,y=0,v=3,w=5,B=!1,W=1,ae;x!==void 0&&typeof x=="object"?(g=!!x.generateMipMaps,y=x.type===void 0?0:x.type,v=x.samplingMode===void 0?3:x.samplingMode,w=x.format===void 0?5:x.format,B=x.useSRGBBuffer===void 0?!1:x.useSRGBBuffer,W=x.samples??1,ae=x.label):g=!!x,B&&(B=this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU)),(y===1&&!this._caps.textureFloatLinearFiltering||y===2&&!this._caps.textureHalfFloatLinearFiltering)&&(v=1),y===1&&!this._caps.textureFloat&&(y=0,Qt.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));const ue=this._gl,fe=new a0(this,u),Re=a.width||a,_e=a.height||a,Be=a.layers||0,tt=this._getSamplingParameters(v,g),$e=Be!==0?ue.TEXTURE_2D_ARRAY:ue.TEXTURE_2D,Et=this._getRGBABufferInternalSizedFormat(y,w,B),ft=this._getInternalFormat(w),dt=this._getWebGLTextureType(y);return this._bindTextureDirectly($e,fe),Be!==0?(fe.is2DArray=!0,ue.texImage3D($e,0,Et,Re,_e,Be,0,ft,dt,null)):ue.texImage2D($e,0,Et,Re,_e,0,ft,dt,null),ue.texParameteri($e,ue.TEXTURE_MAG_FILTER,tt.mag),ue.texParameteri($e,ue.TEXTURE_MIN_FILTER,tt.min),ue.texParameteri($e,ue.TEXTURE_WRAP_S,ue.CLAMP_TO_EDGE),ue.texParameteri($e,ue.TEXTURE_WRAP_T,ue.CLAMP_TO_EDGE),g&&this._gl.generateMipmap($e),this._bindTextureDirectly($e,null),fe._useSRGBBuffer=B,fe.baseWidth=Re,fe.baseHeight=_e,fe.width=Re,fe.height=_e,fe.depth=Be,fe.isReady=!0,fe.samples=W,fe.generateMipMaps=g,fe.samplingMode=v,fe.type=y,fe.format=w,fe.label=ae,this._internalTexturesCache.push(fe),fe}_getUseSRGBBuffer(a,x){return a&&this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU||x)}_createTextureBase(a,x,c,u,g=3,y=null,v=null,w,B,W=null,ae=null,ue=null,fe=null,Re,_e,Be){a=a||"";const tt=a.substr(0,5)==="data:",$e=a.substr(0,5)==="blob:",Et=tt&&a.indexOf(";base64,")!==-1,ft=ae||new a0(this,hn.Url);ft!==ae&&(ft.label=a.substring(0,60));const dt=a;this._transformTextureUrl&&!Et&&!ae&&!W&&(a=this._transformTextureUrl(a)),dt!==a&&(ft._originalUrl=dt);const ut=a.lastIndexOf(".");let Mt=fe||(ut>-1?a.substring(ut).toLowerCase():""),ai=null;Mt.indexOf("?")>-1&&(Mt=Mt.split("?")[0]);for(const Rr of Es._TextureLoaders)if(Rr.canLoad(Mt,Re)){ai=Rr;break}u&&u.addPendingData(ft),ft.url=a,ft.generateMipMaps=!x,ft.samplingMode=g,ft.invertY=c,ft._useSRGBBuffer=this._getUseSRGBBuffer(!!Be,x),this._doNotHandleContextLost||(ft._buffer=W);let Vi=null;y&&!ae&&(Vi=ft.onLoadedObservable.add(y)),ae||this._internalTexturesCache.push(ft);const Js=(Rr,_r)=>{u&&u.removePendingData(ft),a===dt?(Vi&&ft.onLoadedObservable.remove(Vi),tr.UseFallbackTexture&&a!==tr.FallbackTexture&&this._createTextureBase(tr.FallbackTexture,x,ft.invertY,u,g,null,v,w,B,W,ft),Rr=(Rr||"Unknown error")+(tr.UseFallbackTexture?" - Fallback texture was used":""),ft.onErrorObservable.notifyObservers({message:Rr,exception:_r}),v&&v(Rr,_r)):(Qt.Warn(`Failed to load ${a}, falling back to ${dt}`),this._createTextureBase(dt,x,ft.invertY,u,g,y,v,w,B,W,ft,ue,fe,Re,_e,Be))};if(ai){const Rr=_r=>{ai.loadData(_r,ft,(Vr,Ja,ta,ja,k0,B0)=>{B0?Js("TextureLoader failed to load data"):w(ft,Mt,u,{width:Vr,height:Ja},ft.invertY,!ta,ja,()=>(k0(),!1),g)},_e)};W?W instanceof ArrayBuffer?Rr(new Uint8Array(W)):ArrayBuffer.isView(W)?Rr(W):v&&v("Unable to load: only ArrayBuffer or ArrayBufferView is supported",null):this._loadFile(a,_r=>Rr(new Uint8Array(_r)),void 0,u?u.offlineProvider:void 0,!0,(_r,Vr)=>{Js("Unable to load "+(_r&&_r.responseURL,Vr))})}else{const Rr=_r=>{$e&&!this._doNotHandleContextLost&&(ft._buffer=_r),w(ft,Mt,u,_r,ft.invertY,x,!1,B,g)};!tt||Et?W&&(typeof W.decoding=="string"||W.close)?Rr(W):Es._FileToolsLoadImage(a,Rr,Js,u?u.offlineProvider:null,Re,ft.invertY&&this._features.needsInvertingBitmap?{imageOrientation:"flipY"}:void 0):typeof W=="string"||W instanceof ArrayBuffer||ArrayBuffer.isView(W)||W instanceof Blob?Es._FileToolsLoadImage(W,Rr,Js,u?u.offlineProvider:null,Re,ft.invertY&&this._features.needsInvertingBitmap?{imageOrientation:"flipY"}:void 0):W&&Rr(W)}return ft}createTexture(a,x,c,u,g=3,y=null,v=null,w=null,B=null,W=null,ae=null,ue,fe,Re,_e){return this._createTextureBase(a,x,c,u,g,y,v,this._prepareWebGLTexture.bind(this),(Be,tt,$e,Et,ft,dt)=>{const ut=this._gl,Mt=$e.width===Be&&$e.height===tt;ft._creationFlags=Re??0;const ai=this._getTexImageParametersForCreateTexture(W,Et,ft._useSRGBBuffer);if(Mt)return ut.texImage2D(ut.TEXTURE_2D,0,ai.internalFormat,ai.format,ai.type,$e),!1;const Yi=this._caps.maxTextureSize;if($e.width>Yi||$e.height>Yi||!this._supportsHardwareTextureRescaling)return this._prepareWorkingCanvas(),!this._workingCanvas||!this._workingContext||(this._workingCanvas.width=Be,this._workingCanvas.height=tt,this._workingContext.drawImage($e,0,0,$e.width,$e.height,0,0,Be,tt),ut.texImage2D(ut.TEXTURE_2D,0,ai.internalFormat,ai.format,ai.type,this._workingCanvas),ft.width=Be,ft.height=tt),!1;{const Vi=new a0(this,hn.Temp);this._bindTextureDirectly(ut.TEXTURE_2D,Vi,!0),ut.texImage2D(ut.TEXTURE_2D,0,ai.internalFormat,ai.format,ai.type,$e),this._rescaleTexture(Vi,ft,u,ai.format,()=>{this._releaseTexture(Vi),this._bindTextureDirectly(ut.TEXTURE_2D,ft,!0),dt()})}return!0},w,B,W,ae,ue,fe,_e)}_getTexImageParametersForCreateTexture(a,x,c){a==null&&(a=x===".jpg"&&!c?4:5);let u,g;return this.webGLVersion===1?(u=this._getInternalFormat(a,c),g=u):(u=this._getInternalFormat(a,!1),g=this._getRGBABufferInternalSizedFormat(0,a,c)),{internalFormat:g,format:u,type:this._gl.UNSIGNED_BYTE}}static _FileToolsLoadImage(a,x,c,u,g,y){throw js("FileTools")}_rescaleTexture(a,x,c,u,g){}createRawTexture(a,x,c,u,g,y,v,w=null,B=0,W=0,ae=!1){throw js("Engine.RawTexture")}createRawCubeTexture(a,x,c,u,g,y,v,w=null){throw js("Engine.RawTexture")}createRawTexture3D(a,x,c,u,g,y,v,w,B=null,W=0){throw js("Engine.RawTexture")}createRawTexture2DArray(a,x,c,u,g,y,v,w,B=null,W=0){throw js("Engine.RawTexture")}_unpackFlipY(a){this._unpackFlipYCached!==a&&(this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL,a?1:0),this.enableUnpackFlipYCached&&(this._unpackFlipYCached=a))}_getUnpackAlignement(){return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT)}_getTextureTarget(a){return a.isCube?this._gl.TEXTURE_CUBE_MAP:a.is3D?this._gl.TEXTURE_3D:a.is2DArray||a.isMultiview?this._gl.TEXTURE_2D_ARRAY:this._gl.TEXTURE_2D}updateTextureSamplingMode(a,x,c=!1){const u=this._getTextureTarget(x),g=this._getSamplingParameters(a,x.useMipMaps||c);this._setTextureParameterInteger(u,this._gl.TEXTURE_MAG_FILTER,g.mag,x),this._setTextureParameterInteger(u,this._gl.TEXTURE_MIN_FILTER,g.min),c&&(x.generateMipMaps=!0,this._gl.generateMipmap(u)),this._bindTextureDirectly(u,null),x.samplingMode=a}updateTextureDimensions(a,x,c,u=1){}updateTextureWrappingMode(a,x,c=null,u=null){const g=this._getTextureTarget(a);x!==null&&(this._setTextureParameterInteger(g,this._gl.TEXTURE_WRAP_S,this._getTextureWrapMode(x),a),a._cachedWrapU=x),c!==null&&(this._setTextureParameterInteger(g,this._gl.TEXTURE_WRAP_T,this._getTextureWrapMode(c),a),a._cachedWrapV=c),(a.is2DArray||a.is3D)&&u!==null&&(this._setTextureParameterInteger(g,this._gl.TEXTURE_WRAP_R,this._getTextureWrapMode(u),a),a._cachedWrapR=u),this._bindTextureDirectly(g,null)}_setupDepthStencilTexture(a,x,c,u,g,y=1){const v=x.width||x,w=x.height||x,B=x.layers||0;a.baseWidth=v,a.baseHeight=w,a.width=v,a.height=w,a.is2DArray=B>0,a.depth=B,a.isReady=!0,a.samples=y,a.generateMipMaps=!1,a.samplingMode=u?2:1,a.type=0,a._comparisonFunction=g;const W=this._gl,ae=this._getTextureTarget(a),ue=this._getSamplingParameters(a.samplingMode,!1);W.texParameteri(ae,W.TEXTURE_MAG_FILTER,ue.mag),W.texParameteri(ae,W.TEXTURE_MIN_FILTER,ue.min),W.texParameteri(ae,W.TEXTURE_WRAP_S,W.CLAMP_TO_EDGE),W.texParameteri(ae,W.TEXTURE_WRAP_T,W.CLAMP_TO_EDGE),this.webGLVersion>1&&(g===0?(W.texParameteri(ae,W.TEXTURE_COMPARE_FUNC,515),W.texParameteri(ae,W.TEXTURE_COMPARE_MODE,W.NONE)):(W.texParameteri(ae,W.TEXTURE_COMPARE_FUNC,g),W.texParameteri(ae,W.TEXTURE_COMPARE_MODE,W.COMPARE_REF_TO_TEXTURE)))}_uploadCompressedDataToTextureDirectly(a,x,c,u,g,y=0,v=0){const w=this._gl;let B=w.TEXTURE_2D;if(a.isCube&&(B=w.TEXTURE_CUBE_MAP_POSITIVE_X+y),a._useSRGBBuffer)switch(x){case 37492:case 36196:this._caps.etc2?x=w.COMPRESSED_SRGB8_ETC2:a._useSRGBBuffer=!1;break;case 37496:this._caps.etc2?x=w.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a._useSRGBBuffer=!1;break;case 36492:x=w.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;break;case 37808:x=w.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;break;case 33776:this._caps.s3tc_srgb?x=w.COMPRESSED_SRGB_S3TC_DXT1_EXT:a._useSRGBBuffer=!1;break;case 33777:this._caps.s3tc_srgb?x=w.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:a._useSRGBBuffer=!1;break;case 33779:this._caps.s3tc_srgb?x=w.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:a._useSRGBBuffer=!1;break;default:a._useSRGBBuffer=!1;break}this._gl.compressedTexImage2D(B,v,x,c,u,0,g)}_uploadDataToTextureDirectly(a,x,c=0,u=0,g,y=!1){const v=this._gl,w=this._getWebGLTextureType(a.type),B=this._getInternalFormat(a.format),W=g===void 0?this._getRGBABufferInternalSizedFormat(a.type,a.format,a._useSRGBBuffer):this._getInternalFormat(g,a._useSRGBBuffer);this._unpackFlipY(a.invertY);let ae=v.TEXTURE_2D;a.isCube&&(ae=v.TEXTURE_CUBE_MAP_POSITIVE_X+c);const ue=Math.round(Math.log(a.width)*Math.LOG2E),fe=Math.round(Math.log(a.height)*Math.LOG2E),Re=y?a.width:Math.pow(2,Math.max(ue-u,0)),_e=y?a.height:Math.pow(2,Math.max(fe-u,0));v.texImage2D(ae,u,W,Re,_e,0,B,w,x)}updateTextureData(a,x,c,u,g,y,v=0,w=0,B=!1){const W=this._gl,ae=this._getWebGLTextureType(a.type),ue=this._getInternalFormat(a.format);this._unpackFlipY(a.invertY);let fe=W.TEXTURE_2D,Re=W.TEXTURE_2D;a.isCube&&(Re=W.TEXTURE_CUBE_MAP_POSITIVE_X+v,fe=W.TEXTURE_CUBE_MAP),this._bindTextureDirectly(fe,a,!0),W.texSubImage2D(Re,w,c,u,g,y,ue,ae,x),B&&this._gl.generateMipmap(Re),this._bindTextureDirectly(fe,null)}_uploadArrayBufferViewToTexture(a,x,c=0,u=0){const g=this._gl,y=a.isCube?g.TEXTURE_CUBE_MAP:g.TEXTURE_2D;this._bindTextureDirectly(y,a,!0),this._uploadDataToTextureDirectly(a,x,c,u),this._bindTextureDirectly(y,null,!0)}_prepareWebGLTextureContinuation(a,x,c,u,g){const y=this._gl;if(!y)return;const v=this._getSamplingParameters(g,!c);y.texParameteri(y.TEXTURE_2D,y.TEXTURE_MAG_FILTER,v.mag),y.texParameteri(y.TEXTURE_2D,y.TEXTURE_MIN_FILTER,v.min),!c&&!u&&y.generateMipmap(y.TEXTURE_2D),this._bindTextureDirectly(y.TEXTURE_2D,null),x&&x.removePendingData(a),a.onLoadedObservable.notifyObservers(a),a.onLoadedObservable.clear()}_prepareWebGLTexture(a,x,c,u,g,y,v,w,B=3){const W=this.getCaps().maxTextureSize,ae=Math.min(W,this.needPOTTextures?Es.GetExponentOfTwo(u.width,W):u.width),ue=Math.min(W,this.needPOTTextures?Es.GetExponentOfTwo(u.height,W):u.height),fe=this._gl;if(fe){if(!a._hardwareTexture){c&&c.removePendingData(a);return}this._bindTextureDirectly(fe.TEXTURE_2D,a,!0),this._unpackFlipY(g===void 0?!0:!!g),a.baseWidth=u.width,a.baseHeight=u.height,a.width=ae,a.height=ue,a.isReady=!0,a.type=a.type!==-1?a.type:0,a.format=a.format!==-1?a.format:x===".jpg"&&!a._useSRGBBuffer?4:5,!w(ae,ue,u,x,a,()=>{this._prepareWebGLTextureContinuation(a,c,y,v,B)})&&this._prepareWebGLTextureContinuation(a,c,y,v,B)}}_setupFramebufferDepthAttachments(a,x,c,u,g=1){const y=this._gl;if(a&&x)return this._createRenderBuffer(c,u,g,y.DEPTH_STENCIL,y.DEPTH24_STENCIL8,y.DEPTH_STENCIL_ATTACHMENT);if(x){let v=y.DEPTH_COMPONENT16;return this._webGLVersion>1&&(v=y.DEPTH_COMPONENT32F),this._createRenderBuffer(c,u,g,v,v,y.DEPTH_ATTACHMENT)}return a?this._createRenderBuffer(c,u,g,y.STENCIL_INDEX8,y.STENCIL_INDEX8,y.STENCIL_ATTACHMENT):null}_createRenderBuffer(a,x,c,u,g,y,v=!0){const B=this._gl.createRenderbuffer();return this._updateRenderBuffer(B,a,x,c,u,g,y,v)}_updateRenderBuffer(a,x,c,u,g,y,v,w=!0){const B=this._gl;return B.bindRenderbuffer(B.RENDERBUFFER,a),u>1&&B.renderbufferStorageMultisample?B.renderbufferStorageMultisample(B.RENDERBUFFER,u,y,x,c):B.renderbufferStorage(B.RENDERBUFFER,g,x,c),B.framebufferRenderbuffer(B.FRAMEBUFFER,v,B.RENDERBUFFER,a),w&&B.bindRenderbuffer(B.RENDERBUFFER,null),a}_releaseTexture(a){this._deleteTexture(a._hardwareTexture?.underlyingResource),this.unbindAllTextures();const x=this._internalTexturesCache.indexOf(a);x!==-1&&this._internalTexturesCache.splice(x,1),a._lodTextureHigh&&a._lodTextureHigh.dispose(),a._lodTextureMid&&a._lodTextureMid.dispose(),a._lodTextureLow&&a._lodTextureLow.dispose(),a._irradianceTexture&&a._irradianceTexture.dispose()}_releaseRenderTargetWrapper(a){const x=this._renderTargetWrapperCache.indexOf(a);x!==-1&&this._renderTargetWrapperCache.splice(x,1)}_deleteTexture(a){a&&this._gl.deleteTexture(a)}_setProgram(a){this._currentProgram!==a&&(this._gl.useProgram(a),this._currentProgram=a)}bindSamplers(a){const x=a.getPipelineContext();this._setProgram(x.program);const c=a.getSamplers();for(let u=0;u<c.length;u++){const g=a.getUniform(c[u]);g&&(this._boundUniforms[u]=g)}this._currentEffect=null}_activateCurrentTexture(){this._currentTextureChannel!==this._activeChannel&&(this._gl.activeTexture(this._gl.TEXTURE0+this._activeChannel),this._currentTextureChannel=this._activeChannel)}_bindTextureDirectly(a,x,c=!1,u=!1){let g=!1;const y=x&&x._associatedChannel>-1;if(c&&y&&(this._activeChannel=x._associatedChannel),this._boundTexturesCache[this._activeChannel]!==x||u){if(this._activateCurrentTexture(),x&&x.isMultiview)throw Qt.Error(["_bindTextureDirectly called with a multiview texture!",a,x]),"_bindTextureDirectly called with a multiview texture!";this._gl.bindTexture(a,x?._hardwareTexture?.underlyingResource??null),this._boundTexturesCache[this._activeChannel]=x,x&&(x._associatedChannel=this._activeChannel)}else c&&(g=!0,this._activateCurrentTexture());return y&&!c&&this._bindSamplerUniformToChannel(x._associatedChannel,this._activeChannel),g}_bindTexture(a,x,c){if(a===void 0)return;x&&(x._associatedChannel=a),this._activeChannel=a;const u=x?this._getTextureTarget(x):this._gl.TEXTURE_2D;this._bindTextureDirectly(u,x)}unbindAllTextures(){for(let a=0;a<this._maxSimultaneousTextures;a++)this._activeChannel=a,this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),this.webGLVersion>1&&(this._bindTextureDirectly(this._gl.TEXTURE_3D,null),this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY,null))}setTexture(a,x,c,u){a!==void 0&&(x&&(this._boundUniforms[a]=x),this._setTexture(a,c))}_bindSamplerUniformToChannel(a,x){const c=this._boundUniforms[a];!c||c._currentState===x||(this._gl.uniform1i(c,x),c._currentState=x)}_getTextureWrapMode(a){switch(a){case 1:return this._gl.REPEAT;case 0:return this._gl.CLAMP_TO_EDGE;case 2:return this._gl.MIRRORED_REPEAT}return this._gl.REPEAT}_setTexture(a,x,c=!1,u=!1,g=""){if(!x)return this._boundTexturesCache[a]!=null&&(this._activeChannel=a,this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),this.webGLVersion>1&&(this._bindTextureDirectly(this._gl.TEXTURE_3D,null),this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY,null))),!1;if(x.video){this._activeChannel=a;const B=x.getInternalTexture();B&&(B._associatedChannel=a),x.update()}else if(x.delayLoadState===4)return x.delayLoad(),!1;let y;u?y=x.depthStencilTexture:x.isReady()?y=x.getInternalTexture():x.isCube?y=this.emptyCubeTexture:x.is3D?y=this.emptyTexture3D:x.is2DArray?y=this.emptyTexture2DArray:y=this.emptyTexture,!c&&y&&(y._associatedChannel=a);let v=!0;this._boundTexturesCache[a]===y&&(c||this._bindSamplerUniformToChannel(y._associatedChannel,a),v=!1),this._activeChannel=a;const w=this._getTextureTarget(y);if(v&&this._bindTextureDirectly(w,y,c),y&&!y.isMultiview){if(y.isCube&&y._cachedCoordinatesMode!==x.coordinatesMode){y._cachedCoordinatesMode=x.coordinatesMode;const B=x.coordinatesMode!==3&&x.coordinatesMode!==5?1:0;x.wrapU=B,x.wrapV=B}y._cachedWrapU!==x.wrapU&&(y._cachedWrapU=x.wrapU,this._setTextureParameterInteger(w,this._gl.TEXTURE_WRAP_S,this._getTextureWrapMode(x.wrapU),y)),y._cachedWrapV!==x.wrapV&&(y._cachedWrapV=x.wrapV,this._setTextureParameterInteger(w,this._gl.TEXTURE_WRAP_T,this._getTextureWrapMode(x.wrapV),y)),y.is3D&&y._cachedWrapR!==x.wrapR&&(y._cachedWrapR=x.wrapR,this._setTextureParameterInteger(w,this._gl.TEXTURE_WRAP_R,this._getTextureWrapMode(x.wrapR),y)),this._setAnisotropicLevel(w,y,x.anisotropicFilteringLevel)}return!0}setTextureArray(a,x,c,u){if(!(a===void 0||!x)){(!this._textureUnits||this._textureUnits.length!==c.length)&&(this._textureUnits=new Int32Array(c.length));for(let g=0;g<c.length;g++){const y=c[g].getInternalTexture();y?(this._textureUnits[g]=a+g,y._associatedChannel=a+g):this._textureUnits[g]=-1}this._gl.uniform1iv(x,this._textureUnits);for(let g=0;g<c.length;g++)this._setTexture(this._textureUnits[g],c[g],!0)}}_setAnisotropicLevel(a,x,c){const u=this._caps.textureAnisotropicFilterExtension;x.samplingMode!==11&&x.samplingMode!==3&&x.samplingMode!==2&&(c=1),u&&x._cachedAnisotropicFilteringLevel!==c&&(this._setTextureParameterFloat(a,u.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(c,this._caps.maxAnisotropy),x),x._cachedAnisotropicFilteringLevel=c)}_setTextureParameterFloat(a,x,c,u){this._bindTextureDirectly(a,u,!0,!0),this._gl.texParameterf(a,x,c)}_setTextureParameterInteger(a,x,c,u){u&&this._bindTextureDirectly(a,u,!0,!0),this._gl.texParameteri(a,x,c)}unbindAllAttributes(){if(this._mustWipeVertexAttributes){this._mustWipeVertexAttributes=!1;for(let a=0;a<this._caps.maxVertexAttribs;a++)this.disableAttributeByIndex(a);return}for(let a=0,x=this._vertexAttribArraysEnabled.length;a<x;a++)a>=this._caps.maxVertexAttribs||!this._vertexAttribArraysEnabled[a]||this.disableAttributeByIndex(a)}releaseEffects(){for(const a in this._compiledEffects){const x=this._compiledEffects[a].getPipelineContext();this._deletePipelineContext(x)}this._compiledEffects={}}dispose(){this._isDisposed=!0,this.stopRenderLoop(),this.onBeforeTextureInitObservable&&this.onBeforeTextureInitObservable.clear(),this._emptyTexture&&(this._releaseTexture(this._emptyTexture),this._emptyTexture=null),this._emptyCubeTexture&&(this._releaseTexture(this._emptyCubeTexture),this._emptyCubeTexture=null),this._dummyFramebuffer&&this._gl.deleteFramebuffer(this._dummyFramebuffer),this.releaseEffects(),this.releaseComputeEffects?.(),this.unbindAllAttributes(),this._boundUniforms={},xa()&&this._renderingCanvas&&(this._doNotHandleContextLost||(this._renderingCanvas.removeEventListener("webglcontextlost",this._onContextLost),this._renderingCanvas.removeEventListener("webglcontextrestored",this._onContextRestored)),window.removeEventListener("resize",this._checkForMobile)),this._workingCanvas=null,this._workingContext=null,this._currentBufferPointers.length=0,this._renderingCanvas=null,this._currentProgram=null,this._boundRenderFunction=null,Yn.ResetCache();for(const a of this._activeRequests)a.abort();this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this._creationOptions.loseContextOnDispose&&this._gl.getExtension("WEBGL_lose_context")?.loseContext()}attachContextLostEvent(a){this._renderingCanvas&&this._renderingCanvas.addEventListener("webglcontextlost",a,!1)}attachContextRestoredEvent(a){this._renderingCanvas&&this._renderingCanvas.addEventListener("webglcontextrestored",a,!1)}getError(){return this._gl.getError()}_canRenderToFloatFramebuffer(){return this._webGLVersion>1?this._caps.colorBufferFloat:this._canRenderToFramebuffer(1)}_canRenderToHalfFloatFramebuffer(){return this._webGLVersion>1?this._caps.colorBufferFloat:this._canRenderToFramebuffer(2)}_canRenderToFramebuffer(a){const x=this._gl;for(;x.getError()!==x.NO_ERROR;);let c=!0;const u=x.createTexture();x.bindTexture(x.TEXTURE_2D,u),x.texImage2D(x.TEXTURE_2D,0,this._getRGBABufferInternalSizedFormat(a),1,1,0,x.RGBA,this._getWebGLTextureType(a),null),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_MIN_FILTER,x.NEAREST),x.texParameteri(x.TEXTURE_2D,x.TEXTURE_MAG_FILTER,x.NEAREST);const g=x.createFramebuffer();x.bindFramebuffer(x.FRAMEBUFFER,g),x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,u,0);const y=x.checkFramebufferStatus(x.FRAMEBUFFER);if(c=c&&y===x.FRAMEBUFFER_COMPLETE,c=c&&x.getError()===x.NO_ERROR,c&&(x.clear(x.COLOR_BUFFER_BIT),c=c&&x.getError()===x.NO_ERROR),c){x.bindFramebuffer(x.FRAMEBUFFER,null);const v=x.RGBA,w=x.UNSIGNED_BYTE,B=new Uint8Array(4);x.readPixels(0,0,1,1,v,w,B),c=c&&x.getError()===x.NO_ERROR}for(x.deleteTexture(u),x.deleteFramebuffer(g),x.bindFramebuffer(x.FRAMEBUFFER,null);!c&&x.getError()!==x.NO_ERROR;);return c}_getWebGLTextureType(a){if(this._webGLVersion===1){switch(a){case 1:return this._gl.FLOAT;case 2:return this._gl.HALF_FLOAT_OES;case 0:return this._gl.UNSIGNED_BYTE;case 8:return this._gl.UNSIGNED_SHORT_4_4_4_4;case 9:return this._gl.UNSIGNED_SHORT_5_5_5_1;case 10:return this._gl.UNSIGNED_SHORT_5_6_5}return this._gl.UNSIGNED_BYTE}switch(a){case 3:return this._gl.BYTE;case 0:return this._gl.UNSIGNED_BYTE;case 4:return this._gl.SHORT;case 5:return this._gl.UNSIGNED_SHORT;case 6:return this._gl.INT;case 7:return this._gl.UNSIGNED_INT;case 1:return this._gl.FLOAT;case 2:return this._gl.HALF_FLOAT;case 8:return this._gl.UNSIGNED_SHORT_4_4_4_4;case 9:return this._gl.UNSIGNED_SHORT_5_5_5_1;case 10:return this._gl.UNSIGNED_SHORT_5_6_5;case 11:return this._gl.UNSIGNED_INT_2_10_10_10_REV;case 12:return this._gl.UNSIGNED_INT_24_8;case 13:return this._gl.UNSIGNED_INT_10F_11F_11F_REV;case 14:return this._gl.UNSIGNED_INT_5_9_9_9_REV;case 15:return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV}return this._gl.UNSIGNED_BYTE}_getInternalFormat(a,x=!1){let c=x?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA;switch(a){case 0:c=this._gl.ALPHA;break;case 1:c=this._gl.LUMINANCE;break;case 2:c=this._gl.LUMINANCE_ALPHA;break;case 6:c=this._gl.RED;break;case 7:c=this._gl.RG;break;case 4:c=x?this._glSRGBExtensionValues.SRGB:this._gl.RGB;break;case 5:c=x?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA;break}if(this._webGLVersion>1)switch(a){case 8:c=this._gl.RED_INTEGER;break;case 9:c=this._gl.RG_INTEGER;break;case 10:c=this._gl.RGB_INTEGER;break;case 11:c=this._gl.RGBA_INTEGER;break}return c}_getRGBABufferInternalSizedFormat(a,x,c=!1){if(this._webGLVersion===1){if(x!==void 0)switch(x){case 0:return this._gl.ALPHA;case 1:return this._gl.LUMINANCE;case 2:return this._gl.LUMINANCE_ALPHA;case 4:return c?this._glSRGBExtensionValues.SRGB:this._gl.RGB}return this._gl.RGBA}switch(a){case 3:switch(x){case 6:return this._gl.R8_SNORM;case 7:return this._gl.RG8_SNORM;case 4:return this._gl.RGB8_SNORM;case 8:return this._gl.R8I;case 9:return this._gl.RG8I;case 10:return this._gl.RGB8I;case 11:return this._gl.RGBA8I;default:return this._gl.RGBA8_SNORM}case 0:switch(x){case 6:return this._gl.R8;case 7:return this._gl.RG8;case 4:return c?this._glSRGBExtensionValues.SRGB8:this._gl.RGB8;case 5:return c?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA8;case 8:return this._gl.R8UI;case 9:return this._gl.RG8UI;case 10:return this._gl.RGB8UI;case 11:return this._gl.RGBA8UI;case 0:return this._gl.ALPHA;case 1:return this._gl.LUMINANCE;case 2:return this._gl.LUMINANCE_ALPHA;default:return this._gl.RGBA8}case 4:switch(x){case 8:return this._gl.R16I;case 9:return this._gl.RG16I;case 10:return this._gl.RGB16I;case 11:return this._gl.RGBA16I;default:return this._gl.RGBA16I}case 5:switch(x){case 8:return this._gl.R16UI;case 9:return this._gl.RG16UI;case 10:return this._gl.RGB16UI;case 11:return this._gl.RGBA16UI;default:return this._gl.RGBA16UI}case 6:switch(x){case 8:return this._gl.R32I;case 9:return this._gl.RG32I;case 10:return this._gl.RGB32I;case 11:return this._gl.RGBA32I;default:return this._gl.RGBA32I}case 7:switch(x){case 8:return this._gl.R32UI;case 9:return this._gl.RG32UI;case 10:return this._gl.RGB32UI;case 11:return this._gl.RGBA32UI;default:return this._gl.RGBA32UI}case 1:switch(x){case 6:return this._gl.R32F;case 7:return this._gl.RG32F;case 4:return this._gl.RGB32F;case 5:return this._gl.RGBA32F;default:return this._gl.RGBA32F}case 2:switch(x){case 6:return this._gl.R16F;case 7:return this._gl.RG16F;case 4:return this._gl.RGB16F;case 5:return this._gl.RGBA16F;default:return this._gl.RGBA16F}case 10:return this._gl.RGB565;case 13:return this._gl.R11F_G11F_B10F;case 14:return this._gl.RGB9_E5;case 8:return this._gl.RGBA4;case 9:return this._gl.RGB5_A1;case 11:switch(x){case 5:return this._gl.RGB10_A2;case 11:return this._gl.RGB10_A2UI;default:return this._gl.RGB10_A2}}return c?this._glSRGBExtensionValues.SRGB8_ALPHA8:this._gl.RGBA8}_loadFile(a,x,c,u,g,y){const v=Es._FileToolsLoadFile(a,x,c,u,g,y);return this._activeRequests.push(v),v.onCompleteObservable.add(w=>{this._activeRequests.splice(this._activeRequests.indexOf(w),1)}),v}static _FileToolsLoadFile(a,x,c,u,g,y){throw js("FileTools")}readPixels(a,x,c,u,g=!0,y=!0){const v=g?4:3,w=g?this._gl.RGBA:this._gl.RGB,B=new Uint8Array(u*c*v);return y&&this.flushFramebuffer(),this._gl.readPixels(a,x,c,u,w,this._gl.UNSIGNED_BYTE,B),Promise.resolve(B)}static get IsSupportedAsync(){return Promise.resolve(this.isSupported())}static get IsSupported(){return this.isSupported()}static isSupported(){if(this._HasMajorPerformanceCaveat!==null)return!this._HasMajorPerformanceCaveat;if(this._IsSupported===null)try{const a=this._CreateCanvas(1,1),x=a.getContext("webgl")||a.getContext("experimental-webgl");this._IsSupported=x!=null&&!!window.WebGLRenderingContext}catch{this._IsSupported=!1}return this._IsSupported}static get HasMajorPerformanceCaveat(){if(this._HasMajorPerformanceCaveat===null)try{const a=this._CreateCanvas(1,1),x=a.getContext("webgl",{failIfMajorPerformanceCaveat:!0})||a.getContext("experimental-webgl",{failIfMajorPerformanceCaveat:!0});this._HasMajorPerformanceCaveat=!x}catch{this._HasMajorPerformanceCaveat=!1}return this._HasMajorPerformanceCaveat}static CeilingPOT(a){return a--,a|=a>>1,a|=a>>2,a|=a>>4,a|=a>>8,a|=a>>16,a++,a}static FloorPOT(a){return a=a|a>>1,a=a|a>>2,a=a|a>>4,a=a|a>>8,a=a|a>>16,a-(a>>1)}static NearestPOT(a){const x=Es.CeilingPOT(a),c=Es.FloorPOT(a);return x-a>a-c?c:x}static GetExponentOfTwo(a,x,c=2){let u;switch(c){case 1:u=Es.FloorPOT(a);break;case 2:u=Es.NearestPOT(a);break;case 3:default:u=Es.CeilingPOT(a);break}return Math.min(u,x)}static QueueNewFrame(a,x){if(xa()){const{requestAnimationFrame:c}=x||window;if(typeof c=="function")return c(a)}else if(typeof requestAnimationFrame=="function")return requestAnimationFrame(a);return setTimeout(a,16)}getHostDocument(){return this._renderingCanvas&&this._renderingCanvas.ownerDocument?this._renderingCanvas.ownerDocument:ux()?document:null}}Es._TempClearColorUint32=new Uint32Array(4),Es._TempClearColorInt32=new Int32Array(4),Es.ExceptionList=[{key:"Chrome/63.0",capture:"63\\.0\\.3239\\.(\\d+)",captureConstraint:108,targets:["uniformBuffer"]},{key:"Firefox/58",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Firefox/59",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Chrome/72.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Chrome/73.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Chrome/74.+?Mobile",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome/71",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome/72",capture:null,captureConstraint:null,targets:["vao"]},{key:"Mac OS.+Chrome",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:"Chrome/12\\d\\..+?Mobile",capture:null,captureConstraint:null,targets:["uniformBuffer"]},{key:".*AppleWebKit.*(15.4).*Safari",capture:null,captureConstraint:null,targets:["antialias","maxMSAASamples"]},{key:".*(15.4).*AppleWebKit.*Safari",capture:null,captureConstraint:null,targets:["antialias","maxMSAASamples"]}],Es._TextureLoaders=[],Es.CollisionsEpsilon=.001,Es._IsSupported=null,Es._HasMajorPerformanceCaveat=null;class vh{constructor(a=30){this._enabled=!0,this._rollingFrameTime=new t2(a)}sampleFrame(a=Wo.Now){if(this._enabled){if(this._lastFrameTimeMs!=null){const x=a-this._lastFrameTimeMs;this._rollingFrameTime.add(x)}this._lastFrameTimeMs=a}}get averageFrameTime(){return this._rollingFrameTime.average}get averageFrameTimeVariance(){return this._rollingFrameTime.variance}get instantaneousFrameTime(){return this._rollingFrameTime.history(0)}get averageFPS(){return 1e3/this._rollingFrameTime.average}get instantaneousFPS(){const a=this._rollingFrameTime.history(0);return a===0?0:1e3/a}get isSaturated(){return this._rollingFrameTime.isSaturated()}enable(){this._enabled=!0}disable(){this._enabled=!1,this._lastFrameTimeMs=null}get isEnabled(){return this._enabled}reset(){this._lastFrameTimeMs=null,this._rollingFrameTime.reset()}}class t2{constructor(a){this._samples=new Array(a),this.reset()}add(a){let x;if(this.isSaturated()){const c=this._samples[this._pos];x=c-this.average,this.average-=x/(this._sampleCount-1),this._m2-=x*(c-this.average)}else this._sampleCount++;x=a-this.average,this.average+=x/this._sampleCount,this._m2+=x*(a-this.average),this.variance=this._m2/(this._sampleCount-1),this._samples[this._pos]=a,this._pos++,this._pos%=this._samples.length}history(a){if(a>=this._sampleCount||a>=this._samples.length)return 0;const x=this._wrapPosition(this._pos-1);return this._samples[this._wrapPosition(x-a)]}isSaturated(){return this._sampleCount>=this._samples.length}reset(){this.average=0,this.variance=0,this._sampleCount=0,this._pos=0,this._m2=0}_wrapPosition(a){const x=this._samples.length;return(a%x+x)%x}}class l0{get min(){return this._min}get max(){return this._max}get average(){return this._average}get lastSecAverage(){return this._lastSecAverage}get current(){return this._current}get total(){return this._totalAccumulated}get count(){return this._totalValueCount}constructor(){this._startMonitoringTime=0,this._min=0,this._max=0,this._average=0,this._lastSecAverage=0,this._current=0,this._totalValueCount=0,this._totalAccumulated=0,this._lastSecAccumulated=0,this._lastSecTime=0,this._lastSecValueCount=0}fetchNewFrame(){this._totalValueCount++,this._current=0,this._lastSecValueCount++}addCount(a,x){l0.Enabled&&(this._current+=a,x&&this._fetchResult())}beginMonitoring(){l0.Enabled&&(this._startMonitoringTime=Wo.Now)}endMonitoring(a=!0){if(!l0.Enabled)return;a&&this.fetchNewFrame();const x=Wo.Now;this._current=x-this._startMonitoringTime,a&&this._fetchResult()}endFrame(){this._fetchResult()}_fetchResult(){this._totalAccumulated+=this._current,this._lastSecAccumulated+=this._current,this._min=Math.min(this._min,this._current),this._max=Math.max(this._max,this._current),this._average=this._totalAccumulated/this._totalValueCount;const a=Wo.Now;a-this._lastSecTime>1e3&&(this._lastSecAverage=this._lastSecAccumulated/this._lastSecValueCount,this._lastSecTime=a,this._lastSecAccumulated=0,this._lastSecValueCount=0)}}l0.Enabled=!0,Es.prototype.setAlphaConstants=function(F,a,x,c){this._alphaState.setAlphaBlendConstants(F,a,x,c)},Es.prototype.setAlphaMode=function(F,a=!1){if(this._alphaMode===F){if(!a){const x=F===0;this.depthCullingState.depthMask!==x&&(this.depthCullingState.depthMask=x)}return}switch(F){case 0:this._alphaState.alphaBlend=!1;break;case 7:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 8:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 2:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 6:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE,this._gl.ZERO,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 1:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE,this._gl.ZERO,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 3:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 4:this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR,this._gl.ZERO,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 5:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 9:this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR,this._gl.ONE_MINUS_CONSTANT_COLOR,this._gl.CONSTANT_ALPHA,this._gl.ONE_MINUS_CONSTANT_ALPHA),this._alphaState.alphaBlend=!0;break;case 10:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 11:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE,this._gl.ONE,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 12:this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA,this._gl.ONE,this._gl.ZERO,this._gl.ZERO),this._alphaState.alphaBlend=!0;break;case 13:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ONE_MINUS_DST_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 14:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break;case 15:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE,this._gl.ONE,this._gl.ONE,this._gl.ZERO),this._alphaState.alphaBlend=!0;break;case 16:this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR,this._gl.ONE_MINUS_SRC_COLOR,this._gl.ZERO,this._gl.ONE),this._alphaState.alphaBlend=!0;break;case 17:this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA,this._gl.ONE_MINUS_SRC_ALPHA,this._gl.ONE,this._gl.ONE_MINUS_SRC_ALPHA),this._alphaState.alphaBlend=!0;break}a||(this.depthCullingState.depthMask=F===0),this._alphaMode=F},Es.prototype.getAlphaMode=function(){return this._alphaMode},Es.prototype.setAlphaEquation=function(F){if(this._alphaEquation!==F){switch(F){case 0:this._alphaState.setAlphaEquationParameters(32774,32774);break;case 1:this._alphaState.setAlphaEquationParameters(32778,32778);break;case 2:this._alphaState.setAlphaEquationParameters(32779,32779);break;case 3:this._alphaState.setAlphaEquationParameters(32776,32776);break;case 4:this._alphaState.setAlphaEquationParameters(32775,32775);break;case 5:this._alphaState.setAlphaEquationParameters(32775,32774);break}this._alphaEquation=F}},Es.prototype.getAlphaEquation=function(){return this._alphaEquation};function a2(F,a,x=!1,c){switch(F){case 3:{const g=a instanceof ArrayBuffer?new Int8Array(a):new Int8Array(a);return c&&g.set(new Int8Array(c)),g}case 0:{const g=a instanceof ArrayBuffer?new Uint8Array(a):new Uint8Array(a);return c&&g.set(new Uint8Array(c)),g}case 4:{const g=a instanceof ArrayBuffer?new Int16Array(a):new Int16Array(x?a/2:a);return c&&g.set(new Int16Array(c)),g}case 5:case 8:case 9:case 10:case 2:{const g=a instanceof ArrayBuffer?new Uint16Array(a):new Uint16Array(x?a/2:a);return c&&g.set(new Uint16Array(c)),g}case 6:{const g=a instanceof ArrayBuffer?new Int32Array(a):new Int32Array(x?a/4:a);return c&&g.set(new Int32Array(c)),g}case 7:case 11:case 12:case 13:case 14:case 15:{const g=a instanceof ArrayBuffer?new Uint32Array(a):new Uint32Array(x?a/4:a);return c&&g.set(new Uint32Array(c)),g}case 1:{const g=a instanceof ArrayBuffer?new Float32Array(a):new Float32Array(x?a/4:a);return c&&g.set(new Float32Array(c)),g}}const u=a instanceof ArrayBuffer?new Uint8Array(a):new Uint8Array(a);return c&&u.set(new Uint8Array(c)),u}Es.prototype._readTexturePixelsSync=function(F,a,x,c=-1,u=0,g=null,y=!0,v=!1,w=0,B=0){const W=this._gl;if(!W)throw new Error("Engine does not have gl rendering context.");if(!this._dummyFramebuffer){const ue=W.createFramebuffer();if(!ue)throw new Error("Unable to create dummy framebuffer");this._dummyFramebuffer=ue}W.bindFramebuffer(W.FRAMEBUFFER,this._dummyFramebuffer),c>-1?W.framebufferTexture2D(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_CUBE_MAP_POSITIVE_X+c,F._hardwareTexture?.underlyingResource,u):W.framebufferTexture2D(W.FRAMEBUFFER,W.COLOR_ATTACHMENT0,W.TEXTURE_2D,F._hardwareTexture?.underlyingResource,u);let ae=F.type!==void 0?this._getWebGLTextureType(F.type):W.UNSIGNED_BYTE;if(v)g||(g=a2(F.type,4*a*x));else switch(ae){case W.UNSIGNED_BYTE:g||(g=new Uint8Array(4*a*x)),ae=W.UNSIGNED_BYTE;break;default:g||(g=new Float32Array(4*a*x)),ae=W.FLOAT;break}return y&&this.flushFramebuffer(),W.readPixels(w,B,a,x,W.RGBA,ae,g),W.bindFramebuffer(W.FRAMEBUFFER,this._currentFramebuffer),g},Es.prototype._readTexturePixels=function(F,a,x,c=-1,u=0,g=null,y=!0,v=!1,w=0,B=0){return Promise.resolve(this._readTexturePixelsSync(F,a,x,c,u,g,y,v,w,B))},Es.prototype.updateDynamicIndexBuffer=function(F,a,x=0){this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER]=null,this.bindIndexBuffer(F);let c;F.is32Bits?c=a instanceof Uint32Array?a:new Uint32Array(a):c=a instanceof Uint16Array?a:new Uint16Array(a),this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER,c,this._gl.DYNAMIC_DRAW),this._resetIndexBufferBinding()},Es.prototype.updateDynamicVertexBuffer=function(F,a,x,c){this.bindArrayBuffer(F),x===void 0&&(x=0);const u=a.byteLength||a.length;c===void 0||c>=u&&x===0?a instanceof Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,x,new Float32Array(a)):this._gl.bufferSubData(this._gl.ARRAY_BUFFER,x,a):a instanceof Array?this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,new Float32Array(a).subarray(x,x+c)):(a instanceof ArrayBuffer?a=new Uint8Array(a,x,c):a=new Uint8Array(a.buffer,a.byteOffset+x,c),this._gl.bufferSubData(this._gl.ARRAY_BUFFER,0,a)),this._resetVertexBufferBinding()};class Bt extends Es{static get NpmPackage(){return Es.NpmPackage}static get Version(){return Es.Version}static get Instances(){return tr.Instances}static get LastCreatedEngine(){return tr.LastCreatedEngine}static get LastCreatedScene(){return tr.LastCreatedScene}_createImageBitmapFromSource(a,x){return new Promise((u,g)=>{const y=new Image;y.onload=()=>{y.decode().then(()=>{this.createImageBitmap(y,x).then(v=>{u(v)})})},y.onerror=()=>{g(`Error loading image ${y.src}`)},y.src=a})}createImageBitmap(a,x){return createImageBitmap(a,x)}resizeImageBitmap(a,x,c){const g=this.createCanvas(x,c).getContext("2d");if(!g)throw new Error("Unable to get 2d context for resizeImageBitmap");return g.drawImage(a,0,0),g.getImageData(0,0,x,c).data}static MarkAllMaterialsAsDirty(a,x){for(let c=0;c<Bt.Instances.length;c++){const u=Bt.Instances[c];for(let g=0;g<u.scenes.length;g++)u.scenes[g].markAllMaterialsAsDirty(a,x)}}static DefaultLoadingScreenFactory(a){throw js("LoadingScreen")}get _supportsHardwareTextureRescaling(){return!!Bt._RescalePostProcessFactory}get performanceMonitor(){return this._performanceMonitor}get compatibilityMode(){return this._compatibilityMode}set compatibilityMode(a){this._compatibilityMode=!0}getInputElement(){return this._renderingCanvas}constructor(a,x,c,u=!1){if(super(a,x,c,u),this.enableOfflineSupport=!1,this.disableManifestCheck=!1,this.disableContextMenu=!0,this.scenes=[],this._virtualScenes=new Array,this.onNewSceneAddedObservable=new Jt,this.postProcesses=[],this.isPointerLock=!1,this.onResizeObservable=new Jt,this.onCanvasBlurObservable=new Jt,this.onCanvasFocusObservable=new Jt,this.onCanvasPointerOutObservable=new Jt,this.onBeginFrameObservable=new Jt,this.customAnimationFrameRequester=null,this.onEndFrameObservable=new Jt,this.onBeforeShaderCompilationObservable=new Jt,this.onAfterShaderCompilationObservable=new Jt,this._deterministicLockstep=!1,this._lockstepMaxSteps=4,this._timeStep=1/60,this._fps=60,this._deltaTime=0,this._drawCalls=new l0,this.canvasTabIndex=1,this.disablePerformanceMonitorInBackground=!1,this._performanceMonitor=new vh,this._compatibilityMode=!0,this.currentRenderPassId=0,this._renderPassNames=["main"],Bt.Instances.push(this),!!a&&(this._features.supportRenderPasses=!0,c=this._creationOptions,a.getContext)){const g=a;this._sharedInit(g)}}_initGLContext(){super._initGLContext(),this._rescalePostProcess=null}_sharedInit(a){super._sharedInit(a),this._onCanvasFocus=()=>{this.onCanvasFocusObservable.notifyObservers(this)},this._onCanvasBlur=()=>{this.onCanvasBlurObservable.notifyObservers(this)},this._onCanvasContextMenu=c=>{this.disableContextMenu&&c.preventDefault()},a.addEventListener("focus",this._onCanvasFocus),a.addEventListener("blur",this._onCanvasBlur),a.addEventListener("contextmenu",this._onCanvasContextMenu),this._onBlur=()=>{this.disablePerformanceMonitorInBackground&&this._performanceMonitor.disable(),this._windowIsBackground=!0},this._onFocus=()=>{this.disablePerformanceMonitorInBackground&&this._performanceMonitor.enable(),this._windowIsBackground=!1},this._onCanvasPointerOut=c=>{document.elementFromPoint(c.clientX,c.clientY)!==a&&this.onCanvasPointerOutObservable.notifyObservers(c)};const x=this.getHostWindow();x&&typeof x.addEventListener=="function"&&(x.addEventListener("blur",this._onBlur),x.addEventListener("focus",this._onFocus)),a.addEventListener("pointerout",this._onCanvasPointerOut),this._creationOptions.doNotHandleTouchAction||this._disableTouchAction(),!Bt.audioEngine&&this._creationOptions.audioEngine&&Bt.AudioEngineFactory&&(Bt.audioEngine=Bt.AudioEngineFactory(this.getRenderingCanvas(),this.getAudioContext(),this.getAudioDestination())),ux()&&(this._onFullscreenChange=()=>{this.isFullscreen=!!document.fullscreenElement,this.isFullscreen&&this._pointerLockRequested&&a&&Bt._RequestPointerlock(a)},document.addEventListener("fullscreenchange",this._onFullscreenChange,!1),document.addEventListener("webkitfullscreenchange",this._onFullscreenChange,!1),this._onPointerLockChange=()=>{this.isPointerLock=document.pointerLockElement===a},document.addEventListener("pointerlockchange",this._onPointerLockChange,!1),document.addEventListener("webkitpointerlockchange",this._onPointerLockChange,!1)),this.enableOfflineSupport=Bt.OfflineProviderFactory!==void 0,this._deterministicLockstep=!!this._creationOptions.deterministicLockstep,this._lockstepMaxSteps=this._creationOptions.lockstepMaxSteps||0,this._timeStep=this._creationOptions.timeStep||1/60}_verifyPointerLock(){this._onPointerLockChange?.()}getAspectRatio(a,x=!1){const c=a.viewport;return this.getRenderWidth(x)*c.width/(this.getRenderHeight(x)*c.height)}getScreenAspectRatio(){return this.getRenderWidth(!0)/this.getRenderHeight(!0)}getRenderingCanvasClientRect(){return this._renderingCanvas?this._renderingCanvas.getBoundingClientRect():null}getInputElementClientRect(){return this._renderingCanvas?this.getInputElement().getBoundingClientRect():null}isDeterministicLockStep(){return this._deterministicLockstep}getLockstepMaxSteps(){return this._lockstepMaxSteps}getTimeStep(){return this._timeStep*1e3}generateMipMapsForCubemap(a,x=!0){if(a.generateMipMaps){const c=this._gl;this._bindTextureDirectly(c.TEXTURE_CUBE_MAP,a,!0),c.generateMipmap(c.TEXTURE_CUBE_MAP),x&&this._bindTextureDirectly(c.TEXTURE_CUBE_MAP,null)}}getDepthWrite(){return this._depthCullingState.depthMask}setDepthWrite(a){this._depthCullingState.depthMask=a}getStencilBuffer(){return this._stencilState.stencilTest}setStencilBuffer(a){this._stencilState.stencilTest=a}getStencilMask(){return this._stencilState.stencilMask}setStencilMask(a){this._stencilState.stencilMask=a}getStencilFunction(){return this._stencilState.stencilFunc}getStencilFunctionReference(){return this._stencilState.stencilFuncRef}getStencilFunctionMask(){return this._stencilState.stencilFuncMask}setStencilFunction(a){this._stencilState.stencilFunc=a}setStencilFunctionReference(a){this._stencilState.stencilFuncRef=a}setStencilFunctionMask(a){this._stencilState.stencilFuncMask=a}getStencilOperationFail(){return this._stencilState.stencilOpStencilFail}getStencilOperationDepthFail(){return this._stencilState.stencilOpDepthFail}getStencilOperationPass(){return this._stencilState.stencilOpStencilDepthPass}setStencilOperationFail(a){this._stencilState.stencilOpStencilFail=a}setStencilOperationDepthFail(a){this._stencilState.stencilOpDepthFail=a}setStencilOperationPass(a){this._stencilState.stencilOpStencilDepthPass=a}setDitheringState(a){a?this._gl.enable(this._gl.DITHER):this._gl.disable(this._gl.DITHER)}setRasterizerState(a){a?this._gl.disable(this._gl.RASTERIZER_DISCARD):this._gl.enable(this._gl.RASTERIZER_DISCARD)}getDepthFunction(){return this._depthCullingState.depthFunc}setDepthFunction(a){this._depthCullingState.depthFunc=a}setDepthFunctionToGreater(){this.setDepthFunction(516)}setDepthFunctionToGreaterOrEqual(){this.setDepthFunction(518)}setDepthFunctionToLess(){this.setDepthFunction(513)}setDepthFunctionToLessOrEqual(){this.setDepthFunction(515)}cacheStencilState(){this._cachedStencilBuffer=this.getStencilBuffer(),this._cachedStencilFunction=this.getStencilFunction(),this._cachedStencilMask=this.getStencilMask(),this._cachedStencilOperationPass=this.getStencilOperationPass(),this._cachedStencilOperationFail=this.getStencilOperationFail(),this._cachedStencilOperationDepthFail=this.getStencilOperationDepthFail(),this._cachedStencilReference=this.getStencilFunctionReference()}restoreStencilState(){this.setStencilFunction(this._cachedStencilFunction),this.setStencilMask(this._cachedStencilMask),this.setStencilBuffer(this._cachedStencilBuffer),this.setStencilOperationPass(this._cachedStencilOperationPass),this.setStencilOperationFail(this._cachedStencilOperationFail),this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail),this.setStencilFunctionReference(this._cachedStencilReference)}setDirectViewport(a,x,c,u){const g=this._cachedViewport;return this._cachedViewport=null,this._viewport(a,x,c,u),g}scissorClear(a,x,c,u,g){this.enableScissor(a,x,c,u),this.clear(g,!0,!0,!0),this.disableScissor()}enableScissor(a,x,c,u){const g=this._gl;g.enable(g.SCISSOR_TEST),g.scissor(a,x,c,u)}disableScissor(){const a=this._gl;a.disable(a.SCISSOR_TEST)}_reportDrawCall(a=1){this._drawCalls.addCount(a,!1)}_loadFileAsync(a,x,c){return new Promise((u,g)=>{this._loadFile(a,y=>{u(y)},void 0,x,c,(y,v)=>{g(v)})})}getVertexShaderSource(a){const x=this._gl.getAttachedShaders(a);return x?this._gl.getShaderSource(x[0]):null}getFragmentShaderSource(a){const x=this._gl.getAttachedShaders(a);return x?this._gl.getShaderSource(x[1]):null}setDepthStencilTexture(a,x,c,u){a!==void 0&&(x&&(this._boundUniforms[a]=x),!c||!c.depthStencilTexture?this._setTexture(a,null,void 0,void 0,u):this._setTexture(a,c,!1,!0,u))}setTextureFromPostProcess(a,x,c){let u=null;x&&(x._forcedOutputTexture?u=x._forcedOutputTexture:x._textures.data[x._currentRenderTextureInd]&&(u=x._textures.data[x._currentRenderTextureInd])),this._bindTexture(a,u?.texture??null,c)}setTextureFromPostProcessOutput(a,x,c){this._bindTexture(a,x?._outputTexture?.texture??null,c)}set framebufferDimensionsObject(a){this._framebufferDimensionsObject=a,this._framebufferDimensionsObject&&this.onResizeObservable.notifyObservers(this)}_rebuildBuffers(){for(const a of this.scenes)a.resetCachedMaterial(),a._rebuildGeometries();for(const a of this._virtualScenes)a.resetCachedMaterial(),a._rebuildGeometries();super._rebuildBuffers()}_rebuildTextures(){for(const a of this.scenes)a._rebuildTextures();for(const a of this._virtualScenes)a._rebuildTextures();super._rebuildTextures()}_renderFrame(){for(let a=0;a<this._activeRenderLoops.length;a++){const x=this._activeRenderLoops[a];x()}}_cancelFrame(){if(this.customAnimationFrameRequester){if(this._frameHandler!==0){this._frameHandler=0;const{cancelAnimationFrame:a}=this.customAnimationFrameRequester;a&&a(this.customAnimationFrameRequester.requestID)}}else super._cancelFrame()}_renderLoop(){if(this._frameHandler=0,!this._contextWasLost){let a=!0;(this.isDisposed||!this.renderEvenInBackground&&this._windowIsBackground)&&(a=!1),a&&(this.beginFrame(),this._renderViews()||this._renderFrame(),this.endFrame())}this._frameHandler===0&&(this.customAnimationFrameRequester?(this.customAnimationFrameRequester.requestID=this._queueNewFrame(this.customAnimationFrameRequester.renderFunction||this._boundRenderFunction,this.customAnimationFrameRequester),this._frameHandler=this.customAnimationFrameRequester.requestID):this._frameHandler=this._queueNewFrame(this._boundRenderFunction,this.getHostWindow()))}_renderViews(){return!1}switchFullscreen(a){this.isFullscreen?this.exitFullscreen():this.enterFullscreen(a)}enterFullscreen(a){this.isFullscreen||(this._pointerLockRequested=a,this._renderingCanvas&&Bt._RequestFullscreen(this._renderingCanvas))}exitFullscreen(){this.isFullscreen&&Bt._ExitFullscreen()}enterPointerlock(){this._renderingCanvas&&Bt._RequestPointerlock(this._renderingCanvas)}exitPointerlock(){Bt._ExitPointerlock()}beginFrame(){this._measureFps(),this.onBeginFrameObservable.notifyObservers(this),super.beginFrame()}endFrame(){super.endFrame(),this.onEndFrameObservable.notifyObservers(this)}setSize(a,x,c=!1){if(!this._renderingCanvas||!super.setSize(a,x,c))return!1;if(this.scenes){for(let u=0;u<this.scenes.length;u++){const g=this.scenes[u];for(let y=0;y<g.cameras.length;y++){const v=g.cameras[y];v._currentRenderId=0}}this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this)}return!0}_deletePipelineContext(a){const x=a;x&&x.program&&x.transformFeedback&&(this.deleteTransformFeedback(x.transformFeedback),x.transformFeedback=null),super._deletePipelineContext(a)}createShaderProgram(a,x,c,u,g,y=null){g=g||this._gl,this.onBeforeShaderCompilationObservable.notifyObservers(this);const v=super.createShaderProgram(a,x,c,u,g,y);return this.onAfterShaderCompilationObservable.notifyObservers(this),v}_createShaderProgram(a,x,c,u,g=null){const y=u.createProgram();if(a.program=y,!y)throw new Error("Unable to create program");if(u.attachShader(y,x),u.attachShader(y,c),this.webGLVersion>1&&g){const v=this.createTransformFeedback();this.bindTransformFeedback(v),this.setTranformFeedbackVaryings(y,g),a.transformFeedback=v}return u.linkProgram(y),this.webGLVersion>1&&g&&this.bindTransformFeedback(null),a.context=u,a.vertexShader=x,a.fragmentShader=c,a.isParallelCompiled||this._finalizePipelineContext(a),y}_releaseTexture(a){super._releaseTexture(a)}_releaseRenderTargetWrapper(a){super._releaseRenderTargetWrapper(a),this.scenes.forEach(x=>{x.postProcesses.forEach(c=>{c._outputTexture===a&&(c._outputTexture=null)}),x.cameras.forEach(c=>{c._postProcesses.forEach(u=>{u&&u._outputTexture===a&&(u._outputTexture=null)})})})}getRenderPassNames(){return this._renderPassNames}getCurrentRenderPassName(){return this._renderPassNames[this.currentRenderPassId]}createRenderPassId(a){const x=++Bt._RenderPassIdCounter;return this._renderPassNames[x]=a??"NONAME",x}releaseRenderPassId(a){this._renderPassNames[a]=void 0;for(let x=0;x<this.scenes.length;++x){const c=this.scenes[x];for(let u=0;u<c.meshes.length;++u){const g=c.meshes[u];if(g.subMeshes)for(let y=0;y<g.subMeshes.length;++y)g.subMeshes[y]._removeDrawWrapper(a)}}}_rescaleTexture(a,x,c,u,g){this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,this._gl.LINEAR),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,this._gl.LINEAR),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_S,this._gl.CLAMP_TO_EDGE),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_WRAP_T,this._gl.CLAMP_TO_EDGE);const y=this.createRenderTargetTexture({width:x.width,height:x.height},{generateMipMaps:!1,type:0,samplingMode:2,generateDepthBuffer:!1,generateStencilBuffer:!1});!this._rescalePostProcess&&Bt._RescalePostProcessFactory&&(this._rescalePostProcess=Bt._RescalePostProcessFactory(this)),this._rescalePostProcess&&(this._rescalePostProcess.externalTextureSamplerBinding=!0,this._rescalePostProcess.getEffect().executeWhenCompiled(()=>{this._rescalePostProcess.onApply=function(w){w._bindTexture("textureSampler",a)};let v=c;v||(v=this.scenes[this.scenes.length-1]),v.postProcessManager.directRender([this._rescalePostProcess],y,!0),this._bindTextureDirectly(this._gl.TEXTURE_2D,x,!0),this._gl.copyTexImage2D(this._gl.TEXTURE_2D,0,u,0,0,x.width,x.height,0),this.unBindFramebuffer(y),y.dispose(),g&&g()}))}getFps(){return this._fps}getDeltaTime(){return this._deltaTime}_measureFps(){this._performanceMonitor.sampleFrame(),this._fps=this._performanceMonitor.averageFPS,this._deltaTime=this._performanceMonitor.instantaneousFrameTime||0}wrapWebGLTexture(a,x=!1,c=3,u=0,g=0){const y=new Yx(a,this._gl),v=new a0(this,hn.Unknown,!0);return v._hardwareTexture=y,v.baseWidth=u,v.baseHeight=g,v.width=u,v.height=g,v.isReady=!0,v.useMipMaps=x,this.updateTextureSamplingMode(c,v),v}_uploadImageToTexture(a,x,c=0,u=0){const g=this._gl,y=this._getWebGLTextureType(a.type),v=this._getInternalFormat(a.format),w=this._getRGBABufferInternalSizedFormat(a.type,v),B=a.isCube?g.TEXTURE_CUBE_MAP:g.TEXTURE_2D;this._bindTextureDirectly(B,a,!0),this._unpackFlipY(a.invertY);let W=g.TEXTURE_2D;a.isCube&&(W=g.TEXTURE_CUBE_MAP_POSITIVE_X+c),g.texImage2D(W,u,w,v,y,x),this._bindTextureDirectly(B,null,!0)}updateTextureComparisonFunction(a,x){if(this.webGLVersion===1){Qt.Error("WebGL 1 does not support texture comparison.");return}const c=this._gl;a.isCube?(this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,a,!0),x===0?(c.texParameteri(c.TEXTURE_CUBE_MAP,c.TEXTURE_COMPARE_FUNC,515),c.texParameteri(c.TEXTURE_CUBE_MAP,c.TEXTURE_COMPARE_MODE,c.NONE)):(c.texParameteri(c.TEXTURE_CUBE_MAP,c.TEXTURE_COMPARE_FUNC,x),c.texParameteri(c.TEXTURE_CUBE_MAP,c.TEXTURE_COMPARE_MODE,c.COMPARE_REF_TO_TEXTURE)),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null)):(this._bindTextureDirectly(this._gl.TEXTURE_2D,a,!0),x===0?(c.texParameteri(c.TEXTURE_2D,c.TEXTURE_COMPARE_FUNC,515),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_COMPARE_MODE,c.NONE)):(c.texParameteri(c.TEXTURE_2D,c.TEXTURE_COMPARE_FUNC,x),c.texParameteri(c.TEXTURE_2D,c.TEXTURE_COMPARE_MODE,c.COMPARE_REF_TO_TEXTURE)),this._bindTextureDirectly(this._gl.TEXTURE_2D,null)),a._comparisonFunction=x}createInstancesBuffer(a){const x=this._gl.createBuffer();if(!x)throw new Error("Unable to create instance buffer");const c=new Vo(x);return c.capacity=a,this.bindArrayBuffer(c),this._gl.bufferData(this._gl.ARRAY_BUFFER,a,this._gl.DYNAMIC_DRAW),c.references=1,c}deleteInstancesBuffer(a){this._gl.deleteBuffer(a)}_clientWaitAsync(a,x=0,c=10){const u=this._gl;return new Promise((g,y)=>{const v=()=>{const w=u.clientWaitSync(a,x,0);if(w==u.WAIT_FAILED){y();return}if(w==u.TIMEOUT_EXPIRED){setTimeout(v,c);return}g()};v()})}_readPixelsAsync(a,x,c,u,g,y,v){if(this._webGLVersion<2)throw new Error("_readPixelsAsync only work on WebGL2+");const w=this._gl,B=w.createBuffer();w.bindBuffer(w.PIXEL_PACK_BUFFER,B),w.bufferData(w.PIXEL_PACK_BUFFER,v.byteLength,w.STREAM_READ),w.readPixels(a,x,c,u,g,y,0),w.bindBuffer(w.PIXEL_PACK_BUFFER,null);const W=w.fenceSync(w.SYNC_GPU_COMMANDS_COMPLETE,0);return W?(w.flush(),this._clientWaitAsync(W,0,10).then(()=>(w.deleteSync(W),w.bindBuffer(w.PIXEL_PACK_BUFFER,B),w.getBufferSubData(w.PIXEL_PACK_BUFFER,0,v),w.bindBuffer(w.PIXEL_PACK_BUFFER,null),w.deleteBuffer(B),v))):null}dispose(){for(this.hideLoadingUI(),this.onNewSceneAddedObservable.clear();this.postProcesses.length;)this.postProcesses[0].dispose();for(this._rescalePostProcess&&this._rescalePostProcess.dispose();this.scenes.length;)this.scenes[0].dispose();for(;this._virtualScenes.length;)this._virtualScenes[0].dispose();tr.Instances.length===1&&Bt.audioEngine&&(Bt.audioEngine.dispose(),Bt.audioEngine=null);const a=this.getHostWindow();a&&typeof a.removeEventListener=="function"&&(a.removeEventListener("blur",this._onBlur),a.removeEventListener("focus",this._onFocus)),this._renderingCanvas&&(this._renderingCanvas.removeEventListener("focus",this._onCanvasFocus),this._renderingCanvas.removeEventListener("blur",this._onCanvasBlur),this._renderingCanvas.removeEventListener("pointerout",this._onCanvasPointerOut),this._renderingCanvas.removeEventListener("contextmenu",this._onCanvasContextMenu)),ux()&&(document.removeEventListener("fullscreenchange",this._onFullscreenChange),document.removeEventListener("mozfullscreenchange",this._onFullscreenChange),document.removeEventListener("webkitfullscreenchange",this._onFullscreenChange),document.removeEventListener("msfullscreenchange",this._onFullscreenChange),document.removeEventListener("pointerlockchange",this._onPointerLockChange),document.removeEventListener("mspointerlockchange",this._onPointerLockChange),document.removeEventListener("mozpointerlockchange",this._onPointerLockChange),document.removeEventListener("webkitpointerlockchange",this._onPointerLockChange)),super.dispose();const x=tr.Instances.indexOf(this);x>=0&&tr.Instances.splice(x,1),Bt.Instances.length||tr.OnEnginesDisposedObservable.notifyObservers(this),this.onResizeObservable.clear(),this.onCanvasBlurObservable.clear(),this.onCanvasFocusObservable.clear(),this.onCanvasPointerOutObservable.clear(),this.onBeginFrameObservable.clear(),this.onEndFrameObservable.clear()}_disableTouchAction(){!this._renderingCanvas||!this._renderingCanvas.setAttribute||(this._renderingCanvas.setAttribute("touch-action","none"),this._renderingCanvas.style.touchAction="none",this._renderingCanvas.style.webkitTapHighlightColor="transparent")}displayLoadingUI(){if(!xa())return;const a=this.loadingScreen;a&&a.displayLoadingUI()}hideLoadingUI(){if(!xa())return;const a=this._loadingScreen;a&&a.hideLoadingUI()}get loadingScreen(){return!this._loadingScreen&&this._renderingCanvas&&(this._loadingScreen=Bt.DefaultLoadingScreenFactory(this._renderingCanvas)),this._loadingScreen}set loadingScreen(a){this._loadingScreen=a}set loadingUIText(a){this.loadingScreen.loadingUIText=a}set loadingUIBackgroundColor(a){this.loadingScreen.loadingUIBackgroundColor=a}createVideoElement(a){return document.createElement("video")}static _RequestPointerlock(a){if(a.requestPointerLock){const x=a.requestPointerLock();x instanceof Promise?x.then(()=>{a.focus()}).catch(()=>{}):a.focus()}}static _ExitPointerlock(){document.exitPointerLock&&document.exitPointerLock()}static _RequestFullscreen(a){const x=a.requestFullscreen||a.webkitRequestFullscreen;x&&x.call(a)}static _ExitFullscreen(){const a=document;document.exitFullscreen?document.exitFullscreen():a.webkitCancelFullScreen&&a.webkitCancelFullScreen()}getFontOffset(a){const x=document.createElement("span");x.innerHTML="Hg",x.setAttribute("style",`font: ${a} !important`);const c=document.createElement("div");c.style.display="inline-block",c.style.width="1px",c.style.height="0px",c.style.verticalAlign="bottom";const u=document.createElement("div");u.style.whiteSpace="nowrap",u.appendChild(x),u.appendChild(c),document.body.appendChild(u);let g=0,y=0;try{y=c.getBoundingClientRect().top-x.getBoundingClientRect().top,c.style.verticalAlign="baseline",g=c.getBoundingClientRect().top-x.getBoundingClientRect().top}finally{document.body.removeChild(u)}return{ascent:g,height:y,descent:y-g}}}Bt.ALPHA_DISABLE=0,Bt.ALPHA_ADD=1,Bt.ALPHA_COMBINE=2,Bt.ALPHA_SUBTRACT=3,Bt.ALPHA_MULTIPLY=4,Bt.ALPHA_MAXIMIZED=5,Bt.ALPHA_ONEONE=6,Bt.ALPHA_PREMULTIPLIED=7,Bt.ALPHA_PREMULTIPLIED_PORTERDUFF=8,Bt.ALPHA_INTERPOLATE=9,Bt.ALPHA_SCREENMODE=10,Bt.DELAYLOADSTATE_NONE=0,Bt.DELAYLOADSTATE_LOADED=1,Bt.DELAYLOADSTATE_LOADING=2,Bt.DELAYLOADSTATE_NOTLOADED=4,Bt.NEVER=512,Bt.ALWAYS=519,Bt.LESS=513,Bt.EQUAL=514,Bt.LEQUAL=515,Bt.GREATER=516,Bt.GEQUAL=518,Bt.NOTEQUAL=517,Bt.KEEP=7680,Bt.REPLACE=7681,Bt.INCR=7682,Bt.DECR=7683,Bt.INVERT=5386,Bt.INCR_WRAP=34055,Bt.DECR_WRAP=34056,Bt.TEXTURE_CLAMP_ADDRESSMODE=0,Bt.TEXTURE_WRAP_ADDRESSMODE=1,Bt.TEXTURE_MIRROR_ADDRESSMODE=2,Bt.TEXTUREFORMAT_ALPHA=0,Bt.TEXTUREFORMAT_LUMINANCE=1,Bt.TEXTUREFORMAT_LUMINANCE_ALPHA=2,Bt.TEXTUREFORMAT_RGB=4,Bt.TEXTUREFORMAT_RGBA=5,Bt.TEXTUREFORMAT_RED=6,Bt.TEXTUREFORMAT_R=6,Bt.TEXTUREFORMAT_RG=7,Bt.TEXTUREFORMAT_RED_INTEGER=8,Bt.TEXTUREFORMAT_R_INTEGER=8,Bt.TEXTUREFORMAT_RG_INTEGER=9,Bt.TEXTUREFORMAT_RGB_INTEGER=10,Bt.TEXTUREFORMAT_RGBA_INTEGER=11,Bt.TEXTURETYPE_UNSIGNED_BYTE=0,Bt.TEXTURETYPE_UNSIGNED_INT=0,Bt.TEXTURETYPE_FLOAT=1,Bt.TEXTURETYPE_HALF_FLOAT=2,Bt.TEXTURETYPE_BYTE=3,Bt.TEXTURETYPE_SHORT=4,Bt.TEXTURETYPE_UNSIGNED_SHORT=5,Bt.TEXTURETYPE_INT=6,Bt.TEXTURETYPE_UNSIGNED_INTEGER=7,Bt.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4=8,Bt.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1=9,Bt.TEXTURETYPE_UNSIGNED_SHORT_5_6_5=10,Bt.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV=11,Bt.TEXTURETYPE_UNSIGNED_INT_24_8=12,Bt.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV=13,Bt.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV=14,Bt.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV=15,Bt.TEXTURE_NEAREST_SAMPLINGMODE=1,Bt.TEXTURE_BILINEAR_SAMPLINGMODE=2,Bt.TEXTURE_TRILINEAR_SAMPLINGMODE=3,Bt.TEXTURE_NEAREST_NEAREST_MIPLINEAR=8,Bt.TEXTURE_LINEAR_LINEAR_MIPNEAREST=11,Bt.TEXTURE_LINEAR_LINEAR_MIPLINEAR=3,Bt.TEXTURE_NEAREST_NEAREST_MIPNEAREST=4,Bt.TEXTURE_NEAREST_LINEAR_MIPNEAREST=5,Bt.TEXTURE_NEAREST_LINEAR_MIPLINEAR=6,Bt.TEXTURE_NEAREST_LINEAR=7,Bt.TEXTURE_NEAREST_NEAREST=1,Bt.TEXTURE_LINEAR_NEAREST_MIPNEAREST=9,Bt.TEXTURE_LINEAR_NEAREST_MIPLINEAR=10,Bt.TEXTURE_LINEAR_LINEAR=2,Bt.TEXTURE_LINEAR_NEAREST=12,Bt.TEXTURE_EXPLICIT_MODE=0,Bt.TEXTURE_SPHERICAL_MODE=1,Bt.TEXTURE_PLANAR_MODE=2,Bt.TEXTURE_CUBIC_MODE=3,Bt.TEXTURE_PROJECTION_MODE=4,Bt.TEXTURE_SKYBOX_MODE=5,Bt.TEXTURE_INVCUBIC_MODE=6,Bt.TEXTURE_EQUIRECTANGULAR_MODE=7,Bt.TEXTURE_FIXED_EQUIRECTANGULAR_MODE=8,Bt.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,Bt.SCALEMODE_FLOOR=1,Bt.SCALEMODE_NEAREST=2,Bt.SCALEMODE_CEILING=3,Bt._RescalePostProcessFactory=null,Bt._RenderPassIdCounter=0;const x2=(F,a,x)=>!F||F.getClassName&&F.getClassName()==="Mesh"?null:F.getClassName&&(F.getClassName()==="SubMesh"||F.getClassName()==="PhysicsBody")?F.clone(a):F.clone?F.clone():Array.isArray(F)?F.slice():x&&typeof F=="object"?{...F}:null;function Ro(F){const a=[];do Object.getOwnPropertyNames(F).forEach(function(x){a.indexOf(x)===-1&&a.push(x)});while(F=Object.getPrototypeOf(F));return a}class $x{static DeepCopy(a,x,c,u,g=!1){const y=Ro(a);for(const v of y){if(v[0]==="_"&&(!u||u.indexOf(v)===-1)||v.endsWith("Observable")||c&&c.indexOf(v)!==-1)continue;const w=a[v],B=typeof w;if(B!=="function")try{if(B==="object")if(w instanceof Uint8Array)x[v]=Uint8Array.from(w);else if(w instanceof Array){if(x[v]=[],w.length>0)if(typeof w[0]=="object")for(let W=0;W<w.length;W++){const ae=x2(w[W],x,g);x[v].indexOf(ae)===-1&&x[v].push(ae)}else x[v]=w.slice(0)}else x[v]=x2(w,x,g);else x[v]=w}catch(W){Qt.Warn(W.message)}}}}function l2(){return typeof _native<"u"&&_native.XMLHttpRequest?new _native.XMLHttpRequest:new XMLHttpRequest}class da{constructor(){this._xhr=l2(),this._requestURL=""}static get IsCustomRequestAvailable(){return Object.keys(da.CustomRequestHeaders).length>0||da.CustomRequestModifiers.length>0}_injectCustomRequestHeaders(){if(!this._shouldSkipRequestModifications(this._requestURL))for(const a in da.CustomRequestHeaders){const x=da.CustomRequestHeaders[a];x&&this._xhr.setRequestHeader(a,x)}}_shouldSkipRequestModifications(a){return da.SkipRequestModificationForBabylonCDN&&(a.includes("preview.babylonjs.com")||a.includes("cdn.babylonjs.com"))}get onprogress(){return this._xhr.onprogress}set onprogress(a){this._xhr.onprogress=a}get readyState(){return this._xhr.readyState}get status(){return this._xhr.status}get statusText(){return this._xhr.statusText}get response(){return this._xhr.response}get responseURL(){return this._xhr.responseURL}get responseText(){return this._xhr.responseText}get responseType(){return this._xhr.responseType}set responseType(a){this._xhr.responseType=a}get timeout(){return this._xhr.timeout}set timeout(a){this._xhr.timeout=a}addEventListener(a,x,c){this._xhr.addEventListener(a,x,c)}removeEventListener(a,x,c){this._xhr.removeEventListener(a,x,c)}abort(){this._xhr.abort()}send(a){da.CustomRequestHeaders&&this._injectCustomRequestHeaders(),this._xhr.send(a)}open(a,x){for(const c of da.CustomRequestModifiers){if(this._shouldSkipRequestModifications(x))return;c(this._xhr,x)}x=x.replace("file:http:","http:"),x=x.replace("file:https:","https:"),this._requestURL=x,this._xhr.open(a,x,!0)}setRequestHeader(a,x){this._xhr.setRequestHeader(a,x)}getResponseHeader(a){return this._xhr.getResponseHeader(a)}}da.CustomRequestHeaders={},da.CustomRequestModifiers=new Array,da.SkipRequestModificationForBabylonCDN=!0;class h0{}h0.FilesToLoad={};class V2{static ExponentialBackoff(a=3,x=500){return(c,u,g)=>u.status!==0||g>=a||c.indexOf("file:")!==-1?-1:Math.pow(2,g)*x}}class Jx extends Error{}Jx._setPrototypeOf=Object.setPrototypeOf||((F,a)=>(F.__proto__=a,F));const Ho={MeshInvalidPositionsError:0,UnsupportedTextureError:1e3,GLTFLoaderUnexpectedMagicError:2e3,SceneLoaderError:3e3,LoadFileError:4e3,RequestFileError:4001,ReadFileError:4002};class Xo extends Jx{constructor(a,x,c){super(a),this.errorCode=x,this.innerError=c,this.name="RuntimeError",Jx._setPrototypeOf(this,Xo.prototype)}}const Ih=(F,a)=>F.endsWith(a),Rh=(F,a)=>F?F.startsWith(a):!1,Rc=F=>{if(typeof TextDecoder<"u")return new TextDecoder().decode(F);let a="";for(let x=0;x<F.byteLength;x++)a+=String.fromCharCode(F[x]);return a},h2=F=>{const a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";let x="",c,u,g,y,v,w,B,W=0;const ae=ArrayBuffer.isView(F)?new Uint8Array(F.buffer,F.byteOffset,F.byteLength):new Uint8Array(F);for(;W<ae.length;)c=ae[W++],u=W<ae.length?ae[W++]:Number.NaN,g=W<ae.length?ae[W++]:Number.NaN,y=c>>2,v=(c&3)<<4|u>>4,w=(u&15)<<2|g>>6,B=g&63,isNaN(u)?w=B=64:isNaN(g)&&(B=64),x+=a.charAt(y)+a.charAt(v)+a.charAt(w)+a.charAt(B);return x},u2=F=>atob(F),yo=F=>{const a=u2(F),x=a.length,c=new Uint8Array(new ArrayBuffer(x));for(let u=0;u<x;u++)c[u]=a.charCodeAt(u);return c.buffer},Mc={EndsWith:Ih,StartsWith:Rh,Decode:Rc,EncodeArrayBufferToBase64:h2,DecodeBase64ToString:u2,DecodeBase64ToBinary:yo,PadNumber:(F,a)=>{let x=String(F);for(;x.length<a;)x="0"+x;return x}};class d2{static SetImmediate(a){xa()&&window.setImmediate?window.setImmediate(a):setTimeout(a,1)}}const b0=new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);class gl extends Xo{constructor(a,x){super(a,Ho.LoadFileError),this.name="LoadFileError",Jx._setPrototypeOf(this,gl.prototype),x instanceof da?this.request=x:this.file=x}}class _l extends Xo{constructor(a,x){super(a,Ho.RequestFileError),this.request=x,this.name="RequestFileError",Jx._setPrototypeOf(this,_l.prototype)}}class W2 extends Xo{constructor(a,x){super(a,Ho.ReadFileError),this.file=x,this.name="ReadFileError",Jx._setPrototypeOf(this,W2.prototype)}}const la={DefaultRetryStrategy:V2.ExponentialBackoff(),BaseUrl:"",CorsBehavior:"anonymous",PreprocessUrl:F=>F,ScriptBaseUrl:"",ScriptPreprocessUrl:F=>F},Bc=F=>(F=F.replace(/#/gm,"%23"),F),H2=(F,a)=>{if(!(F&&F.indexOf("data:")===0)&&la.CorsBehavior)if(typeof la.CorsBehavior=="string"||la.CorsBehavior instanceof String)a.crossOrigin=la.CorsBehavior;else{const x=la.CorsBehavior(F);x&&(a.crossOrigin=x)}},f2=(F,a,x,c,u="",g)=>{const y=tr.LastCreatedEngine;if(typeof HTMLImageElement>"u"&&!y?._features.forceBitmapOverHTMLImageElement)return x("LoadImage is only supported in web or BabylonNative environments."),null;let v,w=!1;F instanceof ArrayBuffer||ArrayBuffer.isView(F)?typeof Blob<"u"&&typeof URL<"u"?(v=URL.createObjectURL(new Blob([F],{type:u})),w=!0):v=`data:${u};base64,`+h2(F):F instanceof Blob?(v=URL.createObjectURL(F),w=!0):(v=Bc(F),v=la.PreprocessUrl(F));const B=dt=>{if(x){const ut=v||F.toString();x(`Error while trying to load image: ${ut.indexOf("http")===0||ut.length<=128?ut:ut.slice(0,128)+"..."}`,dt)}};if(y?._features.forceBitmapOverHTMLImageElement)return fx(v,dt=>{y.createImageBitmap(new Blob([dt],{type:u}),{premultiplyAlpha:"none",...g}).then(ut=>{a(ut),w&&URL.revokeObjectURL(v)}).catch(ut=>{x&&x("Error while trying to load image: "+F,ut)})},void 0,c||void 0,!0,(dt,ut)=>{B(ut)}),null;const W=new Image;H2(v,W);const ae=[],ue=()=>{ae.forEach(dt=>{dt.target.addEventListener(dt.name,dt.handler)})},fe=()=>{ae.forEach(dt=>{dt.target.removeEventListener(dt.name,dt.handler)}),ae.length=0},Re=()=>{fe(),a(W),w&&W.src&&URL.revokeObjectURL(W.src)},_e=dt=>{fe(),B(dt),w&&W.src&&URL.revokeObjectURL(W.src)},Be=dt=>{if(dt.blockedURI!==W.src)return;fe();const ut=new Error(`CSP violation of policy ${dt.effectiveDirective} ${dt.blockedURI}. Current policy is ${dt.originalPolicy}`);tr.UseFallbackTexture=!1,B(ut),w&&W.src&&URL.revokeObjectURL(W.src),W.src=""};ae.push({target:W,name:"load",handler:Re}),ae.push({target:W,name:"error",handler:_e}),ae.push({target:document,name:"securitypolicyviolation",handler:Be}),ue();const tt=v.substring(0,5)==="blob:",$e=v.substring(0,5)==="data:",Et=()=>{tt||$e||!da.IsCustomRequestAvailable?W.src=v:fx(v,(dt,ut,Mt)=>{const ai=!u&&Mt?Mt:u,Yi=new Blob([dt],{type:ai}),Vi=URL.createObjectURL(Yi);w=!0,W.src=Vi},void 0,c||void 0,!0,(dt,ut)=>{B(ut)})},ft=()=>{c&&c.loadImage(v,W)};if(!tt&&!$e&&c&&c.enableTexturesOffline)c.open(ft,Et);else{if(v.indexOf("file:")!==-1){const dt=decodeURIComponent(v.substring(5).toLowerCase());if(h0.FilesToLoad[dt]&&typeof URL<"u"){try{let ut;try{ut=URL.createObjectURL(h0.FilesToLoad[dt])}catch{ut=URL.createObjectURL(h0.FilesToLoad[dt])}W.src=ut,w=!0}catch{W.src=""}return W}}Et()}return W},yl=(F,a,x,c,u)=>{const g=new FileReader,y={onCompleteObservable:new Jt,abort:()=>g.abort()};return g.onloadend=()=>y.onCompleteObservable.notifyObservers(y),u&&(g.onerror=()=>{u(new W2(`Unable to read ${F.name}`,F))}),g.onload=v=>{a(v.target.result)},x&&(g.onprogress=x),c?g.readAsArrayBuffer(F):g.readAsText(F),y},fx=(F,a,x,c,u,g,y)=>{if(F.name)return yl(F,a,x,u,g?W=>{g(void 0,W)}:void 0);const v=F;if(v.indexOf("file:")!==-1){let W=decodeURIComponent(v.substring(5).toLowerCase());W.indexOf("./")===0&&(W=W.substring(2));const ae=h0.FilesToLoad[W];if(ae)return yl(ae,a,x,u,g?ue=>g(void 0,new gl(ue.message,ue.file)):void 0)}const{match:w,type:B}=Bh(v);if(w){const W={onCompleteObservable:new Jt,abort:()=>()=>{}};try{const ae=u?El(v):Vc(v);a(ae,void 0,B)}catch(ae){g?g(void 0,ae):Qt.Error(ae.message||"Failed to parse the Data URL")}return d2.SetImmediate(()=>{W.onCompleteObservable.notifyObservers(W)}),W}return X2(v,(W,ae)=>{a(W,ae?.responseURL,ae?.getResponseHeader("content-type"))},x,c,u,g?W=>{g(W.request,new gl(W.message,W.request))}:void 0,y)},X2=(F,a,x,c,u,g,y)=>{F=Bc(F),F=la.PreprocessUrl(F);const v=la.BaseUrl+F;let w=!1;const B={onCompleteObservable:new Jt,abort:()=>w=!0},W=()=>{let ae=new da,ue=null,fe;const Re=()=>{ae&&(x&&ae.removeEventListener("progress",x),fe&&ae.removeEventListener("readystatechange",fe),ae.removeEventListener("loadend",_e))};let _e=()=>{Re(),B.onCompleteObservable.notifyObservers(B),B.onCompleteObservable.clear(),x=void 0,fe=null,_e=null,g=void 0,y=void 0,a=void 0};B.abort=()=>{w=!0,_e&&_e(),ae&&ae.readyState!==(XMLHttpRequest.DONE||4)&&ae.abort(),ue!==null&&(clearTimeout(ue),ue=null),ae=null};const Be=$e=>{const Et=$e.message||"Unknown error";g&&ae?g(new _l(Et,ae)):Qt.Error(Et)},tt=$e=>{if(ae){if(ae.open("GET",v),y)try{y(ae)}catch(Et){Be(Et);return}u&&(ae.responseType="arraybuffer"),x&&ae.addEventListener("progress",x),_e&&ae.addEventListener("loadend",_e),fe=()=>{if(!(w||!ae)&&ae.readyState===(XMLHttpRequest.DONE||4)){if(fe&&ae.removeEventListener("readystatechange",fe),ae.status>=200&&ae.status<300||ae.status===0&&(!xa()||Uc())){try{a&&a(u?ae.response:ae.responseText,ae)}catch(dt){Be(dt)}return}const Et=la.DefaultRetryStrategy;if(Et){const dt=Et(v,ae,$e);if(dt!==-1){Re(),ae=new da,ue=setTimeout(()=>tt($e+1),dt);return}}const ft=new _l("Error status: "+ae.status+" "+ae.statusText+" - Unable to load "+v,ae);g&&g(ft)}},ae.addEventListener("readystatechange",fe),ae.send()}};tt(0)};if(c&&c.enableSceneOffline){const ae=fe=>{fe&&fe.status>400?g&&g(fe):W()},ue=()=>{c&&c.loadFile(la.BaseUrl+F,fe=>{!w&&a&&a(fe),B.onCompleteObservable.notifyObservers(B)},x?fe=>{!w&&x&&x(fe)}:void 0,ae,u)};c.open(ue,ae)}else W();return B},Uc=()=>typeof location<"u"&&location.protocol==="file:",bl=F=>b0.test(F),Bh=F=>{const a=b0.exec(F);return a===null||a.length===0?{match:!1,type:""}:{match:!0,type:a[0].replace("data:","").replace("base64,","")}};function El(F){return yo(F.split(",")[1])}const Vc=F=>u2(F.split(",")[1]);(()=>{Es._FileToolsLoadImage=f2,Es._FileToolsLoadFile=fx,ho._FileToolsLoadFile=fx})();let J0;((F,a,x,c,u,g,y,v,w,B)=>{J0={DecodeBase64UrlToBinary:F,DecodeBase64UrlToString:a,DefaultRetryStrategy:x.DefaultRetryStrategy,BaseUrl:x.BaseUrl,CorsBehavior:x.CorsBehavior,PreprocessUrl:x.PreprocessUrl,IsBase64DataUrl:c,IsFileURL:u,LoadFile:g,LoadImage:y,ReadFile:v,RequestFile:w,SetCorsBehavior:B},Object.defineProperty(J0,"DefaultRetryStrategy",{get:function(){return x.DefaultRetryStrategy},set:function(W){x.DefaultRetryStrategy=W}}),Object.defineProperty(J0,"BaseUrl",{get:function(){return x.BaseUrl},set:function(W){x.BaseUrl=W}}),Object.defineProperty(J0,"PreprocessUrl",{get:function(){return x.PreprocessUrl},set:function(W){x.PreprocessUrl=W}}),Object.defineProperty(J0,"CorsBehavior",{get:function(){return x.CorsBehavior},set:function(W){x.CorsBehavior=W}})})(El,Vc,la,bl,Uc,fx,f2,yl,X2,H2);const m2={};function as(F,a){m2[F]=a}function Ua(F){return m2[F]}class E0{static Instantiate(a){if(this.RegisteredExternalClasses&&this.RegisteredExternalClasses[a])return this.RegisteredExternalClasses[a];const x=Ua(a);if(x)return x;Qt.Warn(a+" not found, you may have missed an import.");const c=a.split(".");let u=window||this;for(let g=0,y=c.length;g<y;g++)u=u[c[g]];return typeof u!="function"?null:u}}E0.RegisteredExternalClasses={};function v0(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,F=>{const a=Math.random()*16|0;return(F==="x"?a:a&3|8).toString(16)})}const at={RandomId:v0};function Je(F){let a=1;do a*=2;while(a<F);return a===F}function Rt(F,a,x){return F*(1-x)+a*x}class _t{static get BaseUrl(){return la.BaseUrl}static set BaseUrl(a){la.BaseUrl=a}static IsAbsoluteUrl(a){return a.indexOf("//")===0?!0:a.indexOf("://")===-1||a.indexOf(".")===-1||a.indexOf("/")===-1||a.indexOf(":")>a.indexOf("/")?!1:a.indexOf("://")<a.indexOf(".")||a.indexOf("data:")===0||a.indexOf("blob:")===0}static set ScriptBaseUrl(a){la.ScriptBaseUrl=a}static get ScriptBaseUrl(){return la.ScriptBaseUrl}static set ScriptPreprocessUrl(a){la.ScriptPreprocessUrl=a}static get ScriptPreprocessUrl(){return la.ScriptPreprocessUrl}static get DefaultRetryStrategy(){return la.DefaultRetryStrategy}static set DefaultRetryStrategy(a){la.DefaultRetryStrategy=a}static get CorsBehavior(){return la.CorsBehavior}static set CorsBehavior(a){la.CorsBehavior=a}static get UseFallbackTexture(){return tr.UseFallbackTexture}static set UseFallbackTexture(a){tr.UseFallbackTexture=a}static get RegisteredExternalClasses(){return E0.RegisteredExternalClasses}static set RegisteredExternalClasses(a){E0.RegisteredExternalClasses=a}static get fallbackTexture(){return tr.FallbackTexture}static set fallbackTexture(a){tr.FallbackTexture=a}static FetchToRef(a,x,c,u,g,y){const v=Math.abs(a)*c%c|0,w=Math.abs(x)*u%u|0,B=(v+w*c)*4;y.r=g[B]/255,y.g=g[B+1]/255,y.b=g[B+2]/255,y.a=g[B+3]/255}static Mix(a,x,c){return 0}static Instantiate(a){return E0.Instantiate(a)}static SetImmediate(a){d2.SetImmediate(a)}static IsExponentOfTwo(a){return!0}static FloatRound(a){return Math.fround(a)}static GetFilename(a){const x=a.lastIndexOf("/");return x<0?a:a.substring(x+1)}static GetFolderPath(a,x=!1){const c=a.lastIndexOf("/");return c<0?x?a:"":a.substring(0,c+1)}static ToDegrees(a){return a*180/Math.PI}static ToRadians(a){return a*Math.PI/180}static SmoothAngleChange(a,x,c=.9){const u=this.ToRadians(a),g=this.ToRadians(x);return this.ToDegrees(Math.atan2((1-c)*Math.sin(g)+c*Math.sin(u),(1-c)*Math.cos(g)+c*Math.cos(u)))}static MakeArray(a,x){return x!==!0&&(a===void 0||a==null)?null:Array.isArray(a)?a:[a]}static GetPointerPrefix(a){let x="pointer";return xa()&&!window.PointerEvent&&(x="mouse"),a._badDesktopOS&&!a._badOS&&!(document&&"ontouchend"in document)&&(x="mouse"),x}static SetCorsBehavior(a,x){H2(a,x)}static SetReferrerPolicyBehavior(a,x){x.referrerPolicy=a}static CleanUrl(a){return a=a.replace(/#/gm,"%23"),a}static get PreprocessUrl(){return la.PreprocessUrl}static set PreprocessUrl(a){la.PreprocessUrl=a}static LoadImage(a,x,c,u,g,y){return f2(a,x,c,u,g,y)}static LoadFile(a,x,c,u,g,y){return fx(a,x,c,u,g,y)}static LoadFileAsync(a,x=!0){return new Promise((c,u)=>{fx(a,g=>{c(g)},void 0,void 0,x,(g,y)=>{u(y)})})}static GetBabylonScriptURL(a,x){if(!a)return"";if(_t.ScriptBaseUrl&&a.startsWith(_t._DefaultCdnUrl)){const c=_t.ScriptBaseUrl[_t.ScriptBaseUrl.length-1]==="/"?_t.ScriptBaseUrl.substring(0,_t.ScriptBaseUrl.length-1):_t.ScriptBaseUrl;a=a.replace(_t._DefaultCdnUrl,c)}return a=_t.ScriptPreprocessUrl(a),x&&(a=_t.GetAbsoluteUrl(a)),a}static LoadBabylonScript(a,x,c,u){a=_t.GetBabylonScriptURL(a),_t.LoadScript(a,x,c)}static LoadBabylonScriptAsync(a){return a=_t.GetBabylonScriptURL(a),_t.LoadScriptAsync(a)}static LoadScript(a,x,c,u){if(typeof importScripts=="function"){try{importScripts(a),x()}catch(v){c?.(`Unable to load script '${a}' in worker`,v)}return}else if(!xa()){c?.(`Cannot load script '${a}' outside of a window or a worker`);return}const g=document.getElementsByTagName("head")[0],y=document.createElement("script");y.setAttribute("type","text/javascript"),y.setAttribute("src",a),u&&(y.id=u),y.onload=()=>{x&&x()},y.onerror=v=>{c&&c(`Unable to load script '${a}'`,v)},g.appendChild(y)}static LoadScriptAsync(a,x){return new Promise((c,u)=>{this.LoadScript(a,()=>{c()},(g,y)=>{u(y||new Error(g))},x)})}static ReadFileAsDataURL(a,x,c){const u=new FileReader,g={onCompleteObservable:new Jt,abort:()=>u.abort()};return u.onloadend=()=>{g.onCompleteObservable.notifyObservers(g)},u.onload=y=>{x(y.target.result)},u.onprogress=c,u.readAsDataURL(a),g}static ReadFile(a,x,c,u,g){return yl(a,x,c,u,g)}static FileAsURL(a){const x=new Blob([a]);return window.URL.createObjectURL(x)}static Format(a,x=2){return a.toFixed(x)}static DeepCopy(a,x,c,u){$x.DeepCopy(a,x,c,u)}static IsEmpty(a){for(const x in a)if(Object.prototype.hasOwnProperty.call(a,x))return!1;return!0}static RegisterTopRootEvents(a,x){for(let c=0;c<x.length;c++){const u=x[c];a.addEventListener(u.name,u.handler,!1);try{window.parent&&window.parent.addEventListener(u.name,u.handler,!1)}catch{}}}static UnregisterTopRootEvents(a,x){for(let c=0;c<x.length;c++){const u=x[c];a.removeEventListener(u.name,u.handler);try{a.parent&&a.parent.removeEventListener(u.name,u.handler)}catch{}}}static async DumpFramebuffer(a,x,c,u,g="image/png",y,v){throw js("DumpTools")}static DumpData(a,x,c,u,g="image/png",y,v=!1,w=!1,B){throw js("DumpTools")}static DumpDataAsync(a,x,c,u="image/png",g,y=!1,v=!1,w){throw js("DumpTools")}static _IsOffScreenCanvas(a){return a.convertToBlob!==void 0}static ToBlob(a,x,c="image/png",u){!_t._IsOffScreenCanvas(a)&&!a.toBlob&&(a.toBlob=function(g,y,v){setTimeout(()=>{const w=atob(this.toDataURL(y,v).split(",")[1]),B=w.length,W=new Uint8Array(B);for(let ae=0;ae<B;ae++)W[ae]=w.charCodeAt(ae);g(new Blob([W]))})}),_t._IsOffScreenCanvas(a)?a.convertToBlob({type:c,quality:u}).then(g=>x(g)):a.toBlob(function(g){x(g)},c,u)}static DownloadBlob(a,x){if("download"in document.createElement("a")){if(!x){const c=new Date;x="screenshot_"+((c.getFullYear()+"-"+(c.getMonth()+1)).slice(2)+"-"+c.getDate()+"_"+c.getHours()+"-"+("0"+c.getMinutes()).slice(-2))+".png"}_t.Download(a,x)}else if(a&&typeof URL<"u"){const c=URL.createObjectURL(a),u=window.open("");if(!u)return;const g=u.document.createElement("img");g.onload=function(){URL.revokeObjectURL(c)},g.src=c,u.document.body.appendChild(g)}}static EncodeScreenshotCanvasData(a,x,c="image/png",u,g){if(typeof u=="string"||!x)this.ToBlob(a,function(y){y&&_t.DownloadBlob(y,u),x&&x("")},c,g);else if(x){if(_t._IsOffScreenCanvas(a)){a.convertToBlob({type:c,quality:g}).then(v=>{const w=new FileReader;w.readAsDataURL(v),w.onloadend=()=>{const B=w.result;x(B)}});return}const y=a.toDataURL(c,g);x(y)}}static Download(a,x){if(typeof URL>"u")return;const c=window.URL.createObjectURL(a),u=document.createElement("a");document.body.appendChild(u),u.style.display="none",u.href=c,u.download=x,u.addEventListener("click",()=>{u.parentElement&&u.parentElement.removeChild(u)}),u.click(),window.URL.revokeObjectURL(c)}static BackCompatCameraNoPreventDefault(a){return typeof a[0]=="boolean"?a[0]:typeof a[1]=="boolean"?a[1]:!1}static CreateScreenshot(a,x,c,u,g="image/png",y=!1,v){throw js("ScreenshotTools")}static CreateScreenshotAsync(a,x,c,u="image/png",g){throw js("ScreenshotTools")}static CreateScreenshotUsingRenderTarget(a,x,c,u,g="image/png",y=1,v=!1,w,B=!1,W=!1,ae=!0,ue){throw js("ScreenshotTools")}static CreateScreenshotUsingRenderTargetAsync(a,x,c,u="image/png",g=1,y=!1,v,w=!1,B=!1,W=!0,ae){throw js("ScreenshotTools")}static RandomId(){return v0()}static IsBase64(a){return bl(a)}static DecodeBase64(a){return El(a)}static get errorsCount(){return Qt.errorsCount}static Log(a){Qt.Log(a)}static Warn(a){Qt.Warn(a)}static Error(a){Qt.Error(a)}static get LogCache(){return Qt.LogCache}static ClearLogCache(){Qt.ClearLogCache()}static set LogLevels(a){Qt.LogLevels=a}static set PerformanceLogLevel(a){if((a&_t.PerformanceUserMarkLogLevel)===_t.PerformanceUserMarkLogLevel){_t.StartPerformanceCounter=_t._StartUserMark,_t.EndPerformanceCounter=_t._EndUserMark;return}if((a&_t.PerformanceConsoleLogLevel)===_t.PerformanceConsoleLogLevel){_t.StartPerformanceCounter=_t._StartPerformanceConsole,_t.EndPerformanceCounter=_t._EndPerformanceConsole;return}_t.StartPerformanceCounter=_t._StartPerformanceCounterDisabled,_t.EndPerformanceCounter=_t._EndPerformanceCounterDisabled}static _StartPerformanceCounterDisabled(a,x){}static _EndPerformanceCounterDisabled(a,x){}static _StartUserMark(a,x=!0){if(!_t._Performance){if(!xa())return;_t._Performance=window.performance}!x||!_t._Performance.mark||_t._Performance.mark(a+"-Begin")}static _EndUserMark(a,x=!0){!x||!_t._Performance.mark||(_t._Performance.mark(a+"-End"),_t._Performance.measure(a,a+"-Begin",a+"-End"))}static _StartPerformanceConsole(a,x=!0){x&&(_t._StartUserMark(a,x),console.time&&console.time(a))}static _EndPerformanceConsole(a,x=!0){x&&(_t._EndUserMark(a,x),console.timeEnd(a))}static get Now(){return Wo.Now}static GetClassName(a,x=!1){let c=null;return!x&&a.getClassName?c=a.getClassName():(a instanceof Object&&(c=(x?a:Object.getPrototypeOf(a)).constructor.__bjsclassName__),c||(c=typeof a)),c}static First(a,x){for(const c of a)if(x(c))return c;return null}static getFullClassName(a,x=!1){let c=null,u=null;if(!x&&a.getClassName)c=a.getClassName();else{if(a instanceof Object){const g=x?a:Object.getPrototypeOf(a);c=g.constructor.__bjsclassName__,u=g.constructor.__bjsmoduleName__}c||(c=typeof a)}return c?(u!=null?u+".":"")+c:null}static DelayAsync(a){return new Promise(x=>{setTimeout(()=>{x()},a)})}static IsSafari(){return Uo()?/^((?!chrome|android).)*safari/i.test(navigator.userAgent):!1}}_t.UseCustomRequestHeaders=!1,_t.CustomRequestHeaders=da.CustomRequestHeaders,_t.GetDOMTextContent=U0,_t._DefaultCdnUrl="https://cdn.babylonjs.com",_t.GetAbsoluteUrl=typeof document=="object"?F=>{const a=document.createElement("a");return a.href=F,a.href}:typeof URL=="function"&&typeof location=="object"?F=>new URL(F,location.origin).href:()=>{throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.")},_t.NoneLogLevel=Qt.NoneLogLevel,_t.MessageLogLevel=Qt.MessageLogLevel,_t.WarningLogLevel=Qt.WarningLogLevel,_t.ErrorLogLevel=Qt.ErrorLogLevel,_t.AllLogLevel=Qt.AllLogLevel,_t.IsWindowObjectExist=xa,_t.PerformanceNoneLogLevel=0,_t.PerformanceUserMarkLogLevel=1,_t.PerformanceConsoleLogLevel=2,_t.StartPerformanceCounter=_t._StartPerformanceCounterDisabled,_t.EndPerformanceCounter=_t._EndPerformanceCounterDisabled;function He(F,a){return x=>{x.__bjsclassName__=F,x.__bjsmoduleName__=a??null}}class Xe{constructor(a,x,c,u=0){this.iterations=a,this.index=u-1,this._done=!1,this._fn=x,this._successCallback=c}executeNext(){this._done||(this.index+1<this.iterations?(++this.index,this._fn(this)):this.breakLoop())}breakLoop(){this._done=!0,this._successCallback()}static Run(a,x,c,u=0){const g=new Xe(a,x,c,u);return g.executeNext(),g}static SyncAsyncForLoop(a,x,c,u,g,y=0){return Xe.Run(Math.ceil(a/x),v=>{g&&g()?v.breakLoop():setTimeout(()=>{for(let w=0;w<x;++w){const B=v.index*x+w;if(B>=a)break;if(c(B),g&&g()){v.breakLoop();break}}v.executeNext()},y)},u)}}_t.Mix=Rt,_t.IsExponentOfTwo=Je,tr.FallbackTexture="data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";class lt{constructor(a){this.length=0,this.data=new Array(a),this._id=lt._GlobalId++}push(a){this.data[this.length++]=a,this.length>this.data.length&&(this.data.length*=2)}forEach(a){for(let x=0;x<this.length;x++)a(this.data[x])}sort(a){this.data.sort(a)}reset(){this.length=0}dispose(){this.reset(),this.data&&(this.data.length=0)}concat(a){if(a.length!==0){this.length+a.length>this.data.length&&(this.data.length=(this.length+a.length)*2);for(let x=0;x<a.length;x++)this.data[this.length++]=(a.data||a)[x]}}indexOf(a){const x=this.data.indexOf(a);return x>=this.length?-1:x}contains(a){return this.indexOf(a)!==-1}}lt._GlobalId=0;class yt extends lt{constructor(){super(...arguments),this._duplicateId=0}push(a){super.push(a),a.__smartArrayFlags||(a.__smartArrayFlags={}),a.__smartArrayFlags[this._id]=this._duplicateId}pushNoDuplicate(a){return a.__smartArrayFlags&&a.__smartArrayFlags[this._id]===this._duplicateId?!1:(this.push(a),!0)}reset(){super.reset(),this._duplicateId++}concatWithNoDuplicate(a){if(a.length!==0){this.length+a.length>this.data.length&&(this.data.length=(this.length+a.length)*2);for(let x=0;x<a.length;x++){const c=(a.data||a)[x];this.pushNoDuplicate(c)}}}}class jt{constructor(){this._count=0,this._data={}}copyFrom(a){this.clear(),a.forEach((x,c)=>this.add(x,c))}get(a){const x=this._data[a];if(x!==void 0)return x}getOrAddWithFactory(a,x){let c=this.get(a);return c!==void 0||(c=x(a),c&&this.add(a,c)),c}getOrAdd(a,x){const c=this.get(a);return c!==void 0?c:(this.add(a,x),x)}contains(a){return this._data[a]!==void 0}add(a,x){return this._data[a]!==void 0?!1:(this._data[a]=x,++this._count,!0)}set(a,x){return this._data[a]===void 0?!1:(this._data[a]=x,!0)}getAndRemove(a){const x=this.get(a);return x!==void 0?(delete this._data[a],--this._count,x):null}remove(a){return this.contains(a)?(delete this._data[a],--this._count,!0):!1}clear(){this._data={},this._count=0}get count(){return this._count}forEach(a){for(const x in this._data){const c=this._data[x];a(x,c)}}first(a){for(const x in this._data){const c=this._data[x],u=a(x,c);if(u)return u}return null}}class ti{static Eval(a,x){return a.match(/\([^()]*\)/g)?a=a.replace(/\([^()]*\)/g,c=>(c=c.slice(1,c.length-1),ti._HandleParenthesisContent(c,x))):a=ti._HandleParenthesisContent(a,x),a==="true"?!0:a==="false"?!1:ti.Eval(a,x)}static _HandleParenthesisContent(a,x){x=x||(g=>g==="true");let c;const u=a.split("||");for(const g in u)if(Object.prototype.hasOwnProperty.call(u,g)){let y=ti._SimplifyNegation(u[g].trim());const v=y.split("&&");if(v.length>1)for(let w=0;w<v.length;++w){const B=ti._SimplifyNegation(v[w].trim());if(B!=="true"&&B!=="false"?B[0]==="!"?c=!x(B.substring(1)):c=x(B):c=B==="true",!c){y="false";break}}if(c||y==="true"){c=!0;break}y!=="true"&&y!=="false"?y[0]==="!"?c=!x(y.substring(1)):c=x(y):c=y==="true"}return c?"true":"false"}static _SimplifyNegation(a){return a=a.replace(/^[\s!]+/,x=>(x=x.replace(/[\s]/g,()=>""),x.length%2?"!":"")),a=a.trim(),a==="!true"?a="false":a==="!false"&&(a="true"),a}}class Vt{static EnableFor(a){a._tags=a._tags||{},a.hasTags=()=>Vt.HasTags(a),a.addTags=x=>Vt.AddTagsTo(a,x),a.removeTags=x=>Vt.RemoveTagsFrom(a,x),a.matchesTagsQuery=x=>Vt.MatchesQuery(a,x)}static DisableFor(a){delete a._tags,delete a.hasTags,delete a.addTags,delete a.removeTags,delete a.matchesTagsQuery}static HasTags(a){if(!a._tags)return!1;const x=a._tags;for(const c in x)if(Object.prototype.hasOwnProperty.call(x,c))return!0;return!1}static GetTags(a,x=!0){if(!a._tags)return null;if(x){const c=[];for(const u in a._tags)Object.prototype.hasOwnProperty.call(a._tags,u)&&a._tags[u]===!0&&c.push(u);return c.join(" ")}else return a._tags}static AddTagsTo(a,x){if(!x||typeof x!="string")return;x.split(" ").forEach(function(u){Vt._AddTagTo(a,u)})}static _AddTagTo(a,x){x=x.trim(),!(x===""||x==="true"||x==="false")&&(x.match(/[\s]/)||x.match(/^([!]|([|]|[&]){2})/)||(Vt.EnableFor(a),a._tags[x]=!0))}static RemoveTagsFrom(a,x){if(!Vt.HasTags(a))return;const c=x.split(" ");for(const u in c)Vt._RemoveTagFrom(a,c[u])}static _RemoveTagFrom(a,x){delete a._tags[x]}static MatchesQuery(a,x){return x===void 0?!0:x===""?Vt.HasTags(a):ti.Eval(x,c=>Vt.HasTags(a)&&a._tags[c])}}const di=1/2.2,Xi=2.2,hs=(1+Math.sqrt(5))/2,Mi=.001;class Ws{static BuildArray(a,x){const c=[];for(let u=0;u<a;++u)c.push(x());return c}static BuildTuple(a,x){return Ws.BuildArray(a,x)}}function Br(F,a,x){const c=F[a];if(typeof c!="function")return null;const u=function(){const g=F.length,y=u.previous.apply(F,arguments);return x(a,g),y};return c.next=u,u.previous=c,F[a]=u,()=>{const g=u.previous;if(!g)return;const y=u.next;y?(g.next=y,y.previous=g):(g.next=void 0,F[a]=g),u.next=void 0,u.previous=void 0}}const Jr=["push","splice","pop","shift","unshift"];function Mn(F,a){const x=Jr.map(c=>Br(F,c,a));return()=>{x.forEach(c=>{c?.()})}}function $n(F){return parseInt(F.toString().replace(/\W/g,""))}function Hr(F,a,x=1401298e-51){return Math.abs(F-a)<=x}function Ir(F,a){return F===a?F:Math.random()*(a-F)+F}function u0(F,a,x){return F+(a-F)*x}function tn(F,a=0,x=1){return Math.min(x,Math.max(a,F))}function W0(F){return F-=Math.PI*2*Math.floor((F+Math.PI)/(Math.PI*2)),F}function Va(F){const a=F.toString(16);return F<=15?("0"+a).toUpperCase():a.toUpperCase()}const R0=F=>parseInt(F.toString().replace(/\W/g,""));class mr{constructor(a=0,x=0){this.x=a,this.y=x}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){const a=R0(this.x),x=R0(this.y);let c=a;return c=c*397^x,c}toArray(a,x=0){return a[x]=this.x,a[x+1]=this.y,this}fromArray(a,x=0){return mr.FromArrayToRef(a,x,this),this}asArray(){return[this.x,this.y]}copyFrom(a){return this.x=a.x,this.y=a.y,this}copyFromFloats(a,x){return this.x=a,this.y=x,this}set(a,x){return this.copyFromFloats(a,x)}setAll(a){return this.copyFromFloats(a,a)}add(a){return new this.constructor(this.x+a.x,this.y+a.y)}addToRef(a,x){return x.x=this.x+a.x,x.y=this.y+a.y,x}addInPlace(a){return this.x+=a.x,this.y+=a.y,this}addInPlaceFromFloats(a,x){return this.x+=a,this.y+=x,this}addVector3(a){return new this.constructor(this.x+a.x,this.y+a.y)}subtract(a){return new this.constructor(this.x-a.x,this.y-a.y)}subtractToRef(a,x){return x.x=this.x-a.x,x.y=this.y-a.y,x}subtractInPlace(a){return this.x-=a.x,this.y-=a.y,this}multiplyInPlace(a){return this.x*=a.x,this.y*=a.y,this}multiply(a){return new this.constructor(this.x*a.x,this.y*a.y)}multiplyToRef(a,x){return x.x=this.x*a.x,x.y=this.y*a.y,x}multiplyByFloats(a,x){return new this.constructor(this.x*a,this.y*x)}divide(a){return new this.constructor(this.x/a.x,this.y/a.y)}divideToRef(a,x){return x.x=this.x/a.x,x.y=this.y/a.y,x}divideInPlace(a){return this.x=this.x/a.x,this.y=this.y/a.y,this}minimizeInPlace(a){return this.minimizeInPlaceFromFloats(a.x,a.y)}maximizeInPlace(a){return this.maximizeInPlaceFromFloats(a.x,a.y)}minimizeInPlaceFromFloats(a,x){return this.x=Math.min(a,this.x),this.y=Math.min(x,this.y),this}maximizeInPlaceFromFloats(a,x){return this.x=Math.max(a,this.x),this.y=Math.max(x,this.y),this}subtractFromFloats(a,x){return new this.constructor(this.x-a,this.y-x)}subtractFromFloatsToRef(a,x,c){return c.copyFromFloats(this.x-a,this.y-x)}negate(){return new this.constructor(-this.x,-this.y)}negateInPlace(){return this.x*=-1,this.y*=-1,this}negateToRef(a){return a.copyFromFloats(this.x*-1,this.y*-1)}scaleInPlace(a){return this.x*=a,this.y*=a,this}scale(a){return new this.constructor(this.x*a,this.y*a)}scaleToRef(a,x){return x.x=this.x*a,x.y=this.y*a,x}scaleAndAddToRef(a,x){return x.x+=this.x*a,x.y+=this.y*a,x}equals(a){return a&&this.x===a.x&&this.y===a.y}equalsWithEpsilon(a,x=Mi){return a&&Hr(this.x,a.x,x)&&Hr(this.y,a.y,x)}equalsToFloats(a,x){return this.x===a&&this.y===x}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y))}floorToRef(a){return a.x=Math.floor(this.x),a.y=Math.floor(this.y),a}fract(){return new this.constructor(this.x-Math.floor(this.x),this.y-Math.floor(this.y))}fractToRef(a){return a.x=this.x-Math.floor(this.x),a.y=this.y-Math.floor(this.y),a}rotateToRef(a,x){const c=Math.cos(a),u=Math.sin(a),g=c*this.x-u*this.y,y=u*this.x+c*this.y;return x.x=g,x.y=y,x}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(a){return a===0||a===1?this:this.scaleInPlace(1/a)}normalizeToNew(){const a=new this.constructor;return this.normalizeToRef(a),a}normalizeToRef(a){const x=this.length();return x===0?a.copyFrom(this):this.scaleToRef(1/x,a)}clone(){return new this.constructor(this.x,this.y)}dot(a){return this.x*a.x+this.y*a.y}static Zero(){return new mr(0,0)}static One(){return new mr(1,1)}static Random(a=0,x=1){return new mr(Ir(a,x),Ir(a,x))}static RandomToRef(a=0,x=1,c){return c.copyFromFloats(Ir(a,x),Ir(a,x))}static get ZeroReadOnly(){return mr._ZeroReadOnly}static FromArray(a,x=0){return new mr(a[x],a[x+1])}static FromArrayToRef(a,x,c){return c.x=a[x],c.y=a[x+1],c}static FromFloatsToRef(a,x,c){return c.copyFromFloats(a,x),c}static CatmullRom(a,x,c,u,g){const y=g*g,v=g*y,w=.5*(2*x.x+(-a.x+c.x)*g+(2*a.x-5*x.x+4*c.x-u.x)*y+(-a.x+3*x.x-3*c.x+u.x)*v),B=.5*(2*x.y+(-a.y+c.y)*g+(2*a.y-5*x.y+4*c.y-u.y)*y+(-a.y+3*x.y-3*c.y+u.y)*v);return new a.constructor(w,B)}static ClampToRef(a,x,c,u){return u.x=tn(a.x,x.x,c.x),u.y=tn(a.y,x.y,c.y),u}static Clamp(a,x,c){const u=tn(a.x,x.x,c.x),g=tn(a.y,x.y,c.y);return new a.constructor(u,g)}static Hermite(a,x,c,u,g){const y=g*g,v=g*y,w=2*v-3*y+1,B=-2*v+3*y,W=v-2*y+g,ae=v-y,ue=a.x*w+c.x*B+x.x*W+u.x*ae,fe=a.y*w+c.y*B+x.y*W+u.y*ae;return new a.constructor(ue,fe)}static Hermite1stDerivative(a,x,c,u,g){const y=new a.constructor;return this.Hermite1stDerivativeToRef(a,x,c,u,g,y),y}static Hermite1stDerivativeToRef(a,x,c,u,g,y){const v=g*g;return y.x=(v-g)*6*a.x+(3*v-4*g+1)*x.x+(-v+g)*6*c.x+(3*v-2*g)*u.x,y.y=(v-g)*6*a.y+(3*v-4*g+1)*x.y+(-v+g)*6*c.y+(3*v-2*g)*u.y,y}static Lerp(a,x,c){const u=a.x+(x.x-a.x)*c,g=a.y+(x.y-a.y)*c;return new a.constructor(u,g)}static Dot(a,x){return a.x*x.x+a.y*x.y}static Normalize(a){const x=new a.constructor;return mr.NormalizeToRef(a,x),x}static NormalizeToRef(a,x){return a.normalizeToRef(x),x}static Minimize(a,x){const c=a.x<x.x?a.x:x.x,u=a.y<x.y?a.y:x.y;return new a.constructor(c,u)}static Maximize(a,x){const c=a.x>x.x?a.x:x.x,u=a.y>x.y?a.y:x.y;return new a.constructor(c,u)}static Transform(a,x){const c=new a.constructor;return mr.TransformToRef(a,x,c),c}static TransformToRef(a,x,c){const u=x.m,g=a.x*u[0]+a.y*u[4]+u[12],y=a.x*u[1]+a.y*u[5]+u[13];return c.x=g,c.y=y,c}static PointInTriangle(a,x,c,u){const g=.5*(-c.y*u.x+x.y*(-c.x+u.x)+x.x*(c.y-u.y)+c.x*u.y),y=g<0?-1:1,v=(x.y*u.x-x.x*u.y+(u.y-x.y)*a.x+(x.x-u.x)*a.y)*y,w=(x.x*c.y-x.y*c.x+(x.y-c.y)*a.x+(c.x-x.x)*a.y)*y;return v>0&&w>0&&v+w<2*g*y}static Distance(a,x){return Math.sqrt(mr.DistanceSquared(a,x))}static DistanceSquared(a,x){const c=a.x-x.x,u=a.y-x.y;return c*c+u*u}static Center(a,x){const c=new a.constructor;return mr.CenterToRef(a,x,c)}static CenterToRef(a,x,c){return c.copyFromFloats((a.x+x.x)/2,(a.y+x.y)/2)}static DistanceOfPointFromSegment(a,x,c){const u=mr.DistanceSquared(x,c);if(u===0)return mr.Distance(a,x);const g=c.subtract(x),y=Math.max(0,Math.min(1,mr.Dot(a.subtract(x),g)/u)),v=x.add(g.multiplyByFloats(y,y));return mr.Distance(a,v)}}mr._ZeroReadOnly=mr.Zero(),Object.defineProperties(mr.prototype,{dimension:{value:[2]},rank:{value:1}});class Ee{get x(){return this._x}set x(a){this._x=a,this._isDirty=!0}get y(){return this._y}set y(a){this._y=a,this._isDirty=!0}get z(){return this._z}set z(a){this._z=a,this._isDirty=!0}constructor(a=0,x=0,c=0){this._isDirty=!0,this._x=a,this._y=x,this._z=c}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vector3"}getHashCode(){const a=R0(this._x),x=R0(this._y),c=R0(this._z);let u=a;return u=u*397^x,u=u*397^c,u}asArray(){return[this._x,this._y,this._z]}toArray(a,x=0){return a[x]=this._x,a[x+1]=this._y,a[x+2]=this._z,this}fromArray(a,x=0){return Ee.FromArrayToRef(a,x,this),this}toQuaternion(){return Wi.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(a){return this._x+=a._x,this._y+=a._y,this._z+=a._z,this._isDirty=!0,this}addInPlaceFromFloats(a,x,c){return this._x+=a,this._y+=x,this._z+=c,this._isDirty=!0,this}add(a){return new this.constructor(this._x+a._x,this._y+a._y,this._z+a._z)}addToRef(a,x){return x.copyFromFloats(this._x+a._x,this._y+a._y,this._z+a._z)}subtractInPlace(a){return this._x-=a._x,this._y-=a._y,this._z-=a._z,this._isDirty=!0,this}subtract(a){return new this.constructor(this._x-a._x,this._y-a._y,this._z-a._z)}subtractToRef(a,x){return this.subtractFromFloatsToRef(a._x,a._y,a._z,x)}subtractFromFloats(a,x,c){return new this.constructor(this._x-a,this._y-x,this._z-c)}subtractFromFloatsToRef(a,x,c,u){return u.copyFromFloats(this._x-a,this._y-x,this._z-c)}negate(){return new this.constructor(-this._x,-this._y,-this._z)}negateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}negateToRef(a){return a.copyFromFloats(this._x*-1,this._y*-1,this._z*-1)}scaleInPlace(a){return this._x*=a,this._y*=a,this._z*=a,this._isDirty=!0,this}scale(a){return new this.constructor(this._x*a,this._y*a,this._z*a)}scaleToRef(a,x){return x.copyFromFloats(this._x*a,this._y*a,this._z*a)}getNormalToRef(a){const x=this.length();let c=Math.acos(this.y/x);const u=Math.atan2(this.z,this.x);c>Math.PI/2?c-=Math.PI/2:c+=Math.PI/2;const g=x*Math.sin(c)*Math.cos(u),y=x*Math.cos(c),v=x*Math.sin(c)*Math.sin(u);return a.set(g,y,v),a}applyRotationQuaternionToRef(a,x){const c=this._x,u=this._y,g=this._z,y=a._x,v=a._y,w=a._z,B=a._w,W=2*(v*g-w*u),ae=2*(w*c-y*g),ue=2*(y*u-v*c);return x._x=c+B*W+v*ue-w*ae,x._y=u+B*ae+w*W-y*ue,x._z=g+B*ue+y*ae-v*W,x._isDirty=!0,x}applyRotationQuaternionInPlace(a){return this.applyRotationQuaternionToRef(a,this)}applyRotationQuaternion(a){return this.applyRotationQuaternionToRef(a,new this.constructor)}scaleAndAddToRef(a,x){return x.addInPlaceFromFloats(this._x*a,this._y*a,this._z*a)}projectOnPlane(a,x){const c=new this.constructor;return this.projectOnPlaneToRef(a,x,c),c}projectOnPlaneToRef(a,x,c){const u=a.normal,g=a.d,y=gs.Vector3[0];this.subtractToRef(x,y),y.normalize();const v=Ee.Dot(y,u);if(Math.abs(v)<1e-10)c.setAll(1/0);else{const w=-(Ee.Dot(x,u)+g)/v,B=y.scaleInPlace(w);x.addToRef(B,c)}return c}equals(a){return a&&this._x===a._x&&this._y===a._y&&this._z===a._z}equalsWithEpsilon(a,x=Mi){return a&&Hr(this._x,a._x,x)&&Hr(this._y,a._y,x)&&Hr(this._z,a._z,x)}equalsToFloats(a,x,c){return this._x===a&&this._y===x&&this._z===c}multiplyInPlace(a){return this._x*=a._x,this._y*=a._y,this._z*=a._z,this._isDirty=!0,this}multiply(a){return this.multiplyByFloats(a._x,a._y,a._z)}multiplyToRef(a,x){return x.copyFromFloats(this._x*a._x,this._y*a._y,this._z*a._z)}multiplyByFloats(a,x,c){return new this.constructor(this._x*a,this._y*x,this._z*c)}divide(a){return new this.constructor(this._x/a._x,this._y/a._y,this._z/a._z)}divideToRef(a,x){return x.copyFromFloats(this._x/a._x,this._y/a._y,this._z/a._z)}divideInPlace(a){return this._x=this._x/a._x,this._y=this._y/a._y,this._z=this._z/a._z,this._isDirty=!0,this}minimizeInPlace(a){return this.minimizeInPlaceFromFloats(a._x,a._y,a._z)}maximizeInPlace(a){return this.maximizeInPlaceFromFloats(a._x,a._y,a._z)}minimizeInPlaceFromFloats(a,x,c){return a<this._x&&(this.x=a),x<this._y&&(this.y=x),c<this._z&&(this.z=c),this}maximizeInPlaceFromFloats(a,x,c){return a>this._x&&(this.x=a),x>this._y&&(this.y=x),c>this._z&&(this.z=c),this}isNonUniformWithinEpsilon(a){const x=Math.abs(this._x),c=Math.abs(this._y);if(!Hr(x,c,a))return!0;const u=Math.abs(this._z);return!Hr(x,u,a)||!Hr(c,u,a)}get isNonUniform(){const a=Math.abs(this._x),x=Math.abs(this._y);if(a!==x)return!0;const c=Math.abs(this._z);return a!==c}floorToRef(a){return a._x=Math.floor(this._x),a._y=Math.floor(this._y),a._z=Math.floor(this._z),a._isDirty=!0,a}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z))}fractToRef(a){return a._x=this.x-Math.floor(this._x),a._y=this.y-Math.floor(this._y),a._z=this.z-Math.floor(this._z),a._isDirty=!0,a}fract(){return new this.constructor(this.x-Math.floor(this._x),this.y-Math.floor(this._y),this.z-Math.floor(this._z))}length(){return Math.sqrt(this.lengthSquared())}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return this._x*this._y*this._z===0}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(a){if(a=a.toLowerCase(),a==="xyz")return this;const x=gs.Vector3[0].copyFrom(this);return this.x=x[a[0]],this.y=x[a[1]],this.z=x[a[2]],this}rotateByQuaternionToRef(a,x){return a.toRotationMatrix(gs.Matrix[0]),Ee.TransformCoordinatesToRef(this,gs.Matrix[0],x),x}rotateByQuaternionAroundPointToRef(a,x,c){return this.subtractToRef(x,gs.Vector3[0]),gs.Vector3[0].rotateByQuaternionToRef(a,gs.Vector3[0]),x.addToRef(gs.Vector3[0],c),c}cross(a){const x=new this.constructor;return Ee.CrossToRef(this,a,x)}normalizeFromLength(a){return a===0||a===1?this:this.scaleInPlace(1/a)}normalizeToNew(){const a=new this.constructor(0,0,0);return this.normalizeToRef(a),a}normalizeToRef(a){const x=this.length();return x===0||x===1?a.copyFrom(this):this.scaleToRef(1/x,a)}clone(){return new this.constructor(this._x,this._y,this._z)}copyFrom(a){return this.copyFromFloats(a._x,a._y,a._z)}copyFromFloats(a,x,c){return this._x=a,this._y=x,this._z=c,this._isDirty=!0,this}set(a,x,c){return this.copyFromFloats(a,x,c)}setAll(a){return this._x=this._y=this._z=a,this._isDirty=!0,this}static GetClipFactor(a,x,c,u){const g=Ee.Dot(a,c),y=Ee.Dot(x,c);return(g-u)/(g-y)}static GetAngleBetweenVectors(a,x,c){const u=a.normalizeToRef(gs.Vector3[1]),g=x.normalizeToRef(gs.Vector3[2]);let y=Ee.Dot(u,g);y=tn(y,-1,1);const v=Math.acos(y),w=gs.Vector3[3];return Ee.CrossToRef(u,g,w),Ee.Dot(w,c)>0?isNaN(v)?0:v:isNaN(v)?-Math.PI:-Math.acos(y)}static GetAngleBetweenVectorsOnPlane(a,x,c){gs.Vector3[0].copyFrom(a);const u=gs.Vector3[0];gs.Vector3[1].copyFrom(x);const g=gs.Vector3[1];gs.Vector3[2].copyFrom(c);const y=gs.Vector3[2],v=gs.Vector3[3],w=gs.Vector3[4];u.normalize(),g.normalize(),y.normalize(),Ee.CrossToRef(y,u,v),Ee.CrossToRef(v,y,w);const B=Math.atan2(Ee.Dot(g,v),Ee.Dot(g,w));return W0(B)}static PitchYawRollToMoveBetweenPointsToRef(a,x,c){const u=Yt.Vector3[0];return x.subtractToRef(a,u),c._y=Math.atan2(u.x,u.z)||0,c._x=Math.atan2(Math.sqrt(u.x**2+u.z**2),u.y)||0,c._z=0,c._isDirty=!0,c}static PitchYawRollToMoveBetweenPoints(a,x){const c=Ee.Zero();return Ee.PitchYawRollToMoveBetweenPointsToRef(a,x,c)}static SlerpToRef(a,x,c,u){c=tn(c,0,1);const g=gs.Vector3[0],y=gs.Vector3[1];g.copyFrom(a);const v=g.length();g.normalizeFromLength(v),y.copyFrom(x);const w=y.length();y.normalizeFromLength(w);const B=Ee.Dot(g,y);let W,ae;if(B<1-Mi){const ue=Math.acos(B),fe=1/Math.sin(ue);W=Math.sin((1-c)*ue)*fe,ae=Math.sin(c*ue)*fe}else W=1-c,ae=c;return g.scaleInPlace(W),y.scaleInPlace(ae),u.copyFrom(g).addInPlace(y),u.scaleInPlace(u0(v,w,c)),u}static SmoothToRef(a,x,c,u,g){return Ee.SlerpToRef(a,x,u===0?1:c/u,g),g}static FromArray(a,x=0){return new Ee(a[x],a[x+1],a[x+2])}static FromFloatArray(a,x){return Ee.FromArray(a,x)}static FromArrayToRef(a,x,c){return c._x=a[x],c._y=a[x+1],c._z=a[x+2],c._isDirty=!0,c}static FromFloatArrayToRef(a,x,c){return Ee.FromArrayToRef(a,x,c)}static FromFloatsToRef(a,x,c,u){return u.copyFromFloats(a,x,c),u}static Zero(){return new Ee(0,0,0)}static One(){return new Ee(1,1,1)}static Up(){return new Ee(0,1,0)}static get UpReadOnly(){return Ee._UpReadOnly}static get DownReadOnly(){return Ee._DownReadOnly}static get RightReadOnly(){return Ee._RightReadOnly}static get LeftReadOnly(){return Ee._LeftReadOnly}static get LeftHandedForwardReadOnly(){return Ee._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return Ee._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return Ee._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return Ee._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return Ee._ZeroReadOnly}static get OneReadOnly(){return Ee._OneReadOnly}static Down(){return new Ee(0,-1,0)}static Forward(a=!1){return new Ee(0,0,a?-1:1)}static Backward(a=!1){return new Ee(0,0,a?1:-1)}static Right(){return new Ee(1,0,0)}static Left(){return new Ee(-1,0,0)}static Random(a=0,x=1){return new Ee(Ir(a,x),Ir(a,x),Ir(a,x))}static RandomToRef(a=0,x=1,c){return c.copyFromFloats(Ir(a,x),Ir(a,x),Ir(a,x))}static TransformCoordinates(a,x){const c=Ee.Zero();return Ee.TransformCoordinatesToRef(a,x,c),c}static TransformCoordinatesToRef(a,x,c){return Ee.TransformCoordinatesFromFloatsToRef(a._x,a._y,a._z,x,c),c}static TransformCoordinatesFromFloatsToRef(a,x,c,u,g){const y=u.m,v=a*y[0]+x*y[4]+c*y[8]+y[12],w=a*y[1]+x*y[5]+c*y[9]+y[13],B=a*y[2]+x*y[6]+c*y[10]+y[14],W=1/(a*y[3]+x*y[7]+c*y[11]+y[15]);return g._x=v*W,g._y=w*W,g._z=B*W,g._isDirty=!0,g}static TransformNormal(a,x){const c=Ee.Zero();return Ee.TransformNormalToRef(a,x,c),c}static TransformNormalToRef(a,x,c){return this.TransformNormalFromFloatsToRef(a._x,a._y,a._z,x,c),c}static TransformNormalFromFloatsToRef(a,x,c,u,g){const y=u.m;return g._x=a*y[0]+x*y[4]+c*y[8],g._y=a*y[1]+x*y[5]+c*y[9],g._z=a*y[2]+x*y[6]+c*y[10],g._isDirty=!0,g}static CatmullRom(a,x,c,u,g){const y=g*g,v=g*y,w=.5*(2*x._x+(-a._x+c._x)*g+(2*a._x-5*x._x+4*c._x-u._x)*y+(-a._x+3*x._x-3*c._x+u._x)*v),B=.5*(2*x._y+(-a._y+c._y)*g+(2*a._y-5*x._y+4*c._y-u._y)*y+(-a._y+3*x._y-3*c._y+u._y)*v),W=.5*(2*x._z+(-a._z+c._z)*g+(2*a._z-5*x._z+4*c._z-u._z)*y+(-a._z+3*x._z-3*c._z+u._z)*v);return new a.constructor(w,B,W)}static Clamp(a,x,c){const u=new a.constructor;return Ee.ClampToRef(a,x,c,u),u}static ClampToRef(a,x,c,u){let g=a._x;g=g>c._x?c._x:g,g=g<x._x?x._x:g;let y=a._y;y=y>c._y?c._y:y,y=y<x._y?x._y:y;let v=a._z;return v=v>c._z?c._z:v,v=v<x._z?x._z:v,u.copyFromFloats(g,y,v),u}static CheckExtends(a,x,c){x.minimizeInPlace(a),c.maximizeInPlace(a)}static Hermite(a,x,c,u,g){const y=g*g,v=g*y,w=2*v-3*y+1,B=-2*v+3*y,W=v-2*y+g,ae=v-y,ue=a._x*w+c._x*B+x._x*W+u._x*ae,fe=a._y*w+c._y*B+x._y*W+u._y*ae,Re=a._z*w+c._z*B+x._z*W+u._z*ae;return new a.constructor(ue,fe,Re)}static Hermite1stDerivative(a,x,c,u,g){const y=new a.constructor;return this.Hermite1stDerivativeToRef(a,x,c,u,g,y),y}static Hermite1stDerivativeToRef(a,x,c,u,g,y){const v=g*g;return y._x=(v-g)*6*a._x+(3*v-4*g+1)*x._x+(-v+g)*6*c._x+(3*v-2*g)*u._x,y._y=(v-g)*6*a._y+(3*v-4*g+1)*x._y+(-v+g)*6*c._y+(3*v-2*g)*u._y,y._z=(v-g)*6*a._z+(3*v-4*g+1)*x._z+(-v+g)*6*c._z+(3*v-2*g)*u._z,y._isDirty=!0,y}static Lerp(a,x,c){const u=new a.constructor(0,0,0);return Ee.LerpToRef(a,x,c,u),u}static LerpToRef(a,x,c,u){return u._x=a._x+(x._x-a._x)*c,u._y=a._y+(x._y-a._y)*c,u._z=a._z+(x._z-a._z)*c,u._isDirty=!0,u}static Dot(a,x){return a._x*x._x+a._y*x._y+a._z*x._z}dot(a){return this._x*a._x+this._y*a._y+this._z*a._z}static Cross(a,x){const c=new a.constructor;return Ee.CrossToRef(a,x,c),c}static CrossToRef(a,x,c){const u=a._y*x._z-a._z*x._y,g=a._z*x._x-a._x*x._z,y=a._x*x._y-a._y*x._x;return c.copyFromFloats(u,g,y),c}static Normalize(a){const x=Ee.Zero();return Ee.NormalizeToRef(a,x),x}static NormalizeToRef(a,x){return a.normalizeToRef(x),x}static Project(a,x,c,u){const g=new a.constructor;return Ee.ProjectToRef(a,x,c,u,g),g}static ProjectToRef(a,x,c,u,g){const y=u.width,v=u.height,w=u.x,B=u.y,W=gs.Matrix[1];vt.FromValuesToRef(y/2,0,0,0,0,-v/2,0,0,0,0,.5,0,w+y/2,v/2+B,.5,1,W);const ae=gs.Matrix[0];return x.multiplyToRef(c,ae),ae.multiplyToRef(W,ae),Ee.TransformCoordinatesToRef(a,ae,g),g}static Reflect(a,x){return this.ReflectToRef(a,x,new Ee)}static ReflectToRef(a,x,c){const u=Yt.Vector3[0];return u.copyFrom(x).scaleInPlace(2*Ee.Dot(a,x)),c.copyFrom(a).subtractInPlace(u)}static _UnprojectFromInvertedMatrixToRef(a,x,c){Ee.TransformCoordinatesToRef(a,x,c);const u=x.m,g=a._x*u[3]+a._y*u[7]+a._z*u[11]+u[15];return Hr(g,1)&&c.scaleInPlace(1/g),c}static UnprojectFromTransform(a,x,c,u,g){return this.Unproject(a,x,c,u,g,vt.IdentityReadOnly)}static Unproject(a,x,c,u,g,y){const v=new a.constructor;return Ee.UnprojectToRef(a,x,c,u,g,y,v),v}static UnprojectToRef(a,x,c,u,g,y,v){return Ee.UnprojectFloatsToRef(a._x,a._y,a._z,x,c,u,g,y,v),v}static UnprojectFloatsToRef(a,x,c,u,g,y,v,w,B){const W=gs.Matrix[0];y.multiplyToRef(v,W),W.multiplyToRef(w,W),W.invert();const ae=gs.Vector3[0];return ae.x=a/u*2-1,ae.y=-(x/g*2-1),tr.LastCreatedEngine?.isNDCHalfZRange?ae.z=c:ae.z=2*c-1,Ee._UnprojectFromInvertedMatrixToRef(ae,W,B),B}static Minimize(a,x){const c=new a.constructor;return c.copyFrom(a),c.minimizeInPlace(x),c}static Maximize(a,x){const c=new a.constructor;return c.copyFrom(a),c.maximizeInPlace(x),c}static Distance(a,x){return Math.sqrt(Ee.DistanceSquared(a,x))}static DistanceSquared(a,x){const c=a._x-x._x,u=a._y-x._y,g=a._z-x._z;return c*c+u*u+g*g}static ProjectOnTriangleToRef(a,x,c,u,g){const y=gs.Vector3[0],v=gs.Vector3[1],w=gs.Vector3[2],B=gs.Vector3[3],W=gs.Vector3[4];c.subtractToRef(x,y),u.subtractToRef(x,v),u.subtractToRef(c,w);const ae=y.length(),ue=v.length(),fe=w.length();if(ae<Mi||ue<Mi||fe<Mi)return g.copyFrom(x),Ee.Distance(a,x);a.subtractToRef(x,W),Ee.CrossToRef(y,v,B);const Re=B.length();if(Re<Mi)return g.copyFrom(x),Ee.Distance(a,x);B.normalizeFromLength(Re);let _e=W.length();if(_e<Mi)return g.copyFrom(x),0;W.normalizeFromLength(_e);const Be=Ee.Dot(B,W),tt=gs.Vector3[5],$e=gs.Vector3[6];tt.copyFrom(B).scaleInPlace(-_e*Be),$e.copyFrom(a).addInPlace(tt);const Et=gs.Vector3[4],ft=gs.Vector3[5],dt=gs.Vector3[7],ut=gs.Vector3[8];Et.copyFrom(y).scaleInPlace(1/ae),ut.copyFrom(v).scaleInPlace(1/ue),Et.addInPlace(ut).scaleInPlace(-1),ft.copyFrom(y).scaleInPlace(-1/ae),ut.copyFrom(w).scaleInPlace(1/fe),ft.addInPlace(ut).scaleInPlace(-1),dt.copyFrom(w).scaleInPlace(-1/fe),ut.copyFrom(v).scaleInPlace(-1/ue),dt.addInPlace(ut).scaleInPlace(-1);const Mt=gs.Vector3[9];let ai;Mt.copyFrom($e).subtractInPlace(x),Ee.CrossToRef(Et,Mt,ut),ai=Ee.Dot(ut,B);const Yi=ai;Mt.copyFrom($e).subtractInPlace(c),Ee.CrossToRef(ft,Mt,ut),ai=Ee.Dot(ut,B);const Vi=ai;Mt.copyFrom($e).subtractInPlace(u),Ee.CrossToRef(dt,Mt,ut),ai=Ee.Dot(ut,B);const Js=ai,Rr=gs.Vector3[10];let _r,Vr;Yi>0&&Vi<0?(Rr.copyFrom(y),_r=x,Vr=c):Vi>0&&Js<0?(Rr.copyFrom(w),_r=c,Vr=u):(Rr.copyFrom(v).scaleInPlace(-1),_r=u,Vr=x);const Ja=gs.Vector3[9],ta=gs.Vector3[4];if(_r.subtractToRef($e,ut),Vr.subtractToRef($e,Ja),Ee.CrossToRef(ut,Ja,ta),!(Ee.Dot(ta,B)<0))return g.copyFrom($e),Math.abs(_e*Be);const k0=gs.Vector3[5];Ee.CrossToRef(Rr,ta,k0),k0.normalize();const B0=gs.Vector3[9];B0.copyFrom(_r).subtractInPlace($e);const Hx=B0.length();if(Hx<Mi)return g.copyFrom(_r),Ee.Distance(a,_r);B0.normalizeFromLength(Hx);const Ex=Ee.Dot(k0,B0),E2=gs.Vector3[7];E2.copyFrom($e).addInPlace(k0.scaleInPlace(Hx*Ex)),ut.copyFrom(E2).subtractInPlace(_r),_e=Rr.length(),Rr.normalizeFromLength(_e);let dh=Ee.Dot(ut,Rr)/Math.max(_e,Mi);return dh=tn(dh,0,1),E2.copyFrom(_r).addInPlace(Rr.scaleInPlace(dh*_e)),g.copyFrom(E2),Ee.Distance(a,E2)}static Center(a,x){return Ee.CenterToRef(a,x,Ee.Zero())}static CenterToRef(a,x,c){return c.copyFromFloats((a._x+x._x)/2,(a._y+x._y)/2,(a._z+x._z)/2)}static RotationFromAxis(a,x,c){const u=new a.constructor;return Ee.RotationFromAxisToRef(a,x,c,u),u}static RotationFromAxisToRef(a,x,c,u){const g=gs.Quaternion[0];return Wi.RotationQuaternionFromAxisToRef(a,x,c,g),g.toEulerAnglesToRef(u),u}}Ee._UpReadOnly=Ee.Up(),Ee._DownReadOnly=Ee.Down(),Ee._LeftHandedForwardReadOnly=Ee.Forward(!1),Ee._RightHandedForwardReadOnly=Ee.Forward(!0),Ee._LeftHandedBackwardReadOnly=Ee.Backward(!1),Ee._RightHandedBackwardReadOnly=Ee.Backward(!0),Ee._RightReadOnly=Ee.Right(),Ee._LeftReadOnly=Ee.Left(),Ee._ZeroReadOnly=Ee.Zero(),Ee._OneReadOnly=Ee.One(),Object.defineProperties(Ee.prototype,{dimension:{value:[3]},rank:{value:1}});class an{constructor(a=0,x=0,c=0,u=0){this.x=a,this.y=x,this.z=c,this.w=u}toString(){return`{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`}getClassName(){return"Vector4"}getHashCode(){const a=R0(this.x),x=R0(this.y),c=R0(this.z),u=R0(this.w);let g=a;return g=g*397^x,g=g*397^c,g=g*397^u,g}asArray(){return[this.x,this.y,this.z,this.w]}toArray(a,x){return x===void 0&&(x=0),a[x]=this.x,a[x+1]=this.y,a[x+2]=this.z,a[x+3]=this.w,this}fromArray(a,x=0){return an.FromArrayToRef(a,x,this),this}addInPlace(a){return this.x+=a.x,this.y+=a.y,this.z+=a.z,this.w+=a.w,this}addInPlaceFromFloats(a,x,c,u){return this.x+=a,this.y+=x,this.z+=c,this.w+=u,this}add(a){return new this.constructor(this.x+a.x,this.y+a.y,this.z+a.z,this.w+a.w)}addToRef(a,x){return x.x=this.x+a.x,x.y=this.y+a.y,x.z=this.z+a.z,x.w=this.w+a.w,x}subtractInPlace(a){return this.x-=a.x,this.y-=a.y,this.z-=a.z,this.w-=a.w,this}subtract(a){return new this.constructor(this.x-a.x,this.y-a.y,this.z-a.z,this.w-a.w)}subtractToRef(a,x){return x.x=this.x-a.x,x.y=this.y-a.y,x.z=this.z-a.z,x.w=this.w-a.w,x}subtractFromFloats(a,x,c,u){return new this.constructor(this.x-a,this.y-x,this.z-c,this.w-u)}subtractFromFloatsToRef(a,x,c,u,g){return g.x=this.x-a,g.y=this.y-x,g.z=this.z-c,g.w=this.w-u,g}negate(){return new this.constructor(-this.x,-this.y,-this.z,-this.w)}negateInPlace(){return this.x*=-1,this.y*=-1,this.z*=-1,this.w*=-1,this}negateToRef(a){return a.copyFromFloats(this.x*-1,this.y*-1,this.z*-1,this.w*-1)}scaleInPlace(a){return this.x*=a,this.y*=a,this.z*=a,this.w*=a,this}scale(a){return new this.constructor(this.x*a,this.y*a,this.z*a,this.w*a)}scaleToRef(a,x){return x.x=this.x*a,x.y=this.y*a,x.z=this.z*a,x.w=this.w*a,x}scaleAndAddToRef(a,x){return x.x+=this.x*a,x.y+=this.y*a,x.z+=this.z*a,x.w+=this.w*a,x}equals(a){return a&&this.x===a.x&&this.y===a.y&&this.z===a.z&&this.w===a.w}equalsWithEpsilon(a,x=Mi){return a&&Hr(this.x,a.x,x)&&Hr(this.y,a.y,x)&&Hr(this.z,a.z,x)&&Hr(this.w,a.w,x)}equalsToFloats(a,x,c,u){return this.x===a&&this.y===x&&this.z===c&&this.w===u}multiplyInPlace(a){return this.x*=a.x,this.y*=a.y,this.z*=a.z,this.w*=a.w,this}multiply(a){return new this.constructor(this.x*a.x,this.y*a.y,this.z*a.z,this.w*a.w)}multiplyToRef(a,x){return x.x=this.x*a.x,x.y=this.y*a.y,x.z=this.z*a.z,x.w=this.w*a.w,x}multiplyByFloats(a,x,c,u){return new this.constructor(this.x*a,this.y*x,this.z*c,this.w*u)}divide(a){return new this.constructor(this.x/a.x,this.y/a.y,this.z/a.z,this.w/a.w)}divideToRef(a,x){return x.x=this.x/a.x,x.y=this.y/a.y,x.z=this.z/a.z,x.w=this.w/a.w,x}divideInPlace(a){return this.divideToRef(a,this)}minimizeInPlace(a){return a.x<this.x&&(this.x=a.x),a.y<this.y&&(this.y=a.y),a.z<this.z&&(this.z=a.z),a.w<this.w&&(this.w=a.w),this}maximizeInPlace(a){return a.x>this.x&&(this.x=a.x),a.y>this.y&&(this.y=a.y),a.z>this.z&&(this.z=a.z),a.w>this.w&&(this.w=a.w),this}minimizeInPlaceFromFloats(a,x,c,u){return this.x=Math.min(a,this.x),this.y=Math.min(x,this.y),this.z=Math.min(c,this.z),this.w=Math.min(u,this.w),this}maximizeInPlaceFromFloats(a,x,c,u){return this.x=Math.max(a,this.x),this.y=Math.max(x,this.y),this.z=Math.max(c,this.z),this.w=Math.max(u,this.w),this}floorToRef(a){return a.x=Math.floor(this.x),a.y=Math.floor(this.y),a.z=Math.floor(this.z),a.w=Math.floor(this.w),a}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z),Math.floor(this.w))}fractToRef(a){return a.x=this.x-Math.floor(this.x),a.y=this.y-Math.floor(this.y),a.z=this.z-Math.floor(this.z),a.w=this.w-Math.floor(this.w),a}fract(){return new this.constructor(this.x-Math.floor(this.x),this.y-Math.floor(this.y),this.z-Math.floor(this.z),this.w-Math.floor(this.w))}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(a){return a===0||a===1?this:this.scaleInPlace(1/a)}normalizeToNew(){const a=new this.constructor;return this.normalizeToRef(a),a}normalizeToRef(a){const x=this.length();return x===0||x===1?a.copyFrom(this):this.scaleToRef(1/x,a)}toVector3(){return new Ee(this.x,this.y,this.z)}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copyFrom(a){return this.x=a.x,this.y=a.y,this.z=a.z,this.w=a.w,this}copyFromFloats(a,x,c,u){return this.x=a,this.y=x,this.z=c,this.w=u,this}set(a,x,c,u){return this.copyFromFloats(a,x,c,u)}setAll(a){return this.x=this.y=this.z=this.w=a,this}dot(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w}static FromArray(a,x){return x||(x=0),new an(a[x],a[x+1],a[x+2],a[x+3])}static FromArrayToRef(a,x,c){return c.x=a[x],c.y=a[x+1],c.z=a[x+2],c.w=a[x+3],c}static FromFloatArrayToRef(a,x,c){return an.FromArrayToRef(a,x,c),c}static FromFloatsToRef(a,x,c,u,g){return g.x=a,g.y=x,g.z=c,g.w=u,g}static Zero(){return new an(0,0,0,0)}static One(){return new an(1,1,1,1)}static Random(a=0,x=1){return new an(Ir(a,x),Ir(a,x),Ir(a,x),Ir(a,x))}static RandomToRef(a=0,x=1,c){return c.copyFromFloats(Ir(a,x),Ir(a,x),Ir(a,x),Ir(a,x))}static Clamp(a,x,c){const u=new a.constructor;return an.ClampToRef(a,x,c,u),u}static ClampToRef(a,x,c,u){return u.copyFromFloats(tn(a.x,x.x,c.x),tn(a.y,x.y,c.y),tn(a.z,x.z,c.z),tn(a.w,x.w,c.w))}static CheckExtends(a,x,c){x.minimizeInPlace(a),c.maximizeInPlace(a)}static get ZeroReadOnly(){return an._ZeroReadOnly}static Normalize(a){const x=an.Zero();return an.NormalizeToRef(a,x),x}static NormalizeToRef(a,x){return a.normalizeToRef(x),x}static Minimize(a,x){const c=new a.constructor;return c.copyFrom(a),c.minimizeInPlace(x),c}static Maximize(a,x){const c=new a.constructor;return c.copyFrom(a),c.maximizeInPlace(x),c}static Distance(a,x){return Math.sqrt(an.DistanceSquared(a,x))}static DistanceSquared(a,x){const c=a.x-x.x,u=a.y-x.y,g=a.z-x.z,y=a.w-x.w;return c*c+u*u+g*g+y*y}static Center(a,x){return an.CenterToRef(a,x,an.Zero())}static CenterToRef(a,x,c){return c.copyFromFloats((a.x+x.x)/2,(a.y+x.y)/2,(a.z+x.z)/2,(a.w+x.w)/2)}static TransformCoordinates(a,x){const c=an.Zero();return an.TransformCoordinatesToRef(a,x,c),c}static TransformCoordinatesToRef(a,x,c){return an.TransformCoordinatesFromFloatsToRef(a._x,a._y,a._z,x,c),c}static TransformCoordinatesFromFloatsToRef(a,x,c,u,g){const y=u.m,v=a*y[0]+x*y[4]+c*y[8]+y[12],w=a*y[1]+x*y[5]+c*y[9]+y[13],B=a*y[2]+x*y[6]+c*y[10]+y[14],W=a*y[3]+x*y[7]+c*y[11]+y[15];return g.x=v,g.y=w,g.z=B,g.w=W,g}static TransformNormal(a,x){const c=new a.constructor;return an.TransformNormalToRef(a,x,c),c}static TransformNormalToRef(a,x,c){const u=x.m,g=a.x*u[0]+a.y*u[4]+a.z*u[8],y=a.x*u[1]+a.y*u[5]+a.z*u[9],v=a.x*u[2]+a.y*u[6]+a.z*u[10];return c.x=g,c.y=y,c.z=v,c.w=a.w,c}static TransformNormalFromFloatsToRef(a,x,c,u,g,y){const v=g.m;return y.x=a*v[0]+x*v[4]+c*v[8],y.y=a*v[1]+x*v[5]+c*v[9],y.z=a*v[2]+x*v[6]+c*v[10],y.w=u,y}static FromVector3(a,x=0){return new an(a._x,a._y,a._z,x)}static Dot(a,x){return a.dot(x)}}an._ZeroReadOnly=an.Zero(),Object.defineProperties(an.prototype,{dimension:{value:[4]},rank:{value:1}});class Wi{get x(){return this._x}set x(a){this._x=a,this._isDirty=!0}get y(){return this._y}set y(a){this._y=a,this._isDirty=!0}get z(){return this._z}set z(a){this._z=a,this._isDirty=!0}get w(){return this._w}set w(a){this._w=a,this._isDirty=!0}constructor(a=0,x=0,c=0,u=1){this._isDirty=!0,this._x=a,this._y=x,this._z=c,this._w=u}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){const a=R0(this._x),x=R0(this._y),c=R0(this._z),u=R0(this._w);let g=a;return g=g*397^x,g=g*397^c,g=g*397^u,g}asArray(){return[this._x,this._y,this._z,this._w]}toArray(a,x=0){return a[x]=this._x,a[x+1]=this._y,a[x+2]=this._z,a[x+3]=this._w,this}fromArray(a,x=0){return Wi.FromArrayToRef(a,x,this)}equals(a){return a&&this._x===a._x&&this._y===a._y&&this._z===a._z&&this._w===a._w}equalsWithEpsilon(a,x=Mi){return a&&Hr(this._x,a._x,x)&&Hr(this._y,a._y,x)&&Hr(this._z,a._z,x)&&Hr(this._w,a._w,x)}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copyFrom(a){return this._x=a._x,this._y=a._y,this._z=a._z,this._w=a._w,this._isDirty=!0,this}copyFromFloats(a,x,c,u){return this._x=a,this._y=x,this._z=c,this._w=u,this._isDirty=!0,this}set(a,x,c,u){return this.copyFromFloats(a,x,c,u)}setAll(a){return this.copyFromFloats(a,a,a,a)}add(a){return new this.constructor(this._x+a._x,this._y+a._y,this._z+a._z,this._w+a._w)}addInPlace(a){return this._x+=a._x,this._y+=a._y,this._z+=a._z,this._w+=a._w,this._isDirty=!0,this}addToRef(a,x){return x._x=this._x+a._x,x._y=this._y+a._y,x._z=this._z+a._z,x._w=this._w+a._w,x._isDirty=!0,x}addInPlaceFromFloats(a,x,c,u){return this._x+=a,this._y+=x,this._z+=c,this._w+=u,this._isDirty=!0,this}subtractToRef(a,x){return x._x=this._x-a._x,x._y=this._y-a._y,x._z=this._z-a._z,x._w=this._w-a._w,x._isDirty=!0,x}subtractFromFloats(a,x,c,u){return this.subtractFromFloatsToRef(a,x,c,u,new this.constructor)}subtractFromFloatsToRef(a,x,c,u,g){return g._x=this._x-a,g._y=this._y-x,g._z=this._z-c,g._w=this._w-u,g._isDirty=!0,g}subtract(a){return new this.constructor(this._x-a._x,this._y-a._y,this._z-a._z,this._w-a._w)}subtractInPlace(a){return this._x-=a._x,this._y-=a._y,this._z-=a._z,this._w-=a._w,this._isDirty=!0,this}scale(a){return new this.constructor(this._x*a,this._y*a,this._z*a,this._w*a)}scaleToRef(a,x){return x._x=this._x*a,x._y=this._y*a,x._z=this._z*a,x._w=this._w*a,x._isDirty=!0,x}scaleInPlace(a){return this._x*=a,this._y*=a,this._z*=a,this._w*=a,this._isDirty=!0,this}scaleAndAddToRef(a,x){return x._x+=this._x*a,x._y+=this._y*a,x._z+=this._z*a,x._w+=this._w*a,x._isDirty=!0,x}multiply(a){const x=new this.constructor(0,0,0,1);return this.multiplyToRef(a,x),x}multiplyToRef(a,x){const c=this._x*a._w+this._y*a._z-this._z*a._y+this._w*a._x,u=-this._x*a._z+this._y*a._w+this._z*a._x+this._w*a._y,g=this._x*a._y-this._y*a._x+this._z*a._w+this._w*a._z,y=-this._x*a._x-this._y*a._y-this._z*a._z+this._w*a._w;return x.copyFromFloats(c,u,g,y),x}multiplyInPlace(a){return this.multiplyToRef(a,this)}multiplyByFloats(a,x,c,u){return this._x*=a,this._y*=x,this._z*=c,this._w*=u,this._isDirty=!0,this}divide(a){throw new ReferenceError("Can not divide a quaternion")}divideToRef(a,x){throw new ReferenceError("Can not divide a quaternion")}divideInPlace(a){throw new ReferenceError("Can not divide a quaternion")}minimizeInPlace(){throw new ReferenceError("Can not minimize a quaternion")}minimizeInPlaceFromFloats(){throw new ReferenceError("Can not minimize a quaternion")}maximizeInPlace(){throw new ReferenceError("Can not maximize a quaternion")}maximizeInPlaceFromFloats(){throw new ReferenceError("Can not maximize a quaternion")}negate(){return this.negateToRef(new this.constructor)}negateInPlace(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this._w=-this._w,this._isDirty=!0,this}negateToRef(a){return a._x=-this._x,a._y=-this._y,a._z=-this._z,a._w=-this._w,a._isDirty=!0,a}equalsToFloats(a,x,c,u){return this._x===a&&this._y===x&&this._z===c&&this._w===u}floorToRef(a){throw new ReferenceError("Can not floor a quaternion")}floor(){throw new ReferenceError("Can not floor a quaternion")}fractToRef(a){throw new ReferenceError("Can not fract a quaternion")}fract(){throw new ReferenceError("Can not fract a quaternion")}conjugateToRef(a){return a.copyFromFloats(-this._x,-this._y,-this._z,this._w),a}conjugateInPlace(){return this._x*=-1,this._y*=-1,this._z*=-1,this._isDirty=!0,this}conjugate(){return new this.constructor(-this._x,-this._y,-this._z,this._w)}invert(){const a=this.conjugate(),x=this.lengthSquared();return x==0||x==1||a.scaleInPlace(1/x),a}invertInPlace(){this.conjugateInPlace();const a=this.lengthSquared();return a==0||a==1?this:(this.scaleInPlace(1/a),this)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){return this.normalizeFromLength(this.length())}normalizeFromLength(a){return a===0||a===1?this:this.scaleInPlace(1/a)}normalizeToNew(){const a=new this.constructor(0,0,0,1);return this.normalizeToRef(a),a}normalizeToRef(a){const x=this.length();return x===0||x===1?a.copyFromFloats(this._x,this._y,this._z,this._w):this.scaleToRef(1/x,a)}toEulerAngles(){const a=Ee.Zero();return this.toEulerAnglesToRef(a),a}toEulerAnglesToRef(a){const x=this._z,c=this._x,u=this._y,g=this._w,y=u*x-c*g,v=.4999999;if(y<-v)a._y=2*Math.atan2(u,g),a._x=Math.PI/2,a._z=0,a._isDirty=!0;else if(y>v)a._y=2*Math.atan2(u,g),a._x=-Math.PI/2,a._z=0,a._isDirty=!0;else{const w=g*g,B=x*x,W=c*c,ae=u*u;a._z=Math.atan2(2*(c*u+x*g),-B-W+ae+w),a._x=Math.asin(-2*y),a._y=Math.atan2(2*(x*c+u*g),B-W-ae+w),a._isDirty=!0}return a}toRotationMatrix(a){return vt.FromQuaternionToRef(this,a),a}fromRotationMatrix(a){return Wi.FromRotationMatrixToRef(a,this),this}dot(a){return this._x*a._x+this._y*a._y+this._z*a._z+this._w*a._w}static FromRotationMatrix(a){const x=new Wi;return Wi.FromRotationMatrixToRef(a,x),x}static FromRotationMatrixToRef(a,x){const c=a.m,u=c[0],g=c[4],y=c[8],v=c[1],w=c[5],B=c[9],W=c[2],ae=c[6],ue=c[10],fe=u+w+ue;let Re;return fe>0?(Re=.5/Math.sqrt(fe+1),x._w=.25/Re,x._x=(ae-B)*Re,x._y=(y-W)*Re,x._z=(v-g)*Re,x._isDirty=!0):u>w&&u>ue?(Re=2*Math.sqrt(1+u-w-ue),x._w=(ae-B)/Re,x._x=.25*Re,x._y=(g+v)/Re,x._z=(y+W)/Re,x._isDirty=!0):w>ue?(Re=2*Math.sqrt(1+w-u-ue),x._w=(y-W)/Re,x._x=(g+v)/Re,x._y=.25*Re,x._z=(B+ae)/Re,x._isDirty=!0):(Re=2*Math.sqrt(1+ue-u-w),x._w=(v-g)/Re,x._x=(y+W)/Re,x._y=(B+ae)/Re,x._z=.25*Re,x._isDirty=!0),x}static Dot(a,x){return a._x*x._x+a._y*x._y+a._z*x._z+a._w*x._w}static AreClose(a,x,c=.1){const u=Wi.Dot(a,x);return 1-u*u<=c}static SmoothToRef(a,x,c,u,g){let y=u===0?1:c/u;return y=tn(y,0,1),Wi.SlerpToRef(a,x,y,g),g}static Zero(){return new Wi(0,0,0,0)}static Inverse(a){return new a.constructor(-a._x,-a._y,-a._z,a._w)}static InverseToRef(a,x){return x.set(-a._x,-a._y,-a._z,a._w),x}static Identity(){return new Wi(0,0,0,1)}static IsIdentity(a){return a&&a._x===0&&a._y===0&&a._z===0&&a._w===1}static RotationAxis(a,x){return Wi.RotationAxisToRef(a,x,new Wi)}static RotationAxisToRef(a,x,c){const u=Math.sin(x/2);return a.normalize(),c._w=Math.cos(x/2),c._x=a._x*u,c._y=a._y*u,c._z=a._z*u,c._isDirty=!0,c}static FromArray(a,x){return x||(x=0),new Wi(a[x],a[x+1],a[x+2],a[x+3])}static FromArrayToRef(a,x,c){return c._x=a[x],c._y=a[x+1],c._z=a[x+2],c._w=a[x+3],c._isDirty=!0,c}static FromFloatsToRef(a,x,c,u,g){return g.copyFromFloats(a,x,c,u),g}static FromEulerAngles(a,x,c){const u=new Wi;return Wi.RotationYawPitchRollToRef(x,a,c,u),u}static FromEulerAnglesToRef(a,x,c,u){return Wi.RotationYawPitchRollToRef(x,a,c,u),u}static FromEulerVector(a){const x=new Wi;return Wi.RotationYawPitchRollToRef(a._y,a._x,a._z,x),x}static FromEulerVectorToRef(a,x){return Wi.RotationYawPitchRollToRef(a._y,a._x,a._z,x),x}static FromUnitVectorsToRef(a,x,c,u=Mi){const g=Ee.Dot(a,x)+1;return g<u?Math.abs(a.x)>Math.abs(a.z)?c.set(-a.y,a.x,0,0):c.set(0,-a.z,a.y,0):(Ee.CrossToRef(a,x,Yt.Vector3[0]),c.set(Yt.Vector3[0].x,Yt.Vector3[0].y,Yt.Vector3[0].z,g)),c.normalize()}static RotationYawPitchRoll(a,x,c){const u=new Wi;return Wi.RotationYawPitchRollToRef(a,x,c,u),u}static RotationYawPitchRollToRef(a,x,c,u){const g=c*.5,y=x*.5,v=a*.5,w=Math.sin(g),B=Math.cos(g),W=Math.sin(y),ae=Math.cos(y),ue=Math.sin(v),fe=Math.cos(v);return u._x=fe*W*B+ue*ae*w,u._y=ue*ae*B-fe*W*w,u._z=fe*ae*w-ue*W*B,u._w=fe*ae*B+ue*W*w,u._isDirty=!0,u}static RotationAlphaBetaGamma(a,x,c){const u=new Wi;return Wi.RotationAlphaBetaGammaToRef(a,x,c,u),u}static RotationAlphaBetaGammaToRef(a,x,c,u){const g=(c+a)*.5,y=(c-a)*.5,v=x*.5;return u._x=Math.cos(y)*Math.sin(v),u._y=Math.sin(y)*Math.sin(v),u._z=Math.sin(g)*Math.cos(v),u._w=Math.cos(g)*Math.cos(v),u._isDirty=!0,u}static RotationQuaternionFromAxis(a,x,c){const u=new Wi(0,0,0,0);return Wi.RotationQuaternionFromAxisToRef(a,x,c,u),u}static RotationQuaternionFromAxisToRef(a,x,c,u){const g=gs.Matrix[0];return vt.FromXYZAxesToRef(a.normalize(),x.normalize(),c.normalize(),g),Wi.FromRotationMatrixToRef(g,u),u}static FromLookDirectionLH(a,x){const c=new Wi;return Wi.FromLookDirectionLHToRef(a,x,c),c}static FromLookDirectionLHToRef(a,x,c){const u=gs.Matrix[0];return vt.LookDirectionLHToRef(a,x,u),Wi.FromRotationMatrixToRef(u,c),c}static FromLookDirectionRH(a,x){const c=new Wi;return Wi.FromLookDirectionRHToRef(a,x,c),c}static FromLookDirectionRHToRef(a,x,c){const u=gs.Matrix[0];return vt.LookDirectionRHToRef(a,x,u),Wi.FromRotationMatrixToRef(u,c)}static Slerp(a,x,c){const u=Wi.Identity();return Wi.SlerpToRef(a,x,c,u),u}static SlerpToRef(a,x,c,u){let g,y,v=a._x*x._x+a._y*x._y+a._z*x._z+a._w*x._w,w=!1;if(v<0&&(w=!0,v=-v),v>.999999)y=1-c,g=w?-c:c;else{const B=Math.acos(v),W=1/Math.sin(B);y=Math.sin((1-c)*B)*W,g=w?-Math.sin(c*B)*W:Math.sin(c*B)*W}return u._x=y*a._x+g*x._x,u._y=y*a._y+g*x._y,u._z=y*a._z+g*x._z,u._w=y*a._w+g*x._w,u._isDirty=!0,u}static Hermite(a,x,c,u,g){const y=g*g,v=g*y,w=2*v-3*y+1,B=-2*v+3*y,W=v-2*y+g,ae=v-y,ue=a._x*w+c._x*B+x._x*W+u._x*ae,fe=a._y*w+c._y*B+x._y*W+u._y*ae,Re=a._z*w+c._z*B+x._z*W+u._z*ae,_e=a._w*w+c._w*B+x._w*W+u._w*ae;return new a.constructor(ue,fe,Re,_e)}static Hermite1stDerivative(a,x,c,u,g){const y=new a.constructor;return this.Hermite1stDerivativeToRef(a,x,c,u,g,y),y}static Hermite1stDerivativeToRef(a,x,c,u,g,y){const v=g*g;return y._x=(v-g)*6*a._x+(3*v-4*g+1)*x._x+(-v+g)*6*c._x+(3*v-2*g)*u._x,y._y=(v-g)*6*a._y+(3*v-4*g+1)*x._y+(-v+g)*6*c._y+(3*v-2*g)*u._y,y._z=(v-g)*6*a._z+(3*v-4*g+1)*x._z+(-v+g)*6*c._z+(3*v-2*g)*u._z,y._w=(v-g)*6*a._w+(3*v-4*g+1)*x._w+(-v+g)*6*c._w+(3*v-2*g)*u._w,y._isDirty=!0,y}static Normalize(a){const x=Wi.Zero();return Wi.NormalizeToRef(a,x),x}static NormalizeToRef(a,x){return a.normalizeToRef(x),x}static Clamp(a,x,c){const u=new a.constructor;return Wi.ClampToRef(a,x,c,u),u}static ClampToRef(a,x,c,u){return u.copyFromFloats(tn(a.x,x.x,c.x),tn(a.y,x.y,c.y),tn(a.z,x.z,c.z),tn(a.w,x.w,c.w))}static Random(a=0,x=1){return new Wi(Ir(a,x),Ir(a,x),Ir(a,x),Ir(a,x))}static RandomToRef(a=0,x=1,c){return c.copyFromFloats(Ir(a,x),Ir(a,x),Ir(a,x),Ir(a,x))}static Minimize(){throw new ReferenceError("Quaternion.Minimize does not make sense")}static Maximize(){throw new ReferenceError("Quaternion.Maximize does not make sense")}static Distance(a,x){return Math.sqrt(Wi.DistanceSquared(a,x))}static DistanceSquared(a,x){const c=a.x-x.x,u=a.y-x.y,g=a.z-x.z,y=a.w-x.w;return c*c+u*u+g*g+y*y}static Center(a,x){return Wi.CenterToRef(a,x,Wi.Zero())}static CenterToRef(a,x,c){return c.copyFromFloats((a.x+x.x)/2,(a.y+x.y)/2,(a.z+x.z)/2,(a.w+x.w)/2)}}Object.defineProperties(Wi.prototype,{dimension:{value:[4]},rank:{value:1}});class vt{static get Use64Bits(){return Wn.MatrixUse64Bits}get m(){return this._m}markAsUpdated(){this.updateFlag=vt._UpdateFlagSeed++,this._isIdentity=!1,this._isIdentity3x2=!1,this._isIdentityDirty=!0,this._isIdentity3x2Dirty=!0}_updateIdentityStatus(a,x=!1,c=!1,u=!0){this._isIdentity=a,this._isIdentity3x2=a||c,this._isIdentityDirty=this._isIdentity?!1:x,this._isIdentity3x2Dirty=this._isIdentity3x2?!1:u}constructor(){this._isIdentity=!1,this._isIdentityDirty=!0,this._isIdentity3x2=!0,this._isIdentity3x2Dirty=!0,this.updateFlag=-1,Wn.MatrixTrackPrecisionChange&&Wn.MatrixTrackedMatrices.push(this),this._m=new Wn.MatrixCurrentType(16),this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const a=this._m;this._isIdentity=a[0]===1&&a[1]===0&&a[2]===0&&a[3]===0&&a[4]===0&&a[5]===1&&a[6]===0&&a[7]===0&&a[8]===0&&a[9]===0&&a[10]===1&&a[11]===0&&a[12]===0&&a[13]===0&&a[14]===0&&a[15]===1}return this._isIdentity}isIdentityAs3x2(){return this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,this._m[0]!==1||this._m[5]!==1||this._m[15]!==1?this._isIdentity3x2=!1:this._m[1]!==0||this._m[2]!==0||this._m[3]!==0||this._m[4]!==0||this._m[6]!==0||this._m[7]!==0||this._m[8]!==0||this._m[9]!==0||this._m[10]!==0||this._m[11]!==0||this._m[12]!==0||this._m[13]!==0||this._m[14]!==0?this._isIdentity3x2=!1:this._isIdentity3x2=!0),this._isIdentity3x2}determinant(){if(this._isIdentity===!0)return 1;const a=this._m,x=a[0],c=a[1],u=a[2],g=a[3],y=a[4],v=a[5],w=a[6],B=a[7],W=a[8],ae=a[9],ue=a[10],fe=a[11],Re=a[12],_e=a[13],Be=a[14],tt=a[15],$e=ue*tt-Be*fe,Et=ae*tt-_e*fe,ft=ae*Be-_e*ue,dt=W*tt-Re*fe,ut=W*Be-ue*Re,Mt=W*_e-Re*ae,ai=+(v*$e-w*Et+B*ft),Yi=-(y*$e-w*dt+B*ut),Vi=+(y*Et-v*dt+B*Mt),Js=-(y*ft-v*ut+w*Mt);return x*ai+c*Yi+u*Vi+g*Js}toString(){return`{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}
${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}
${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}
${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`}toArray(a=null,x=0){if(!a)return this._m;const c=this._m;for(let u=0;u<16;u++)a[x+u]=c[u];return this}asArray(){return this._m}fromArray(a,x=0){return vt.FromArrayToRef(a,x,this)}copyFromFloats(...a){return vt.FromArrayToRef(a,0,this)}set(...a){const x=this._m;for(let c=0;c<16;c++)x[c]=a[c];return this.markAsUpdated(),this}setAll(a){const x=this._m;for(let c=0;c<16;c++)x[c]=a;return this.markAsUpdated(),this}invert(){return this.invertToRef(this),this}reset(){return vt.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this),this._updateIdentityStatus(!1),this}add(a){const x=new this.constructor;return this.addToRef(a,x),x}addToRef(a,x){const c=this._m,u=x._m,g=a.m;for(let y=0;y<16;y++)u[y]=c[y]+g[y];return x.markAsUpdated(),x}addToSelf(a){const x=this._m,c=a.m;for(let u=0;u<16;u++)x[u]+=c[u];return this.markAsUpdated(),this}addInPlace(a){const x=this._m,c=a.m;for(let u=0;u<16;u++)x[u]+=c[u];return this.markAsUpdated(),this}addInPlaceFromFloats(...a){const x=this._m;for(let c=0;c<16;c++)x[c]+=a[c];return this.markAsUpdated(),this}subtract(a){const x=this._m,c=a.m;for(let u=0;u<16;u++)x[u]-=c[u];return this.markAsUpdated(),this}subtractToRef(a,x){const c=this._m,u=a.m,g=x._m;for(let y=0;y<16;y++)g[y]=c[y]-u[y];return x.markAsUpdated(),x}subtractInPlace(a){const x=this._m,c=a.m;for(let u=0;u<16;u++)x[u]-=c[u];return this.markAsUpdated(),this}subtractFromFloats(...a){return this.subtractFromFloatsToRef(...a,new this.constructor)}subtractFromFloatsToRef(...a){const x=a.pop(),c=this._m,u=x._m,g=a;for(let y=0;y<16;y++)u[y]=c[y]-g[y];return x.markAsUpdated(),x}invertToRef(a){if(this._isIdentity===!0)return vt.IdentityToRef(a),a;const x=this._m,c=x[0],u=x[1],g=x[2],y=x[3],v=x[4],w=x[5],B=x[6],W=x[7],ae=x[8],ue=x[9],fe=x[10],Re=x[11],_e=x[12],Be=x[13],tt=x[14],$e=x[15],Et=fe*$e-tt*Re,ft=ue*$e-Be*Re,dt=ue*tt-Be*fe,ut=ae*$e-_e*Re,Mt=ae*tt-fe*_e,ai=ae*Be-_e*ue,Yi=+(w*Et-B*ft+W*dt),Vi=-(v*Et-B*ut+W*Mt),Js=+(v*ft-w*ut+W*ai),Rr=-(v*dt-w*Mt+B*ai),_r=c*Yi+u*Vi+g*Js+y*Rr;if(_r===0)return a.copyFrom(this),a;const Vr=1/_r,Ja=B*$e-tt*W,ta=w*$e-Be*W,ja=w*tt-Be*B,k0=v*$e-_e*W,B0=v*tt-_e*B,Hx=v*Be-_e*w,Ex=B*Re-fe*W,E2=w*Re-ue*W,dh=w*fe-ue*B,t_=v*Re-ae*W,i_=v*fe-ae*B,s_=v*ue-ae*w,Vy=-(u*Et-g*ft+y*dt),Wy=+(c*Et-g*ut+y*Mt),Hy=-(c*ft-u*ut+y*ai),Xy=+(c*dt-u*Mt+g*ai),jy=+(u*Ja-g*ta+y*ja),Yy=-(c*Ja-g*k0+y*B0),mc=+(c*ta-u*k0+y*Hx),gc=-(c*ja-u*B0+g*Hx),_c=-(u*Ex-g*E2+y*dh),yc=+(c*Ex-g*t_+y*i_),V3=-(c*E2-u*t_+y*s_),W3=+(c*dh-u*i_+g*s_);return vt.FromValuesToRef(Yi*Vr,Vy*Vr,jy*Vr,_c*Vr,Vi*Vr,Wy*Vr,Yy*Vr,yc*Vr,Js*Vr,Hy*Vr,mc*Vr,V3*Vr,Rr*Vr,Xy*Vr,gc*Vr,W3*Vr,a),a}addAtIndex(a,x){return this._m[a]+=x,this.markAsUpdated(),this}multiplyAtIndex(a,x){return this._m[a]*=x,this.markAsUpdated(),this}setTranslationFromFloats(a,x,c){return this._m[12]=a,this._m[13]=x,this._m[14]=c,this.markAsUpdated(),this}addTranslationFromFloats(a,x,c){return this._m[12]+=a,this._m[13]+=x,this._m[14]+=c,this.markAsUpdated(),this}setTranslation(a){return this.setTranslationFromFloats(a._x,a._y,a._z)}getTranslation(){return new Ee(this._m[12],this._m[13],this._m[14])}getTranslationToRef(a){return a.x=this._m[12],a.y=this._m[13],a.z=this._m[14],a}removeRotationAndScaling(){const a=this.m;return vt.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,a[12],a[13],a[14],a[15],this),this._updateIdentityStatus(a[12]===0&&a[13]===0&&a[14]===0&&a[15]===1),this}copyFrom(a){a.copyToArray(this._m);const x=a;return this.updateFlag=x.updateFlag,this._updateIdentityStatus(x._isIdentity,x._isIdentityDirty,x._isIdentity3x2,x._isIdentity3x2Dirty),this}copyToArray(a,x=0){const c=this._m;return a[x]=c[0],a[x+1]=c[1],a[x+2]=c[2],a[x+3]=c[3],a[x+4]=c[4],a[x+5]=c[5],a[x+6]=c[6],a[x+7]=c[7],a[x+8]=c[8],a[x+9]=c[9],a[x+10]=c[10],a[x+11]=c[11],a[x+12]=c[12],a[x+13]=c[13],a[x+14]=c[14],a[x+15]=c[15],this}multiply(a){const x=new this.constructor;return this.multiplyToRef(a,x),x}multiplyInPlace(a){const x=this._m,c=a.m;for(let u=0;u<16;u++)x[u]*=c[u];return this.markAsUpdated(),this}multiplyByFloats(...a){const x=this._m;for(let c=0;c<16;c++)x[c]=a[c];return this.markAsUpdated(),this}multiplyByFloatsToRef(...a){const x=a.pop(),c=this._m,u=x._m,g=a;for(let y=0;y<16;y++)u[y]=c[y]*g[y];return x.markAsUpdated(),x}multiplyToRef(a,x){return this._isIdentity?(x.copyFrom(a),x):a._isIdentity?(x.copyFrom(this),x):(this.multiplyToArray(a,x._m,0),x.markAsUpdated(),x)}multiplyToArray(a,x,c){const u=this._m,g=a.m,y=u[0],v=u[1],w=u[2],B=u[3],W=u[4],ae=u[5],ue=u[6],fe=u[7],Re=u[8],_e=u[9],Be=u[10],tt=u[11],$e=u[12],Et=u[13],ft=u[14],dt=u[15],ut=g[0],Mt=g[1],ai=g[2],Yi=g[3],Vi=g[4],Js=g[5],Rr=g[6],_r=g[7],Vr=g[8],Ja=g[9],ta=g[10],ja=g[11],k0=g[12],B0=g[13],Hx=g[14],Ex=g[15];return x[c]=y*ut+v*Vi+w*Vr+B*k0,x[c+1]=y*Mt+v*Js+w*Ja+B*B0,x[c+2]=y*ai+v*Rr+w*ta+B*Hx,x[c+3]=y*Yi+v*_r+w*ja+B*Ex,x[c+4]=W*ut+ae*Vi+ue*Vr+fe*k0,x[c+5]=W*Mt+ae*Js+ue*Ja+fe*B0,x[c+6]=W*ai+ae*Rr+ue*ta+fe*Hx,x[c+7]=W*Yi+ae*_r+ue*ja+fe*Ex,x[c+8]=Re*ut+_e*Vi+Be*Vr+tt*k0,x[c+9]=Re*Mt+_e*Js+Be*Ja+tt*B0,x[c+10]=Re*ai+_e*Rr+Be*ta+tt*Hx,x[c+11]=Re*Yi+_e*_r+Be*ja+tt*Ex,x[c+12]=$e*ut+Et*Vi+ft*Vr+dt*k0,x[c+13]=$e*Mt+Et*Js+ft*Ja+dt*B0,x[c+14]=$e*ai+Et*Rr+ft*ta+dt*Hx,x[c+15]=$e*Yi+Et*_r+ft*ja+dt*Ex,this}divide(a){return this.divideToRef(a,new this.constructor)}divideToRef(a,x){const c=this._m,u=a.m,g=x._m;for(let y=0;y<16;y++)g[y]=c[y]/u[y];return x.markAsUpdated(),x}divideInPlace(a){const x=this._m,c=a.m;for(let u=0;u<16;u++)x[u]/=c[u];return this.markAsUpdated(),this}minimizeInPlace(a){const x=this._m,c=a.m;for(let u=0;u<16;u++)x[u]=Math.min(x[u],c[u]);return this.markAsUpdated(),this}minimizeInPlaceFromFloats(...a){const x=this._m;for(let c=0;c<16;c++)x[c]=Math.min(x[c],a[c]);return this.markAsUpdated(),this}maximizeInPlace(a){const x=this._m,c=a.m;for(let u=0;u<16;u++)x[u]=Math.min(x[u],c[u]);return this.markAsUpdated(),this}maximizeInPlaceFromFloats(...a){const x=this._m;for(let c=0;c<16;c++)x[c]=Math.min(x[c],a[c]);return this.markAsUpdated(),this}negate(){return this.negateToRef(new this.constructor)}negateInPlace(){const a=this._m;for(let x=0;x<16;x++)a[x]=-a[x];return this.markAsUpdated(),this}negateToRef(a){const x=this._m,c=a._m;for(let u=0;u<16;u++)c[u]=-x[u];return a.markAsUpdated(),a}equals(a){const x=a;if(!x)return!1;if((this._isIdentity||x._isIdentity)&&!this._isIdentityDirty&&!x._isIdentityDirty)return this._isIdentity&&x._isIdentity;const c=this.m,u=x.m;return c[0]===u[0]&&c[1]===u[1]&&c[2]===u[2]&&c[3]===u[3]&&c[4]===u[4]&&c[5]===u[5]&&c[6]===u[6]&&c[7]===u[7]&&c[8]===u[8]&&c[9]===u[9]&&c[10]===u[10]&&c[11]===u[11]&&c[12]===u[12]&&c[13]===u[13]&&c[14]===u[14]&&c[15]===u[15]}equalsWithEpsilon(a,x=0){const c=this._m,u=a.m;for(let g=0;g<16;g++)if(!Hr(c[g],u[g],x))return!1;return!0}equalsToFloats(...a){const x=this._m;for(let c=0;c<16;c++)if(x[c]!=a[c])return!1;return!0}floor(){return this.floorToRef(new this.constructor)}floorToRef(a){const x=this._m,c=a._m;for(let u=0;u<16;u++)c[u]=Math.floor(x[u]);return a.markAsUpdated(),a}fract(){return this.fractToRef(new this.constructor)}fractToRef(a){const x=this._m,c=a._m;for(let u=0;u<16;u++)c[u]=x[u]-Math.floor(x[u]);return a.markAsUpdated(),a}clone(){const a=new this.constructor;return a.copyFrom(this),a}getClassName(){return"Matrix"}getHashCode(){let a=R0(this._m[0]);for(let x=1;x<16;x++)a=a*397^R0(this._m[x]);return a}decomposeToTransformNode(a){return a.rotationQuaternion=a.rotationQuaternion||new Wi,this.decompose(a.scaling,a.rotationQuaternion,a.position)}decompose(a,x,c,u,g=!0){if(this._isIdentity)return c&&c.setAll(0),a&&a.setAll(1),x&&x.copyFromFloats(0,0,0,1),!0;const y=this._m;if(c&&c.copyFromFloats(y[12],y[13],y[14]),a=a||gs.Vector3[0],a.x=Math.sqrt(y[0]*y[0]+y[1]*y[1]+y[2]*y[2]),a.y=Math.sqrt(y[4]*y[4]+y[5]*y[5]+y[6]*y[6]),a.z=Math.sqrt(y[8]*y[8]+y[9]*y[9]+y[10]*y[10]),u){const v=(g?u.absoluteScaling.x:u.scaling.x)<0?-1:1,w=(g?u.absoluteScaling.y:u.scaling.y)<0?-1:1,B=(g?u.absoluteScaling.z:u.scaling.z)<0?-1:1;a.x*=v,a.y*=w,a.z*=B}else this.determinant()<=0&&(a.y*=-1);if(a._x===0||a._y===0||a._z===0)return x&&x.copyFromFloats(0,0,0,1),!1;if(x){const v=1/a._x,w=1/a._y,B=1/a._z;vt.FromValuesToRef(y[0]*v,y[1]*v,y[2]*v,0,y[4]*w,y[5]*w,y[6]*w,0,y[8]*B,y[9]*B,y[10]*B,0,0,0,0,1,gs.Matrix[0]),Wi.FromRotationMatrixToRef(gs.Matrix[0],x)}return!0}getRow(a){if(a<0||a>3)return null;const x=a*4;return new an(this._m[x+0],this._m[x+1],this._m[x+2],this._m[x+3])}getRowToRef(a,x){if(a>=0&&a<=3){const c=a*4;x.x=this._m[c+0],x.y=this._m[c+1],x.z=this._m[c+2],x.w=this._m[c+3]}return x}setRow(a,x){return this.setRowFromFloats(a,x.x,x.y,x.z,x.w)}transpose(){const a=new this.constructor;return vt.TransposeToRef(this,a),a}transposeToRef(a){return vt.TransposeToRef(this,a),a}setRowFromFloats(a,x,c,u,g){if(a<0||a>3)return this;const y=a*4;return this._m[y+0]=x,this._m[y+1]=c,this._m[y+2]=u,this._m[y+3]=g,this.markAsUpdated(),this}scale(a){const x=new this.constructor;return this.scaleToRef(a,x),x}scaleToRef(a,x){for(let c=0;c<16;c++)x._m[c]=this._m[c]*a;return x.markAsUpdated(),x}scaleAndAddToRef(a,x){for(let c=0;c<16;c++)x._m[c]+=this._m[c]*a;return x.markAsUpdated(),x}scaleInPlace(a){const x=this._m;for(let c=0;c<16;c++)x[c]*=a;return this.markAsUpdated(),this}toNormalMatrix(a){const x=gs.Matrix[0];this.invertToRef(x),x.transposeToRef(a);const c=a._m;return vt.FromValuesToRef(c[0],c[1],c[2],0,c[4],c[5],c[6],0,c[8],c[9],c[10],0,0,0,0,1,a),a}getRotationMatrix(){const a=new this.constructor;return this.getRotationMatrixToRef(a),a}getRotationMatrixToRef(a){const x=gs.Vector3[0];if(!this.decompose(x))return vt.IdentityToRef(a),a;const c=this._m,u=1/x._x,g=1/x._y,y=1/x._z;return vt.FromValuesToRef(c[0]*u,c[1]*u,c[2]*u,0,c[4]*g,c[5]*g,c[6]*g,0,c[8]*y,c[9]*y,c[10]*y,0,0,0,0,1,a),a}toggleModelMatrixHandInPlace(){const a=this._m;return a[2]*=-1,a[6]*=-1,a[8]*=-1,a[9]*=-1,a[14]*=-1,this.markAsUpdated(),this}toggleProjectionMatrixHandInPlace(){const a=this._m;return a[8]*=-1,a[9]*=-1,a[10]*=-1,a[11]*=-1,this.markAsUpdated(),this}static FromArray(a,x=0){const c=new vt;return vt.FromArrayToRef(a,x,c),c}static FromArrayToRef(a,x,c){for(let u=0;u<16;u++)c._m[u]=a[u+x];return c.markAsUpdated(),c}static FromFloat32ArrayToRefScaled(a,x,c,u){for(let g=0;g<16;g++)u._m[g]=a[g+x]*c;return u.markAsUpdated(),u}static get IdentityReadOnly(){return vt._IdentityReadOnly}static FromValuesToRef(a,x,c,u,g,y,v,w,B,W,ae,ue,fe,Re,_e,Be,tt){const $e=tt._m;$e[0]=a,$e[1]=x,$e[2]=c,$e[3]=u,$e[4]=g,$e[5]=y,$e[6]=v,$e[7]=w,$e[8]=B,$e[9]=W,$e[10]=ae,$e[11]=ue,$e[12]=fe,$e[13]=Re,$e[14]=_e,$e[15]=Be,tt.markAsUpdated()}static FromValues(a,x,c,u,g,y,v,w,B,W,ae,ue,fe,Re,_e,Be){const tt=new vt,$e=tt._m;return $e[0]=a,$e[1]=x,$e[2]=c,$e[3]=u,$e[4]=g,$e[5]=y,$e[6]=v,$e[7]=w,$e[8]=B,$e[9]=W,$e[10]=ae,$e[11]=ue,$e[12]=fe,$e[13]=Re,$e[14]=_e,$e[15]=Be,tt.markAsUpdated(),tt}static Compose(a,x,c){const u=new vt;return vt.ComposeToRef(a,x,c,u),u}static ComposeToRef(a,x,c,u){const g=u._m,y=x._x,v=x._y,w=x._z,B=x._w,W=y+y,ae=v+v,ue=w+w,fe=y*W,Re=y*ae,_e=y*ue,Be=v*ae,tt=v*ue,$e=w*ue,Et=B*W,ft=B*ae,dt=B*ue,ut=a._x,Mt=a._y,ai=a._z;return g[0]=(1-(Be+$e))*ut,g[1]=(Re+dt)*ut,g[2]=(_e-ft)*ut,g[3]=0,g[4]=(Re-dt)*Mt,g[5]=(1-(fe+$e))*Mt,g[6]=(tt+Et)*Mt,g[7]=0,g[8]=(_e+ft)*ai,g[9]=(tt-Et)*ai,g[10]=(1-(fe+Be))*ai,g[11]=0,g[12]=c._x,g[13]=c._y,g[14]=c._z,g[15]=1,u.markAsUpdated(),u}static Identity(){const a=vt.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return a._updateIdentityStatus(!0),a}static IdentityToRef(a){return vt.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,a),a._updateIdentityStatus(!0),a}static Zero(){const a=vt.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);return a._updateIdentityStatus(!1),a}static RotationX(a){const x=new vt;return vt.RotationXToRef(a,x),x}static Invert(a){const x=new a.constructor;return a.invertToRef(x),x}static RotationXToRef(a,x){const c=Math.sin(a),u=Math.cos(a);return vt.FromValuesToRef(1,0,0,0,0,u,c,0,0,-c,u,0,0,0,0,1,x),x._updateIdentityStatus(u===1&&c===0),x}static RotationY(a){const x=new vt;return vt.RotationYToRef(a,x),x}static RotationYToRef(a,x){const c=Math.sin(a),u=Math.cos(a);return vt.FromValuesToRef(u,0,-c,0,0,1,0,0,c,0,u,0,0,0,0,1,x),x._updateIdentityStatus(u===1&&c===0),x}static RotationZ(a){const x=new vt;return vt.RotationZToRef(a,x),x}static RotationZToRef(a,x){const c=Math.sin(a),u=Math.cos(a);return vt.FromValuesToRef(u,c,0,0,-c,u,0,0,0,0,1,0,0,0,0,1,x),x._updateIdentityStatus(u===1&&c===0),x}static RotationAxis(a,x){const c=new vt;return vt.RotationAxisToRef(a,x,c),c}static RotationAxisToRef(a,x,c){const u=Math.sin(-x),g=Math.cos(-x),y=1-g;a.normalize();const v=c._m;return v[0]=a._x*a._x*y+g,v[1]=a._x*a._y*y-a._z*u,v[2]=a._x*a._z*y+a._y*u,v[3]=0,v[4]=a._y*a._x*y+a._z*u,v[5]=a._y*a._y*y+g,v[6]=a._y*a._z*y-a._x*u,v[7]=0,v[8]=a._z*a._x*y-a._y*u,v[9]=a._z*a._y*y+a._x*u,v[10]=a._z*a._z*y+g,v[11]=0,v[12]=0,v[13]=0,v[14]=0,v[15]=1,c.markAsUpdated(),c}static RotationAlignToRef(a,x,c,u=!1){const g=Ee.Dot(x,a),y=c._m;if(g<-1+Mi)y[0]=-1,y[1]=0,y[2]=0,y[3]=0,y[4]=0,y[5]=u?1:-1,y[6]=0,y[7]=0,y[8]=0,y[9]=0,y[10]=u?-1:1,y[11]=0;else{const v=Ee.Cross(x,a),w=1/(1+g);y[0]=v._x*v._x*w+g,y[1]=v._y*v._x*w-v._z,y[2]=v._z*v._x*w+v._y,y[3]=0,y[4]=v._x*v._y*w+v._z,y[5]=v._y*v._y*w+g,y[6]=v._z*v._y*w-v._x,y[7]=0,y[8]=v._x*v._z*w-v._y,y[9]=v._y*v._z*w+v._x,y[10]=v._z*v._z*w+g,y[11]=0}return y[12]=0,y[13]=0,y[14]=0,y[15]=1,c.markAsUpdated(),c}static RotationYawPitchRoll(a,x,c){const u=new vt;return vt.RotationYawPitchRollToRef(a,x,c,u),u}static RotationYawPitchRollToRef(a,x,c,u){return Wi.RotationYawPitchRollToRef(a,x,c,gs.Quaternion[0]),gs.Quaternion[0].toRotationMatrix(u),u}static Scaling(a,x,c){const u=new vt;return vt.ScalingToRef(a,x,c,u),u}static ScalingToRef(a,x,c,u){return vt.FromValuesToRef(a,0,0,0,0,x,0,0,0,0,c,0,0,0,0,1,u),u._updateIdentityStatus(a===1&&x===1&&c===1),u}static Translation(a,x,c){const u=new vt;return vt.TranslationToRef(a,x,c,u),u}static TranslationToRef(a,x,c,u){return vt.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,a,x,c,1,u),u._updateIdentityStatus(a===0&&x===0&&c===0),u}static Lerp(a,x,c){const u=new a.constructor;return vt.LerpToRef(a,x,c,u),u}static LerpToRef(a,x,c,u){const g=u._m,y=a.m,v=x.m;for(let w=0;w<16;w++)g[w]=y[w]*(1-c)+v[w]*c;return u.markAsUpdated(),u}static DecomposeLerp(a,x,c){const u=new a.constructor;return vt.DecomposeLerpToRef(a,x,c,u),u}static DecomposeLerpToRef(a,x,c,u){const g=gs.Vector3[0],y=gs.Quaternion[0],v=gs.Vector3[1];a.decompose(g,y,v);const w=gs.Vector3[2],B=gs.Quaternion[1],W=gs.Vector3[3];x.decompose(w,B,W);const ae=gs.Vector3[4];Ee.LerpToRef(g,w,c,ae);const ue=gs.Quaternion[2];Wi.SlerpToRef(y,B,c,ue);const fe=gs.Vector3[5];return Ee.LerpToRef(v,W,c,fe),vt.ComposeToRef(ae,ue,fe,u),u}static LookAtLH(a,x,c){const u=new vt;return vt.LookAtLHToRef(a,x,c,u),u}static LookAtLHToRef(a,x,c,u){const g=gs.Vector3[0],y=gs.Vector3[1],v=gs.Vector3[2];x.subtractToRef(a,v),v.normalize(),Ee.CrossToRef(c,v,g);const w=g.lengthSquared();w===0?g.x=1:g.normalizeFromLength(Math.sqrt(w)),Ee.CrossToRef(v,g,y),y.normalize();const B=-Ee.Dot(g,a),W=-Ee.Dot(y,a),ae=-Ee.Dot(v,a);return vt.FromValuesToRef(g._x,y._x,v._x,0,g._y,y._y,v._y,0,g._z,y._z,v._z,0,B,W,ae,1,u),u}static LookAtRH(a,x,c){const u=new vt;return vt.LookAtRHToRef(a,x,c,u),u}static LookAtRHToRef(a,x,c,u){const g=gs.Vector3[0],y=gs.Vector3[1],v=gs.Vector3[2];a.subtractToRef(x,v),v.normalize(),Ee.CrossToRef(c,v,g);const w=g.lengthSquared();w===0?g.x=1:g.normalizeFromLength(Math.sqrt(w)),Ee.CrossToRef(v,g,y),y.normalize();const B=-Ee.Dot(g,a),W=-Ee.Dot(y,a),ae=-Ee.Dot(v,a);return vt.FromValuesToRef(g._x,y._x,v._x,0,g._y,y._y,v._y,0,g._z,y._z,v._z,0,B,W,ae,1,u),u}static LookDirectionLH(a,x){const c=new vt;return vt.LookDirectionLHToRef(a,x,c),c}static LookDirectionLHToRef(a,x,c){const u=gs.Vector3[0];u.copyFrom(a),u.scaleInPlace(-1);const g=gs.Vector3[1];return Ee.CrossToRef(x,u,g),vt.FromValuesToRef(g._x,g._y,g._z,0,x._x,x._y,x._z,0,u._x,u._y,u._z,0,0,0,0,1,c),c}static LookDirectionRH(a,x){const c=new vt;return vt.LookDirectionRHToRef(a,x,c),c}static LookDirectionRHToRef(a,x,c){const u=gs.Vector3[2];return Ee.CrossToRef(x,a,u),vt.FromValuesToRef(u._x,u._y,u._z,0,x._x,x._y,x._z,0,a._x,a._y,a._z,0,0,0,0,1,c),c}static OrthoLH(a,x,c,u,g){const y=new vt;return vt.OrthoLHToRef(a,x,c,u,y,g),y}static OrthoLHToRef(a,x,c,u,g,y){const v=c,w=u,B=2/a,W=2/x,ae=2/(w-v),ue=-(w+v)/(w-v);return vt.FromValuesToRef(B,0,0,0,0,W,0,0,0,0,ae,0,0,0,ue,1,g),y&&g.multiplyToRef(j2,g),g._updateIdentityStatus(B===1&&W===1&&ae===1&&ue===0),g}static OrthoOffCenterLH(a,x,c,u,g,y,v){const w=new vt;return vt.OrthoOffCenterLHToRef(a,x,c,u,g,y,w,v),w}static OrthoOffCenterLHToRef(a,x,c,u,g,y,v,w){const B=g,W=y,ae=2/(x-a),ue=2/(u-c),fe=2/(W-B),Re=-(W+B)/(W-B),_e=(a+x)/(a-x),Be=(u+c)/(c-u);return vt.FromValuesToRef(ae,0,0,0,0,ue,0,0,0,0,fe,0,_e,Be,Re,1,v),w&&v.multiplyToRef(j2,v),v.markAsUpdated(),v}static ObliqueOffCenterLHToRef(a,x,c,u,g,y,v,w,B,W,ae){const ue=-v*Math.cos(w),fe=-v*Math.sin(w);return vt.TranslationToRef(0,0,-B,gs.Matrix[1]),vt.FromValuesToRef(1,0,0,0,0,1,0,0,ue,fe,1,0,0,0,0,1,gs.Matrix[0]),gs.Matrix[1].multiplyToRef(gs.Matrix[0],gs.Matrix[0]),vt.TranslationToRef(0,0,B,gs.Matrix[1]),gs.Matrix[0].multiplyToRef(gs.Matrix[1],gs.Matrix[0]),vt.OrthoOffCenterLHToRef(a,x,c,u,g,y,W,ae),gs.Matrix[0].multiplyToRef(W,W),W}static OrthoOffCenterRH(a,x,c,u,g,y,v){const w=new vt;return vt.OrthoOffCenterRHToRef(a,x,c,u,g,y,w,v),w}static OrthoOffCenterRHToRef(a,x,c,u,g,y,v,w){return vt.OrthoOffCenterLHToRef(a,x,c,u,g,y,v,w),v._m[10]*=-1,v}static ObliqueOffCenterRHToRef(a,x,c,u,g,y,v,w,B,W,ae){const ue=v*Math.cos(w),fe=v*Math.sin(w);return vt.TranslationToRef(0,0,B,gs.Matrix[1]),vt.FromValuesToRef(1,0,0,0,0,1,0,0,ue,fe,1,0,0,0,0,1,gs.Matrix[0]),gs.Matrix[1].multiplyToRef(gs.Matrix[0],gs.Matrix[0]),vt.TranslationToRef(0,0,-B,gs.Matrix[1]),gs.Matrix[0].multiplyToRef(gs.Matrix[1],gs.Matrix[0]),vt.OrthoOffCenterRHToRef(a,x,c,u,g,y,W,ae),gs.Matrix[0].multiplyToRef(W,W),W}static PerspectiveLH(a,x,c,u,g,y=0){const v=new vt,w=c,B=u,W=2*w/a,ae=2*w/x,ue=(B+w)/(B-w),fe=-2*B*w/(B-w),Re=Math.tan(y);return vt.FromValuesToRef(W,0,0,0,0,ae,0,Re,0,0,ue,1,0,0,fe,0,v),g&&v.multiplyToRef(j2,v),v._updateIdentityStatus(!1),v}static PerspectiveFovLH(a,x,c,u,g,y=0,v=!1){const w=new vt;return vt.PerspectiveFovLHToRef(a,x,c,u,w,!0,g,y,v),w}static PerspectiveFovLHToRef(a,x,c,u,g,y=!0,v,w=0,B=!1){const W=c,ae=u,ue=1/Math.tan(a*.5),fe=y?ue/x:ue,Re=y?ue:ue*x,_e=B&&W===0?-1:ae!==0?(ae+W)/(ae-W):1,Be=B&&W===0?2*ae:ae!==0?-2*ae*W/(ae-W):-2*W,tt=Math.tan(w);return vt.FromValuesToRef(fe,0,0,0,0,Re,0,tt,0,0,_e,1,0,0,Be,0,g),v&&g.multiplyToRef(j2,g),g._updateIdentityStatus(!1),g}static PerspectiveFovReverseLHToRef(a,x,c,u,g,y=!0,v,w=0){const B=1/Math.tan(a*.5),W=y?B/x:B,ae=y?B:B*x,ue=Math.tan(w);return vt.FromValuesToRef(W,0,0,0,0,ae,0,ue,0,0,-c,1,0,0,1,0,g),v&&g.multiplyToRef(j2,g),g._updateIdentityStatus(!1),g}static PerspectiveFovRH(a,x,c,u,g,y=0,v=!1){const w=new vt;return vt.PerspectiveFovRHToRef(a,x,c,u,w,!0,g,y,v),w}static PerspectiveFovRHToRef(a,x,c,u,g,y=!0,v,w=0,B=!1){const W=c,ae=u,ue=1/Math.tan(a*.5),fe=y?ue/x:ue,Re=y?ue:ue*x,_e=B&&W===0?1:ae!==0?-(ae+W)/(ae-W):-1,Be=B&&W===0?2*ae:ae!==0?-2*ae*W/(ae-W):-2*W,tt=Math.tan(w);return vt.FromValuesToRef(fe,0,0,0,0,Re,0,tt,0,0,_e,-1,0,0,Be,0,g),v&&g.multiplyToRef(j2,g),g._updateIdentityStatus(!1),g}static PerspectiveFovReverseRHToRef(a,x,c,u,g,y=!0,v,w=0){const B=1/Math.tan(a*.5),W=y?B/x:B,ae=y?B:B*x,ue=Math.tan(w);return vt.FromValuesToRef(W,0,0,0,0,ae,0,ue,0,0,-c,-1,0,0,-1,0,g),v&&g.multiplyToRef(j2,g),g._updateIdentityStatus(!1),g}static GetFinalMatrix(a,x,c,u,g,y){const v=a.width,w=a.height,B=a.x,W=a.y,ae=vt.FromValues(v/2,0,0,0,0,-w/2,0,0,0,0,y-g,0,B+v/2,w/2+W,g,1),ue=new x.constructor;return x.multiplyToRef(c,ue),ue.multiplyToRef(u,ue),ue.multiplyToRef(ae,ue)}static GetAsMatrix2x2(a){const x=a.m,c=[x[0],x[1],x[4],x[5]];return Wn.MatrixUse64Bits?c:new Float32Array(c)}static GetAsMatrix3x3(a){const x=a.m,c=[x[0],x[1],x[2],x[4],x[5],x[6],x[8],x[9],x[10]];return Wn.MatrixUse64Bits?c:new Float32Array(c)}static Transpose(a){const x=new a.constructor;return vt.TransposeToRef(a,x),x}static TransposeToRef(a,x){const c=a.m,u=c[0],g=c[4],y=c[8],v=c[12],w=c[1],B=c[5],W=c[9],ae=c[13],ue=c[2],fe=c[6],Re=c[10],_e=c[14],Be=c[3],tt=c[7],$e=c[11],Et=c[15],ft=x._m;return ft[0]=u,ft[1]=g,ft[2]=y,ft[3]=v,ft[4]=w,ft[5]=B,ft[6]=W,ft[7]=ae,ft[8]=ue,ft[9]=fe,ft[10]=Re,ft[11]=_e,ft[12]=Be,ft[13]=tt,ft[14]=$e,ft[15]=Et,x.markAsUpdated(),x._updateIdentityStatus(a._isIdentity,a._isIdentityDirty),x}static Reflection(a){const x=new vt;return vt.ReflectionToRef(a,x),x}static ReflectionToRef(a,x){a.normalize();const c=a.normal.x,u=a.normal.y,g=a.normal.z,y=-2*c,v=-2*u,w=-2*g;return vt.FromValuesToRef(y*c+1,v*c,w*c,0,y*u,v*u+1,w*u,0,y*g,v*g,w*g+1,0,y*a.d,v*a.d,w*a.d,1,x),x}static FromXYZAxesToRef(a,x,c,u){return vt.FromValuesToRef(a._x,a._y,a._z,0,x._x,x._y,x._z,0,c._x,c._y,c._z,0,0,0,0,1,u),u}static FromQuaternionToRef(a,x){const c=a._x*a._x,u=a._y*a._y,g=a._z*a._z,y=a._x*a._y,v=a._z*a._w,w=a._z*a._x,B=a._y*a._w,W=a._y*a._z,ae=a._x*a._w;return x._m[0]=1-2*(u+g),x._m[1]=2*(y+v),x._m[2]=2*(w-B),x._m[3]=0,x._m[4]=2*(y-v),x._m[5]=1-2*(g+c),x._m[6]=2*(W+ae),x._m[7]=0,x._m[8]=2*(w+B),x._m[9]=2*(W-ae),x._m[10]=1-2*(u+c),x._m[11]=0,x._m[12]=0,x._m[13]=0,x._m[14]=0,x._m[15]=1,x.markAsUpdated(),x}}vt._UpdateFlagSeed=0,vt._IdentityReadOnly=vt.Identity(),Object.defineProperties(vt.prototype,{dimension:{value:[4,4]},rank:{value:2}});class gs{}gs.Vector3=Ws.BuildTuple(11,Ee.Zero),gs.Matrix=Ws.BuildTuple(2,vt.Identity),gs.Quaternion=Ws.BuildTuple(3,Wi.Zero);class Yt{}Yt.Vector2=Ws.BuildTuple(3,mr.Zero),Yt.Vector3=Ws.BuildTuple(13,Ee.Zero),Yt.Vector4=Ws.BuildTuple(3,an.Zero),Yt.Quaternion=Ws.BuildTuple(2,Wi.Zero),Yt.Matrix=Ws.BuildTuple(8,vt.Identity),as("BABYLON.Vector2",mr),as("BABYLON.Vector3",Ee),as("BABYLON.Vector4",an),as("BABYLON.Matrix",vt);const j2=vt.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1);class Wc{constructor(){this.rootNodes=[],this.cameras=[],this.lights=[],this.meshes=[],this.skeletons=[],this.particleSystems=[],this.animations=[],this.animationGroups=[],this.multiMaterials=[],this.materials=[],this.morphTargetManagers=[],this.geometries=[],this.transformNodes=[],this.actionManagers=[],this.textures=[],this._environmentTexture=null,this.postProcesses=[]}static AddParser(a,x){this._BabylonFileParsers[a]=x}static GetParser(a){return this._BabylonFileParsers[a]?this._BabylonFileParsers[a]:null}static AddIndividualParser(a,x){this._IndividualBabylonFileParsers[a]=x}static GetIndividualParser(a){return this._IndividualBabylonFileParsers[a]?this._IndividualBabylonFileParsers[a]:null}static Parse(a,x,c,u){for(const g in this._BabylonFileParsers)Object.prototype.hasOwnProperty.call(this._BabylonFileParsers,g)&&this._BabylonFileParsers[g](a,x,c,u)}get environmentTexture(){return this._environmentTexture}set environmentTexture(a){this._environmentTexture=a}getNodes(){let a=[];return a=a.concat(this.meshes),a=a.concat(this.lights),a=a.concat(this.cameras),a=a.concat(this.transformNodes),this.skeletons.forEach(x=>a=a.concat(x.bones)),a}}Wc._BabylonFileParsers={},Wc._IndividualBabylonFileParsers={};var Jp=function(F,a){return Jp=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(x,c){x.__proto__=c}||function(x,c){for(var u in c)Object.prototype.hasOwnProperty.call(c,u)&&(x[u]=c[u])},Jp(F,a)};function gx(F,a){if(typeof a!="function"&&a!==null)throw new TypeError("Class extends value "+String(a)+" is not a constructor or null");Jp(F,a);function x(){this.constructor=F}F.prototype=a===null?Object.create(a):(x.prototype=a.prototype,new x)}var Y2=function(){return Y2=Object.assign||function(a){for(var x,c=1,u=arguments.length;c<u;c++){x=arguments[c];for(var g in x)Object.prototype.hasOwnProperty.call(x,g)&&(a[g]=x[g])}return a},Y2.apply(this,arguments)};function vl(F,a){var x={};for(var c in F)Object.prototype.hasOwnProperty.call(F,c)&&a.indexOf(c)<0&&(x[c]=F[c]);if(F!=null&&typeof Object.getOwnPropertySymbols=="function")for(var u=0,c=Object.getOwnPropertySymbols(F);u<c.length;u++)a.indexOf(c[u])<0&&Object.prototype.propertyIsEnumerable.call(F,c[u])&&(x[c[u]]=F[c[u]]);return x}function Ye(F,a,x,c){var u=arguments.length,g=u<3?a:c===null?c=Object.getOwnPropertyDescriptor(a,x):c,y;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")g=Reflect.decorate(F,a,x,c);else for(var v=F.length-1;v>=0;v--)(y=F[v])&&(g=(u<3?y(g):u>3?y(a,x,g):y(a,x))||g);return u>3&&g&&Object.defineProperty(a,x,g),g}function r_(F,a){return function(x,c){a(x,c,F)}}function tm(F,a){if(typeof Reflect=="object"&&typeof Reflect.metadata=="function")return Reflect.metadata(F,a)}function n_(F,a,x,c){function u(g){return g instanceof x?g:new x(function(y){y(g)})}return new(x||(x=Promise))(function(g,y){function v(W){try{B(c.next(W))}catch(ae){y(ae)}}function w(W){try{B(c.throw(W))}catch(ae){y(ae)}}function B(W){W.done?g(W.value):u(W.value).then(v,w)}B((c=c.apply(F,a||[])).next())})}function We(F,a){var x={label:0,sent:function(){if(g[0]&1)throw g[1];return g[1]},trys:[],ops:[]},c,u,g,y;return y={next:v(0),throw:v(1),return:v(2)},typeof Symbol=="function"&&(y[Symbol.iterator]=function(){return this}),y;function v(B){return function(W){return w([B,W])}}function w(B){if(c)throw new TypeError("Generator is already executing.");for(;x;)try{if(c=1,u&&(g=B[0]&2?u.return:B[0]?u.throw||((g=u.return)&&g.call(u),0):u.next)&&!(g=g.call(u,B[1])).done)return g;switch(u=0,g&&(B=[B[0]&2,g.value]),B[0]){case 0:case 1:g=B;break;case 4:return x.label++,{value:B[1],done:!1};case 5:x.label++,u=B[1],B=[0];continue;case 7:B=x.ops.pop(),x.trys.pop();continue;default:if(g=x.trys,!(g=g.length>0&&g[g.length-1])&&(B[0]===6||B[0]===2)){x=0;continue}if(B[0]===3&&(!g||B[1]>g[0]&&B[1]<g[3])){x.label=B[1];break}if(B[0]===6&&x.label<g[1]){x.label=g[1],g=B;break}if(g&&x.label<g[2]){x.label=g[2],x.ops.push(B);break}g[2]&&x.ops.pop(),x.trys.pop();continue}B=a.call(F,x)}catch(W){B=[6,W],u=0}finally{c=g=0}if(B[0]&5)throw B[1];return{value:B[0]?B[1]:void 0,done:!0}}}var Ue=Object.create?function(F,a,x,c){c===void 0&&(c=x);var u=Object.getOwnPropertyDescriptor(a,x);(!u||("get"in u?!a.__esModule:u.writable||u.configurable))&&(u={enumerable:!0,get:function(){return a[x]}}),Object.defineProperty(F,c,u)}:function(F,a,x,c){c===void 0&&(c=x),F[c]=a[x]};function mt(F,a){for(var x in F)x!=="default"&&!Object.prototype.hasOwnProperty.call(a,x)&&Ue(a,F,x)}function Wt(F){var a=typeof Symbol=="function"&&Symbol.iterator,x=a&&F[a],c=0;if(x)return x.call(F);if(F&&typeof F.length=="number")return{next:function(){return F&&c>=F.length&&(F=void 0),{value:F&&F[c++],done:!F}}};throw new TypeError(a?"Object is not iterable.":"Symbol.iterator is not defined.")}function _i(F,a){var x=typeof Symbol=="function"&&F[Symbol.iterator];if(!x)return F;var c=x.call(F),u,g=[],y;try{for(;(a===void 0||a-- >0)&&!(u=c.next()).done;)g.push(u.value)}catch(v){y={error:v}}finally{try{u&&!u.done&&(x=c.return)&&x.call(c)}finally{if(y)throw y.error}}return g}function Ii(){for(var F=[],a=0;a<arguments.length;a++)F=F.concat(_i(arguments[a]));return F}function ji(){for(var F=0,a=0,x=arguments.length;a<x;a++)F+=arguments[a].length;for(var c=Array(F),u=0,a=0;a<x;a++)for(var g=arguments[a],y=0,v=g.length;y<v;y++,u++)c[u]=g[y];return c}function Bi(F,a,x){if(x||arguments.length===2)for(var c=0,u=a.length,g;c<u;c++)(g||!(c in a))&&(g||(g=Array.prototype.slice.call(a,0,c)),g[c]=a[c]);return F.concat(g||Array.prototype.slice.call(a))}function vs(F){return this instanceof vs?(this.v=F,this):new vs(F)}function Ys(F,a,x){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var c=x.apply(F,a||[]),u,g=[];return u={},y("next"),y("throw"),y("return"),u[Symbol.asyncIterator]=function(){return this},u;function y(ue){c[ue]&&(u[ue]=function(fe){return new Promise(function(Re,_e){g.push([ue,fe,Re,_e])>1||v(ue,fe)})})}function v(ue,fe){try{w(c[ue](fe))}catch(Re){ae(g[0][3],Re)}}function w(ue){ue.value instanceof vs?Promise.resolve(ue.value.v).then(B,W):ae(g[0][2],ue)}function B(ue){v("next",ue)}function W(ue){v("throw",ue)}function ae(ue,fe){ue(fe),g.shift(),g.length&&v(g[0][0],g[0][1])}}function Ms(F){var a,x;return a={},c("next"),c("throw",function(u){throw u}),c("return"),a[Symbol.iterator]=function(){return this},a;function c(u,g){a[u]=F[u]?function(y){return(x=!x)?{value:vs(F[u](y)),done:u==="return"}:g?g(y):y}:g}}function $r(F){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var a=F[Symbol.asyncIterator],x;return a?a.call(F):(F=typeof Wt=="function"?Wt(F):F[Symbol.iterator](),x={},c("next"),c("throw"),c("return"),x[Symbol.asyncIterator]=function(){return this},x);function c(g){x[g]=F[g]&&function(y){return new Promise(function(v,w){y=F[g](y),u(v,w,y.done,y.value)})}}function u(g,y,v,w){Promise.resolve(w).then(function(B){g({value:B,done:v})},y)}}function Xr(F,a){return Object.defineProperty?Object.defineProperty(F,"raw",{value:a}):F.raw=a,F}var bn=Object.create?function(F,a){Object.defineProperty(F,"default",{enumerable:!0,value:a})}:function(F,a){F.default=a};function ya(F){if(F&&F.__esModule)return F;var a={};if(F!=null)for(var x in F)x!=="default"&&Object.prototype.hasOwnProperty.call(F,x)&&Ue(a,F,x);return bn(a,F),a}function Wa(F){return F&&F.__esModule?F:{default:F}}function Ha(F,a,x,c){if(x==="a"&&!c)throw new TypeError("Private accessor was defined without a getter");if(typeof a=="function"?F!==a||!c:!a.has(F))throw new TypeError("Cannot read private member from an object whose class did not declare it");return x==="m"?c:x==="a"?c.call(F):c?c.value:a.get(F)}function Xa(F,a,x,c,u){if(c==="m")throw new TypeError("Private method is not writable");if(c==="a"&&!u)throw new TypeError("Private accessor was defined without a setter");if(typeof a=="function"?F!==a||!u:!a.has(F))throw new TypeError("Cannot write private member to an object whose class did not declare it");return c==="a"?u.call(F,x):u?u.value=x:a.set(F,x),x}function ds(F,a){if(a===null||typeof a!="object"&&typeof a!="function")throw new TypeError("Cannot use 'in' operator on non-object");return typeof F=="function"?a===F:F.has(a)}const br={},Bn={};function ha(F){const a=F.getClassName();return Bn[a]||(Bn[a]={}),Bn[a]}function Er(F){const a=F.getClassName();if(br[a])return br[a];br[a]={};const x=br[a];let c=F,u=a;for(;u;){const g=Bn[u];for(const w in g)x[w]=g[w];let y,v=!1;do{if(y=Object.getPrototypeOf(c),!y.getClassName){v=!0;break}if(y.getClassName()!==u)break;c=y}while(y);if(v)break;u=y.getClassName(),c=y}return x}function d0(F,a){return(x,c)=>{const u=ha(x);u[c]||(u[c]={type:F,sourceName:a})}}function Il(F,a=null){return(x,c)=>{const u=a||"_"+c;Object.defineProperty(x,c,{get:function(){return this[u]},set:function(g){typeof this.equals=="function"&&this.equals(g)||this[u]!==g&&(this[u]=g,x[F].apply(this))},enumerable:!0,configurable:!0})}}function Ji(F,a=null){return Il(F,a)}function ht(F){return d0(0,F)}function gn(F){return d0(1,F)}function va(F){return d0(2,F)}function jm(F){return d0(3,F)}function Vh(F){return d0(4,F)}function En(F){return d0(5,F)}function Rx(F){return d0(6,F)}function tl(F){return d0(7,F)}function $y(F){return d0(8,F)}function _P(F){return d0(9,F)}function yP(F){return d0(10,F)}function Jy(F){return d0(12,F)}function H3(F){return d0(11,F)}function Hc(F,a,x,c){const u=x.value;x.value=(...g)=>{let y=u;if(typeof _native<"u"&&_native[a]){const v=_native[a];c?y=(...w)=>c(...w)?v(...w):u(...w):y=v}return F[a]=y,y(...g)}}Hc.filter=function(F){return(a,x,c)=>Hc(a,x,c,F)};class _n{static Sign(a){return a=+a,a===0||isNaN(a)?a:a>0?1:-1}static Log2(a){return Math.log(a)*Math.LOG2E}static ILog2(a){if(Math.log2)return Math.floor(Math.log2(a));if(a<0)return NaN;if(a===0)return-1/0;let x=0;if(a<1){for(;a<1;)x++,a=a*2;x=-x}else if(a>1)for(;a>1;)x++,a=Math.floor(a/2);return x}static Repeat(a,x){return a-Math.floor(a/x)*x}static Normalize(a,x,c){return(a-x)/(c-x)}static Denormalize(a,x,c){return a*(c-x)+x}static DeltaAngle(a,x){let c=_n.Repeat(x-a,360);return c>180&&(c-=360),c}static PingPong(a,x){const c=_n.Repeat(a,x*2);return x-Math.abs(c-x)}static SmoothStep(a,x,c){let u=_n.Clamp(c);return u=-2*u*u*u+3*u*u,x*u+a*(1-u)}static MoveTowards(a,x,c){let u=0;return Math.abs(x-a)<=c?u=x:u=a+_n.Sign(x-a)*c,u}static MoveTowardsAngle(a,x,c){const u=_n.DeltaAngle(a,x);let g=0;return-c<u&&u<c?g=x:(x=a+u,g=_n.MoveTowards(a,x,c)),g}static LerpAngle(a,x,c){let u=_n.Repeat(x-a,360);return u>180&&(u-=360),a+u*tn(c)}static InverseLerp(a,x,c){let u=0;return a!=x?u=tn((c-a)/(x-a)):u=0,u}static Hermite(a,x,c,u,g){const y=g*g,v=g*y,w=2*v-3*y+1,B=-2*v+3*y,W=v-2*y+g,ae=v-y;return a*w+c*B+x*W+u*ae}static Hermite1stDerivative(a,x,c,u,g){const y=g*g;return(y-g)*6*a+(3*y-4*g+1)*x+(-y+g)*6*c+(3*y-2*g)*u}static RangeToPercent(a,x,c){return(a-x)/(c-x)}static PercentToRange(a,x,c){return(c-x)*a+x}static HCF(a,x){const c=a%x;return c===0?x:_n.HCF(x,c)}}_n.TwoPi=Math.PI*2,_n.WithinEpsilon=Hr,_n.ToHex=Va,_n.Clamp=tn,_n.Lerp=u0,_n.RandomRange=Ir,_n.NormalizeRadians=W0;function hu(F){return Math.pow(F,Xi)}function uu(F){return F<=.04045?.0773993808*F:Math.pow(.947867299*(F+.055),2.4)}function du(F){return Math.pow(F,di)}function fu(F){return F<=.0031308?12.92*F:1.055*Math.pow(F,.41666)-.055}class Bs{constructor(a=0,x=0,c=0){this.r=a,this.g=x,this.b=c}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Color3"}getHashCode(){let a=this.r*255|0;return a=a*397^(this.g*255|0),a=a*397^(this.b*255|0),a}toArray(a,x=0){return a[x]=this.r,a[x+1]=this.g,a[x+2]=this.b,this}fromArray(a,x=0){return Bs.FromArrayToRef(a,x,this),this}toColor4(a=1){return new Yr(this.r,this.g,this.b,a)}asArray(){return[this.r,this.g,this.b]}toLuminance(){return this.r*.3+this.g*.59+this.b*.11}multiply(a){return new this.constructor(this.r*a.r,this.g*a.g,this.b*a.b)}multiplyToRef(a,x){return x.r=this.r*a.r,x.g=this.g*a.g,x.b=this.b*a.b,x}multiplyInPlace(a){return this.r*=a.r,this.g*=a.g,this.b*=a.b,this}multiplyByFloats(a,x,c){return new this.constructor(this.r*a,this.g*x,this.b*c)}divide(a){throw new ReferenceError("Can not divide a color")}divideToRef(a,x){throw new ReferenceError("Can not divide a color")}divideInPlace(a){throw new ReferenceError("Can not divide a color")}minimizeInPlace(a){return this.minimizeInPlaceFromFloats(a.r,a.g,a.b)}maximizeInPlace(a){return this.maximizeInPlaceFromFloats(a.r,a.g,a.b)}minimizeInPlaceFromFloats(a,x,c){return this.r=Math.min(a,this.r),this.g=Math.min(x,this.g),this.b=Math.min(c,this.b),this}maximizeInPlaceFromFloats(a,x,c){return this.r=Math.max(a,this.r),this.g=Math.max(x,this.g),this.b=Math.max(c,this.b),this}floorToRef(a){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(a){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(a){return a&&this.r===a.r&&this.g===a.g&&this.b===a.b}equalsFloats(a,x,c){return this.equalsToFloats(a,x,c)}equalsToFloats(a,x,c){return this.r===a&&this.g===x&&this.b===c}equalsWithEpsilon(a,x=Mi){return _n.WithinEpsilon(this.r,a.r,x)&&_n.WithinEpsilon(this.g,a.g,x)&&_n.WithinEpsilon(this.b,a.b,x)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(a){throw new ReferenceError("Can not negate a color")}scale(a){return new this.constructor(this.r*a,this.g*a,this.b*a)}scaleInPlace(a){return this.r*=a,this.g*=a,this.b*=a,this}scaleToRef(a,x){return x.r=this.r*a,x.g=this.g*a,x.b=this.b*a,x}scaleAndAddToRef(a,x){return x.r+=this.r*a,x.g+=this.g*a,x.b+=this.b*a,x}clampToRef(a=0,x=1,c){return c.r=tn(this.r,a,x),c.g=tn(this.g,a,x),c.b=tn(this.b,a,x),c}add(a){return new this.constructor(this.r+a.r,this.g+a.g,this.b+a.b)}addInPlace(a){return this.r+=a.r,this.g+=a.g,this.b+=a.b,this}addInPlaceFromFloats(a,x,c){return this.r+=a,this.g+=x,this.b+=c,this}addToRef(a,x){return x.r=this.r+a.r,x.g=this.g+a.g,x.b=this.b+a.b,x}subtract(a){return new this.constructor(this.r-a.r,this.g-a.g,this.b-a.b)}subtractToRef(a,x){return x.r=this.r-a.r,x.g=this.g-a.g,x.b=this.b-a.b,x}subtractInPlace(a){return this.r-=a.r,this.g-=a.g,this.b-=a.b,this}subtractFromFloats(a,x,c){return new this.constructor(this.r-a,this.g-x,this.b-c)}subtractFromFloatsToRef(a,x,c,u){return u.copyFromFloats(this.r-a,this.g-x,this.b-c)}clone(){return new this.constructor(this.r,this.g,this.b)}copyFrom(a){return this.r=a.r,this.g=a.g,this.b=a.b,this}copyFromFloats(a,x,c){return this.r=a,this.g=x,this.b=c,this}set(a,x,c){return this.copyFromFloats(a,x,c)}setAll(a){return this.r=this.g=this.b=a,this}toHexString(){const a=Math.round(this.r*255),x=Math.round(this.g*255),c=Math.round(this.b*255);return"#"+Va(a)+Va(x)+Va(c)}toHSV(){const a=new this.constructor;return this.toHSVToRef(a),a}toHSVToRef(a){const x=this.r,c=this.g,u=this.b,g=Math.max(x,c,u),y=Math.min(x,c,u);let v=0,w=0;const B=g,W=g-y;g!==0&&(w=W/g),g!=y&&(g==x?(v=(c-u)/W,c<u&&(v+=6)):g==c?v=(u-x)/W+2:g==u&&(v=(x-c)/W+4),v*=60),a.r=v,a.g=w,a.b=B}toLinearSpace(a=!1){const x=new this.constructor;return this.toLinearSpaceToRef(x,a),x}toLinearSpaceToRef(a,x=!1){return x?(a.r=uu(this.r),a.g=uu(this.g),a.b=uu(this.b)):(a.r=hu(this.r),a.g=hu(this.g),a.b=hu(this.b)),this}toGammaSpace(a=!1){const x=new this.constructor;return this.toGammaSpaceToRef(x,a),x}toGammaSpaceToRef(a,x=!1){return x?(a.r=fu(this.r),a.g=fu(this.g),a.b=fu(this.b)):(a.r=du(this.r),a.g=du(this.g),a.b=du(this.b)),this}static HSVtoRGBToRef(a,x,c,u){const g=c*x,y=a/60,v=g*(1-Math.abs(y%2-1));let w=0,B=0,W=0;y>=0&&y<=1?(w=g,B=v):y>=1&&y<=2?(w=v,B=g):y>=2&&y<=3?(B=g,W=v):y>=3&&y<=4?(B=v,W=g):y>=4&&y<=5?(w=v,W=g):y>=5&&y<=6&&(w=g,W=v);const ae=c-g;u.set(w+ae,B+ae,W+ae)}static FromHSV(a,x,c){const u=new Bs(0,0,0);return Bs.HSVtoRGBToRef(a,x,c,u),u}static FromHexString(a){if(a.substring(0,1)!=="#"||a.length!==7)return new Bs(0,0,0);const x=parseInt(a.substring(1,3),16),c=parseInt(a.substring(3,5),16),u=parseInt(a.substring(5,7),16);return Bs.FromInts(x,c,u)}static FromArray(a,x=0){return new Bs(a[x],a[x+1],a[x+2])}static FromArrayToRef(a,x=0,c){c.r=a[x],c.g=a[x+1],c.b=a[x+2]}static FromInts(a,x,c){return new Bs(a/255,x/255,c/255)}static Lerp(a,x,c){const u=new Bs(0,0,0);return Bs.LerpToRef(a,x,c,u),u}static LerpToRef(a,x,c,u){u.r=a.r+(x.r-a.r)*c,u.g=a.g+(x.g-a.g)*c,u.b=a.b+(x.b-a.b)*c}static Hermite(a,x,c,u,g){const y=g*g,v=g*y,w=2*v-3*y+1,B=-2*v+3*y,W=v-2*y+g,ae=v-y,ue=a.r*w+c.r*B+x.r*W+u.r*ae,fe=a.g*w+c.g*B+x.g*W+u.g*ae,Re=a.b*w+c.b*B+x.b*W+u.b*ae;return new Bs(ue,fe,Re)}static Hermite1stDerivative(a,x,c,u,g){const y=Bs.Black();return this.Hermite1stDerivativeToRef(a,x,c,u,g,y),y}static Hermite1stDerivativeToRef(a,x,c,u,g,y){const v=g*g;y.r=(v-g)*6*a.r+(3*v-4*g+1)*x.r+(-v+g)*6*c.r+(3*v-2*g)*u.r,y.g=(v-g)*6*a.g+(3*v-4*g+1)*x.g+(-v+g)*6*c.g+(3*v-2*g)*u.g,y.b=(v-g)*6*a.b+(3*v-4*g+1)*x.b+(-v+g)*6*c.b+(3*v-2*g)*u.b}static Red(){return new Bs(1,0,0)}static Green(){return new Bs(0,1,0)}static Blue(){return new Bs(0,0,1)}static Black(){return new Bs(0,0,0)}static get BlackReadOnly(){return Bs._BlackReadOnly}static White(){return new Bs(1,1,1)}static Purple(){return new Bs(.5,0,.5)}static Magenta(){return new Bs(1,0,1)}static Yellow(){return new Bs(1,1,0)}static Gray(){return new Bs(.5,.5,.5)}static Teal(){return new Bs(0,1,1)}static Random(){return new Bs(Math.random(),Math.random(),Math.random())}}Bs._BlackReadOnly=Bs.Black(),Object.defineProperties(Bs.prototype,{dimension:{value:[3]},rank:{value:1}});class Yr{constructor(a=0,x=0,c=0,u=1){this.r=a,this.g=x,this.b=c,this.a=u}asArray(){return[this.r,this.g,this.b,this.a]}toArray(a,x=0){return a[x]=this.r,a[x+1]=this.g,a[x+2]=this.b,a[x+3]=this.a,this}fromArray(a,x=0){return this.r=a[x],this.g=a[x+1],this.b=a[x+2],this.a=a[x+3],this}equals(a){return a&&this.r===a.r&&this.g===a.g&&this.b===a.b&&this.a===a.a}add(a){return new this.constructor(this.r+a.r,this.g+a.g,this.b+a.b,this.a+a.a)}addToRef(a,x){return x.r=this.r+a.r,x.g=this.g+a.g,x.b=this.b+a.b,x.a=this.a+a.a,x}addInPlace(a){return this.r+=a.r,this.g+=a.g,this.b+=a.b,this.a+=a.a,this}addInPlaceFromFloats(a,x,c,u){return this.r+=a,this.g+=x,this.b+=c,this.a+=u,this}subtract(a){return new this.constructor(this.r-a.r,this.g-a.g,this.b-a.b,this.a-a.a)}subtractToRef(a,x){return x.r=this.r-a.r,x.g=this.g-a.g,x.b=this.b-a.b,x.a=this.a-a.a,x}subtractInPlace(a){return this.r-=a.r,this.g-=a.g,this.b-=a.b,this.a-=a.a,this}subtractFromFloats(a,x,c,u){return new this.constructor(this.r-a,this.g-x,this.b-c,this.a-u)}subtractFromFloatsToRef(a,x,c,u,g){return g.r=this.r-a,g.g=this.g-x,g.b=this.b-c,g.a=this.a-u,g}scale(a){return new this.constructor(this.r*a,this.g*a,this.b*a,this.a*a)}scaleInPlace(a){return this.r*=a,this.g*=a,this.b*=a,this.a*=a,this}scaleToRef(a,x){return x.r=this.r*a,x.g=this.g*a,x.b=this.b*a,x.a=this.a*a,x}scaleAndAddToRef(a,x){return x.r+=this.r*a,x.g+=this.g*a,x.b+=this.b*a,x.a+=this.a*a,x}clampToRef(a=0,x=1,c){return c.r=tn(this.r,a,x),c.g=tn(this.g,a,x),c.b=tn(this.b,a,x),c.a=tn(this.a,a,x),c}multiply(a){return new this.constructor(this.r*a.r,this.g*a.g,this.b*a.b,this.a*a.a)}multiplyToRef(a,x){return x.r=this.r*a.r,x.g=this.g*a.g,x.b=this.b*a.b,x.a=this.a*a.a,x}multiplyInPlace(a){return this.r*=a.r,this.g*=a.g,this.b*=a.b,this.a*=a.a,this}multiplyByFloats(a,x,c,u){return new this.constructor(this.r*a,this.g*x,this.b*c,this.a*u)}divide(a){throw new ReferenceError("Can not divide a color")}divideToRef(a,x){throw new ReferenceError("Can not divide a color")}divideInPlace(a){throw new ReferenceError("Can not divide a color")}minimizeInPlace(a){return this.r=Math.min(this.r,a.r),this.g=Math.min(this.g,a.g),this.b=Math.min(this.b,a.b),this.a=Math.min(this.a,a.a),this}maximizeInPlace(a){return this.r=Math.max(this.r,a.r),this.g=Math.max(this.g,a.g),this.b=Math.max(this.b,a.b),this.a=Math.max(this.a,a.a),this}minimizeInPlaceFromFloats(a,x,c,u){return this.r=Math.min(a,this.r),this.g=Math.min(x,this.g),this.b=Math.min(c,this.b),this.a=Math.min(u,this.a),this}maximizeInPlaceFromFloats(a,x,c,u){return this.r=Math.max(a,this.r),this.g=Math.max(x,this.g),this.b=Math.max(c,this.b),this.a=Math.max(u,this.a),this}floorToRef(a){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(a){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(a){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(a,x=Mi){return _n.WithinEpsilon(this.r,a.r,x)&&_n.WithinEpsilon(this.g,a.g,x)&&_n.WithinEpsilon(this.b,a.b,x)&&_n.WithinEpsilon(this.a,a.a,x)}equalsToFloats(a,x,c,u){return this.r===a&&this.g===x&&this.b===c&&this.a===u}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Color4"}getHashCode(){let a=this.r*255|0;return a=a*397^(this.g*255|0),a=a*397^(this.b*255|0),a=a*397^(this.a*255|0),a}clone(){return new this.constructor().copyFrom(this)}copyFrom(a){return this.r=a.r,this.g=a.g,this.b=a.b,this.a=a.a,this}copyFromFloats(a,x,c,u){return this.r=a,this.g=x,this.b=c,this.a=u,this}set(a,x,c,u){return this.copyFromFloats(a,x,c,u)}setAll(a){return this.r=this.g=this.b=this.a=a,this}toHexString(a=!1){const x=Math.round(this.r*255),c=Math.round(this.g*255),u=Math.round(this.b*255);if(a)return"#"+Va(x)+Va(c)+Va(u);const g=Math.round(this.a*255);return"#"+Va(x)+Va(c)+Va(u)+Va(g)}toLinearSpace(a=!1){const x=new Yr;return this.toLinearSpaceToRef(x,a),x}toLinearSpaceToRef(a,x=!1){return x?(a.r=uu(this.r),a.g=uu(this.g),a.b=uu(this.b)):(a.r=hu(this.r),a.g=hu(this.g),a.b=hu(this.b)),a.a=this.a,this}toGammaSpace(a=!1){const x=new Yr;return this.toGammaSpaceToRef(x,a),x}toGammaSpaceToRef(a,x=!1){return x?(a.r=fu(this.r),a.g=fu(this.g),a.b=fu(this.b)):(a.r=du(this.r),a.g=du(this.g),a.b=du(this.b)),a.a=this.a,this}static FromHexString(a){if(a.substring(0,1)!=="#"||a.length!==9&&a.length!==7)return new Yr(0,0,0,0);const x=parseInt(a.substring(1,3),16),c=parseInt(a.substring(3,5),16),u=parseInt(a.substring(5,7),16),g=a.length===9?parseInt(a.substring(7,9),16):255;return Yr.FromInts(x,c,u,g)}static Lerp(a,x,c){const u=new Yr(0,0,0,0);return Yr.LerpToRef(a,x,c,u),u}static LerpToRef(a,x,c,u){u.r=a.r+(x.r-a.r)*c,u.g=a.g+(x.g-a.g)*c,u.b=a.b+(x.b-a.b)*c,u.a=a.a+(x.a-a.a)*c}static Hermite(a,x,c,u,g){const y=g*g,v=g*y,w=2*v-3*y+1,B=-2*v+3*y,W=v-2*y+g,ae=v-y,ue=a.r*w+c.r*B+x.r*W+u.r*ae,fe=a.g*w+c.g*B+x.g*W+u.g*ae,Re=a.b*w+c.b*B+x.b*W+u.b*ae,_e=a.a*w+c.a*B+x.a*W+u.a*ae;return new Yr(ue,fe,Re,_e)}static Hermite1stDerivative(a,x,c,u,g){const y=new Yr;return this.Hermite1stDerivativeToRef(a,x,c,u,g,y),y}static Hermite1stDerivativeToRef(a,x,c,u,g,y){const v=g*g;y.r=(v-g)*6*a.r+(3*v-4*g+1)*x.r+(-v+g)*6*c.r+(3*v-2*g)*u.r,y.g=(v-g)*6*a.g+(3*v-4*g+1)*x.g+(-v+g)*6*c.g+(3*v-2*g)*u.g,y.b=(v-g)*6*a.b+(3*v-4*g+1)*x.b+(-v+g)*6*c.b+(3*v-2*g)*u.b,y.a=(v-g)*6*a.a+(3*v-4*g+1)*x.a+(-v+g)*6*c.a+(3*v-2*g)*u.a}static FromColor3(a,x=1){return new Yr(a.r,a.g,a.b,x)}static FromArray(a,x=0){return new Yr(a[x],a[x+1],a[x+2],a[x+3])}static FromArrayToRef(a,x=0,c){c.r=a[x],c.g=a[x+1],c.b=a[x+2],c.a=a[x+3]}static FromInts(a,x,c,u){return new Yr(a/255,x/255,c/255,u/255)}static CheckColors4(a,x){if(a.length===x*3){const c=[];for(let u=0;u<a.length;u+=3){const g=u/3*4;c[g]=a[u],c[g+1]=a[u+1],c[g+2]=a[u+2],c[g+3]=1}return c}return a}}Object.defineProperties(Yr.prototype,{dimension:{value:[4]},rank:{value:1}});class Rl{}Rl.Color3=Ws.BuildArray(3,Bs.Black),Rl.Color4=Ws.BuildArray(3,()=>new Yr(0,0,0,0)),as("BABYLON.Color3",Bs),as("BABYLON.Color4",Yr);const tT=function(F,a,x,c={}){const u=F();Vt&&Vt.HasTags(a)&&Vt.AddTagsTo(u,Vt.GetTags(a,!0));const g=Er(u),y={};for(const v in g){const w=g[v],B=a[v],W=w.type;if(B!=null&&(v!=="uniqueId"||hr.AllowLoadingUniqueId))switch(W){case 0:case 6:case 11:u[v]=B;break;case 1:c.cloneTexturesOnlyOnce&&y[B.uniqueId]?u[v]=y[B.uniqueId]:(u[v]=x||B.isRenderTarget?B:B.clone(),y[B.uniqueId]=u[v]);break;case 2:case 3:case 4:case 5:case 7:case 10:case 12:u[v]=x?B:B.clone();break}}return u};class hr{static AppendSerializedAnimations(a,x){if(a.animations){x.animations=[];for(let c=0;c<a.animations.length;c++){const u=a.animations[c];x.animations.push(u.serialize())}}}static Serialize(a,x){x||(x={}),Vt&&(x.tags=Vt.GetTags(a));const c=Er(a);for(const u in c){const g=c[u],y=g.sourceName||u,v=g.type,w=a[u];if(w!=null&&(u!=="uniqueId"||hr.AllowLoadingUniqueId))switch(v){case 0:x[y]=w;break;case 1:x[y]=w.serialize();break;case 2:x[y]=w.asArray();break;case 3:x[y]=w.serialize();break;case 4:x[y]=w.asArray();break;case 5:x[y]=w.asArray();break;case 6:x[y]=w.id;break;case 7:x[y]=w.serialize();break;case 8:x[y]=w.asArray();break;case 9:x[y]=w.serialize();break;case 10:x[y]=w.asArray();break;case 11:x[y]=w.id;break;case 12:x[y]=w.asArray();break}}return x}static ParseProperties(a,x,c,u){u||(u="");const g=Er(x);for(const y in g){const v=g[y],w=a[v.sourceName||y],B=v.type;if(w!=null&&(y!=="uniqueId"||hr.AllowLoadingUniqueId)){const W=x;switch(B){case 0:W[y]=w;break;case 1:c&&(W[y]=hr._TextureParser(w,c,u));break;case 2:W[y]=Bs.FromArray(w);break;case 3:W[y]=hr._FresnelParametersParser(w);break;case 4:W[y]=mr.FromArray(w);break;case 5:W[y]=Ee.FromArray(w);break;case 6:c&&(W[y]=c.getLastMeshById(w));break;case 7:W[y]=hr._ColorCurvesParser(w);break;case 8:W[y]=Yr.FromArray(w);break;case 9:W[y]=hr._ImageProcessingConfigurationParser(w);break;case 10:W[y]=Wi.FromArray(w);break;case 11:c&&(W[y]=c.getCameraById(w));break;case 12:W[y]=vt.FromArray(w);break}}}}static Parse(a,x,c,u=null){const g=a();return Vt&&Vt.AddTagsTo(g,x.tags),hr.ParseProperties(x,g,c,u),g}static Clone(a,x,c={}){return tT(a,x,!1,c)}static Instanciate(a,x){return tT(a,x,!0)}}hr.AllowLoadingUniqueId=!1,hr._ImageProcessingConfigurationParser=F=>{throw js("ImageProcessingConfiguration")},hr._FresnelParametersParser=F=>{throw js("FresnelParameters")},hr._ColorCurvesParser=F=>{throw js("ColorCurves")},hr._TextureParser=(F,a,x)=>{throw js("Texture")};function aT(F){F.push("vCameraColorCurveNeutral","vCameraColorCurvePositive","vCameraColorCurveNegative")}class ua{constructor(){this._dirty=!0,this._tempColor=new Yr(0,0,0,0),this._globalCurve=new Yr(0,0,0,0),this._highlightsCurve=new Yr(0,0,0,0),this._midtonesCurve=new Yr(0,0,0,0),this._shadowsCurve=new Yr(0,0,0,0),this._positiveCurve=new Yr(0,0,0,0),this._negativeCurve=new Yr(0,0,0,0),this._globalHue=30,this._globalDensity=0,this._globalSaturation=0,this._globalExposure=0,this._highlightsHue=30,this._highlightsDensity=0,this._highlightsSaturation=0,this._highlightsExposure=0,this._midtonesHue=30,this._midtonesDensity=0,this._midtonesSaturation=0,this._midtonesExposure=0,this._shadowsHue=30,this._shadowsDensity=0,this._shadowsSaturation=0,this._shadowsExposure=0}get globalHue(){return this._globalHue}set globalHue(a){this._globalHue=a,this._dirty=!0}get globalDensity(){return this._globalDensity}set globalDensity(a){this._globalDensity=a,this._dirty=!0}get globalSaturation(){return this._globalSaturation}set globalSaturation(a){this._globalSaturation=a,this._dirty=!0}get globalExposure(){return this._globalExposure}set globalExposure(a){this._globalExposure=a,this._dirty=!0}get highlightsHue(){return this._highlightsHue}set highlightsHue(a){this._highlightsHue=a,this._dirty=!0}get highlightsDensity(){return this._highlightsDensity}set highlightsDensity(a){this._highlightsDensity=a,this._dirty=!0}get highlightsSaturation(){return this._highlightsSaturation}set highlightsSaturation(a){this._highlightsSaturation=a,this._dirty=!0}get highlightsExposure(){return this._highlightsExposure}set highlightsExposure(a){this._highlightsExposure=a,this._dirty=!0}get midtonesHue(){return this._midtonesHue}set midtonesHue(a){this._midtonesHue=a,this._dirty=!0}get midtonesDensity(){return this._midtonesDensity}set midtonesDensity(a){this._midtonesDensity=a,this._dirty=!0}get midtonesSaturation(){return this._midtonesSaturation}set midtonesSaturation(a){this._midtonesSaturation=a,this._dirty=!0}get midtonesExposure(){return this._midtonesExposure}set midtonesExposure(a){this._midtonesExposure=a,this._dirty=!0}get shadowsHue(){return this._shadowsHue}set shadowsHue(a){this._shadowsHue=a,this._dirty=!0}get shadowsDensity(){return this._shadowsDensity}set shadowsDensity(a){this._shadowsDensity=a,this._dirty=!0}get shadowsSaturation(){return this._shadowsSaturation}set shadowsSaturation(a){this._shadowsSaturation=a,this._dirty=!0}get shadowsExposure(){return this._shadowsExposure}set shadowsExposure(a){this._shadowsExposure=a,this._dirty=!0}getClassName(){return"ColorCurves"}static Bind(a,x,c="vCameraColorCurvePositive",u="vCameraColorCurveNeutral",g="vCameraColorCurveNegative"){a._dirty&&(a._dirty=!1,a._getColorGradingDataToRef(a._globalHue,a._globalDensity,a._globalSaturation,a._globalExposure,a._globalCurve),a._getColorGradingDataToRef(a._highlightsHue,a._highlightsDensity,a._highlightsSaturation,a._highlightsExposure,a._tempColor),a._tempColor.multiplyToRef(a._globalCurve,a._highlightsCurve),a._getColorGradingDataToRef(a._midtonesHue,a._midtonesDensity,a._midtonesSaturation,a._midtonesExposure,a._tempColor),a._tempColor.multiplyToRef(a._globalCurve,a._midtonesCurve),a._getColorGradingDataToRef(a._shadowsHue,a._shadowsDensity,a._shadowsSaturation,a._shadowsExposure,a._tempColor),a._tempColor.multiplyToRef(a._globalCurve,a._shadowsCurve),a._highlightsCurve.subtractToRef(a._midtonesCurve,a._positiveCurve),a._midtonesCurve.subtractToRef(a._shadowsCurve,a._negativeCurve)),x&&(x.setFloat4(c,a._positiveCurve.r,a._positiveCurve.g,a._positiveCurve.b,a._positiveCurve.a),x.setFloat4(u,a._midtonesCurve.r,a._midtonesCurve.g,a._midtonesCurve.b,a._midtonesCurve.a),x.setFloat4(g,a._negativeCurve.r,a._negativeCurve.g,a._negativeCurve.b,a._negativeCurve.a))}_getColorGradingDataToRef(a,x,c,u,g){a!=null&&(a=ua._Clamp(a,0,360),x=ua._Clamp(x,-100,100),c=ua._Clamp(c,-100,100),u=ua._Clamp(u,-100,100),x=ua._ApplyColorGradingSliderNonlinear(x),x*=.5,u=ua._ApplyColorGradingSliderNonlinear(u),x<0&&(x*=-1,a=(a+180)%360),ua._FromHSBToRef(a,x,50+.25*u,g),g.scaleToRef(2,g),g.a=1+.01*c)}static _ApplyColorGradingSliderNonlinear(a){a/=100;let x=Math.abs(a);return x=Math.pow(x,2),a<0&&(x*=-1),x*=100,x}static _FromHSBToRef(a,x,c,u){let g=ua._Clamp(a,0,360);const y=ua._Clamp(x/100,0,1),v=ua._Clamp(c/100,0,1);if(y===0)u.r=v,u.g=v,u.b=v;else{g/=60;const w=Math.floor(g),B=g-w,W=v*(1-y),ae=v*(1-y*B),ue=v*(1-y*(1-B));switch(w){case 0:u.r=v,u.g=ue,u.b=W;break;case 1:u.r=ae,u.g=v,u.b=W;break;case 2:u.r=W,u.g=v,u.b=ue;break;case 3:u.r=W,u.g=ae,u.b=v;break;case 4:u.r=ue,u.g=W,u.b=v;break;default:u.r=v,u.g=W,u.b=ae;break}}u.a=1}static _Clamp(a,x,c){return Math.min(Math.max(a,x),c)}clone(){return hr.Clone(()=>new ua,this)}serialize(){return hr.Serialize(this)}static Parse(a){return hr.Parse(()=>new ua,a,null,null)}}ua.PrepareUniforms=aT,Ye([ht()],ua.prototype,"_globalHue",void 0),Ye([ht()],ua.prototype,"_globalDensity",void 0),Ye([ht()],ua.prototype,"_globalSaturation",void 0),Ye([ht()],ua.prototype,"_globalExposure",void 0),Ye([ht()],ua.prototype,"_highlightsHue",void 0),Ye([ht()],ua.prototype,"_highlightsDensity",void 0),Ye([ht()],ua.prototype,"_highlightsSaturation",void 0),Ye([ht()],ua.prototype,"_highlightsExposure",void 0),Ye([ht()],ua.prototype,"_midtonesHue",void 0),Ye([ht()],ua.prototype,"_midtonesDensity",void 0),Ye([ht()],ua.prototype,"_midtonesSaturation",void 0),Ye([ht()],ua.prototype,"_midtonesExposure",void 0),hr._ColorCurvesParser=ua.Parse;function bP(F,a){a.EXPOSURE&&F.push("exposureLinear"),a.CONTRAST&&F.push("contrast"),a.COLORGRADING&&F.push("colorTransformSettings"),(a.VIGNETTE||a.DITHER)&&F.push("vInverseScreenSize"),a.VIGNETTE&&(F.push("vignetteSettings1"),F.push("vignetteSettings2")),a.COLORCURVES&&aT(F),a.DITHER&&F.push("ditherIntensity")}function EP(F,a){a.COLORGRADING&&F.push("txColorTransform")}class un{constructor(){this.colorCurves=new ua,this._colorCurvesEnabled=!1,this._colorGradingEnabled=!1,this._colorGradingWithGreenDepth=!0,this._colorGradingBGR=!0,this._exposure=1,this._toneMappingEnabled=!1,this._toneMappingType=un.TONEMAPPING_STANDARD,this._contrast=1,this.vignetteStretch=0,this.vignetteCenterX=0,this.vignetteCenterY=0,this.vignetteWeight=1.5,this.vignetteColor=new Yr(0,0,0,0),this.vignetteCameraFov=.5,this._vignetteBlendMode=un.VIGNETTEMODE_MULTIPLY,this._vignetteEnabled=!1,this._ditheringEnabled=!1,this._ditheringIntensity=1/255,this._skipFinalColorClamp=!1,this._applyByPostProcess=!1,this._isEnabled=!0,this.onUpdateParameters=new Jt}get colorCurvesEnabled(){return this._colorCurvesEnabled}set colorCurvesEnabled(a){this._colorCurvesEnabled!==a&&(this._colorCurvesEnabled=a,this._updateParameters())}get colorGradingTexture(){return this._colorGradingTexture}set colorGradingTexture(a){this._colorGradingTexture!==a&&(this._colorGradingTexture=a,this._updateParameters())}get colorGradingEnabled(){return this._colorGradingEnabled}set colorGradingEnabled(a){this._colorGradingEnabled!==a&&(this._colorGradingEnabled=a,this._updateParameters())}get colorGradingWithGreenDepth(){return this._colorGradingWithGreenDepth}set colorGradingWithGreenDepth(a){this._colorGradingWithGreenDepth!==a&&(this._colorGradingWithGreenDepth=a,this._updateParameters())}get colorGradingBGR(){return this._colorGradingBGR}set colorGradingBGR(a){this._colorGradingBGR!==a&&(this._colorGradingBGR=a,this._updateParameters())}get exposure(){return this._exposure}set exposure(a){this._exposure!==a&&(this._exposure=a,this._updateParameters())}get toneMappingEnabled(){return this._toneMappingEnabled}set toneMappingEnabled(a){this._toneMappingEnabled!==a&&(this._toneMappingEnabled=a,this._updateParameters())}get toneMappingType(){return this._toneMappingType}set toneMappingType(a){this._toneMappingType!==a&&(this._toneMappingType=a,this._updateParameters())}get contrast(){return this._contrast}set contrast(a){this._contrast!==a&&(this._contrast=a,this._updateParameters())}get vignetteCentreY(){return this.vignetteCenterY}set vignetteCentreY(a){this.vignetteCenterY=a}get vignetteCentreX(){return this.vignetteCenterX}set vignetteCentreX(a){this.vignetteCenterX=a}get vignetteBlendMode(){return this._vignetteBlendMode}set vignetteBlendMode(a){this._vignetteBlendMode!==a&&(this._vignetteBlendMode=a,this._updateParameters())}get vignetteEnabled(){return this._vignetteEnabled}set vignetteEnabled(a){this._vignetteEnabled!==a&&(this._vignetteEnabled=a,this._updateParameters())}get ditheringEnabled(){return this._ditheringEnabled}set ditheringEnabled(a){this._ditheringEnabled!==a&&(this._ditheringEnabled=a,this._updateParameters())}get ditheringIntensity(){return this._ditheringIntensity}set ditheringIntensity(a){this._ditheringIntensity!==a&&(this._ditheringIntensity=a,this._updateParameters())}get skipFinalColorClamp(){return this._skipFinalColorClamp}set skipFinalColorClamp(a){this._skipFinalColorClamp!==a&&(this._skipFinalColorClamp=a,this._updateParameters())}get applyByPostProcess(){return this._applyByPostProcess}set applyByPostProcess(a){this._applyByPostProcess!==a&&(this._applyByPostProcess=a,this._updateParameters())}get isEnabled(){return this._isEnabled}set isEnabled(a){this._isEnabled!==a&&(this._isEnabled=a,this._updateParameters())}_updateParameters(){this.onUpdateParameters.notifyObservers(this)}getClassName(){return"ImageProcessingConfiguration"}prepareDefines(a,x=!1){if(x!==this.applyByPostProcess||!this._isEnabled){a.VIGNETTE=!1,a.TONEMAPPING=!1,a.TONEMAPPING_ACES=!1,a.CONTRAST=!1,a.EXPOSURE=!1,a.COLORCURVES=!1,a.COLORGRADING=!1,a.COLORGRADING3D=!1,a.DITHER=!1,a.IMAGEPROCESSING=!1,a.SKIPFINALCOLORCLAMP=this.skipFinalColorClamp,a.IMAGEPROCESSINGPOSTPROCESS=this.applyByPostProcess&&this._isEnabled;return}switch(a.VIGNETTE=this.vignetteEnabled,a.VIGNETTEBLENDMODEMULTIPLY=this.vignetteBlendMode===un._VIGNETTEMODE_MULTIPLY,a.VIGNETTEBLENDMODEOPAQUE=!a.VIGNETTEBLENDMODEMULTIPLY,a.TONEMAPPING=this.toneMappingEnabled,this._toneMappingType){case un.TONEMAPPING_ACES:a.TONEMAPPING_ACES=!0;break;default:a.TONEMAPPING_ACES=!1;break}a.CONTRAST=this.contrast!==1,a.EXPOSURE=this.exposure!==1,a.COLORCURVES=this.colorCurvesEnabled&&!!this.colorCurves,a.COLORGRADING=this.colorGradingEnabled&&!!this.colorGradingTexture,a.COLORGRADING?a.COLORGRADING3D=this.colorGradingTexture.is3D:a.COLORGRADING3D=!1,a.SAMPLER3DGREENDEPTH=this.colorGradingWithGreenDepth,a.SAMPLER3DBGRMAP=this.colorGradingBGR,a.DITHER=this._ditheringEnabled,a.IMAGEPROCESSINGPOSTPROCESS=this.applyByPostProcess,a.SKIPFINALCOLORCLAMP=this.skipFinalColorClamp,a.IMAGEPROCESSING=a.VIGNETTE||a.TONEMAPPING||a.CONTRAST||a.EXPOSURE||a.COLORCURVES||a.COLORGRADING||a.DITHER}isReady(){return!this.colorGradingEnabled||!this.colorGradingTexture||this.colorGradingTexture.isReady()}bind(a,x){if(this._colorCurvesEnabled&&this.colorCurves&&ua.Bind(this.colorCurves,a),this._vignetteEnabled||this._ditheringEnabled){const c=1/a.getEngine().getRenderWidth(),u=1/a.getEngine().getRenderHeight();if(a.setFloat2("vInverseScreenSize",c,u),this._ditheringEnabled&&a.setFloat("ditherIntensity",.5*this._ditheringIntensity),this._vignetteEnabled){const g=x??u/c;let y=Math.tan(this.vignetteCameraFov*.5),v=y*g;const w=Math.sqrt(v*y);v=Rt(v,w,this.vignetteStretch),y=Rt(y,w,this.vignetteStretch),a.setFloat4("vignetteSettings1",v,y,-v*this.vignetteCenterX,-y*this.vignetteCenterY);const B=-2*this.vignetteWeight;a.setFloat4("vignetteSettings2",this.vignetteColor.r,this.vignetteColor.g,this.vignetteColor.b,B)}}if(a.setFloat("exposureLinear",this.exposure),a.setFloat("contrast",this.contrast),this.colorGradingTexture){a.setTexture("txColorTransform",this.colorGradingTexture);const c=this.colorGradingTexture.getSize().height;a.setFloat4("colorTransformSettings",(c-1)/c,.5/c,c,this.colorGradingTexture.level)}}clone(){return hr.Clone(()=>new un,this)}serialize(){return hr.Serialize(this)}static Parse(a){const x=hr.Parse(()=>new un,a,null,null);return a.vignetteCentreX!==void 0&&(x.vignetteCenterX=a.vignetteCentreX),a.vignetteCentreY!==void 0&&(x.vignetteCenterY=a.vignetteCentreY),x}static get VIGNETTEMODE_MULTIPLY(){return this._VIGNETTEMODE_MULTIPLY}static get VIGNETTEMODE_OPAQUE(){return this._VIGNETTEMODE_OPAQUE}}un.TONEMAPPING_STANDARD=0,un.TONEMAPPING_ACES=1,un.PrepareUniforms=bP,un.PrepareSamplers=EP,un._VIGNETTEMODE_MULTIPLY=0,un._VIGNETTEMODE_OPAQUE=1,Ye([tl()],un.prototype,"colorCurves",void 0),Ye([ht()],un.prototype,"_colorCurvesEnabled",void 0),Ye([gn("colorGradingTexture")],un.prototype,"_colorGradingTexture",void 0),Ye([ht()],un.prototype,"_colorGradingEnabled",void 0),Ye([ht()],un.prototype,"_colorGradingWithGreenDepth",void 0),Ye([ht()],un.prototype,"_colorGradingBGR",void 0),Ye([ht()],un.prototype,"_exposure",void 0),Ye([ht()],un.prototype,"_toneMappingEnabled",void 0),Ye([ht()],un.prototype,"_toneMappingType",void 0),Ye([ht()],un.prototype,"_contrast",void 0),Ye([ht()],un.prototype,"vignetteStretch",void 0),Ye([ht()],un.prototype,"vignetteCenterX",void 0),Ye([ht()],un.prototype,"vignetteCenterY",void 0),Ye([ht()],un.prototype,"vignetteWeight",void 0),Ye([$y()],un.prototype,"vignetteColor",void 0),Ye([ht()],un.prototype,"vignetteCameraFov",void 0),Ye([ht()],un.prototype,"_vignetteBlendMode",void 0),Ye([ht()],un.prototype,"_vignetteEnabled",void 0),Ye([ht()],un.prototype,"_ditheringEnabled",void 0),Ye([ht()],un.prototype,"_ditheringIntensity",void 0),Ye([ht()],un.prototype,"_skipFinalColorClamp",void 0),Ye([ht()],un.prototype,"_applyByPostProcess",void 0),Ye([ht()],un.prototype,"_isEnabled",void 0),hr._ImageProcessingConfigurationParser=un.Parse,Es.prototype.createUniformBuffer=function(F,a){const x=this._gl.createBuffer();if(!x)throw new Error("Unable to create uniform buffer");const c=new Vo(x);return this.bindUniformBuffer(c),F instanceof Float32Array?this._gl.bufferData(this._gl.UNIFORM_BUFFER,F,this._gl.STATIC_DRAW):this._gl.bufferData(this._gl.UNIFORM_BUFFER,new Float32Array(F),this._gl.STATIC_DRAW),this.bindUniformBuffer(null),c.references=1,c},Es.prototype.createDynamicUniformBuffer=function(F,a){const x=this._gl.createBuffer();if(!x)throw new Error("Unable to create dynamic uniform buffer");const c=new Vo(x);return this.bindUniformBuffer(c),F instanceof Float32Array?this._gl.bufferData(this._gl.UNIFORM_BUFFER,F,this._gl.DYNAMIC_DRAW):this._gl.bufferData(this._gl.UNIFORM_BUFFER,new Float32Array(F),this._gl.DYNAMIC_DRAW),this.bindUniformBuffer(null),c.references=1,c},Es.prototype.updateUniformBuffer=function(F,a,x,c){this.bindUniformBuffer(F),x===void 0&&(x=0),c===void 0?a instanceof Float32Array?this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,x,a):this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,x,new Float32Array(a)):a instanceof Float32Array?this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,0,a.subarray(x,x+c)):this._gl.bufferSubData(this._gl.UNIFORM_BUFFER,0,new Float32Array(a).subarray(x,x+c)),this.bindUniformBuffer(null)},Es.prototype.bindUniformBuffer=function(F){this._gl.bindBuffer(this._gl.UNIFORM_BUFFER,F?F.underlyingResource:null)},Es.prototype.bindUniformBufferBase=function(F,a,x){this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER,a,F?F.underlyingResource:null)},Es.prototype.bindUniformBlock=function(F,a,x){const c=F.program,u=this._gl.getUniformBlockIndex(c,a);u!==4294967295&&this._gl.uniformBlockBinding(c,u,x)};class ys{constructor(a,x,c,u,g=!1){this._valueCache={},this._engine=a,this._noUBO=!a.supportsUniformBuffers||g,this._dynamic=c,this._name=u??"no-name",this._data=x||[],this._uniformLocations={},this._uniformSizes={},this._uniformArraySizes={},this._uniformLocationPointer=0,this._needSync=!1,this._engine._features.trackUbosInFrame&&(this._buffers=[],this._bufferIndex=-1,this._createBufferOnWrite=!1,this._currentFrameId=0),this._noUBO?(this.updateMatrix3x3=this._updateMatrix3x3ForEffect,this.updateMatrix2x2=this._updateMatrix2x2ForEffect,this.updateFloat=this._updateFloatForEffect,this.updateFloat2=this._updateFloat2ForEffect,this.updateFloat3=this._updateFloat3ForEffect,this.updateFloat4=this._updateFloat4ForEffect,this.updateFloatArray=this._updateFloatArrayForEffect,this.updateArray=this._updateArrayForEffect,this.updateIntArray=this._updateIntArrayForEffect,this.updateUIntArray=this._updateUIntArrayForEffect,this.updateMatrix=this._updateMatrixForEffect,this.updateMatrices=this._updateMatricesForEffect,this.updateVector3=this._updateVector3ForEffect,this.updateVector4=this._updateVector4ForEffect,this.updateColor3=this._updateColor3ForEffect,this.updateColor4=this._updateColor4ForEffect,this.updateDirectColor4=this._updateDirectColor4ForEffect,this.updateInt=this._updateIntForEffect,this.updateInt2=this._updateInt2ForEffect,this.updateInt3=this._updateInt3ForEffect,this.updateInt4=this._updateInt4ForEffect,this.updateUInt=this._updateUIntForEffect,this.updateUInt2=this._updateUInt2ForEffect,this.updateUInt3=this._updateUInt3ForEffect,this.updateUInt4=this._updateUInt4ForEffect):(this._engine._uniformBuffers.push(this),this.updateMatrix3x3=this._updateMatrix3x3ForUniform,this.updateMatrix2x2=this._updateMatrix2x2ForUniform,this.updateFloat=this._updateFloatForUniform,this.updateFloat2=this._updateFloat2ForUniform,this.updateFloat3=this._updateFloat3ForUniform,this.updateFloat4=this._updateFloat4ForUniform,this.updateFloatArray=this._updateFloatArrayForUniform,this.updateArray=this._updateArrayForUniform,this.updateIntArray=this._updateIntArrayForUniform,this.updateUIntArray=this._updateUIntArrayForUniform,this.updateMatrix=this._updateMatrixForUniform,this.updateMatrices=this._updateMatricesForUniform,this.updateVector3=this._updateVector3ForUniform,this.updateVector4=this._updateVector4ForUniform,this.updateColor3=this._updateColor3ForUniform,this.updateColor4=this._updateColor4ForUniform,this.updateDirectColor4=this._updateDirectColor4ForUniform,this.updateInt=this._updateIntForUniform,this.updateInt2=this._updateInt2ForUniform,this.updateInt3=this._updateInt3ForUniform,this.updateInt4=this._updateInt4ForUniform,this.updateUInt=this._updateUIntForUniform,this.updateUInt2=this._updateUInt2ForUniform,this.updateUInt3=this._updateUInt3ForUniform,this.updateUInt4=this._updateUInt4ForUniform)}get useUbo(){return!this._noUBO}get isSync(){return!this._needSync}isDynamic(){return this._dynamic!==void 0}getData(){return this._bufferData}getBuffer(){return this._buffer}_fillAlignment(a){let x;if(a<=2?x=a:x=4,this._uniformLocationPointer%x!==0){const c=this._uniformLocationPointer;this._uniformLocationPointer+=x-this._uniformLocationPointer%x;const u=this._uniformLocationPointer-c;for(let g=0;g<u;g++)this._data.push(0)}}addUniform(a,x,c=0){if(this._noUBO||this._uniformLocations[a]!==void 0)return;let u;if(c>0){if(x instanceof Array)throw"addUniform should not be use with Array in UBO: "+a;if(this._fillAlignment(4),this._uniformArraySizes[a]={strideSize:x,arraySize:c},x==16)x=x*c;else{const y=(4-x)*c;x=x*c+y}u=[];for(let g=0;g<x;g++)u.push(0)}else{if(x instanceof Array)u=x,x=u.length;else{x=x,u=[];for(let g=0;g<x;g++)u.push(0)}this._fillAlignment(x)}this._uniformSizes[a]=x,this._uniformLocations[a]=this._uniformLocationPointer,this._uniformLocationPointer+=x;for(let g=0;g<x;g++)this._data.push(u[g]);this._needSync=!0}addMatrix(a,x){this.addUniform(a,Array.prototype.slice.call(x.asArray()))}addFloat2(a,x,c){const u=[x,c];this.addUniform(a,u)}addFloat3(a,x,c,u){const g=[x,c,u];this.addUniform(a,g)}addColor3(a,x){const c=[x.r,x.g,x.b];this.addUniform(a,c)}addColor4(a,x,c){const u=[x.r,x.g,x.b,c];this.addUniform(a,u)}addVector3(a,x){const c=[x.x,x.y,x.z];this.addUniform(a,c)}addMatrix3x3(a){this.addUniform(a,12)}addMatrix2x2(a){this.addUniform(a,8)}create(){this._noUBO||this._buffer||(this._fillAlignment(4),this._bufferData=new Float32Array(this._data),this._rebuild(),this._needSync=!0)}_getNames(){const a=[];let x=0;for(const c in this._uniformLocations)if(a.push(c),++x===10)break;return a.join(",")}_rebuild(){this._noUBO||!this._bufferData||(this._dynamic?this._buffer=this._engine.createDynamicUniformBuffer(this._bufferData,this._name+"_UniformList:"+this._getNames()):this._buffer=this._engine.createUniformBuffer(this._bufferData,this._name+"_UniformList:"+this._getNames()),this._engine._features.trackUbosInFrame&&(this._buffers.push([this._buffer,this._engine._features.checkUbosContentBeforeUpload?this._bufferData.slice():void 0]),this._bufferIndex=this._buffers.length-1,this._createBufferOnWrite=!1))}_rebuildAfterContextLost(){this._engine._features.trackUbosInFrame&&(this._buffers=[],this._currentFrameId=0),this._rebuild()}get _numBuffers(){return this._buffers.length}get _indexBuffer(){return this._bufferIndex}get name(){return this._name}get currentEffect(){return this._currentEffect}_buffersEqual(a,x){for(let c=0;c<a.length;++c)if(a[c]!==x[c])return!1;return!0}_copyBuffer(a,x){for(let c=0;c<a.length;++c)x[c]=a[c]}update(){if(!this._noUBO){if(this.bindUniformBuffer(),!this._buffer){this.create();return}if(!this._dynamic&&!this._needSync){this._createBufferOnWrite=this._engine._features.trackUbosInFrame;return}if(this._buffers&&this._buffers.length>1&&this._buffers[this._bufferIndex][1])if(this._buffersEqual(this._bufferData,this._buffers[this._bufferIndex][1])){this._needSync=!1,this._createBufferOnWrite=this._engine._features.trackUbosInFrame;return}else this._copyBuffer(this._bufferData,this._buffers[this._bufferIndex][1]);this._engine.updateUniformBuffer(this._buffer,this._bufferData),this._engine._features._collectUbosUpdatedInFrame&&(ys._UpdatedUbosInFrame[this._name]||(ys._UpdatedUbosInFrame[this._name]=0),ys._UpdatedUbosInFrame[this._name]++),this._needSync=!1,this._createBufferOnWrite=this._engine._features.trackUbosInFrame}}_createNewBuffer(){this._bufferIndex+1<this._buffers.length?(this._bufferIndex++,this._buffer=this._buffers[this._bufferIndex][0],this._createBufferOnWrite=!1,this._needSync=!0):this._rebuild()}_checkNewFrame(){this._engine._features.trackUbosInFrame&&this._currentFrameId!==this._engine.frameId&&(this._currentFrameId=this._engine.frameId,this._createBufferOnWrite=!1,this._buffers&&this._buffers.length>0?(this._needSync=this._bufferIndex!==0,this._bufferIndex=0,this._buffer=this._buffers[this._bufferIndex][0]):this._bufferIndex=-1)}updateUniform(a,x,c){this._checkNewFrame();let u=this._uniformLocations[a];if(u===void 0){if(this._buffer){Qt.Error("Cannot add an uniform after UBO has been created. uniformName="+a);return}this.addUniform(a,c),u=this._uniformLocations[a]}if(this._buffer||this.create(),this._dynamic)for(let g=0;g<c;g++)this._bufferData[u+g]=x[g];else{let g=!1;for(let y=0;y<c;y++)(c===16&&!this._engine._features.uniformBufferHardCheckMatrix||this._bufferData[u+y]!==Math.fround(x[y]))&&(g=!0,this._createBufferOnWrite&&this._createNewBuffer(),this._bufferData[u+y]=x[y]);this._needSync=this._needSync||g}}updateUniformArray(a,x,c){this._checkNewFrame();const u=this._uniformLocations[a];if(u===void 0){Qt.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");return}this._buffer||this.create();const g=this._uniformArraySizes[a];if(this._dynamic)for(let y=0;y<c;y++)this._bufferData[u+y]=x[y];else{let y=!1,v=0,w=0;for(let B=0;B<c;B++)if(this._bufferData[u+w*4+v]!==_t.FloatRound(x[B])&&(y=!0,this._createBufferOnWrite&&this._createNewBuffer(),this._bufferData[u+w*4+v]=x[B]),v++,v===g.strideSize){for(;v<4;v++)this._bufferData[u+w*4+v]=0;v=0,w++}this._needSync=this._needSync||y}}_cacheMatrix(a,x){this._checkNewFrame();const c=this._valueCache[a],u=x.updateFlag;return c!==void 0&&c===u?!1:(this._valueCache[a]=u,!0)}_updateMatrix3x3ForUniform(a,x){for(let c=0;c<3;c++)ys._TempBuffer[c*4]=x[c*3],ys._TempBuffer[c*4+1]=x[c*3+1],ys._TempBuffer[c*4+2]=x[c*3+2],ys._TempBuffer[c*4+3]=0;this.updateUniform(a,ys._TempBuffer,12)}_updateMatrix3x3ForEffect(a,x){this._currentEffect.setMatrix3x3(a,x)}_updateMatrix2x2ForEffect(a,x){this._currentEffect.setMatrix2x2(a,x)}_updateMatrix2x2ForUniform(a,x){for(let c=0;c<2;c++)ys._TempBuffer[c*4]=x[c*2],ys._TempBuffer[c*4+1]=x[c*2+1],ys._TempBuffer[c*4+2]=0,ys._TempBuffer[c*4+3]=0;this.updateUniform(a,ys._TempBuffer,8)}_updateFloatForEffect(a,x){this._currentEffect.setFloat(a,x)}_updateFloatForUniform(a,x){ys._TempBuffer[0]=x,this.updateUniform(a,ys._TempBuffer,1)}_updateFloat2ForEffect(a,x,c,u=""){this._currentEffect.setFloat2(a+u,x,c)}_updateFloat2ForUniform(a,x,c){ys._TempBuffer[0]=x,ys._TempBuffer[1]=c,this.updateUniform(a,ys._TempBuffer,2)}_updateFloat3ForEffect(a,x,c,u,g=""){this._currentEffect.setFloat3(a+g,x,c,u)}_updateFloat3ForUniform(a,x,c,u){ys._TempBuffer[0]=x,ys._TempBuffer[1]=c,ys._TempBuffer[2]=u,this.updateUniform(a,ys._TempBuffer,3)}_updateFloat4ForEffect(a,x,c,u,g,y=""){this._currentEffect.setFloat4(a+y,x,c,u,g)}_updateFloat4ForUniform(a,x,c,u,g){ys._TempBuffer[0]=x,ys._TempBuffer[1]=c,ys._TempBuffer[2]=u,ys._TempBuffer[3]=g,this.updateUniform(a,ys._TempBuffer,4)}_updateFloatArrayForEffect(a,x){this._currentEffect.setFloatArray(a,x)}_updateFloatArrayForUniform(a,x){this.updateUniformArray(a,x,x.length)}_updateArrayForEffect(a,x){this._currentEffect.setArray(a,x)}_updateArrayForUniform(a,x){this.updateUniformArray(a,x,x.length)}_updateIntArrayForEffect(a,x){this._currentEffect.setIntArray(a,x)}_updateIntArrayForUniform(a,x){ys._TempBufferInt32View.set(x),this.updateUniformArray(a,ys._TempBuffer,x.length)}_updateUIntArrayForEffect(a,x){this._currentEffect.setUIntArray(a,x)}_updateUIntArrayForUniform(a,x){ys._TempBufferUInt32View.set(x),this.updateUniformArray(a,ys._TempBuffer,x.length)}_updateMatrixForEffect(a,x){this._currentEffect.setMatrix(a,x)}_updateMatrixForUniform(a,x){this._cacheMatrix(a,x)&&this.updateUniform(a,x.asArray(),16)}_updateMatricesForEffect(a,x){this._currentEffect.setMatrices(a,x)}_updateMatricesForUniform(a,x){this.updateUniform(a,x,x.length)}_updateVector3ForEffect(a,x){this._currentEffect.setVector3(a,x)}_updateVector3ForUniform(a,x){ys._TempBuffer[0]=x.x,ys._TempBuffer[1]=x.y,ys._TempBuffer[2]=x.z,this.updateUniform(a,ys._TempBuffer,3)}_updateVector4ForEffect(a,x){this._currentEffect.setVector4(a,x)}_updateVector4ForUniform(a,x){ys._TempBuffer[0]=x.x,ys._TempBuffer[1]=x.y,ys._TempBuffer[2]=x.z,ys._TempBuffer[3]=x.w,this.updateUniform(a,ys._TempBuffer,4)}_updateColor3ForEffect(a,x,c=""){this._currentEffect.setColor3(a+c,x)}_updateColor3ForUniform(a,x){ys._TempBuffer[0]=x.r,ys._TempBuffer[1]=x.g,ys._TempBuffer[2]=x.b,this.updateUniform(a,ys._TempBuffer,3)}_updateColor4ForEffect(a,x,c,u=""){this._currentEffect.setColor4(a+u,x,c)}_updateDirectColor4ForEffect(a,x,c=""){this._currentEffect.setDirectColor4(a+c,x)}_updateColor4ForUniform(a,x,c){ys._TempBuffer[0]=x.r,ys._TempBuffer[1]=x.g,ys._TempBuffer[2]=x.b,ys._TempBuffer[3]=c,this.updateUniform(a,ys._TempBuffer,4)}_updateDirectColor4ForUniform(a,x){ys._TempBuffer[0]=x.r,ys._TempBuffer[1]=x.g,ys._TempBuffer[2]=x.b,ys._TempBuffer[3]=x.a,this.updateUniform(a,ys._TempBuffer,4)}_updateIntForEffect(a,x,c=""){this._currentEffect.setInt(a+c,x)}_updateIntForUniform(a,x){ys._TempBufferInt32View[0]=x,this.updateUniform(a,ys._TempBuffer,1)}_updateInt2ForEffect(a,x,c,u=""){this._currentEffect.setInt2(a+u,x,c)}_updateInt2ForUniform(a,x,c){ys._TempBufferInt32View[0]=x,ys._TempBufferInt32View[1]=c,this.updateUniform(a,ys._TempBuffer,2)}_updateInt3ForEffect(a,x,c,u,g=""){this._currentEffect.setInt3(a+g,x,c,u)}_updateInt3ForUniform(a,x,c,u){ys._TempBufferInt32View[0]=x,ys._TempBufferInt32View[1]=c,ys._TempBufferInt32View[2]=u,this.updateUniform(a,ys._TempBuffer,3)}_updateInt4ForEffect(a,x,c,u,g,y=""){this._currentEffect.setInt4(a+y,x,c,u,g)}_updateInt4ForUniform(a,x,c,u,g){ys._TempBufferInt32View[0]=x,ys._TempBufferInt32View[1]=c,ys._TempBufferInt32View[2]=u,ys._TempBufferInt32View[3]=g,this.updateUniform(a,ys._TempBuffer,4)}_updateUIntForEffect(a,x,c=""){this._currentEffect.setUInt(a+c,x)}_updateUIntForUniform(a,x){ys._TempBufferUInt32View[0]=x,this.updateUniform(a,ys._TempBuffer,1)}_updateUInt2ForEffect(a,x,c,u=""){this._currentEffect.setUInt2(a+u,x,c)}_updateUInt2ForUniform(a,x,c){ys._TempBufferUInt32View[0]=x,ys._TempBufferUInt32View[1]=c,this.updateUniform(a,ys._TempBuffer,2)}_updateUInt3ForEffect(a,x,c,u,g=""){this._currentEffect.setUInt3(a+g,x,c,u)}_updateUInt3ForUniform(a,x,c,u){ys._TempBufferUInt32View[0]=x,ys._TempBufferUInt32View[1]=c,ys._TempBufferUInt32View[2]=u,this.updateUniform(a,ys._TempBuffer,3)}_updateUInt4ForEffect(a,x,c,u,g,y=""){this._currentEffect.setUInt4(a+y,x,c,u,g)}_updateUInt4ForUniform(a,x,c,u,g){ys._TempBufferUInt32View[0]=x,ys._TempBufferUInt32View[1]=c,ys._TempBufferUInt32View[2]=u,ys._TempBufferUInt32View[3]=g,this.updateUniform(a,ys._TempBuffer,4)}setTexture(a,x){this._currentEffect.setTexture(a,x)}bindTexture(a,x){this._currentEffect._bindTexture(a,x)}updateUniformDirectly(a,x){this.updateUniform(a,x,x.length),this.update()}bindToEffect(a,x){this._currentEffect=a,this._currentEffectName=x}bindUniformBuffer(){!this._noUBO&&this._buffer&&this._currentEffect&&this._currentEffect.bindUniformBuffer(this._buffer,this._currentEffectName)}unbindEffect(){this._currentEffect=void 0,this._currentEffectName=void 0}setDataBuffer(a){if(!this._buffers)return this._buffer===a;for(let x=0;x<this._buffers.length;++x)if(this._buffers[x][0]===a)return this._bufferIndex=x,this._buffer=a,this._createBufferOnWrite=!1,this._currentEffect=void 0,!0;return!1}dispose(){if(this._noUBO)return;const a=this._engine._uniformBuffers,x=a.indexOf(this);if(x!==-1&&(a[x]=a[a.length-1],a.pop()),this._engine._features.trackUbosInFrame&&this._buffers)for(let c=0;c<this._buffers.length;++c){const u=this._buffers[c][0];this._engine._releaseBuffer(u)}else this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._buffer=null)}}ys._UpdatedUbosInFrame={},ys._MAX_UNIFORM_SIZE=256,ys._TempBuffer=new Float32Array(ys._MAX_UNIFORM_SIZE),ys._TempBufferInt32View=new Int32Array(ys._TempBuffer.buffer),ys._TempBufferUInt32View=new Uint32Array(ys._TempBuffer.buffer);class mu{get isDisposed(){return this._isDisposed}constructor(a,x,c,u=0,g=!1,y=!1,v=!1,w,B){this._isAlreadyOwned=!1,this._isDisposed=!1,a&&a.getScene?this._engine=a.getScene().getEngine():this._engine=a,this._updatable=c,this._instanced=y,this._divisor=w||1,this._label=B,x instanceof fo?(this._data=null,this._buffer=x):(this._data=x,this._buffer=null),this.byteStride=v?u:u*Float32Array.BYTES_PER_ELEMENT,g||this.create()}createVertexBuffer(a,x,c,u,g,y=!1,v){const w=y?x:x*Float32Array.BYTES_PER_ELEMENT,B=u?y?u:u*Float32Array.BYTES_PER_ELEMENT:this.byteStride;return new Ve(this._engine,this,a,this._updatable,!0,B,g===void 0?this._instanced:g,w,c,void 0,void 0,!0,this._divisor||v)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(a=null){!a&&this._buffer||(a=a||this._data,a&&(this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,a),this._data=a):this._updatable?(this._buffer=this._engine.createDynamicVertexBuffer(a,this._label),this._data=a):this._buffer=this._engine.createVertexBuffer(a,void 0,this._label)))}_rebuild(){if(this._data)this._buffer=null,this.create(this._data);else{if(!this._buffer)return;if(this._buffer.capacity>0){this._updatable?this._buffer=this._engine.createDynamicVertexBuffer(this._buffer.capacity,this._label):this._buffer=this._engine.createVertexBuffer(this._buffer.capacity,void 0,this._label);return}Qt.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.uniqueId+")":""}. Buffer reconstruction failed.`),this._buffer=null}}update(a){this.create(a)}updateDirectly(a,x,c,u=!1){this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,a,u?x:x*Float32Array.BYTES_PER_ELEMENT,c?c*this.byteStride:void 0),x===0&&c===void 0?this._data=a:this._data=null)}_increaseReferences(){if(this._buffer){if(!this._isAlreadyOwned){this._isAlreadyOwned=!0;return}this._buffer.references++}}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._isDisposed=!0,this._data=null,this._buffer=null)}}class Ve{get isDisposed(){return this._isDisposed}get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(a){const x=a!=0;this._instanceDivisor=a,x!==this._instanced&&(this._instanced=x,this._computeHashCode())}get _maxVerticesCount(){const a=this.getData();return a?Array.isArray(a)?a.length/(this.byteStride/4)-this.byteOffset/4:(a.byteLength-this.byteOffset)/this.byteStride:0}constructor(a,x,c,u,g,y,v,w,B,W,ae=!1,ue=!1,fe=1,Re=!1){this._isDisposed=!1;let _e=!1;if(this.engine=a,typeof u=="object"&&u!==null?(_e=u.updatable??!1,g=u.postponeInternalCreation,y=u.stride,v=u.instanced,w=u.offset,B=u.size,W=u.type,ae=u.normalized??!1,ue=u.useBytes??!1,fe=u.divisor??1,Re=u.takeBufferOwnership??!1,this._label=u.label):_e=!!u,x instanceof mu?(this._buffer=x,this._ownsBuffer=Re):(this._buffer=new mu(a,x,_e,y,g,v,ue,fe,this._label),this._ownsBuffer=!0),this.uniqueId=Ve._Counter++,this._kind=c,W===void 0){const tt=this.getData();this.type=tt?Ve.GetDataType(tt):Ve.FLOAT}else this.type=W;const Be=Ve.GetTypeByteLength(this.type);ue?(this._size=B||(y?y/Be:Ve.DeduceStride(c)),this.byteStride=y||this._buffer.byteStride||this._size*Be,this.byteOffset=w||0):(this._size=B||y||Ve.DeduceStride(c),this.byteStride=y?y*Be:this._buffer.byteStride||this._size*Be,this.byteOffset=(w||0)*Be),this.normalized=ae,this._instanced=v!==void 0?v:!1,this._instanceDivisor=v?fe:0,this._alignBuffer(),this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120<<0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){this._buffer?._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(a,x){const c=this.getData();return c?Ve.GetFloatData(c,this._size,this.type,this.byteOffset,this.byteStride,this.normalized,a,x):null}getBuffer(){return this._buffer.getBuffer()}getWrapperBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Ve.GetTypeByteLength(this.type)}getOffset(){return this.byteOffset/Ve.GetTypeByteLength(this.type)}getSize(a=!1){return a?this._size*Ve.GetTypeByteLength(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(a){this._buffer.create(a),this._alignBuffer()}update(a){this._buffer.update(a),this._alignBuffer()}updateDirectly(a,x,c=!1){this._buffer.updateDirectly(a,x,void 0,c),this._alignBuffer()}dispose(){this._ownsBuffer&&this._buffer.dispose(),this._isDisposed=!0}forEach(a,x){Ve.ForEach(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,a,this.normalized,x)}_alignBuffer(){}static DeduceStride(a){switch(a){case Ve.UVKind:case Ve.UV2Kind:case Ve.UV3Kind:case Ve.UV4Kind:case Ve.UV5Kind:case Ve.UV6Kind:return 2;case Ve.NormalKind:case Ve.PositionKind:return 3;case Ve.ColorKind:case Ve.ColorInstanceKind:case Ve.MatricesIndicesKind:case Ve.MatricesIndicesExtraKind:case Ve.MatricesWeightsKind:case Ve.MatricesWeightsExtraKind:case Ve.TangentKind:return 4;default:throw new Error("Invalid kind '"+a+"'")}}static GetDataType(a){return a instanceof Int8Array?Ve.BYTE:a instanceof Uint8Array?Ve.UNSIGNED_BYTE:a instanceof Int16Array?Ve.SHORT:a instanceof Uint16Array?Ve.UNSIGNED_SHORT:a instanceof Int32Array?Ve.INT:a instanceof Uint32Array?Ve.UNSIGNED_INT:Ve.FLOAT}static GetTypeByteLength(a){switch(a){case Ve.BYTE:case Ve.UNSIGNED_BYTE:return 1;case Ve.SHORT:case Ve.UNSIGNED_SHORT:return 2;case Ve.INT:case Ve.UNSIGNED_INT:case Ve.FLOAT:return 4;default:throw new Error(`Invalid type '${a}'`)}}static ForEach(a,x,c,u,g,y,v,w){if(a instanceof Array){let B=x/4;const W=c/4;for(let ae=0;ae<y;ae+=u){for(let ue=0;ue<u;ue++)w(a[B+ue],ae+ue);B+=W}}else{const B=a instanceof ArrayBuffer?new DataView(a):new DataView(a.buffer,a.byteOffset,a.byteLength),W=Ve.GetTypeByteLength(g);for(let ae=0;ae<y;ae+=u){let ue=x;for(let fe=0;fe<u;fe++){const Re=Ve._GetFloatValue(B,g,ue,v);w(Re,ae+fe),ue+=W}x+=c}}}static _GetFloatValue(a,x,c,u){switch(x){case Ve.BYTE:{let g=a.getInt8(c);return u&&(g=Math.max(g/127,-1)),g}case Ve.UNSIGNED_BYTE:{let g=a.getUint8(c);return u&&(g=g/255),g}case Ve.SHORT:{let g=a.getInt16(c,!0);return u&&(g=Math.max(g/32767,-1)),g}case Ve.UNSIGNED_SHORT:{let g=a.getUint16(c,!0);return u&&(g=g/65535),g}case Ve.INT:return a.getInt32(c,!0);case Ve.UNSIGNED_INT:return a.getUint32(c,!0);case Ve.FLOAT:return a.getFloat32(c,!0);default:throw new Error(`Invalid component type ${x}`)}}static GetFloatData(a,x,c,u,g,y,v,w){const B=x*Ve.GetTypeByteLength(c),W=v*x;if(c!==Ve.FLOAT||g!==B){const ae=new Float32Array(W);return Ve.ForEach(a,u,g,x,c,W,y,(ue,fe)=>ae[fe]=ue),ae}if(!(a instanceof Array||a instanceof Float32Array)||u!==0||a.length!==W)if(a instanceof Array){const ae=u/4;return a.slice(ae,ae+W)}else{if(a instanceof ArrayBuffer)return new Float32Array(a,u,W);{let ae=a.byteOffset+u;if(w){const fe=new Float32Array(W),Re=new Float32Array(a.buffer,ae,W);return fe.set(Re),fe}const ue=ae%4;return ue&&(ae=Math.max(0,ae-ue)),new Float32Array(a.buffer,ae,W)}}return w?a.slice():a}}Ve._Counter=0,Ve.BYTE=5120,Ve.UNSIGNED_BYTE=5121,Ve.SHORT=5122,Ve.UNSIGNED_SHORT=5123,Ve.INT=5124,Ve.UNSIGNED_INT=5125,Ve.FLOAT=5126,Ve.PositionKind="position",Ve.NormalKind="normal",Ve.TangentKind="tangent",Ve.UVKind="uv",Ve.UV2Kind="uv2",Ve.UV3Kind="uv3",Ve.UV4Kind="uv4",Ve.UV5Kind="uv5",Ve.UV6Kind="uv6",Ve.ColorKind="color",Ve.ColorInstanceKind="instanceColor",Ve.MatricesIndicesKind="matricesIndices",Ve.MatricesWeightsKind="matricesWeights",Ve.MatricesIndicesExtraKind="matricesIndicesExtra",Ve.MatricesWeightsExtraKind="matricesWeightsExtra";class am{constructor(){this.hit=!1,this.distance=0,this.pickedPoint=null,this.pickedMesh=null,this.bu=0,this.bv=0,this.faceId=-1,this.subMeshFaceId=-1,this.subMeshId=0,this.pickedSprite=null,this.thinInstanceIndex=-1,this.ray=null,this.originMesh=null,this.aimTransform=null,this.gripTransform=null}getNormal(a=!1,x=!0){if(!this.pickedMesh||x&&!this.pickedMesh.isVerticesDataPresent(Ve.NormalKind))return null;let c=this.pickedMesh.getIndices();c?.length===0&&(c=null);let u;const g=Yt.Vector3[0],y=Yt.Vector3[1],v=Yt.Vector3[2];if(x){const B=this.pickedMesh.getVerticesData(Ve.NormalKind);let W=c?Ee.FromArrayToRef(B,c[this.faceId*3]*3,g):g.copyFromFloats(B[this.faceId*3*3],B[this.faceId*3*3+1],B[this.faceId*3*3+2]),ae=c?Ee.FromArrayToRef(B,c[this.faceId*3+1]*3,y):y.copyFromFloats(B[(this.faceId*3+1)*3],B[(this.faceId*3+1)*3+1],B[(this.faceId*3+1)*3+2]),ue=c?Ee.FromArrayToRef(B,c[this.faceId*3+2]*3,v):v.copyFromFloats(B[(this.faceId*3+2)*3],B[(this.faceId*3+2)*3+1],B[(this.faceId*3+2)*3+2]);W=W.scale(this.bu),ae=ae.scale(this.bv),ue=ue.scale(1-this.bu-this.bv),u=new Ee(W.x+ae.x+ue.x,W.y+ae.y+ue.y,W.z+ae.z+ue.z)}else{const B=this.pickedMesh.getVerticesData(Ve.PositionKind),W=c?Ee.FromArrayToRef(B,c[this.faceId*3]*3,g):g.copyFromFloats(B[this.faceId*3*3],B[this.faceId*3*3+1],B[this.faceId*3*3+2]),ae=c?Ee.FromArrayToRef(B,c[this.faceId*3+1]*3,y):y.copyFromFloats(B[(this.faceId*3+1)*3],B[(this.faceId*3+1)*3+1],B[(this.faceId*3+1)*3+2]),ue=c?Ee.FromArrayToRef(B,c[this.faceId*3+2]*3,v):v.copyFromFloats(B[(this.faceId*3+2)*3],B[(this.faceId*3+2)*3+1],B[(this.faceId*3+2)*3+2]),fe=W.subtract(ae),Re=ue.subtract(ae);u=Ee.Cross(fe,Re)}const w=(B,W)=>{let ae=B.getWorldMatrix();B.nonUniformScaling&&(Yt.Matrix[0].copyFrom(ae),ae=Yt.Matrix[0],ae.setTranslationFromFloats(0,0,0),ae.invert(),ae.transposeToRef(Yt.Matrix[1]),ae=Yt.Matrix[1]),Ee.TransformNormalToRef(W,ae,W)};if(a&&w(this.pickedMesh,u),this.ray){const B=Yt.Vector3[0].copyFrom(u);a||w(this.pickedMesh,B),Ee.Dot(B,this.ray.direction)>0&&u.negateInPlace()}return u.normalize(),u}getTextureCoordinates(a=Ve.UVKind){if(!this.pickedMesh||!this.pickedMesh.isVerticesDataPresent(a))return null;const x=this.pickedMesh.getIndices();if(!x)return null;const c=this.pickedMesh.getVerticesData(a);if(!c)return null;let u=mr.FromArray(c,x[this.faceId*3]*2),g=mr.FromArray(c,x[this.faceId*3+1]*2),y=mr.FromArray(c,x[this.faceId*3+2]*2);return u=u.scale(this.bu),g=g.scale(this.bv),y=y.scale(1-this.bu-this.bv),new mr(u.x+g.x+y.x,u.y+g.y+y.y)}}class to{constructor(a,x,c,u,g,y){this.source=a,this.pointerX=x,this.pointerY=c,this.meshUnderPointer=u,this.sourceEvent=g,this.additionalData=y}static CreateNew(a,x,c){const u=a.getScene();return new to(a,u.pointerX,u.pointerY,u.meshUnderPointer||a,x,c)}static CreateNewFromSprite(a,x,c,u){return new to(a,x.pointerX,x.pointerY,x.meshUnderPointer,c,u)}static CreateNewFromScene(a,x){return new to(null,a.pointerX,a.pointerY,a.meshUnderPointer,x)}static CreateNewFromPrimitive(a,x,c,u){return new to(a,x.x,x.y,null,c,u)}}class Ym{constructor(a){this._vertexBuffers={},this._scene=a}_prepareBuffers(){if(this._vertexBuffers[Ve.PositionKind])return;const a=[];a.push(1,1),a.push(-1,1),a.push(-1,-1),a.push(1,-1),this._vertexBuffers[Ve.PositionKind]=new Ve(this._scene.getEngine(),a,Ve.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const a=[];a.push(0),a.push(1),a.push(2),a.push(0),a.push(2),a.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(a)}_rebuild(){const a=this._vertexBuffers[Ve.PositionKind];a&&(a._rebuild(),this._buildIndexBuffer())}_prepareFrame(a=null,x=null){const c=this._scene.activeCamera;return!c||(x=x||c._postProcesses.filter(u=>u!=null),!x||x.length===0||!this._scene.postProcessesEnabled)?!1:(x[0].activate(c,a,x!=null),!0)}directRender(a,x=null,c=!1,u=0,g=0,y=!1){const v=this._scene.getEngine();for(let w=0;w<a.length;w++){w<a.length-1?a[w+1].activate(this._scene.activeCamera,x?.texture):(x?v.bindFramebuffer(x,u,void 0,void 0,c,g):y||v.restoreDefaultFramebuffer(),v._debugInsertMarker?.(`post process ${a[w].name} output`));const B=a[w],W=B.apply();W&&(B.onBeforeRenderObservable.notifyObservers(W),this._prepareBuffers(),v.bindBuffers(this._vertexBuffers,this._indexBuffer,W),v.drawElementsType(0,0,6),B.onAfterRenderObservable.notifyObservers(W))}v.setDepthBuffer(!0),v.setDepthWrite(!0)}_finalizeFrame(a,x,c,u,g=!1){const y=this._scene.activeCamera;if(!y||(u=u||y._postProcesses.filter(w=>w!=null),u.length===0||!this._scene.postProcessesEnabled))return;const v=this._scene.getEngine();for(let w=0,B=u.length;w<B;w++){const W=u[w];if(w<B-1?W._outputTexture=u[w+1].activate(y,x?.texture):(x?(v.bindFramebuffer(x,c,void 0,void 0,g),W._outputTexture=x):(v.restoreDefaultFramebuffer(),W._outputTexture=null),v._debugInsertMarker?.(`post process ${u[w].name} output`)),a)break;const ae=W.apply();ae&&(W.onBeforeRenderObservable.notifyObservers(ae),this._prepareBuffers(),v.bindBuffers(this._vertexBuffers,this._indexBuffer,ae),v.drawElementsType(0,0,6),W.onAfterRenderObservable.notifyObservers(ae))}v.setDepthBuffer(!0),v.setDepthWrite(!0),v.setAlphaMode(0)}dispose(){const a=this._vertexBuffers[Ve.PositionKind];a&&(a.dispose(),this._vertexBuffers[Ve.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}class Ml{set opaqueSortCompareFn(a){a?this._opaqueSortCompareFn=a:this._opaqueSortCompareFn=Ml.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(a){a?this._alphaTestSortCompareFn=a:this._alphaTestSortCompareFn=Ml.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(a){a?this._transparentSortCompareFn=a:this._transparentSortCompareFn=Ml.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(a,x,c=null,u=null,g=null){this.index=a,this._opaqueSubMeshes=new lt(256),this._transparentSubMeshes=new lt(256),this._alphaTestSubMeshes=new lt(256),this._depthOnlySubMeshes=new lt(256),this._particleSystems=new lt(256),this._spriteManagers=new lt(256),this._empty=!0,this._edgesRenderers=new yt(16),this._scene=x,this.opaqueSortCompareFn=c,this.alphaTestSortCompareFn=u,this.transparentSortCompareFn=g}render(a,x,c,u){if(a){a(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);return}const g=this._scene.getEngine();this._depthOnlySubMeshes.length!==0&&(g.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),g.setColorWrite(!0)),this._opaqueSubMeshes.length!==0&&this._renderOpaque(this._opaqueSubMeshes),this._alphaTestSubMeshes.length!==0&&this._renderAlphaTest(this._alphaTestSubMeshes);const y=g.getStencilBuffer();if(g.setStencilBuffer(!1),x&&this._renderSprites(),c&&this._renderParticles(u),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),this._transparentSubMeshes.length!==0||this._scene.useOrderIndependentTransparency){if(g.setStencilBuffer(y),this._scene.useOrderIndependentTransparency){const v=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);v.length&&this._renderTransparent(v)}else this._renderTransparent(this._transparentSubMeshes);g.setAlphaMode(0)}if(g.setStencilBuffer(!1),this._edgesRenderers.length){for(let v=0;v<this._edgesRenderers.length;v++)this._edgesRenderers.data[v].render();g.setAlphaMode(0)}g.setStencilBuffer(y)}_renderOpaqueSorted(a){Ml._RenderSorted(a,this._opaqueSortCompareFn,this._scene.activeCamera,!1)}_renderAlphaTestSorted(a){Ml._RenderSorted(a,this._alphaTestSortCompareFn,this._scene.activeCamera,!1)}_renderTransparentSorted(a){Ml._RenderSorted(a,this._transparentSortCompareFn,this._scene.activeCamera,!0)}static _RenderSorted(a,x,c,u){let g=0,y;const v=c?c.globalPosition:Ml._ZeroVector;if(u)for(;g<a.length;g++)y=a.data[g],y._alphaIndex=y.getMesh().alphaIndex,y._distanceToCamera=Ee.Distance(y.getBoundingInfo().boundingSphere.centerWorld,v);const w=a.length===a.data.length?a.data:a.data.slice(0,a.length);x&&w.sort(x);const B=w[0].getMesh().getScene();for(g=0;g<w.length;g++)if(y=w[g],!(B._activeMeshesFrozenButKeepClipping&&!y.isInFrustum(B._frustumPlanes))){if(u){const W=y.getMaterial();if(W&&W.needDepthPrePass){const ae=W.getScene().getEngine();ae.setColorWrite(!1),ae.setAlphaMode(0),y.render(!1),ae.setColorWrite(!0)}}y.render(u)}}static defaultTransparentSortCompare(a,x){return a._alphaIndex>x._alphaIndex?1:a._alphaIndex<x._alphaIndex?-1:Ml.backToFrontSortCompare(a,x)}static backToFrontSortCompare(a,x){return a._distanceToCamera<x._distanceToCamera?1:a._distanceToCamera>x._distanceToCamera?-1:0}static frontToBackSortCompare(a,x){return a._distanceToCamera<x._distanceToCamera?-1:a._distanceToCamera>x._distanceToCamera?1:0}static PainterSortCompare(a,x){const c=a.getMesh(),u=x.getMesh();return c.material&&u.material?c.material.uniqueId-u.material.uniqueId:c.uniqueId-u.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(a,x,c){x===void 0&&(x=a.getMesh()),c===void 0&&(c=a.getMaterial()),c!=null&&(c.needAlphaBlendingForMesh(x)?this._transparentSubMeshes.push(a):c.needAlphaTesting()?(c.needDepthPrePass&&this._depthOnlySubMeshes.push(a),this._alphaTestSubMeshes.push(a)):(c.needDepthPrePass&&this._depthOnlySubMeshes.push(a),this._opaqueSubMeshes.push(a)),x._renderingGroup=this,x._edgesRenderer&&x._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(x._edgesRenderer),this._empty=!1)}dispatchSprites(a){this._spriteManagers.push(a),this._empty=!1}dispatchParticles(a){this._particleSystems.push(a),this._empty=!1}_renderParticles(a){if(this._particleSystems.length===0)return;const x=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let c=0;c<this._particleSystems.length;c++){const u=this._particleSystems.data[c];if((x&&x.layerMask&u.layerMask)===0)continue;const g=u.emitter;(!g.position||!a||a.indexOf(g)!==-1)&&this._scene._activeParticles.addCount(u.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||this._spriteManagers.length===0)return;const a=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let x=0;x<this._spriteManagers.length;x++){const c=this._spriteManagers.data[x];(a&&a.layerMask&c.layerMask)!==0&&c.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}Ml._ZeroVector=Ee.Zero();class vP{}class io{get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(a){a!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=a,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const a of this._scene.meshes)if(a.subMeshes)for(const x of a.subMeshes)x._wasDispatched=!1;if(this._scene.spriteManagers)for(const a of this._scene.spriteManagers)a._wasDispatched=!1;for(const a of this._scene.particleSystems)a._wasDispatched=!1}constructor(a){this._useSceneAutoClearSetup=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new vP,this._maintainStateBetweenFrames=!1,this._scene=a;for(let x=io.MIN_RENDERINGGROUPS;x<io.MAX_RENDERINGGROUPS;x++)this._autoClearDepthStencil[x]={autoClear:!0,depth:!0,stencil:!0}}getRenderingGroup(a){const x=a||0;return this._prepareRenderingGroup(x),this._renderingGroups[x]}_clearDepthStencilBuffer(a=!0,x=!0){this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,a,x),this._depthStencilBufferAlreadyCleaned=!0)}render(a,x,c,u){const g=this._renderingGroupInfo;if(g.scene=this._scene,g.camera=this._scene.activeCamera,this._scene.spriteManagers&&u)for(let y=0;y<this._scene.spriteManagers.length;y++){const v=this._scene.spriteManagers[y];this.dispatchSprites(v)}for(let y=io.MIN_RENDERINGGROUPS;y<io.MAX_RENDERINGGROUPS;y++){this._depthStencilBufferAlreadyCleaned=y===io.MIN_RENDERINGGROUPS;const v=this._renderingGroups[y];if(!v||v._empty)continue;const w=1<<y;if(g.renderingGroupId=y,this._scene.onBeforeRenderingGroupObservable.notifyObservers(g,w),io.AUTOCLEAR){const B=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(y):this._autoClearDepthStencil[y];B&&B.autoClear&&this._clearDepthStencilBuffer(B.depth,B.stencil)}for(const B of this._scene._beforeRenderingGroupDrawStage)B.action(y);v.render(a,u,c,x);for(const B of this._scene._afterRenderingGroupDrawStage)B.action(y);this._scene.onAfterRenderingGroupObservable.notifyObservers(g,w)}}reset(){if(!this.maintainStateBetweenFrames)for(let a=io.MIN_RENDERINGGROUPS;a<io.MAX_RENDERINGGROUPS;a++){const x=this._renderingGroups[a];x&&x.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let a=io.MIN_RENDERINGGROUPS;a<io.MAX_RENDERINGGROUPS;a++){const x=this._renderingGroups[a];x&&x.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let a=io.MIN_RENDERINGGROUPS;a<io.MAX_RENDERINGGROUPS;a++){const x=this._renderingGroups[a];x&&x.dispose()}}_prepareRenderingGroup(a){this._renderingGroups[a]===void 0&&(this._renderingGroups[a]=new Ml(a,this._scene,this._customOpaqueSortCompareFn[a],this._customAlphaTestSortCompareFn[a],this._customTransparentSortCompareFn[a]))}dispatchSprites(a){this.maintainStateBetweenFrames&&a._wasDispatched||(a._wasDispatched=!0,this.getRenderingGroup(a.renderingGroupId).dispatchSprites(a))}dispatchParticles(a){this.maintainStateBetweenFrames&&a._wasDispatched||(a._wasDispatched=!0,this.getRenderingGroup(a.renderingGroupId).dispatchParticles(a))}dispatch(a,x,c){x===void 0&&(x=a.getMesh()),!(this.maintainStateBetweenFrames&&a._wasDispatched)&&(a._wasDispatched=!0,this.getRenderingGroup(x.renderingGroupId).dispatch(a,x,c))}setRenderingOrder(a,x=null,c=null,u=null){if(this._customOpaqueSortCompareFn[a]=x,this._customAlphaTestSortCompareFn[a]=c,this._customTransparentSortCompareFn[a]=u,this._renderingGroups[a]){const g=this._renderingGroups[a];g.opaqueSortCompareFn=this._customOpaqueSortCompareFn[a],g.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[a],g.transparentSortCompareFn=this._customTransparentSortCompareFn[a]}}setRenderingAutoClearDepthStencil(a,x,c=!0,u=!0){this._autoClearDepthStencil[a]={autoClear:x,depth:c,stencil:u}}getAutoClearDepthStencilSetup(a){return this._autoClearDepthStencil[a]}}io.MAX_RENDERINGGROUPS=4,io.MIN_RENDERINGGROUPS=0,io.AUTOCLEAR=!0;class Xs{}Xs.NAME_EFFECTLAYER="EffectLayer",Xs.NAME_LAYER="Layer",Xs.NAME_LENSFLARESYSTEM="LensFlareSystem",Xs.NAME_BOUNDINGBOXRENDERER="BoundingBoxRenderer",Xs.NAME_PARTICLESYSTEM="ParticleSystem",Xs.NAME_GAMEPAD="Gamepad",Xs.NAME_SIMPLIFICATIONQUEUE="SimplificationQueue",Xs.NAME_GEOMETRYBUFFERRENDERER="GeometryBufferRenderer",Xs.NAME_PREPASSRENDERER="PrePassRenderer",Xs.NAME_DEPTHRENDERER="DepthRenderer",Xs.NAME_DEPTHPEELINGRENDERER="DepthPeelingRenderer",Xs.NAME_POSTPROCESSRENDERPIPELINEMANAGER="PostProcessRenderPipelineManager",Xs.NAME_SPRITE="Sprite",Xs.NAME_SUBSURFACE="SubSurface",Xs.NAME_OUTLINERENDERER="Outline",Xs.NAME_PROCEDURALTEXTURE="ProceduralTexture",Xs.NAME_SHADOWGENERATOR="ShadowGenerator",Xs.NAME_OCTREE="Octree",Xs.NAME_PHYSICSENGINE="PhysicsEngine",Xs.NAME_AUDIO="Audio",Xs.NAME_FLUIDRENDERER="FluidRenderer",Xs.STEP_ISREADYFORMESH_EFFECTLAYER=0,Xs.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER=0,Xs.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER=0,Xs.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER=0,Xs.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER=1,Xs.STEP_BEFORECAMERADRAW_PREPASS=0,Xs.STEP_BEFORECAMERADRAW_EFFECTLAYER=1,Xs.STEP_BEFORECAMERADRAW_LAYER=2,Xs.STEP_BEFORERENDERTARGETDRAW_PREPASS=0,Xs.STEP_BEFORERENDERTARGETDRAW_LAYER=1,Xs.STEP_BEFORERENDERINGMESH_PREPASS=0,Xs.STEP_BEFORERENDERINGMESH_OUTLINE=1,Xs.STEP_AFTERRENDERINGMESH_PREPASS=0,Xs.STEP_AFTERRENDERINGMESH_OUTLINE=1,Xs.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW=0,Xs.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER=1,Xs.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE=0,Xs.STEP_BEFORECAMERAUPDATE_GAMEPAD=1,Xs.STEP_BEFORECLEAR_PROCEDURALTEXTURE=0,Xs.STEP_BEFORECLEAR_PREPASS=1,Xs.STEP_BEFORERENDERTARGETCLEAR_PREPASS=0,Xs.STEP_AFTERRENDERTARGETDRAW_PREPASS=0,Xs.STEP_AFTERRENDERTARGETDRAW_LAYER=1,Xs.STEP_AFTERCAMERADRAW_PREPASS=0,Xs.STEP_AFTERCAMERADRAW_EFFECTLAYER=1,Xs.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM=2,Xs.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW=3,Xs.STEP_AFTERCAMERADRAW_LAYER=4,Xs.STEP_AFTERCAMERADRAW_FLUIDRENDERER=5,Xs.STEP_AFTERCAMERAPOSTPROCESS_LAYER=0,Xs.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER=0,Xs.STEP_AFTERRENDER_AUDIO=0,Xs.STEP_GATHERRENDERTARGETS_DEPTHRENDERER=0,Xs.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER=1,Xs.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR=2,Xs.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER=3,Xs.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER=0,Xs.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER=1,Xs.STEP_POINTERMOVE_SPRITE=0,Xs.STEP_POINTERDOWN_SPRITE=0,Xs.STEP_POINTERUP_SPRITE=0;class Ia extends Array{constructor(a){super(...a)}static Create(){return Object.create(Ia.prototype)}registerStep(a,x,c){let u=0,g=Number.MAX_VALUE;for(;u<this.length&&(g=this[u].index,!(a<g));u++);this.splice(u,0,{index:a,component:x,action:c.bind(x)})}clear(){this.length=0}}class dr{}dr.POINTERDOWN=1,dr.POINTERUP=2,dr.POINTERMOVE=4,dr.POINTERWHEEL=8,dr.POINTERPICK=16,dr.POINTERTAP=32,dr.POINTERDOUBLETAP=64;class xT{constructor(a,x){this.type=a,this.event=x}}class IP extends xT{constructor(a,x,c,u){super(a,x),this.ray=null,this.originalPickingInfo=null,this.skipOnPointerObservable=!1,this.localPosition=new mr(c,u)}}class $2 extends xT{get pickInfo(){return this._pickInfo||this._generatePickInfo(),this._pickInfo}constructor(a,x,c,u=null){super(a,x),this._pickInfo=c,this._inputManager=u}_generatePickInfo(){this._inputManager&&(this._pickInfo=this._inputManager._pickMove(this.event),this._inputManager._setRayOnPointerInfo(this._pickInfo,this.event),this._inputManager=null)}}class Mx{constructor(){this.hoverCursor="",this.actions=[],this.isRecursive=!1}static get HasTriggers(){for(const a in Mx.Triggers)if(Object.prototype.hasOwnProperty.call(Mx.Triggers,a))return!0;return!1}static get HasPickTriggers(){for(const a in Mx.Triggers)if(Object.prototype.hasOwnProperty.call(Mx.Triggers,a)){const x=parseInt(a);if(x>=1&&x<=7)return!0}return!1}static HasSpecificTrigger(a){for(const x in Mx.Triggers)if(Object.prototype.hasOwnProperty.call(Mx.Triggers,x)&&parseInt(x)===a)return!0;return!1}}Mx.Triggers={};class gu{}gu.KEYDOWN=1,gu.KEYUP=2;class a_{constructor(a,x){this.type=a,this.event=x}}class lT extends a_{get skipOnPointerObservable(){return this.skipOnKeyboardObservable}set skipOnPointerObservable(a){this.skipOnKeyboardObservable=a}constructor(a,x){super(a,x),this.type=a,this.event=x,this.skipOnKeyboardObservable=!1}}var Rs;(function(F){F[F.Generic=0]="Generic",F[F.Keyboard=1]="Keyboard",F[F.Mouse=2]="Mouse",F[F.Touch=3]="Touch",F[F.DualShock=4]="DualShock",F[F.Xbox=5]="Xbox",F[F.Switch=6]="Switch",F[F.DualSense=7]="DualSense"})(Rs||(Rs={}));var xr;(function(F){F[F.Horizontal=0]="Horizontal",F[F.Vertical=1]="Vertical",F[F.LeftClick=2]="LeftClick",F[F.MiddleClick=3]="MiddleClick",F[F.RightClick=4]="RightClick",F[F.BrowserBack=5]="BrowserBack",F[F.BrowserForward=6]="BrowserForward",F[F.MouseWheelX=7]="MouseWheelX",F[F.MouseWheelY=8]="MouseWheelY",F[F.MouseWheelZ=9]="MouseWheelZ",F[F.Move=12]="Move"})(xr||(xr={}));var $m;(function(F){F[F.Horizontal=0]="Horizontal",F[F.Vertical=1]="Vertical",F[F.LeftClick=2]="LeftClick",F[F.MiddleClick=3]="MiddleClick",F[F.RightClick=4]="RightClick",F[F.BrowserBack=5]="BrowserBack",F[F.BrowserForward=6]="BrowserForward",F[F.MouseWheelX=7]="MouseWheelX",F[F.MouseWheelY=8]="MouseWheelY",F[F.MouseWheelZ=9]="MouseWheelZ",F[F.DeltaHorizontal=10]="DeltaHorizontal",F[F.DeltaVertical=11]="DeltaVertical"})($m||($m={}));var hT;(function(F){F[F.Cross=0]="Cross",F[F.Circle=1]="Circle",F[F.Square=2]="Square",F[F.Triangle=3]="Triangle",F[F.L1=4]="L1",F[F.R1=5]="R1",F[F.L2=6]="L2",F[F.R2=7]="R2",F[F.Share=8]="Share",F[F.Options=9]="Options",F[F.L3=10]="L3",F[F.R3=11]="R3",F[F.DPadUp=12]="DPadUp",F[F.DPadDown=13]="DPadDown",F[F.DPadLeft=14]="DPadLeft",F[F.DPadRight=15]="DPadRight",F[F.Home=16]="Home",F[F.TouchPad=17]="TouchPad",F[F.LStickXAxis=18]="LStickXAxis",F[F.LStickYAxis=19]="LStickYAxis",F[F.RStickXAxis=20]="RStickXAxis",F[F.RStickYAxis=21]="RStickYAxis"})(hT||(hT={}));var uT;(function(F){F[F.Cross=0]="Cross",F[F.Circle=1]="Circle",F[F.Square=2]="Square",F[F.Triangle=3]="Triangle",F[F.L1=4]="L1",F[F.R1=5]="R1",F[F.L2=6]="L2",F[F.R2=7]="R2",F[F.Create=8]="Create",F[F.Options=9]="Options",F[F.L3=10]="L3",F[F.R3=11]="R3",F[F.DPadUp=12]="DPadUp",F[F.DPadDown=13]="DPadDown",F[F.DPadLeft=14]="DPadLeft",F[F.DPadRight=15]="DPadRight",F[F.Home=16]="Home",F[F.TouchPad=17]="TouchPad",F[F.LStickXAxis=18]="LStickXAxis",F[F.LStickYAxis=19]="LStickYAxis",F[F.RStickXAxis=20]="RStickXAxis",F[F.RStickYAxis=21]="RStickYAxis"})(uT||(uT={}));var dT;(function(F){F[F.A=0]="A",F[F.B=1]="B",F[F.X=2]="X",F[F.Y=3]="Y",F[F.LB=4]="LB",F[F.RB=5]="RB",F[F.LT=6]="LT",F[F.RT=7]="RT",F[F.Back=8]="Back",F[F.Start=9]="Start",F[F.LS=10]="LS",F[F.RS=11]="RS",F[F.DPadUp=12]="DPadUp",F[F.DPadDown=13]="DPadDown",F[F.DPadLeft=14]="DPadLeft",F[F.DPadRight=15]="DPadRight",F[F.Home=16]="Home",F[F.LStickXAxis=17]="LStickXAxis",F[F.LStickYAxis=18]="LStickYAxis",F[F.RStickXAxis=19]="RStickXAxis",F[F.RStickYAxis=20]="RStickYAxis"})(dT||(dT={}));var fT;(function(F){F[F.B=0]="B",F[F.A=1]="A",F[F.Y=2]="Y",F[F.X=3]="X",F[F.L=4]="L",F[F.R=5]="R",F[F.ZL=6]="ZL",F[F.ZR=7]="ZR",F[F.Minus=8]="Minus",F[F.Plus=9]="Plus",F[F.LS=10]="LS",F[F.RS=11]="RS",F[F.DPadUp=12]="DPadUp",F[F.DPadDown=13]="DPadDown",F[F.DPadLeft=14]="DPadLeft",F[F.DPadRight=15]="DPadRight",F[F.Home=16]="Home",F[F.Capture=17]="Capture",F[F.LStickXAxis=18]="LStickXAxis",F[F.LStickYAxis=19]="LStickYAxis",F[F.RStickXAxis=20]="RStickXAxis",F[F.RStickYAxis=21]="RStickYAxis"})(fT||(fT={}));var mT;(function(F){F[F.PointerMove=0]="PointerMove",F[F.PointerDown=1]="PointerDown",F[F.PointerUp=2]="PointerUp"})(mT||(mT={}));class _u{}_u.DOM_DELTA_PIXEL=0,_u.DOM_DELTA_LINE=1,_u.DOM_DELTA_PAGE=2;class Wh{static CreateDeviceEvent(a,x,c,u,g,y,v){switch(a){case Rs.Keyboard:return this._CreateKeyboardEvent(c,u,g,y);case Rs.Mouse:if(c===xr.MouseWheelX||c===xr.MouseWheelY||c===xr.MouseWheelZ)return this._CreateWheelEvent(a,x,c,u,g,y);case Rs.Touch:return this._CreatePointerEvent(a,x,c,u,g,y,v);default:throw`Unable to generate event for device ${Rs[a]}`}}static _CreatePointerEvent(a,x,c,u,g,y,v){const w=this._CreateMouseEvent(a,x,c,u,g,y);a===Rs.Mouse?(w.deviceType=Rs.Mouse,w.pointerId=1,w.pointerType="mouse"):(w.deviceType=Rs.Touch,w.pointerId=v??x,w.pointerType="touch");let B=0;return B+=g.pollInput(a,x,xr.LeftClick),B+=g.pollInput(a,x,xr.RightClick)*2,B+=g.pollInput(a,x,xr.MiddleClick)*4,w.buttons=B,c===xr.Move?w.type="pointermove":c>=xr.LeftClick&&c<=xr.RightClick&&(w.type=u===1?"pointerdown":"pointerup",w.button=c-2),w}static _CreateWheelEvent(a,x,c,u,g,y){const v=this._CreateMouseEvent(a,x,c,u,g,y);switch(v.pointerId=1,v.type="wheel",v.deltaMode=_u.DOM_DELTA_PIXEL,v.deltaX=0,v.deltaY=0,v.deltaZ=0,c){case xr.MouseWheelX:v.deltaX=u;break;case xr.MouseWheelY:v.deltaY=u;break;case xr.MouseWheelZ:v.deltaZ=u;break}return v}static _CreateMouseEvent(a,x,c,u,g,y){const v=this._CreateEvent(y),w=g.pollInput(a,x,xr.Horizontal),B=g.pollInput(a,x,xr.Vertical);return y?(v.movementX=0,v.movementY=0,v.offsetX=v.movementX-y.getBoundingClientRect().x,v.offsetY=v.movementY-y.getBoundingClientRect().y):(v.movementX=g.pollInput(a,x,$m.DeltaHorizontal),v.movementY=g.pollInput(a,x,$m.DeltaVertical),v.offsetX=0,v.offsetY=0),this._CheckNonCharacterKeys(v,g),v.clientX=w,v.clientY=B,v.x=w,v.y=B,v.deviceType=a,v.deviceSlot=x,v.inputIndex=c,v}static _CreateKeyboardEvent(a,x,c,u){const g=this._CreateEvent(u);return this._CheckNonCharacterKeys(g,c),g.deviceType=Rs.Keyboard,g.deviceSlot=0,g.inputIndex=a,g.type=x===1?"keydown":"keyup",g.key=String.fromCharCode(a),g.keyCode=a,g}static _CheckNonCharacterKeys(a,x){const c=x.isDeviceAvailable(Rs.Keyboard),u=c&&x.pollInput(Rs.Keyboard,0,18)===1,g=c&&x.pollInput(Rs.Keyboard,0,17)===1,y=c&&(x.pollInput(Rs.Keyboard,0,91)===1||x.pollInput(Rs.Keyboard,0,92)===1||x.pollInput(Rs.Keyboard,0,93)===1),v=c&&x.pollInput(Rs.Keyboard,0,16)===1;a.altKey=u,a.ctrlKey=g,a.metaKey=y,a.shiftKey=v}static _CreateEvent(a){const x={};return x.preventDefault=()=>{},x.target=a,x}}class RP{constructor(a,x,c){this._nativeInput=_native.DeviceInputSystem?new _native.DeviceInputSystem(a,x,(u,g,y,v)=>{const w=Wh.CreateDeviceEvent(u,g,y,v,this);c(u,g,w)}):this._createDummyNativeInput()}pollInput(a,x,c){return this._nativeInput.pollInput(a,x,c)}isDeviceAvailable(a){return a===Rs.Mouse||a===Rs.Touch}dispose(){this._nativeInput.dispose()}_createDummyNativeInput(){return{pollInput:()=>0,isDeviceAvailable:()=>!1,dispose:()=>{}}}}const gT=255,_T=Object.keys(xr).length/2;class MP{constructor(a,x,c,u){this._inputs=[],this._keyboardActive=!1,this._pointerActive=!1,this._usingSafari=_t.IsSafari(),this._usingMacOS=Uo()&&/(Mac|iPhone|iPod|iPad)/i.test(navigator.platform),this._keyboardDownEvent=g=>{},this._keyboardUpEvent=g=>{},this._keyboardBlurEvent=g=>{},this._pointerMoveEvent=g=>{},this._pointerDownEvent=g=>{},this._pointerUpEvent=g=>{},this._pointerCancelEvent=g=>{},this._pointerWheelEvent=g=>{},this._pointerBlurEvent=g=>{},this._pointerMacOSChromeOutEvent=g=>{},this._eventsAttached=!1,this._mouseId=-1,this._isUsingFirefox=Uo()&&navigator.userAgent&&navigator.userAgent.indexOf("Firefox")!==-1,this._isUsingChromium=Uo()&&navigator.userAgent&&navigator.userAgent.indexOf("Chrome")!==-1,this._maxTouchPoints=0,this._pointerInputClearObserver=null,this._gamepadConnectedEvent=g=>{},this._gamepadDisconnectedEvent=g=>{},this._eventPrefix=_t.GetPointerPrefix(a),this._engine=a,this._onDeviceConnected=x,this._onDeviceDisconnected=c,this._onInputChanged=u,this._mouseId=this._isUsingFirefox?0:1,this._enableEvents(),this._usingMacOS&&(this._metaKeys=[]),this._engine._onEngineViewChanged||(this._engine._onEngineViewChanged=()=>{this._enableEvents()})}pollInput(a,x,c){const u=this._inputs[a][x];if(!u)throw`Unable to find device ${Rs[a]}`;a>=Rs.DualShock&&a<=Rs.DualSense&&this._updateDevice(a,x,c);const g=u[c];if(g===void 0)throw`Unable to find input ${c} for device ${Rs[a]} in slot ${x}`;return c===xr.Move&&_t.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."),g}isDeviceAvailable(a){return this._inputs[a]!==void 0}dispose(){this._onDeviceConnected=()=>{},this._onDeviceDisconnected=()=>{},this._onInputChanged=()=>{},delete this._engine._onEngineViewChanged,this._elementToAttachTo&&this._disableEvents()}_enableEvents(){const a=this?._engine.getInputElement();if(a&&(!this._eventsAttached||this._elementToAttachTo!==a)){if(this._disableEvents(),this._inputs){for(const x of this._inputs)if(x)for(const c in x){const u=+c,g=x[u];if(g)for(let y=0;y<g.length;y++)g[y]=0}}this._elementToAttachTo=a,this._elementToAttachTo.tabIndex=this._elementToAttachTo.tabIndex!==-1?this._elementToAttachTo.tabIndex:this._engine.canvasTabIndex,this._handleKeyActions(),this._handlePointerActions(),this._handleGamepadActions(),this._eventsAttached=!0,this._checkForConnectedDevices()}}_disableEvents(){this._elementToAttachTo&&(this._elementToAttachTo.removeEventListener("blur",this._keyboardBlurEvent),this._elementToAttachTo.removeEventListener("blur",this._pointerBlurEvent),this._elementToAttachTo.removeEventListener("keydown",this._keyboardDownEvent),this._elementToAttachTo.removeEventListener("keyup",this._keyboardUpEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"move",this._pointerMoveEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"down",this._pointerDownEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"up",this._pointerUpEvent),this._elementToAttachTo.removeEventListener(this._eventPrefix+"cancel",this._pointerCancelEvent),this._elementToAttachTo.removeEventListener(this._wheelEventName,this._pointerWheelEvent),this._usingMacOS&&this._isUsingChromium&&this._elementToAttachTo.removeEventListener("lostpointercapture",this._pointerMacOSChromeOutEvent),window.removeEventListener("gamepadconnected",this._gamepadConnectedEvent),window.removeEventListener("gamepaddisconnected",this._gamepadDisconnectedEvent)),this._pointerInputClearObserver&&this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver),this._eventsAttached=!1}_checkForConnectedDevices(){if(navigator.getGamepads){const a=navigator.getGamepads();for(const x of a)x&&this._addGamePad(x)}typeof matchMedia=="function"&&matchMedia("(pointer:fine)").matches&&this._addPointerDevice(Rs.Mouse,0,0,0)}_addGamePad(a){const x=this._getGamepadDeviceType(a.id),c=a.index;this._gamepads=this._gamepads||new Array(a.index+1),this._registerDevice(x,c,a.buttons.length+a.axes.length),this._gamepads[c]=x}_addPointerDevice(a,x,c,u){this._pointerActive||(this._pointerActive=!0),this._registerDevice(a,x,_T);const g=this._inputs[a][x];g[0]=c,g[1]=u}_registerDevice(a,x,c){if(x===void 0)throw`Unable to register device ${Rs[a]} to undefined slot.`;if(this._inputs[a]||(this._inputs[a]={}),!this._inputs[a][x]){const u=new Array(c);u.fill(0),this._inputs[a][x]=u,this._onDeviceConnected(a,x)}}_unregisterDevice(a,x){this._inputs[a][x]&&(delete this._inputs[a][x],this._onDeviceDisconnected(a,x))}_handleKeyActions(){this._keyboardDownEvent=a=>{this._keyboardActive||(this._keyboardActive=!0,this._registerDevice(Rs.Keyboard,0,gT));const x=this._inputs[Rs.Keyboard][0];if(x){x[a.keyCode]=1;const c=a;c.inputIndex=a.keyCode,this._usingMacOS&&a.metaKey&&a.key!=="Meta"&&(this._metaKeys.includes(a.keyCode)||this._metaKeys.push(a.keyCode)),this._onInputChanged(Rs.Keyboard,0,c)}},this._keyboardUpEvent=a=>{this._keyboardActive||(this._keyboardActive=!0,this._registerDevice(Rs.Keyboard,0,gT));const x=this._inputs[Rs.Keyboard][0];if(x){x[a.keyCode]=0;const c=a;if(c.inputIndex=a.keyCode,this._usingMacOS&&a.key==="Meta"&&this._metaKeys.length>0){for(const u of this._metaKeys){const g=Wh.CreateDeviceEvent(Rs.Keyboard,0,u,0,this,this._elementToAttachTo);x[u]=0,this._onInputChanged(Rs.Keyboard,0,g)}this._metaKeys.splice(0,this._metaKeys.length)}this._onInputChanged(Rs.Keyboard,0,c)}},this._keyboardBlurEvent=()=>{if(this._keyboardActive){const a=this._inputs[Rs.Keyboard][0];for(let x=0;x<a.length;x++)if(a[x]!==0){a[x]=0;const c=Wh.CreateDeviceEvent(Rs.Keyboard,0,x,0,this,this._elementToAttachTo);this._onInputChanged(Rs.Keyboard,0,c)}this._usingMacOS&&this._metaKeys.splice(0,this._metaKeys.length)}},this._elementToAttachTo.addEventListener("keydown",this._keyboardDownEvent),this._elementToAttachTo.addEventListener("keyup",this._keyboardUpEvent),this._elementToAttachTo.addEventListener("blur",this._keyboardBlurEvent)}_handlePointerActions(){this._maxTouchPoints=Uo()&&navigator.maxTouchPoints||2,this._activeTouchIds||(this._activeTouchIds=new Array(this._maxTouchPoints));for(let c=0;c<this._maxTouchPoints;c++)this._activeTouchIds[c]=-1;this._pointerMoveEvent=c=>{const u=this._getPointerType(c);let g=u===Rs.Mouse?0:this._activeTouchIds.indexOf(c.pointerId);if(u===Rs.Touch&&g===-1){const v=this._activeTouchIds.indexOf(-1);if(v>=0)g=v,this._activeTouchIds[v]=c.pointerId,this._onDeviceConnected(u,g);else{_t.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);return}}this._inputs[u]||(this._inputs[u]={}),this._inputs[u][g]||this._addPointerDevice(u,g,c.clientX,c.clientY);const y=this._inputs[u][g];if(y){const v=c;v.inputIndex=xr.Move,y[xr.Horizontal]=c.clientX,y[xr.Vertical]=c.clientY,u===Rs.Touch&&y[xr.LeftClick]===0&&(y[xr.LeftClick]=1),c.pointerId===void 0&&(c.pointerId=this._mouseId),this._onInputChanged(u,g,v),!this._usingSafari&&c.button!==-1&&(v.inputIndex=c.button+2,y[c.button+2]=y[c.button+2]?0:1,this._onInputChanged(u,g,v))}},this._pointerDownEvent=c=>{const u=this._getPointerType(c);let g=u===Rs.Mouse?0:c.pointerId;if(u===Rs.Touch){const v=this._activeTouchIds.indexOf(-1);if(v>=0)g=v,this._activeTouchIds[v]=c.pointerId;else{_t.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);return}}this._inputs[u]||(this._inputs[u]={}),this._inputs[u][g]?u===Rs.Touch&&this._onDeviceConnected(u,g):this._addPointerDevice(u,g,c.clientX,c.clientY);const y=this._inputs[u][g];if(y){const v=y[xr.Horizontal],w=y[xr.Vertical];if(u===Rs.Mouse){if(c.pointerId===void 0&&(c.pointerId=this._mouseId),!document.pointerLockElement)try{this._elementToAttachTo.setPointerCapture(this._mouseId)}catch{}}else if(c.pointerId&&!document.pointerLockElement)try{this._elementToAttachTo.setPointerCapture(c.pointerId)}catch{}y[xr.Horizontal]=c.clientX,y[xr.Vertical]=c.clientY,y[c.button+2]=1;const B=c;B.inputIndex=c.button+2,this._onInputChanged(u,g,B),(v!==c.clientX||w!==c.clientY)&&(B.inputIndex=xr.Move,this._onInputChanged(u,g,B))}},this._pointerUpEvent=c=>{const u=this._getPointerType(c),g=u===Rs.Mouse?0:this._activeTouchIds.indexOf(c.pointerId);if(u===Rs.Touch){if(g===-1)return;this._activeTouchIds[g]=-1}const y=this._inputs[u]?.[g];if(y&&y[c.button+2]!==0){const v=y[xr.Horizontal],w=y[xr.Vertical];y[xr.Horizontal]=c.clientX,y[xr.Vertical]=c.clientY,y[c.button+2]=0;const B=c;c.pointerId===void 0&&(c.pointerId=this._mouseId),(v!==c.clientX||w!==c.clientY)&&(B.inputIndex=xr.Move,this._onInputChanged(u,g,B)),B.inputIndex=c.button+2,u===Rs.Mouse&&this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)?this._elementToAttachTo.releasePointerCapture(this._mouseId):c.pointerId&&this._elementToAttachTo.hasPointerCapture?.(c.pointerId)&&this._elementToAttachTo.releasePointerCapture(c.pointerId),this._onInputChanged(u,g,B),u===Rs.Touch&&this._onDeviceDisconnected(u,g)}},this._pointerCancelEvent=c=>{if(c.pointerType==="mouse"){const u=this._inputs[Rs.Mouse][0];this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)&&this._elementToAttachTo.releasePointerCapture(this._mouseId);for(let g=xr.LeftClick;g<=xr.BrowserForward;g++)if(u[g]===1){u[g]=0;const y=Wh.CreateDeviceEvent(Rs.Mouse,0,g,0,this,this._elementToAttachTo);this._onInputChanged(Rs.Mouse,0,y)}}else{const u=this._activeTouchIds.indexOf(c.pointerId);if(u===-1)return;this._elementToAttachTo.hasPointerCapture?.(c.pointerId)&&this._elementToAttachTo.releasePointerCapture(c.pointerId),this._inputs[Rs.Touch][u][xr.LeftClick]=0;const g=Wh.CreateDeviceEvent(Rs.Touch,u,xr.LeftClick,0,this,this._elementToAttachTo,c.pointerId);this._onInputChanged(Rs.Touch,u,g),this._activeTouchIds[u]=-1,this._onDeviceDisconnected(Rs.Touch,u)}},this._wheelEventName="onwheel"in document.createElement("div")?"wheel":document.onmousewheel!==void 0?"mousewheel":"DOMMouseScroll";let a=!1;const x=function(){};try{const c=Object.defineProperty({},"passive",{get:function(){a=!0}});this._elementToAttachTo.addEventListener("test",x,c),this._elementToAttachTo.removeEventListener("test",x,c)}catch{}this._pointerBlurEvent=()=>{if(this.isDeviceAvailable(Rs.Mouse)){const c=this._inputs[Rs.Mouse][0];this._mouseId>=0&&this._elementToAttachTo.hasPointerCapture?.(this._mouseId)&&this._elementToAttachTo.releasePointerCapture(this._mouseId);for(let u=xr.LeftClick;u<=xr.BrowserForward;u++)if(c[u]===1){c[u]=0;const g=Wh.CreateDeviceEvent(Rs.Mouse,0,u,0,this,this._elementToAttachTo);this._onInputChanged(Rs.Mouse,0,g)}}if(this.isDeviceAvailable(Rs.Touch)){const c=this._inputs[Rs.Touch];for(let u=0;u<this._activeTouchIds.length;u++){const g=this._activeTouchIds[u];if(this._elementToAttachTo.hasPointerCapture?.(g)&&this._elementToAttachTo.releasePointerCapture(g),g!==-1&&c[u]?.[xr.LeftClick]===1){c[u][xr.LeftClick]=0;const y=Wh.CreateDeviceEvent(Rs.Touch,u,xr.LeftClick,0,this,this._elementToAttachTo,g);this._onInputChanged(Rs.Touch,u,y),this._activeTouchIds[u]=-1,this._onDeviceDisconnected(Rs.Touch,u)}}}},this._pointerWheelEvent=c=>{const u=Rs.Mouse,g=0;this._inputs[u]||(this._inputs[u]=[]),this._inputs[u][g]||(this._pointerActive=!0,this._registerDevice(u,g,_T));const y=this._inputs[u][g];if(y){y[xr.MouseWheelX]=c.deltaX||0,y[xr.MouseWheelY]=c.deltaY||c.wheelDelta||0,y[xr.MouseWheelZ]=c.deltaZ||0;const v=c;c.pointerId===void 0&&(c.pointerId=this._mouseId),y[xr.MouseWheelX]!==0&&(v.inputIndex=xr.MouseWheelX,this._onInputChanged(u,g,v)),y[xr.MouseWheelY]!==0&&(v.inputIndex=xr.MouseWheelY,this._onInputChanged(u,g,v)),y[xr.MouseWheelZ]!==0&&(v.inputIndex=xr.MouseWheelZ,this._onInputChanged(u,g,v))}},this._usingMacOS&&this._isUsingChromium&&(this._pointerMacOSChromeOutEvent=c=>{c.buttons>1&&this._pointerCancelEvent(c)},this._elementToAttachTo.addEventListener("lostpointercapture",this._pointerMacOSChromeOutEvent)),this._elementToAttachTo.addEventListener(this._eventPrefix+"move",this._pointerMoveEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"down",this._pointerDownEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"up",this._pointerUpEvent),this._elementToAttachTo.addEventListener(this._eventPrefix+"cancel",this._pointerCancelEvent),this._elementToAttachTo.addEventListener("blur",this._pointerBlurEvent),this._elementToAttachTo.addEventListener(this._wheelEventName,this._pointerWheelEvent,a?{passive:!1}:!1),this._pointerInputClearObserver=this._engine.onEndFrameObservable.add(()=>{if(this.isDeviceAvailable(Rs.Mouse)){const c=this._inputs[Rs.Mouse][0];c[xr.MouseWheelX]=0,c[xr.MouseWheelY]=0,c[xr.MouseWheelZ]=0}})}_handleGamepadActions(){this._gamepadConnectedEvent=a=>{this._addGamePad(a.gamepad)},this._gamepadDisconnectedEvent=a=>{if(this._gamepads){const x=this._getGamepadDeviceType(a.gamepad.id),c=a.gamepad.index;this._unregisterDevice(x,c),delete this._gamepads[c]}},window.addEventListener("gamepadconnected",this._gamepadConnectedEvent),window.addEventListener("gamepaddisconnected",this._gamepadDisconnectedEvent)}_updateDevice(a,x,c){const u=navigator.getGamepads()[x];if(u&&a===this._gamepads[x]){const g=this._inputs[a][x];c>=u.buttons.length?g[c]=u.axes[c-u.buttons.length].valueOf():g[c]=u.buttons[c].value}}_getGamepadDeviceType(a){return a.indexOf("054c")!==-1?a.indexOf("0ce6")!==-1?Rs.DualSense:Rs.DualShock:a.indexOf("Xbox One")!==-1||a.search("Xbox 360")!==-1||a.search("xinput")!==-1?Rs.Xbox:a.indexOf("057e")!==-1?Rs.Switch:Rs.Generic}_getPointerType(a){let x=Rs.Mouse;return(a.pointerType==="touch"||a.pointerType==="pen"||a.touches)&&(x=Rs.Touch),x}}class yT{constructor(a,x,c=0){this.deviceType=x,this.deviceSlot=c,this.onInputChangedObservable=new Jt,this._deviceInputSystem=a}getInput(a){return this._deviceInputSystem.pollInput(this.deviceType,this.deviceSlot,a)}}class BP{constructor(a){this._registeredManagers=new Array,this._refCount=0,this.registerManager=y=>{for(let v=0;v<this._devices.length;v++){const w=this._devices[v];for(const B in w){const W=+B;y._addDevice(new yT(this._deviceInputSystem,v,W))}}this._registeredManagers.push(y)},this.unregisterManager=y=>{const v=this._registeredManagers.indexOf(y);v>-1&&this._registeredManagers.splice(v,1)};const x=Object.keys(Rs).length/2;this._devices=new Array(x);const c=(y,v)=>{this._devices[y]||(this._devices[y]=new Array),this._devices[y][v]||(this._devices[y][v]=v);for(const w of this._registeredManagers){const B=new yT(this._deviceInputSystem,y,v);w._addDevice(B)}},u=(y,v)=>{this._devices[y]?.[v]&&delete this._devices[y][v];for(const w of this._registeredManagers)w._removeDevice(y,v)},g=(y,v,w)=>{if(w)for(const B of this._registeredManagers)B._onInputChanged(y,v,w)};typeof _native<"u"?this._deviceInputSystem=new RP(c,u,g):this._deviceInputSystem=new MP(a,c,u,g)}dispose(){this._deviceInputSystem.dispose()}}class UP{getDeviceSource(a,x){if(x===void 0){if(this._firstDevice[a]===void 0)return null;x=this._firstDevice[a]}return!this._devices[a]||this._devices[a][x]===void 0?null:this._devices[a][x]}getDeviceSources(a){return this._devices[a]?this._devices[a].filter(x=>!!x):[]}constructor(a){const x=Object.keys(Rs).length/2;this._devices=new Array(x),this._firstDevice=new Array(x),this._engine=a,this._engine._deviceSourceManager||(this._engine._deviceSourceManager=new BP(a)),this._engine._deviceSourceManager._refCount++,this.onDeviceConnectedObservable=new Jt(c=>{for(const u of this._devices)if(u)for(const g of u)g&&this.onDeviceConnectedObservable.notifyObserver(c,g)}),this.onDeviceDisconnectedObservable=new Jt,this._engine._deviceSourceManager.registerManager(this),this._onDisposeObserver=a.onDisposeObservable.add(()=>{this.dispose()})}dispose(){this.onDeviceConnectedObservable.clear(),this.onDeviceDisconnectedObservable.clear(),this._engine._deviceSourceManager&&(this._engine._deviceSourceManager.unregisterManager(this),--this._engine._deviceSourceManager._refCount<1&&(this._engine._deviceSourceManager.dispose(),delete this._engine._deviceSourceManager)),this._engine.onDisposeObservable.remove(this._onDisposeObserver)}_addDevice(a){this._devices[a.deviceType]||(this._devices[a.deviceType]=new Array),this._devices[a.deviceType][a.deviceSlot]||(this._devices[a.deviceType][a.deviceSlot]=a,this._updateFirstDevices(a.deviceType)),this.onDeviceConnectedObservable.notifyObservers(a)}_removeDevice(a,x){const c=this._devices[a]?.[x];this.onDeviceDisconnectedObservable.notifyObservers(c),this._devices[a]?.[x]&&delete this._devices[a][x],this._updateFirstDevices(a)}_onInputChanged(a,x,c){this._devices[a]?.[x]?.onInputChangedObservable.notifyObservers(c)}_updateFirstDevices(a){switch(a){case Rs.Keyboard:case Rs.Mouse:this._firstDevice[a]=0;break;case Rs.Touch:case Rs.DualSense:case Rs.DualShock:case Rs.Xbox:case Rs.Switch:case Rs.Generic:{delete this._firstDevice[a];const x=this._devices[a];if(x){for(let c=0;c<x.length;c++)if(x[c]){this._firstDevice[a]=c;break}}break}}}}class bT{constructor(){this._singleClick=!1,this._doubleClick=!1,this._hasSwiped=!1,this._ignore=!1}get singleClick(){return this._singleClick}get doubleClick(){return this._doubleClick}get hasSwiped(){return this._hasSwiped}get ignore(){return this._ignore}set singleClick(a){this._singleClick=a}set doubleClick(a){this._doubleClick=a}set hasSwiped(a){this._hasSwiped=a}set ignore(a){this._ignore=a}}class Ra{constructor(a){this._alreadyAttached=!1,this._meshPickProceed=!1,this._currentPickResult=null,this._previousPickResult=null,this._totalPointersPressed=0,this._doubleClickOccured=!1,this._isSwiping=!1,this._swipeButtonPressed=-1,this._skipPointerTap=!1,this._isMultiTouchGesture=!1,this._pointerX=0,this._pointerY=0,this._startingPointerPosition=new mr(0,0),this._previousStartingPointerPosition=new mr(0,0),this._startingPointerTime=0,this._previousStartingPointerTime=0,this._pointerCaptures={},this._meshUnderPointerId={},this._movePointerInfo=null,this._cameraObserverCount=0,this._delayedClicks=[null,null,null,null,null],this._deviceSourceManager=null,this._scene=a||tr.LastCreatedScene,this._scene}get meshUnderPointer(){return this._movePointerInfo&&(this._movePointerInfo._generatePickInfo(),this._movePointerInfo=null),this._pointerOverMesh}getMeshUnderPointerByPointerId(a){return this._meshUnderPointerId[a]||null}get unTranslatedPointer(){return new mr(this._unTranslatedPointerX,this._unTranslatedPointerY)}get pointerX(){return this._pointerX}set pointerX(a){this._pointerX=a}get pointerY(){return this._pointerY}set pointerY(a){this._pointerY=a}_updatePointerPosition(a){const x=this._scene.getEngine().getInputElementClientRect();x&&(this._pointerX=a.clientX-x.left,this._pointerY=a.clientY-x.top,this._unTranslatedPointerX=this._pointerX,this._unTranslatedPointerY=this._pointerY)}_processPointerMove(a,x){const c=this._scene,u=c.getEngine(),g=u.getInputElement();g&&(g.tabIndex=u.canvasTabIndex,c.doNotHandleCursors||(g.style.cursor=c.defaultCursor)),this._setCursorAndPointerOverMesh(a,x,c);for(const w of c._pointerMoveStage){a=a||this._pickMove(x);const B=!!a?.pickedMesh;a=w.action(this._unTranslatedPointerX,this._unTranslatedPointerY,a,B,g)}const y=x.inputIndex>=xr.MouseWheelX&&x.inputIndex<=xr.MouseWheelZ?dr.POINTERWHEEL:dr.POINTERMOVE;c.onPointerMove&&(a=a||this._pickMove(x),c.onPointerMove(x,a,y));let v;a?(v=new $2(y,x,a),this._setRayOnPointerInfo(a,x)):(v=new $2(y,x,null,this),this._movePointerInfo=v),c.onPointerObservable.hasObservers()&&c.onPointerObservable.notifyObservers(v,y)}_setRayOnPointerInfo(a,x){const c=this._scene;a&&c._pickingAvailable&&(a.ray||(a.ray=c.createPickingRay(x.offsetX,x.offsetY,vt.Identity(),c.activeCamera)))}_addCameraPointerObserver(a,x){return this._cameraObserverCount++,this._scene.onPointerObservable.add(a,x)}_removeCameraPointerObserver(a){return this._cameraObserverCount--,this._scene.onPointerObservable.remove(a)}_checkForPicking(){return!!(this._scene.onPointerObservable.observers.length>this._cameraObserverCount||this._scene.onPointerPick)}_checkPrePointerObservable(a,x,c){const u=this._scene,g=new IP(c,x,this._unTranslatedPointerX,this._unTranslatedPointerY);return a&&(g.originalPickingInfo=a,g.ray=a.ray,x.pointerType==="xr-near"&&a.originMesh&&(g.nearInteractionPickingInfo=a)),u.onPrePointerObservable.notifyObservers(g,c),!!g.skipOnPointerObservable}_pickMove(a){const x=this._scene,c=x.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,x.pointerMovePredicate,x.pointerMoveFastCheck,x.cameraToUseForPointers,x.pointerMoveTrianglePredicate);return this._setCursorAndPointerOverMesh(c,a,x),c}_setCursorAndPointerOverMesh(a,x,c){const g=c.getEngine().getInputElement();if(a?.pickedMesh){if(this.setPointerOverMesh(a.pickedMesh,x.pointerId,a,x),!c.doNotHandleCursors&&g&&this._pointerOverMesh){const y=this._pointerOverMesh._getActionManagerForTrigger();y&&y.hasPointerTriggers&&(g.style.cursor=y.hoverCursor||c.hoverCursor)}}else this.setPointerOverMesh(null,x.pointerId,a,x)}simulatePointerMove(a,x){const c=new PointerEvent("pointermove",x);c.inputIndex=xr.Move,!this._checkPrePointerObservable(a,c,dr.POINTERMOVE)&&this._processPointerMove(a,c)}simulatePointerDown(a,x){const c=new PointerEvent("pointerdown",x);c.inputIndex=c.button+2,!this._checkPrePointerObservable(a,c,dr.POINTERDOWN)&&this._processPointerDown(a,c)}_processPointerDown(a,x){const c=this._scene;if(a?.pickedMesh){this._pickedDownMesh=a.pickedMesh;const y=a.pickedMesh._getActionManagerForTrigger();if(y){if(y.hasPickTriggers)switch(y.processTrigger(5,to.CreateNew(a.pickedMesh,x,a)),x.button){case 0:y.processTrigger(2,to.CreateNew(a.pickedMesh,x,a));break;case 1:y.processTrigger(4,to.CreateNew(a.pickedMesh,x,a));break;case 2:y.processTrigger(3,to.CreateNew(a.pickedMesh,x,a));break}y.hasSpecificTrigger(8)&&window.setTimeout(()=>{const v=c.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,w=>w.isPickable&&w.isVisible&&w.isReady()&&w.actionManager&&w.actionManager.hasSpecificTrigger(8)&&w===this._pickedDownMesh,!1,c.cameraToUseForPointers);v?.pickedMesh&&y&&this._totalPointersPressed!==0&&Date.now()-this._startingPointerTime>Ra.LongPressDelay&&!this._isPointerSwiping()&&(this._startingPointerTime=0,y.processTrigger(8,to.CreateNew(v.pickedMesh,x)))},Ra.LongPressDelay)}}else for(const y of c._pointerDownStage)a=y.action(this._unTranslatedPointerX,this._unTranslatedPointerY,a,x,!1);let u;const g=dr.POINTERDOWN;a?(c.onPointerDown&&c.onPointerDown(x,a,g),u=new $2(g,x,a),this._setRayOnPointerInfo(a,x)):u=new $2(g,x,null,this),c.onPointerObservable.hasObservers()&&c.onPointerObservable.notifyObservers(u,g)}_isPointerSwiping(){return this._isSwiping}simulatePointerUp(a,x,c){const u=new PointerEvent("pointerup",x);u.inputIndex=xr.Move;const g=new bT;c?g.doubleClick=!0:g.singleClick=!0,!this._checkPrePointerObservable(a,u,dr.POINTERUP)&&this._processPointerUp(a,u,g)}_processPointerUp(a,x,c){const u=this._scene;if(a?.pickedMesh){if(this._pickedUpMesh=a.pickedMesh,this._pickedDownMesh===this._pickedUpMesh&&(u.onPointerPick&&u.onPointerPick(x,a),c.singleClick&&!c.ignore&&u.onPointerObservable.observers.length>this._cameraObserverCount)){const y=dr.POINTERPICK,v=new $2(y,x,a);this._setRayOnPointerInfo(a,x),u.onPointerObservable.notifyObservers(v,y)}const g=a.pickedMesh._getActionManagerForTrigger();if(g&&!c.ignore){g.processTrigger(7,to.CreateNew(a.pickedMesh,x,a)),!c.hasSwiped&&c.singleClick&&g.processTrigger(1,to.CreateNew(a.pickedMesh,x,a));const y=a.pickedMesh._getActionManagerForTrigger(6);c.doubleClick&&y&&y.processTrigger(6,to.CreateNew(a.pickedMesh,x,a))}}else if(!c.ignore)for(const g of u._pointerUpStage)a=g.action(this._unTranslatedPointerX,this._unTranslatedPointerY,a,x,c.doubleClick);if(this._pickedDownMesh&&this._pickedDownMesh!==this._pickedUpMesh){const g=this._pickedDownMesh._getActionManagerForTrigger(16);g&&g.processTrigger(16,to.CreateNew(this._pickedDownMesh,x))}if(!c.ignore){const g=new $2(dr.POINTERUP,x,a);if(this._setRayOnPointerInfo(a,x),u.onPointerObservable.notifyObservers(g,dr.POINTERUP),u.onPointerUp&&u.onPointerUp(x,a,dr.POINTERUP),!c.hasSwiped&&!this._skipPointerTap&&!this._isMultiTouchGesture){let y=0;if(c.singleClick?y=dr.POINTERTAP:c.doubleClick&&(y=dr.POINTERDOUBLETAP),y){const v=new $2(y,x,a);u.onPointerObservable.hasObservers()&&u.onPointerObservable.hasSpecificMask(y)&&u.onPointerObservable.notifyObservers(v,y)}}}}isPointerCaptured(a=0){return this._pointerCaptures[a]}attachControl(a=!0,x=!0,c=!0,u=null){const g=this._scene,y=g.getEngine();u||(u=y.getInputElement()),this._alreadyAttached&&this.detachControl(),u&&(this._alreadyAttachedTo=u),this._deviceSourceManager=new UP(y),this._initActionManager=v=>{if(!this._meshPickProceed){const w=g.skipPointerUpPicking||g._registeredActions===0&&!this._checkForPicking()&&!g.onPointerUp?null:g.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,g.pointerUpPredicate,g.pointerUpFastCheck,g.cameraToUseForPointers,g.pointerUpTrianglePredicate);this._currentPickResult=w,w&&(v=w.hit&&w.pickedMesh?w.pickedMesh._getActionManagerForTrigger():null),this._meshPickProceed=!0}return v},this._delayedSimpleClick=(v,w,B)=>{if((Date.now()-this._previousStartingPointerTime>Ra.DoubleClickDelay&&!this._doubleClickOccured||v!==this._previousButtonPressed)&&(this._doubleClickOccured=!1,w.singleClick=!0,w.ignore=!1,this._delayedClicks[v])){const W=this._delayedClicks[v].evt,ae=dr.POINTERTAP,ue=new $2(ae,W,this._currentPickResult);g.onPointerObservable.hasObservers()&&g.onPointerObservable.hasSpecificMask(ae)&&g.onPointerObservable.notifyObservers(ue,ae),this._delayedClicks[v]=null}},this._initClickEvent=(v,w,B,W)=>{const ae=new bT;this._currentPickResult=null;let ue=null,fe=v.hasSpecificMask(dr.POINTERPICK)||w.hasSpecificMask(dr.POINTERPICK)||v.hasSpecificMask(dr.POINTERTAP)||w.hasSpecificMask(dr.POINTERTAP)||v.hasSpecificMask(dr.POINTERDOUBLETAP)||w.hasSpecificMask(dr.POINTERDOUBLETAP);!fe&&Mx&&(ue=this._initActionManager(ue,ae),ue&&(fe=ue.hasPickTriggers));let Re=!1;if(fe){const _e=B.button;if(ae.hasSwiped=this._isPointerSwiping(),!ae.hasSwiped){let Be=!Ra.ExclusiveDoubleClickMode;if(Be||(Be=!v.hasSpecificMask(dr.POINTERDOUBLETAP)&&!w.hasSpecificMask(dr.POINTERDOUBLETAP),Be&&!Mx.HasSpecificTrigger(6)&&(ue=this._initActionManager(ue,ae),ue&&(Be=!ue.hasSpecificTrigger(6)))),Be)(Date.now()-this._previousStartingPointerTime>Ra.DoubleClickDelay||_e!==this._previousButtonPressed)&&(ae.singleClick=!0,W(ae,this._currentPickResult),Re=!0);else{const $e={evt:B,clickInfo:ae,timeoutId:window.setTimeout(this._delayedSimpleClick.bind(this,_e,ae,W),Ra.DoubleClickDelay)};this._delayedClicks[_e]=$e}let tt=v.hasSpecificMask(dr.POINTERDOUBLETAP)||w.hasSpecificMask(dr.POINTERDOUBLETAP);!tt&&Mx.HasSpecificTrigger(6)&&(ue=this._initActionManager(ue,ae),ue&&(tt=ue.hasSpecificTrigger(6))),tt&&(_e===this._previousButtonPressed&&Date.now()-this._previousStartingPointerTime<Ra.DoubleClickDelay&&!this._doubleClickOccured?(!ae.hasSwiped&&!this._isPointerSwiping()?(this._previousStartingPointerTime=0,this._doubleClickOccured=!0,ae.doubleClick=!0,ae.ignore=!1,Ra.ExclusiveDoubleClickMode&&this._delayedClicks[_e]&&(clearTimeout(this._delayedClicks[_e]?.timeoutId),this._delayedClicks[_e]=null),W(ae,this._currentPickResult)):(this._doubleClickOccured=!1,this._previousStartingPointerTime=this._startingPointerTime,this._previousStartingPointerPosition.x=this._startingPointerPosition.x,this._previousStartingPointerPosition.y=this._startingPointerPosition.y,this._previousButtonPressed=_e,Ra.ExclusiveDoubleClickMode?(this._delayedClicks[_e]&&(clearTimeout(this._delayedClicks[_e]?.timeoutId),this._delayedClicks[_e]=null),W(ae,this._previousPickResult)):W(ae,this._currentPickResult)),Re=!0):(this._doubleClickOccured=!1,this._previousStartingPointerTime=this._startingPointerTime,this._previousStartingPointerPosition.x=this._startingPointerPosition.x,this._previousStartingPointerPosition.y=this._startingPointerPosition.y,this._previousButtonPressed=_e))}}Re||W(ae,this._currentPickResult)},this._onPointerMove=v=>{if(this._updatePointerPosition(v),!this._isSwiping&&this._swipeButtonPressed!==-1&&(this._isSwiping=Math.abs(this._startingPointerPosition.x-this._pointerX)>Ra.DragMovementThreshold||Math.abs(this._startingPointerPosition.y-this._pointerY)>Ra.DragMovementThreshold),y.isPointerLock&&y._verifyPointerLock(),this._checkPrePointerObservable(null,v,v.inputIndex>=xr.MouseWheelX&&v.inputIndex<=xr.MouseWheelZ?dr.POINTERWHEEL:dr.POINTERMOVE)||!g.cameraToUseForPointers&&!g.activeCamera)return;if(g.skipPointerMovePicking){this._processPointerMove(new am,v);return}g.pointerMovePredicate||(g.pointerMovePredicate=B=>B.isPickable&&B.isVisible&&B.isReady()&&B.isEnabled()&&(B.enablePointerMoveEvents||g.constantlyUpdateMeshUnderPointer||B._getActionManagerForTrigger()!==null)&&(!g.cameraToUseForPointers||(g.cameraToUseForPointers.layerMask&B.layerMask)!==0));const w=g._registeredActions>0||g.constantlyUpdateMeshUnderPointer?this._pickMove(v):null;this._processPointerMove(w,v)},this._onPointerDown=v=>{if(this._totalPointersPressed++,this._pickedDownMesh=null,this._meshPickProceed=!1,Ra.ExclusiveDoubleClickMode){for(let B=0;B<this._delayedClicks.length;B++)if(this._delayedClicks[B])if(v.button===B)clearTimeout(this._delayedClicks[B]?.timeoutId);else{const W=this._delayedClicks[B].clickInfo;this._doubleClickOccured=!1,W.singleClick=!0,W.ignore=!1;const ae=this._delayedClicks[B].evt,ue=dr.POINTERTAP,fe=new $2(ue,ae,this._currentPickResult);g.onPointerObservable.hasObservers()&&g.onPointerObservable.hasSpecificMask(ue)&&g.onPointerObservable.notifyObservers(fe,ue),this._delayedClicks[B]=null}}if(this._updatePointerPosition(v),this._swipeButtonPressed===-1&&(this._swipeButtonPressed=v.button),g.preventDefaultOnPointerDown&&u&&(v.preventDefault(),u.focus()),this._startingPointerPosition.x=this._pointerX,this._startingPointerPosition.y=this._pointerY,this._startingPointerTime=Date.now(),this._checkPrePointerObservable(null,v,dr.POINTERDOWN)||!g.cameraToUseForPointers&&!g.activeCamera)return;this._pointerCaptures[v.pointerId]=!0,g.pointerDownPredicate||(g.pointerDownPredicate=B=>B.isPickable&&B.isVisible&&B.isReady()&&B.isEnabled()&&(!g.cameraToUseForPointers||(g.cameraToUseForPointers.layerMask&B.layerMask)!==0)),this._pickedDownMesh=null;let w;g.skipPointerDownPicking||g._registeredActions===0&&!this._checkForPicking()&&!g.onPointerDown?w=new am:w=g.pick(this._unTranslatedPointerX,this._unTranslatedPointerY,g.pointerDownPredicate,g.pointerDownFastCheck,g.cameraToUseForPointers,g.pointerDownTrianglePredicate),this._processPointerDown(w,v)},this._onPointerUp=v=>{this._totalPointersPressed!==0&&(this._totalPointersPressed--,this._pickedUpMesh=null,this._meshPickProceed=!1,this._updatePointerPosition(v),g.preventDefaultOnPointerUp&&u&&(v.preventDefault(),u.focus()),this._initClickEvent(g.onPrePointerObservable,g.onPointerObservable,v,(w,B)=>{if(g.onPrePointerObservable.hasObservers()&&(this._skipPointerTap=!1,!w.ignore)){if(this._checkPrePointerObservable(null,v,dr.POINTERUP)){this._swipeButtonPressed===v.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1),v.buttons===0&&(this._pointerCaptures[v.pointerId]=!1);return}w.hasSwiped||(w.singleClick&&g.onPrePointerObservable.hasSpecificMask(dr.POINTERTAP)&&this._checkPrePointerObservable(null,v,dr.POINTERTAP)&&(this._skipPointerTap=!0),w.doubleClick&&g.onPrePointerObservable.hasSpecificMask(dr.POINTERDOUBLETAP)&&this._checkPrePointerObservable(null,v,dr.POINTERDOUBLETAP)&&(this._skipPointerTap=!0))}if(!this._pointerCaptures[v.pointerId]){this._swipeButtonPressed===v.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1);return}v.buttons===0&&(this._pointerCaptures[v.pointerId]=!1),!(!g.cameraToUseForPointers&&!g.activeCamera)&&(g.pointerUpPredicate||(g.pointerUpPredicate=W=>W.isPickable&&W.isVisible&&W.isReady()&&W.isEnabled()&&(!g.cameraToUseForPointers||(g.cameraToUseForPointers.layerMask&W.layerMask)!==0)),!this._meshPickProceed&&(Mx&&Mx.HasTriggers||this._checkForPicking()||g.onPointerUp)&&this._initActionManager(null,w),B||(B=this._currentPickResult),this._processPointerUp(B,v,w),this._previousPickResult=this._currentPickResult,this._swipeButtonPressed===v.button&&(this._isSwiping=!1,this._swipeButtonPressed=-1))}))},this._onKeyDown=v=>{const w=gu.KEYDOWN;if(g.onPreKeyboardObservable.hasObservers()){const B=new lT(w,v);if(g.onPreKeyboardObservable.notifyObservers(B,w),B.skipOnKeyboardObservable)return}if(g.onKeyboardObservable.hasObservers()){const B=new a_(w,v);g.onKeyboardObservable.notifyObservers(B,w)}g.actionManager&&g.actionManager.processTrigger(14,to.CreateNewFromScene(g,v))},this._onKeyUp=v=>{const w=gu.KEYUP;if(g.onPreKeyboardObservable.hasObservers()){const B=new lT(w,v);if(g.onPreKeyboardObservable.notifyObservers(B,w),B.skipOnKeyboardObservable)return}if(g.onKeyboardObservable.hasObservers()){const B=new a_(w,v);g.onKeyboardObservable.notifyObservers(B,w)}g.actionManager&&g.actionManager.processTrigger(15,to.CreateNewFromScene(g,v))},this._deviceSourceManager.onDeviceConnectedObservable.add(v=>{v.deviceType===Rs.Mouse?v.onInputChangedObservable.add(w=>{w.inputIndex===xr.LeftClick||w.inputIndex===xr.MiddleClick||w.inputIndex===xr.RightClick||w.inputIndex===xr.BrowserBack||w.inputIndex===xr.BrowserForward?x&&v.getInput(w.inputIndex)===1?this._onPointerDown(w):a&&v.getInput(w.inputIndex)===0&&this._onPointerUp(w):c&&(w.inputIndex===xr.Move?this._onPointerMove(w):(w.inputIndex===xr.MouseWheelX||w.inputIndex===xr.MouseWheelY||w.inputIndex===xr.MouseWheelZ)&&this._onPointerMove(w))}):v.deviceType===Rs.Touch?v.onInputChangedObservable.add(w=>{w.inputIndex===xr.LeftClick&&(x&&v.getInput(w.inputIndex)===1?(this._onPointerDown(w),this._totalPointersPressed>1&&(this._isMultiTouchGesture=!0)):a&&v.getInput(w.inputIndex)===0&&(this._onPointerUp(w),this._totalPointersPressed===0&&(this._isMultiTouchGesture=!1))),c&&w.inputIndex===xr.Move&&this._onPointerMove(w)}):v.deviceType===Rs.Keyboard&&v.onInputChangedObservable.add(w=>{w.type==="keydown"?this._onKeyDown(w):w.type==="keyup"&&this._onKeyUp(w)})}),this._alreadyAttached=!0}detachControl(){this._alreadyAttached&&(this._deviceSourceManager.dispose(),this._deviceSourceManager=null,this._alreadyAttachedTo&&!this._scene.doNotHandleCursors&&(this._alreadyAttachedTo.style.cursor=this._scene.defaultCursor),this._alreadyAttached=!1,this._alreadyAttachedTo=null)}setPointerOverMesh(a,x=0,c,u){if(this._meshUnderPointerId[x]===a&&(!a||!a._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting))return;const g=this._meshUnderPointerId[x];let y;g&&(y=g._getActionManagerForTrigger(10),y&&y.processTrigger(10,to.CreateNew(g,u,{pointerId:x}))),a?(this._meshUnderPointerId[x]=a,this._pointerOverMesh=a,y=a._getActionManagerForTrigger(9),y&&y.processTrigger(9,to.CreateNew(a,u,{pointerId:x,pickResult:c}))):(delete this._meshUnderPointerId[x],this._pointerOverMesh=null)}getPointerOverMesh(){return this.meshUnderPointer}_invalidateMesh(a){this._pointerOverMesh===a&&(this._pointerOverMesh=null),this._pickedDownMesh===a&&(this._pickedDownMesh=null),this._pickedUpMesh===a&&(this._pickedUpMesh=null);for(const x in this._meshUnderPointerId)this._meshUnderPointerId[x]===a&&delete this._meshUnderPointerId[x]}}Ra.DragMovementThreshold=10,Ra.LongPressDelay=500,Ra.DoubleClickDelay=300,Ra.ExclusiveDoubleClickMode=!1;class al{constructor(a,x,c,u){this.normal=new Ee(a,x,c),this.d=u}asArray(){return[this.normal.x,this.normal.y,this.normal.z,this.d]}clone(){return new al(this.normal.x,this.normal.y,this.normal.z,this.d)}getClassName(){return"Plane"}getHashCode(){let a=this.normal.getHashCode();return a=a*397^(this.d|0),a}normalize(){const a=Math.sqrt(this.normal.x*this.normal.x+this.normal.y*this.normal.y+this.normal.z*this.normal.z);let x=0;return a!==0&&(x=1/a),this.normal.x*=x,this.normal.y*=x,this.normal.z*=x,this.d*=x,this}transform(a){const x=al._TmpMatrix;a.invertToRef(x);const c=x.m,u=this.normal.x,g=this.normal.y,y=this.normal.z,v=this.d,w=u*c[0]+g*c[1]+y*c[2]+v*c[3],B=u*c[4]+g*c[5]+y*c[6]+v*c[7],W=u*c[8]+g*c[9]+y*c[10]+v*c[11],ae=u*c[12]+g*c[13]+y*c[14]+v*c[15];return new al(w,B,W,ae)}dotCoordinate(a){return this.normal.x*a.x+this.normal.y*a.y+this.normal.z*a.z+this.d}copyFromPoints(a,x,c){const u=x.x-a.x,g=x.y-a.y,y=x.z-a.z,v=c.x-a.x,w=c.y-a.y,B=c.z-a.z,W=g*B-y*w,ae=y*v-u*B,ue=u*w-g*v,fe=Math.sqrt(W*W+ae*ae+ue*ue);let Re;return fe!==0?Re=1/fe:Re=0,this.normal.x=W*Re,this.normal.y=ae*Re,this.normal.z=ue*Re,this.d=-(this.normal.x*a.x+this.normal.y*a.y+this.normal.z*a.z),this}isFrontFacingTo(a,x){return Ee.Dot(this.normal,a)<=x}signedDistanceTo(a){return Ee.Dot(a,this.normal)+this.d}static FromArray(a){return new al(a[0],a[1],a[2],a[3])}static FromPoints(a,x,c){const u=new al(0,0,0,0);return u.copyFromPoints(a,x,c),u}static FromPositionAndNormal(a,x){const c=new al(0,0,0,0);return this.FromPositionAndNormalToRef(a,x,c)}static FromPositionAndNormalToRef(a,x,c){return c.normal.copyFrom(x),c.normal.normalize(),c.d=-a.dot(c.normal),c}static SignedDistanceToPlaneFromPositionAndNormal(a,x,c){const u=-(x.x*a.x+x.y*a.y+x.z*a.z);return Ee.Dot(c,x)+u}}al._TmpMatrix=vt.Identity();class xl{static GetPlanes(a){const x=[];for(let c=0;c<6;c++)x.push(new al(0,0,0,0));return xl.GetPlanesToRef(a,x),x}static GetNearPlaneToRef(a,x){const c=a.m;x.normal.x=c[3]+c[2],x.normal.y=c[7]+c[6],x.normal.z=c[11]+c[10],x.d=c[15]+c[14],x.normalize()}static GetFarPlaneToRef(a,x){const c=a.m;x.normal.x=c[3]-c[2],x.normal.y=c[7]-c[6],x.normal.z=c[11]-c[10],x.d=c[15]-c[14],x.normalize()}static GetLeftPlaneToRef(a,x){const c=a.m;x.normal.x=c[3]+c[0],x.normal.y=c[7]+c[4],x.normal.z=c[11]+c[8],x.d=c[15]+c[12],x.normalize()}static GetRightPlaneToRef(a,x){const c=a.m;x.normal.x=c[3]-c[0],x.normal.y=c[7]-c[4],x.normal.z=c[11]-c[8],x.d=c[15]-c[12],x.normalize()}static GetTopPlaneToRef(a,x){const c=a.m;x.normal.x=c[3]-c[1],x.normal.y=c[7]-c[5],x.normal.z=c[11]-c[9],x.d=c[15]-c[13],x.normalize()}static GetBottomPlaneToRef(a,x){const c=a.m;x.normal.x=c[3]+c[1],x.normal.y=c[7]+c[5],x.normal.z=c[11]+c[9],x.d=c[15]+c[13],x.normalize()}static GetPlanesToRef(a,x){xl.GetNearPlaneToRef(a,x[0]),xl.GetFarPlaneToRef(a,x[1]),xl.GetLeftPlaneToRef(a,x[2]),xl.GetRightPlaneToRef(a,x[3]),xl.GetTopPlaneToRef(a,x[4]),xl.GetBottomPlaneToRef(a,x[5])}static IsPointInFrustum(a,x){for(let c=0;c<6;c++)if(x[c].dotCoordinate(a)<0)return!1;return!0}}class ET{static get UniqueId(){const a=this._UniqueIdCounter;return this._UniqueIdCounter++,a}}ET._UniqueIdCounter=1;class vn{static CompareLightsPriority(a,x){return a.shadowEnabled!==x.shadowEnabled?(x.shadowEnabled?1:0)-(a.shadowEnabled?1:0):x.renderPriority-a.renderPriority}}vn.FALLOFF_DEFAULT=0,vn.FALLOFF_PHYSICAL=1,vn.FALLOFF_GLTF=2,vn.FALLOFF_STANDARD=3,vn.LIGHTMAP_DEFAULT=0,vn.LIGHTMAP_SPECULAR=1,vn.LIGHTMAP_SHADOWSONLY=2,vn.INTENSITYMODE_AUTOMATIC=0,vn.INTENSITYMODE_LUMINOUSPOWER=1,vn.INTENSITYMODE_LUMINOUSINTENSITY=2,vn.INTENSITYMODE_ILLUMINANCE=3,vn.INTENSITYMODE_LUMINANCE=4,vn.LIGHTTYPEID_POINTLIGHT=0,vn.LIGHTTYPEID_DIRECTIONALLIGHT=1,vn.LIGHTTYPEID_SPOTLIGHT=2,vn.LIGHTTYPEID_HEMISPHERICLIGHT=3;class VP{constructor(){this.pointerDownFastCheck=!1,this.pointerUpFastCheck=!1,this.pointerMoveFastCheck=!1,this.skipPointerMovePicking=!1,this.skipPointerDownPicking=!1,this.skipPointerUpPicking=!1}}var g2;(function(F){F[F.BackwardCompatible=0]="BackwardCompatible",F[F.Intermediate=1]="Intermediate",F[F.Aggressive=2]="Aggressive"})(g2||(g2={}));class H0 extends Wc{static DefaultMaterialFactory(a){throw js("StandardMaterial")}static CollisionCoordinatorFactory(){throw js("DefaultCollisionCoordinator")}get environmentTexture(){return this._environmentTexture}set environmentTexture(a){this._environmentTexture!==a&&(this._environmentTexture=a,this.markAllMaterialsAsDirty(1))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}get performancePriority(){return this._performancePriority}set performancePriority(a){if(a!==this._performancePriority){switch(this._performancePriority=a,a){case g2.BackwardCompatible:this.skipFrustumClipping=!1,this._renderingManager.maintainStateBetweenFrames=!1,this.skipPointerMovePicking=!1,this.autoClear=!0;break;case g2.Intermediate:this.skipFrustumClipping=!1,this._renderingManager.maintainStateBetweenFrames=!1,this.skipPointerMovePicking=!0,this.autoClear=!1;break;case g2.Aggressive:this.skipFrustumClipping=!0,this._renderingManager.maintainStateBetweenFrames=!0,this.skipPointerMovePicking=!0,this.autoClear=!1;break}this.onScenePerformancePriorityChangedObservable.notifyObservers(a)}}set forceWireframe(a){this._forceWireframe!==a&&(this._forceWireframe=a,this.markAllMaterialsAsDirty(16))}get forceWireframe(){return this._forceWireframe}set skipFrustumClipping(a){this._skipFrustumClipping!==a&&(this._skipFrustumClipping=a)}get skipFrustumClipping(){return this._skipFrustumClipping}set forcePointsCloud(a){this._forcePointsCloud!==a&&(this._forcePointsCloud=a,this.markAllMaterialsAsDirty(16))}get forcePointsCloud(){return this._forcePointsCloud}get animationPropertiesOverride(){return this._animationPropertiesOverride}set animationPropertiesOverride(a){this._animationPropertiesOverride=a}set onDispose(a){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(a)}set beforeRender(a){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),a&&(this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(a))}set afterRender(a){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),a&&(this._onAfterRenderObserver=this.onAfterRenderObservable.add(a))}set beforeCameraRender(a){this._onBeforeCameraRenderObserver&&this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver),this._onBeforeCameraRenderObserver=this.onBeforeCameraRenderObservable.add(a)}set afterCameraRender(a){this._onAfterCameraRenderObserver&&this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver),this._onAfterCameraRenderObserver=this.onAfterCameraRenderObservable.add(a)}get pointerDownPredicate(){return this._pointerPickingConfiguration.pointerDownPredicate}set pointerDownPredicate(a){this._pointerPickingConfiguration.pointerDownPredicate=a}get pointerUpPredicate(){return this._pointerPickingConfiguration.pointerUpPredicate}set pointerUpPredicate(a){this._pointerPickingConfiguration.pointerUpPredicate=a}get pointerMovePredicate(){return this._pointerPickingConfiguration.pointerMovePredicate}set pointerMovePredicate(a){this._pointerPickingConfiguration.pointerMovePredicate=a}get pointerDownFastCheck(){return this._pointerPickingConfiguration.pointerDownFastCheck}set pointerDownFastCheck(a){this._pointerPickingConfiguration.pointerDownFastCheck=a}get pointerUpFastCheck(){return this._pointerPickingConfiguration.pointerUpFastCheck}set pointerUpFastCheck(a){this._pointerPickingConfiguration.pointerUpFastCheck=a}get pointerMoveFastCheck(){return this._pointerPickingConfiguration.pointerMoveFastCheck}set pointerMoveFastCheck(a){this._pointerPickingConfiguration.pointerMoveFastCheck=a}get skipPointerMovePicking(){return this._pointerPickingConfiguration.skipPointerMovePicking}set skipPointerMovePicking(a){this._pointerPickingConfiguration.skipPointerMovePicking=a}get skipPointerDownPicking(){return this._pointerPickingConfiguration.skipPointerDownPicking}set skipPointerDownPicking(a){this._pointerPickingConfiguration.skipPointerDownPicking=a}get skipPointerUpPicking(){return this._pointerPickingConfiguration.skipPointerUpPicking}set skipPointerUpPicking(a){this._pointerPickingConfiguration.skipPointerUpPicking=a}get unTranslatedPointer(){return this._inputManager.unTranslatedPointer}static get DragMovementThreshold(){return Ra.DragMovementThreshold}static set DragMovementThreshold(a){Ra.DragMovementThreshold=a}static get LongPressDelay(){return Ra.LongPressDelay}static set LongPressDelay(a){Ra.LongPressDelay=a}static get DoubleClickDelay(){return Ra.DoubleClickDelay}static set DoubleClickDelay(a){Ra.DoubleClickDelay=a}static get ExclusiveDoubleClickMode(){return Ra.ExclusiveDoubleClickMode}static set ExclusiveDoubleClickMode(a){Ra.ExclusiveDoubleClickMode=a}bindEyePosition(a,x="vEyePosition",c=!1){const u=this._forcedViewPosition?this._forcedViewPosition:this._mirroredCameraPosition?this._mirroredCameraPosition:this.activeCamera.globalPosition,g=this.useRightHandedSystem===(this._mirroredCameraPosition!=null);return Yt.Vector4[0].set(u.x,u.y,u.z,g?-1:1),a&&(c?a.setFloat3(x,Yt.Vector4[0].x,Yt.Vector4[0].y,Yt.Vector4[0].z):a.setVector4(x,Yt.Vector4[0])),Yt.Vector4[0]}finalizeSceneUbo(){const a=this.getSceneUniformBuffer(),x=this.bindEyePosition(null);return a.updateFloat4("vEyePosition",x.x,x.y,x.z,x.w),a.update(),a}set useRightHandedSystem(a){this._useRightHandedSystem!==a&&(this._useRightHandedSystem=a,this.markAllMaterialsAsDirty(16))}get useRightHandedSystem(){return this._useRightHandedSystem}setStepId(a){this._currentStepId=a}getStepId(){return this._currentStepId}getInternalStep(){return this._currentInternalStep}set fogEnabled(a){this._fogEnabled!==a&&(this._fogEnabled=a,this.markAllMaterialsAsDirty(16))}get fogEnabled(){return this._fogEnabled}set fogMode(a){this._fogMode!==a&&(this._fogMode=a,this.markAllMaterialsAsDirty(16))}get fogMode(){return this._fogMode}get prePass(){return!!this.prePassRenderer&&this.prePassRenderer.defaultRT.enabled}set shadowsEnabled(a){this._shadowsEnabled!==a&&(this._shadowsEnabled=a,this.markAllMaterialsAsDirty(2))}get shadowsEnabled(){return this._shadowsEnabled}set lightsEnabled(a){this._lightsEnabled!==a&&(this._lightsEnabled=a,this.markAllMaterialsAsDirty(2))}get lightsEnabled(){return this._lightsEnabled}get activeCameras(){return this._activeCameras}set activeCameras(a){this._unObserveActiveCameras&&(this._unObserveActiveCameras(),this._unObserveActiveCameras=null),a&&(this._unObserveActiveCameras=Mn(a,()=>{this.onActiveCamerasChanged.notifyObservers(this)})),this._activeCameras=a}get activeCamera(){return this._activeCamera}set activeCamera(a){a!==this._activeCamera&&(this._activeCamera=a,this.onActiveCameraChanged.notifyObservers(this))}get defaultMaterial(){return this._defaultMaterial||(this._defaultMaterial=H0.DefaultMaterialFactory(this)),this._defaultMaterial}set defaultMaterial(a){this._defaultMaterial=a}set texturesEnabled(a){this._texturesEnabled!==a&&(this._texturesEnabled=a,this.markAllMaterialsAsDirty(1))}get texturesEnabled(){return this._texturesEnabled}set skeletonsEnabled(a){this._skeletonsEnabled!==a&&(this._skeletonsEnabled=a,this.markAllMaterialsAsDirty(8))}get skeletonsEnabled(){return this._skeletonsEnabled}get collisionCoordinator(){return this._collisionCoordinator||(this._collisionCoordinator=H0.CollisionCoordinatorFactory(),this._collisionCoordinator.init(this)),this._collisionCoordinator}get renderingManager(){return this._renderingManager}get frustumPlanes(){return this._frustumPlanes}_registerTransientComponents(){if(this._transientComponents.length>0){for(const a of this._transientComponents)a.register();this._transientComponents.length=0}}_addComponent(a){this._components.push(a),this._transientComponents.push(a);const x=a;x.addFromContainer&&x.serialize&&this._serializableComponents.push(x)}_getComponent(a){for(const x of this._components)if(x.name===a)return x;return null}constructor(a,x){super(),this._inputManager=new Ra(this),this.cameraToUseForPointers=null,this._isScene=!0,this._blockEntityCollection=!1,this.autoClear=!0,this.autoClearDepthAndStencil=!0,this.clearColor=new Yr(.2,.2,.3,1),this.ambientColor=new Bs(0,0,0),this.environmentIntensity=1,this._performancePriority=g2.BackwardCompatible,this.onScenePerformancePriorityChangedObservable=new Jt,this._forceWireframe=!1,this._skipFrustumClipping=!1,this._forcePointsCloud=!1,this.animationsEnabled=!0,this._animationPropertiesOverride=null,this.useConstantAnimationDeltaTime=!1,this.constantlyUpdateMeshUnderPointer=!1,this.hoverCursor="pointer",this.defaultCursor="",this.doNotHandleCursors=!1,this.preventDefaultOnPointerDown=!0,this.preventDefaultOnPointerUp=!0,this.metadata=null,this.reservedDataStore=null,this.disableOfflineSupportExceptionRules=[],this.onDisposeObservable=new Jt,this._onDisposeObserver=null,this.onBeforeRenderObservable=new Jt,this._onBeforeRenderObserver=null,this.onAfterRenderObservable=new Jt,this.onAfterRenderCameraObservable=new Jt,this._onAfterRenderObserver=null,this.onBeforeAnimationsObservable=new Jt,this.onAfterAnimationsObservable=new Jt,this.onBeforeDrawPhaseObservable=new Jt,this.onAfterDrawPhaseObservable=new Jt,this.onReadyObservable=new Jt,this.onBeforeCameraRenderObservable=new Jt,this._onBeforeCameraRenderObserver=null,this.onAfterCameraRenderObservable=new Jt,this._onAfterCameraRenderObserver=null,this.onBeforeActiveMeshesEvaluationObservable=new Jt,this.onAfterActiveMeshesEvaluationObservable=new Jt,this.onBeforeParticlesRenderingObservable=new Jt,this.onAfterParticlesRenderingObservable=new Jt,this.onDataLoadedObservable=new Jt,this.onNewCameraAddedObservable=new Jt,this.onCameraRemovedObservable=new Jt,this.onNewLightAddedObservable=new Jt,this.onLightRemovedObservable=new Jt,this.onNewGeometryAddedObservable=new Jt,this.onGeometryRemovedObservable=new Jt,this.onNewTransformNodeAddedObservable=new Jt,this.onTransformNodeRemovedObservable=new Jt,this.onNewMeshAddedObservable=new Jt,this.onMeshRemovedObservable=new Jt,this.onNewSkeletonAddedObservable=new Jt,this.onSkeletonRemovedObservable=new Jt,this.onNewMaterialAddedObservable=new Jt,this.onNewMultiMaterialAddedObservable=new Jt,this.onMaterialRemovedObservable=new Jt,this.onMultiMaterialRemovedObservable=new Jt,this.onNewTextureAddedObservable=new Jt,this.onTextureRemovedObservable=new Jt,this.onBeforeRenderTargetsRenderObservable=new Jt,this.onAfterRenderTargetsRenderObservable=new Jt,this.onBeforeStepObservable=new Jt,this.onAfterStepObservable=new Jt,this.onActiveCameraChanged=new Jt,this.onActiveCamerasChanged=new Jt,this.onBeforeRenderingGroupObservable=new Jt,this.onAfterRenderingGroupObservable=new Jt,this.onMeshImportedObservable=new Jt,this.onAnimationFileImportedObservable=new Jt,this._registeredForLateAnimationBindings=new yt(256),this._pointerPickingConfiguration=new VP,this.onPrePointerObservable=new Jt,this.onPointerObservable=new Jt,this.onPreKeyboardObservable=new Jt,this.onKeyboardObservable=new Jt,this._useRightHandedSystem=!1,this._timeAccumulator=0,this._currentStepId=0,this._currentInternalStep=0,this._fogEnabled=!0,this._fogMode=H0.FOGMODE_NONE,this.fogColor=new Bs(.2,.2,.3),this.fogDensity=.1,this.fogStart=0,this.fogEnd=1e3,this.needsPreviousWorldMatrices=!1,this._shadowsEnabled=!0,this._lightsEnabled=!0,this._unObserveActiveCameras=null,this._texturesEnabled=!0,this.physicsEnabled=!0,this.particlesEnabled=!0,this.spritesEnabled=!0,this._skeletonsEnabled=!0,this.lensFlaresEnabled=!0,this.collisionsEnabled=!0,this.gravity=new Ee(0,-9.807,0),this.postProcessesEnabled=!0,this.renderTargetsEnabled=!0,this.dumpNextRenderTargets=!1,this.customRenderTargets=[],this.importedMeshesFiles=[],this.probesEnabled=!0,this._meshesForIntersections=new yt(256),this.proceduralTexturesEnabled=!0,this._totalVertices=new l0,this._activeIndices=new l0,this._activeParticles=new l0,this._activeBones=new l0,this._animationTime=0,this.animationTimeScale=1,this._renderId=0,this._frameId=0,this._executeWhenReadyTimeoutId=null,this._intermediateRendering=!1,this._defaultFrameBufferCleared=!1,this._viewUpdateFlag=-1,this._projectionUpdateFlag=-1,this._toBeDisposed=new Array(256),this._activeRequests=new Array,this._pendingData=new Array,this._isDisposed=!1,this.dispatchAllSubMeshesOfActiveMeshes=!1,this._activeMeshes=new lt(256),this._processedMaterials=new lt(256),this._renderTargets=new yt(256),this._materialsRenderTargets=new yt(256),this._activeParticleSystems=new lt(256),this._activeSkeletons=new yt(32),this._softwareSkinnedMeshes=new yt(32),this._activeAnimatables=new Array,this._transformMatrix=vt.Zero(),this.requireLightSorting=!1,this._components=[],this._serializableComponents=[],this._transientComponents=[],this._beforeCameraUpdateStage=Ia.Create(),this._beforeClearStage=Ia.Create(),this._beforeRenderTargetClearStage=Ia.Create(),this._gatherRenderTargetsStage=Ia.Create(),this._gatherActiveCameraRenderTargetsStage=Ia.Create(),this._isReadyForMeshStage=Ia.Create(),this._beforeEvaluateActiveMeshStage=Ia.Create(),this._evaluateSubMeshStage=Ia.Create(),this._preActiveMeshStage=Ia.Create(),this._cameraDrawRenderTargetStage=Ia.Create(),this._beforeCameraDrawStage=Ia.Create(),this._beforeRenderTargetDrawStage=Ia.Create(),this._beforeRenderingGroupDrawStage=Ia.Create(),this._beforeRenderingMeshStage=Ia.Create(),this._afterRenderingMeshStage=Ia.Create(),this._afterRenderingGroupDrawStage=Ia.Create(),this._afterCameraDrawStage=Ia.Create(),this._afterCameraPostProcessStage=Ia.Create(),this._afterRenderTargetDrawStage=Ia.Create(),this._afterRenderTargetPostProcessStage=Ia.Create(),this._afterRenderStage=Ia.Create(),this._pointerMoveStage=Ia.Create(),this._pointerDownStage=Ia.Create(),this._pointerUpStage=Ia.Create(),this._geometriesByUniqueId=null,this._defaultMeshCandidates={data:[],length:0},this._defaultSubMeshCandidates={data:[],length:0},this._preventFreeActiveMeshesAndRenderingGroups=!1,this._activeMeshesFrozen=!1,this._activeMeshesFrozenButKeepClipping=!1,this._skipEvaluateActiveMeshesCompletely=!1,this._allowPostProcessClearColor=!0,this.getDeterministicFrameTime=()=>this._engine.getTimeStep(),this._registeredActions=0,this._blockMaterialDirtyMechanism=!1,this._perfCollector=null,this.activeCameras=[];const c={useGeometryUniqueIdsMap:!0,useMaterialMeshMap:!0,useClonedMeshMap:!0,virtual:!1,...x};a=this._engine=a||tr.LastCreatedEngine,c.virtual?a._virtualScenes.push(this):(tr._LastCreatedScene=this,a.scenes.push(this)),this._uid=null,this._renderingManager=new io(this),Ym&&(this.postProcessManager=new Ym(this)),xa()&&this.attachControl(),this._createUbo(),un&&(this._imageProcessingConfiguration=new un),this.setDefaultCandidateProviders(),c.useGeometryUniqueIdsMap&&(this._geometriesByUniqueId={}),this.useMaterialMeshMap=c.useMaterialMeshMap,this.useClonedMeshMap=c.useClonedMeshMap,(!x||!x.virtual)&&a.onNewSceneAddedObservable.notifyObservers(this)}getClassName(){return"Scene"}_getDefaultMeshCandidates(){return this._defaultMeshCandidates.data=this.meshes,this._defaultMeshCandidates.length=this.meshes.length,this._defaultMeshCandidates}_getDefaultSubMeshCandidates(a){return this._defaultSubMeshCandidates.data=a.subMeshes,this._defaultSubMeshCandidates.length=a.subMeshes.length,this._defaultSubMeshCandidates}setDefaultCandidateProviders(){this.getActiveMeshCandidates=()=>this._getDefaultMeshCandidates(),this.getActiveSubMeshCandidates=a=>this._getDefaultSubMeshCandidates(a),this.getIntersectingSubMeshCandidates=(a,x)=>this._getDefaultSubMeshCandidates(a),this.getCollidingSubMeshCandidates=(a,x)=>this._getDefaultSubMeshCandidates(a)}get meshUnderPointer(){return this._inputManager.meshUnderPointer}get pointerX(){return this._inputManager.pointerX}set pointerX(a){this._inputManager.pointerX=a}get pointerY(){return this._inputManager.pointerY}set pointerY(a){this._inputManager.pointerY=a}getCachedMaterial(){return this._cachedMaterial}getCachedEffect(){return this._cachedEffect}getCachedVisibility(){return this._cachedVisibility}isCachedMaterialInvalid(a,x,c=1){return this._cachedEffect!==x||this._cachedMaterial!==a||this._cachedVisibility!==c}getEngine(){return this._engine}getTotalVertices(){return this._totalVertices.current}get totalVerticesPerfCounter(){return this._totalVertices}getActiveIndices(){return this._activeIndices.current}get totalActiveIndicesPerfCounter(){return this._activeIndices}getActiveParticles(){return this._activeParticles.current}get activeParticlesPerfCounter(){return this._activeParticles}getActiveBones(){return this._activeBones.current}get activeBonesPerfCounter(){return this._activeBones}getActiveMeshes(){return this._activeMeshes}getAnimationRatio(){return this._animationRatio!==void 0?this._animationRatio:1}getRenderId(){return this._renderId}getFrameId(){return this._frameId}incrementRenderId(){this._renderId++}_createUbo(){this.setSceneUniformBuffer(this.createSceneUniformBuffer())}simulatePointerMove(a,x){return this._inputManager.simulatePointerMove(a,x),this}simulatePointerDown(a,x){return this._inputManager.simulatePointerDown(a,x),this}simulatePointerUp(a,x,c){return this._inputManager.simulatePointerUp(a,x,c),this}isPointerCaptured(a=0){return this._inputManager.isPointerCaptured(a)}attachControl(a=!0,x=!0,c=!0){this._inputManager.attachControl(a,x,c)}detachControl(){this._inputManager.detachControl()}isReady(a=!0){if(this._isDisposed)return!1;let x;const c=this.getEngine(),u=c.currentRenderPassId;c.currentRenderPassId=this.activeCamera?.renderPassId??u;let g=!0;for(this._pendingData.length>0&&(g=!1),this.prePassRenderer?.update(),this.useOrderIndependentTransparency&&this.depthPeelingRenderer&&g&&(g=this.depthPeelingRenderer.isReady()),a&&(this._processedMaterials.reset(),this._materialsRenderTargets.reset()),x=0;x<this.meshes.length;x++){const y=this.meshes[x];if(!y.subMeshes||y.subMeshes.length===0)continue;if(!y.isReady(!0)){g=!1;continue}const v=y.hasThinInstances||y.getClassName()==="InstancedMesh"||y.getClassName()==="InstancedLinesMesh"||c.getCaps().instancedArrays&&y.instances.length>0;for(const B of this._isReadyForMeshStage)B.action(y,v)||(g=!1);if(!a)continue;const w=y.material||this.defaultMaterial;if(w)if(w._storeEffectOnSubMeshes)for(const B of y.subMeshes){const W=B.getMaterial();W&&W.hasRenderTargetTextures&&W.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(W)===-1&&(this._processedMaterials.push(W),this._materialsRenderTargets.concatWithNoDuplicate(W.getRenderTargetTextures()))}else w.hasRenderTargetTextures&&w.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(w)===-1&&(this._processedMaterials.push(w),this._materialsRenderTargets.concatWithNoDuplicate(w.getRenderTargetTextures()))}if(a)for(x=0;x<this._materialsRenderTargets.length;++x)this._materialsRenderTargets.data[x].isReadyForRendering()||(g=!1);for(x=0;x<this.geometries.length;x++)this.geometries[x].delayLoadState===2&&(g=!1);if(this.activeCameras&&this.activeCameras.length>0)for(const y of this.activeCameras)y.isReady(!0)||(g=!1);else this.activeCamera&&(this.activeCamera.isReady(!0)||(g=!1));for(const y of this.particleSystems)y.isReady()||(g=!1);if(this.layers)for(const y of this.layers)y.isReady()||(g=!1);return c.areAllEffectsReady()||(g=!1),c.currentRenderPassId=u,g}resetCachedMaterial(){this._cachedMaterial=null,this._cachedEffect=null,this._cachedVisibility=null}registerBeforeRender(a){this.onBeforeRenderObservable.add(a)}unregisterBeforeRender(a){this.onBeforeRenderObservable.removeCallback(a)}registerAfterRender(a){this.onAfterRenderObservable.add(a)}unregisterAfterRender(a){this.onAfterRenderObservable.removeCallback(a)}_executeOnceBeforeRender(a){const x=()=>{a(),setTimeout(()=>{this.unregisterBeforeRender(x)})};this.registerBeforeRender(x)}executeOnceBeforeRender(a,x){x!==void 0?setTimeout(()=>{this._executeOnceBeforeRender(a)},x):this._executeOnceBeforeRender(a)}addPendingData(a){this._pendingData.push(a)}removePendingData(a){const x=this.isLoading,c=this._pendingData.indexOf(a);c!==-1&&this._pendingData.splice(c,1),x&&!this.isLoading&&this.onDataLoadedObservable.notifyObservers(this)}getWaitingItemsCount(){return this._pendingData.length}get isLoading(){return this._pendingData.length>0}executeWhenReady(a,x=!1){this.onReadyObservable.addOnce(a),this._executeWhenReadyTimeoutId===null&&this._checkIsReady(x)}whenReadyAsync(a=!1){return new Promise(x=>{this.executeWhenReady(()=>{x()},a)})}_checkIsReady(a=!1){if(this._registerTransientComponents(),this.isReady(a)){this.onReadyObservable.notifyObservers(this),this.onReadyObservable.clear(),this._executeWhenReadyTimeoutId=null;return}if(this._isDisposed){this.onReadyObservable.clear(),this._executeWhenReadyTimeoutId=null;return}this._executeWhenReadyTimeoutId=setTimeout(()=>{this.incrementRenderId(),this._checkIsReady(a)},100)}get animatables(){return this._activeAnimatables}resetLastAnimationTimeFrame(){this._animationTimeLast=Wo.Now}getViewMatrix(){return this._viewMatrix}getProjectionMatrix(){return this._projectionMatrix}getTransformMatrix(){return this._transformMatrix}setTransformMatrix(a,x,c,u){!c&&!u&&this._multiviewSceneUbo&&(this._multiviewSceneUbo.dispose(),this._multiviewSceneUbo=null),!(this._viewUpdateFlag===a.updateFlag&&this._projectionUpdateFlag===x.updateFlag)&&(this._viewUpdateFlag=a.updateFlag,this._projectionUpdateFlag=x.updateFlag,this._viewMatrix=a,this._projectionMatrix=x,this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix),this._frustumPlanes?xl.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=xl.GetPlanes(this._transformMatrix),this._multiviewSceneUbo&&this._multiviewSceneUbo.useUbo?this._updateMultiviewUbo(c,u):this._sceneUbo.useUbo&&(this._sceneUbo.updateMatrix("viewProjection",this._transformMatrix),this._sceneUbo.updateMatrix("view",this._viewMatrix),this._sceneUbo.updateMatrix("projection",this._projectionMatrix)))}getSceneUniformBuffer(){return this._multiviewSceneUbo?this._multiviewSceneUbo:this._sceneUbo}createSceneUniformBuffer(a){const x=new ys(this._engine,void 0,!1,a??"scene");return x.addUniform("viewProjection",16),x.addUniform("view",16),x.addUniform("projection",16),x.addUniform("vEyePosition",4),x}setSceneUniformBuffer(a){this._sceneUbo=a,this._viewUpdateFlag=-1,this._projectionUpdateFlag=-1}getUniqueId(){return ET.UniqueId}addMesh(a,x=!1){this._blockEntityCollection||(this.meshes.push(a),a._resyncLightSources(),a.parent||a._addToSceneRootNodes(),this.onNewMeshAddedObservable.notifyObservers(a),x&&a.getChildMeshes().forEach(c=>{this.addMesh(c)}))}removeMesh(a,x=!1){const c=this.meshes.indexOf(a);return c!==-1&&(this.meshes[c]=this.meshes[this.meshes.length-1],this.meshes.pop(),a.parent||a._removeFromSceneRootNodes()),this._inputManager._invalidateMesh(a),this.onMeshRemovedObservable.notifyObservers(a),x&&a.getChildMeshes().forEach(u=>{this.removeMesh(u)}),c}addTransformNode(a){this._blockEntityCollection||a.getScene()===this&&a._indexInSceneTransformNodesArray!==-1||(a._indexInSceneTransformNodesArray=this.transformNodes.length,this.transformNodes.push(a),a.parent||a._addToSceneRootNodes(),this.onNewTransformNodeAddedObservable.notifyObservers(a))}removeTransformNode(a){const x=a._indexInSceneTransformNodesArray;if(x!==-1){if(x!==this.transformNodes.length-1){const c=this.transformNodes[this.transformNodes.length-1];this.transformNodes[x]=c,c._indexInSceneTransformNodesArray=x}a._indexInSceneTransformNodesArray=-1,this.transformNodes.pop(),a.parent||a._removeFromSceneRootNodes()}return this.onTransformNodeRemovedObservable.notifyObservers(a),x}removeSkeleton(a){const x=this.skeletons.indexOf(a);return x!==-1&&(this.skeletons.splice(x,1),this.onSkeletonRemovedObservable.notifyObservers(a),this._executeActiveContainerCleanup(this._activeSkeletons)),x}removeMorphTargetManager(a){const x=this.morphTargetManagers.indexOf(a);return x!==-1&&this.morphTargetManagers.splice(x,1),x}removeLight(a){const x=this.lights.indexOf(a);if(x!==-1){for(const c of this.meshes)c._removeLightSource(a,!1);this.lights.splice(x,1),this.sortLightsByPriority(),a.parent||a._removeFromSceneRootNodes()}return this.onLightRemovedObservable.notifyObservers(a),x}removeCamera(a){const x=this.cameras.indexOf(a);if(x!==-1&&(this.cameras.splice(x,1),a.parent||a._removeFromSceneRootNodes()),this.activeCameras){const c=this.activeCameras.indexOf(a);c!==-1&&this.activeCameras.splice(c,1)}return this.activeCamera===a&&(this.cameras.length>0?this.activeCamera=this.cameras[0]:this.activeCamera=null),this.onCameraRemovedObservable.notifyObservers(a),x}removeParticleSystem(a){const x=this.particleSystems.indexOf(a);return x!==-1&&(this.particleSystems.splice(x,1),this._executeActiveContainerCleanup(this._activeParticleSystems)),x}removeAnimation(a){const x=this.animations.indexOf(a);return x!==-1&&this.animations.splice(x,1),x}stopAnimation(a,x,c){}removeAnimationGroup(a){const x=this.animationGroups.indexOf(a);return x!==-1&&this.animationGroups.splice(x,1),x}removeMultiMaterial(a){const x=this.multiMaterials.indexOf(a);return x!==-1&&this.multiMaterials.splice(x,1),this.onMultiMaterialRemovedObservable.notifyObservers(a),x}removeMaterial(a){const x=a._indexInSceneMaterialArray;if(x!==-1&&x<this.materials.length){if(x!==this.materials.length-1){const c=this.materials[this.materials.length-1];this.materials[x]=c,c._indexInSceneMaterialArray=x}a._indexInSceneMaterialArray=-1,this.materials.pop()}return this.onMaterialRemovedObservable.notifyObservers(a),x}removeActionManager(a){const x=this.actionManagers.indexOf(a);return x!==-1&&this.actionManagers.splice(x,1),x}removeTexture(a){const x=this.textures.indexOf(a);return x!==-1&&this.textures.splice(x,1),this.onTextureRemovedObservable.notifyObservers(a),x}addLight(a){if(!this._blockEntityCollection){this.lights.push(a),this.sortLightsByPriority(),a.parent||a._addToSceneRootNodes();for(const x of this.meshes)x.lightSources.indexOf(a)===-1&&(x.lightSources.push(a),x._resyncLightSources());this.onNewLightAddedObservable.notifyObservers(a)}}sortLightsByPriority(){this.requireLightSorting&&this.lights.sort(vn.CompareLightsPriority)}addCamera(a){this._blockEntityCollection||(this.cameras.push(a),this.onNewCameraAddedObservable.notifyObservers(a),a.parent||a._addToSceneRootNodes())}addSkeleton(a){this._blockEntityCollection||(this.skeletons.push(a),this.onNewSkeletonAddedObservable.notifyObservers(a))}addParticleSystem(a){this._blockEntityCollection||this.particleSystems.push(a)}addAnimation(a){this._blockEntityCollection||this.animations.push(a)}addAnimationGroup(a){this._blockEntityCollection||this.animationGroups.push(a)}addMultiMaterial(a){this._blockEntityCollection||(this.multiMaterials.push(a),this.onNewMultiMaterialAddedObservable.notifyObservers(a))}addMaterial(a){this._blockEntityCollection||a.getScene()===this&&a._indexInSceneMaterialArray!==-1||(a._indexInSceneMaterialArray=this.materials.length,this.materials.push(a),this.onNewMaterialAddedObservable.notifyObservers(a))}addMorphTargetManager(a){this._blockEntityCollection||this.morphTargetManagers.push(a)}addGeometry(a){this._blockEntityCollection||(this._geometriesByUniqueId&&(this._geometriesByUniqueId[a.uniqueId]=this.geometries.length),this.geometries.push(a))}addActionManager(a){this.actionManagers.push(a)}addTexture(a){this._blockEntityCollection||(this.textures.push(a),this.onNewTextureAddedObservable.notifyObservers(a))}switchActiveCamera(a,x=!0){this._engine.getInputElement()&&(this.activeCamera&&this.activeCamera.detachControl(),this.activeCamera=a,x&&a.attachControl())}setActiveCameraById(a){const x=this.getCameraById(a);return x?(this.activeCamera=x,x):null}setActiveCameraByName(a){const x=this.getCameraByName(a);return x?(this.activeCamera=x,x):null}getAnimationGroupByName(a){for(let x=0;x<this.animationGroups.length;x++)if(this.animationGroups[x].name===a)return this.animationGroups[x];return null}_getMaterial(a,x){for(let c=0;c<this.materials.length;c++){const u=this.materials[c];if(x(u))return u}if(a)for(let c=0;c<this.multiMaterials.length;c++){const u=this.multiMaterials[c];if(x(u))return u}return null}getMaterialByUniqueID(a,x=!1){return this._getMaterial(x,c=>c.uniqueId===a)}getMaterialById(a,x=!1){return this._getMaterial(x,c=>c.id===a)}getMaterialByName(a,x=!1){return this._getMaterial(x,c=>c.name===a)}getLastMaterialById(a,x=!1){for(let c=this.materials.length-1;c>=0;c--)if(this.materials[c].id===a)return this.materials[c];if(x){for(let c=this.multiMaterials.length-1;c>=0;c--)if(this.multiMaterials[c].id===a)return this.multiMaterials[c]}return null}getTextureByUniqueId(a){for(let x=0;x<this.textures.length;x++)if(this.textures[x].uniqueId===a)return this.textures[x];return null}getTextureByName(a){for(let x=0;x<this.textures.length;x++)if(this.textures[x].name===a)return this.textures[x];return null}getCameraById(a){for(let x=0;x<this.cameras.length;x++)if(this.cameras[x].id===a)return this.cameras[x];return null}getCameraByUniqueId(a){for(let x=0;x<this.cameras.length;x++)if(this.cameras[x].uniqueId===a)return this.cameras[x];return null}getCameraByName(a){for(let x=0;x<this.cameras.length;x++)if(this.cameras[x].name===a)return this.cameras[x];return null}getBoneById(a){for(let x=0;x<this.skeletons.length;x++){const c=this.skeletons[x];for(let u=0;u<c.bones.length;u++)if(c.bones[u].id===a)return c.bones[u]}return null}getBoneByName(a){for(let x=0;x<this.skeletons.length;x++){const c=this.skeletons[x];for(let u=0;u<c.bones.length;u++)if(c.bones[u].name===a)return c.bones[u]}return null}getLightByName(a){for(let x=0;x<this.lights.length;x++)if(this.lights[x].name===a)return this.lights[x];return null}getLightById(a){for(let x=0;x<this.lights.length;x++)if(this.lights[x].id===a)return this.lights[x];return null}getLightByUniqueId(a){for(let x=0;x<this.lights.length;x++)if(this.lights[x].uniqueId===a)return this.lights[x];return null}getParticleSystemById(a){for(let x=0;x<this.particleSystems.length;x++)if(this.particleSystems[x].id===a)return this.particleSystems[x];return null}getGeometryById(a){for(let x=0;x<this.geometries.length;x++)if(this.geometries[x].id===a)return this.geometries[x];return null}_getGeometryByUniqueId(a){if(this._geometriesByUniqueId){const x=this._geometriesByUniqueId[a];if(x!==void 0)return this.geometries[x]}else for(let x=0;x<this.geometries.length;x++)if(this.geometries[x].uniqueId===a)return this.geometries[x];return null}pushGeometry(a,x){return!x&&this._getGeometryByUniqueId(a.uniqueId)?!1:(this.addGeometry(a),this.onNewGeometryAddedObservable.notifyObservers(a),!0)}removeGeometry(a){let x;if(this._geometriesByUniqueId){if(x=this._geometriesByUniqueId[a.uniqueId],x===void 0)return!1}else if(x=this.geometries.indexOf(a),x<0)return!1;if(x!==this.geometries.length-1){const c=this.geometries[this.geometries.length-1];c&&(this.geometries[x]=c,this._geometriesByUniqueId&&(this._geometriesByUniqueId[c.uniqueId]=x))}return this._geometriesByUniqueId&&(this._geometriesByUniqueId[a.uniqueId]=void 0),this.geometries.pop(),this.onGeometryRemovedObservable.notifyObservers(a),!0}getGeometries(){return this.geometries}getMeshById(a){for(let x=0;x<this.meshes.length;x++)if(this.meshes[x].id===a)return this.meshes[x];return null}getMeshesById(a){return this.meshes.filter(function(x){return x.id===a})}getTransformNodeById(a){for(let x=0;x<this.transformNodes.length;x++)if(this.transformNodes[x].id===a)return this.transformNodes[x];return null}getTransformNodeByUniqueId(a){for(let x=0;x<this.transformNodes.length;x++)if(this.transformNodes[x].uniqueId===a)return this.transformNodes[x];return null}getTransformNodesById(a){return this.transformNodes.filter(function(x){return x.id===a})}getMeshByUniqueId(a){for(let x=0;x<this.meshes.length;x++)if(this.meshes[x].uniqueId===a)return this.meshes[x];return null}getLastMeshById(a){for(let x=this.meshes.length-1;x>=0;x--)if(this.meshes[x].id===a)return this.meshes[x];return null}getLastTransformNodeById(a){for(let x=this.transformNodes.length-1;x>=0;x--)if(this.transformNodes[x].id===a)return this.transformNodes[x];return null}getLastEntryById(a){let x;for(x=this.meshes.length-1;x>=0;x--)if(this.meshes[x].id===a)return this.meshes[x];for(x=this.transformNodes.length-1;x>=0;x--)if(this.transformNodes[x].id===a)return this.transformNodes[x];for(x=this.cameras.length-1;x>=0;x--)if(this.cameras[x].id===a)return this.cameras[x];for(x=this.lights.length-1;x>=0;x--)if(this.lights[x].id===a)return this.lights[x];return null}getNodeById(a){const x=this.getMeshById(a);if(x)return x;const c=this.getTransformNodeById(a);if(c)return c;const u=this.getLightById(a);if(u)return u;const g=this.getCameraById(a);if(g)return g;const y=this.getBoneById(a);return y||null}getNodeByName(a){const x=this.getMeshByName(a);if(x)return x;const c=this.getTransformNodeByName(a);if(c)return c;const u=this.getLightByName(a);if(u)return u;const g=this.getCameraByName(a);if(g)return g;const y=this.getBoneByName(a);return y||null}getMeshByName(a){for(let x=0;x<this.meshes.length;x++)if(this.meshes[x].name===a)return this.meshes[x];return null}getTransformNodeByName(a){for(let x=0;x<this.transformNodes.length;x++)if(this.transformNodes[x].name===a)return this.transformNodes[x];return null}getLastSkeletonById(a){for(let x=this.skeletons.length-1;x>=0;x--)if(this.skeletons[x].id===a)return this.skeletons[x];return null}getSkeletonByUniqueId(a){for(let x=0;x<this.skeletons.length;x++)if(this.skeletons[x].uniqueId===a)return this.skeletons[x];return null}getSkeletonById(a){for(let x=0;x<this.skeletons.length;x++)if(this.skeletons[x].id===a)return this.skeletons[x];return null}getSkeletonByName(a){for(let x=0;x<this.skeletons.length;x++)if(this.skeletons[x].name===a)return this.skeletons[x];return null}getMorphTargetManagerById(a){for(let x=0;x<this.morphTargetManagers.length;x++)if(this.morphTargetManagers[x].uniqueId===a)return this.morphTargetManagers[x];return null}getMorphTargetById(a){for(let x=0;x<this.morphTargetManagers.length;++x){const c=this.morphTargetManagers[x];for(let u=0;u<c.numTargets;++u){const g=c.getTarget(u);if(g.id===a)return g}}return null}getMorphTargetByName(a){for(let x=0;x<this.morphTargetManagers.length;++x){const c=this.morphTargetManagers[x];for(let u=0;u<c.numTargets;++u){const g=c.getTarget(u);if(g.name===a)return g}}return null}getPostProcessByName(a){for(let x=0;x<this.postProcesses.length;++x){const c=this.postProcesses[x];if(c.name===a)return c}return null}isActiveMesh(a){return this._activeMeshes.indexOf(a)!==-1}get uid(){return this._uid||(this._uid=_t.RandomId()),this._uid}addExternalData(a,x){return this._externalData||(this._externalData=new jt),this._externalData.add(a,x)}getExternalData(a){return this._externalData?this._externalData.get(a):null}getOrAddExternalDataWithFactory(a,x){return this._externalData||(this._externalData=new jt),this._externalData.getOrAddWithFactory(a,x)}removeExternalData(a){return this._externalData.remove(a)}_evaluateSubMesh(a,x,c,u){if(u||a.isInFrustum(this._frustumPlanes)){for(const y of this._evaluateSubMeshStage)y.action(x,a);const g=a.getMaterial();g!=null&&(g.hasRenderTargetTextures&&g.getRenderTargetTextures!=null&&this._processedMaterials.indexOf(g)===-1&&(this._processedMaterials.push(g),this._materialsRenderTargets.concatWithNoDuplicate(g.getRenderTargetTextures())),this._renderingManager.dispatch(a,x,g))}}freeProcessedMaterials(){this._processedMaterials.dispose()}get blockfreeActiveMeshesAndRenderingGroups(){return this._preventFreeActiveMeshesAndRenderingGroups}set blockfreeActiveMeshesAndRenderingGroups(a){this._preventFreeActiveMeshesAndRenderingGroups!==a&&(a&&(this.freeActiveMeshes(),this.freeRenderingGroups()),this._preventFreeActiveMeshesAndRenderingGroups=a)}freeActiveMeshes(){if(!this.blockfreeActiveMeshesAndRenderingGroups&&(this._activeMeshes.dispose(),this.activeCamera&&this.activeCamera._activeMeshes&&this.activeCamera._activeMeshes.dispose(),this.activeCameras))for(let a=0;a<this.activeCameras.length;a++){const x=this.activeCameras[a];x&&x._activeMeshes&&x._activeMeshes.dispose()}}freeRenderingGroups(){if(!this.blockfreeActiveMeshesAndRenderingGroups&&(this._renderingManager&&this._renderingManager.freeRenderingGroups(),this.textures))for(let a=0;a<this.textures.length;a++){const x=this.textures[a];x&&x.renderList&&x.freeRenderingGroups()}}_isInIntermediateRendering(){return this._intermediateRendering}freezeActiveMeshes(a=!1,x,c,u=!0,g=!1){return this.executeWhenReady(()=>{if(!this.activeCamera){c&&c("No active camera found");return}if(this._frustumPlanes||this.updateTransformMatrix(),this._evaluateActiveMeshes(),this._activeMeshesFrozen=!0,this._activeMeshesFrozenButKeepClipping=g,this._skipEvaluateActiveMeshesCompletely=a,u)for(let y=0;y<this._activeMeshes.length;y++)this._activeMeshes.data[y]._freeze();x&&x()}),this}unfreezeActiveMeshes(){for(let a=0;a<this.meshes.length;a++){const x=this.meshes[a];x._internalAbstractMeshDataInfo&&(x._internalAbstractMeshDataInfo._isActive=!1)}for(let a=0;a<this._activeMeshes.length;a++)this._activeMeshes.data[a]._unFreeze();return this._activeMeshesFrozen=!1,this}_executeActiveContainerCleanup(a){!(this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1)&&this._activeMeshesFrozen&&this._activeMeshes.length||this.onBeforeRenderObservable.addOnce(()=>a.dispose())}_evaluateActiveMeshes(){if(this._engine.snapshotRendering&&this._engine.snapshotRenderingMode===1){this._activeMeshes.length>0&&(this.activeCamera?._activeMeshes.reset(),this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset());return}if(this._activeMeshesFrozen&&this._activeMeshes.length){if(!this._skipEvaluateActiveMeshesCompletely){const c=this._activeMeshes.length;for(let u=0;u<c;u++)this._activeMeshes.data[u].computeWorldMatrix()}if(this._activeParticleSystems){const c=this._activeParticleSystems.length;for(let u=0;u<c;u++)this._activeParticleSystems.data[u].animate()}this._renderingManager.resetSprites();return}if(!this.activeCamera)return;this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this),this.activeCamera._activeMeshes.reset(),this._activeMeshes.reset(),this._renderingManager.reset(),this._processedMaterials.reset(),this._activeParticleSystems.reset(),this._activeSkeletons.reset(),this._softwareSkinnedMeshes.reset(),this._materialsRenderTargets.reset();for(const c of this._beforeEvaluateActiveMeshStage)c.action();const a=this.getActiveMeshCandidates(),x=a.length;for(let c=0;c<x;c++){const u=a.data[c];if(u._internalAbstractMeshDataInfo._currentLODIsUpToDate=!1,u.isBlocked||(this._totalVertices.addCount(u.getTotalVertices(),!1),!u.isReady()||!u.isEnabled()||u.scaling.hasAZeroComponent))continue;u.computeWorldMatrix(),u.actionManager&&u.actionManager.hasSpecificTriggers2(12,13)&&this._meshesForIntersections.pushNoDuplicate(u);let g=this.customLODSelector?this.customLODSelector(u,this.activeCamera):u.getLOD(this.activeCamera);if(u._internalAbstractMeshDataInfo._currentLOD=g,u._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0,g!=null&&(g!==u&&g.billboardMode!==0&&g.computeWorldMatrix(),u._preActivate(),u.isVisible&&u.visibility>0&&u.layerMask&this.activeCamera.layerMask&&(this._skipFrustumClipping||u.alwaysSelectAsActiveMesh||u.isInFrustum(this._frustumPlanes)))){this._activeMeshes.push(u),this.activeCamera._activeMeshes.push(u),g!==u&&g._activate(this._renderId,!1);for(const y of this._preActiveMeshStage)y.action(u);u._activate(this._renderId,!1)&&(u.isAnInstance?u._internalAbstractMeshDataInfo._actAsRegularMesh&&(g=u):g._internalAbstractMeshDataInfo._onlyForInstances=!1,g._internalAbstractMeshDataInfo._isActive=!0,this._activeMesh(u,g)),u._postActivate()}}if(this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this),this.particlesEnabled){this.onBeforeParticlesRenderingObservable.notifyObservers(this);for(let c=0;c<this.particleSystems.length;c++){const u=this.particleSystems[c];if(!u.isStarted()||!u.emitter)continue;const g=u.emitter;(!g.position||g.isEnabled())&&(this._activeParticleSystems.push(u),u.animate(),this._renderingManager.dispatchParticles(u))}this.onAfterParticlesRenderingObservable.notifyObservers(this)}}_activeMesh(a,x){this._skeletonsEnabled&&x.skeleton!==null&&x.skeleton!==void 0&&(this._activeSkeletons.pushNoDuplicate(x.skeleton)&&(x.skeleton.prepare(),this._activeBones.addCount(x.skeleton.bones.length,!1)),x.computeBonesUsingShaders||this._softwareSkinnedMeshes.pushNoDuplicate(x));let c=a.hasInstances||a.isAnInstance||this.dispatchAllSubMeshesOfActiveMeshes||this._skipFrustumClipping||x.alwaysSelectAsActiveMesh;if(x&&x.subMeshes&&x.subMeshes.length>0){const u=this.getActiveSubMeshCandidates(x),g=u.length;c=c||g===1;for(let y=0;y<g;y++){const v=u.data[y];this._evaluateSubMesh(v,x,a,c)}}}updateTransformMatrix(a){const x=this.activeCamera;if(x)if(x._renderingMultiview){const c=x._rigCameras[0],u=x._rigCameras[1];this.setTransformMatrix(c.getViewMatrix(),c.getProjectionMatrix(a),u.getViewMatrix(),u.getProjectionMatrix(a))}else this.setTransformMatrix(x.getViewMatrix(),x.getProjectionMatrix(a))}_bindFrameBuffer(a,x=!0){a&&a._multiviewTexture?a._multiviewTexture._bindFrameBuffer():a&&a.outputRenderTarget?a.outputRenderTarget._bindFrameBuffer():this._engine._currentFrameBufferIsDefaultFrameBuffer()||this._engine.restoreDefaultFramebuffer(),x&&this._clearFrameBuffer(a)}_clearFrameBuffer(a){if(!(a&&a._multiviewTexture))if(a&&a.outputRenderTarget&&!a._renderingMultiview){const x=a.outputRenderTarget;x.onClearObservable.hasObservers()?x.onClearObservable.notifyObservers(this._engine):!x.skipInitialClear&&!a.isRightCamera&&(this.autoClear&&this._engine.clear(x.clearColor||this.clearColor,!x._cleared,!0,!0),x._cleared=!0)}else this._defaultFrameBufferCleared?this._engine.clear(null,!1,!0,!0):(this._defaultFrameBufferCleared=!0,this._clear())}_renderForCamera(a,x,c=!0){if(a&&a._skipRendering)return;const u=this._engine;if(this._activeCamera=a,!this.activeCamera)throw new Error("Active camera not set");if(u.setViewport(this.activeCamera.viewport),this.resetCachedMaterial(),this._renderId++,!this.prePass&&c){let y=!0;a._renderingMultiview&&a.outputRenderTarget&&(y=a.outputRenderTarget.skipInitialClear,this.autoClear&&(this._defaultFrameBufferCleared=!1,a.outputRenderTarget.skipInitialClear=!1)),this._bindFrameBuffer(this._activeCamera),a._renderingMultiview&&a.outputRenderTarget&&(a.outputRenderTarget.skipInitialClear=y)}this.updateTransformMatrix(),this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera),this._evaluateActiveMeshes();for(let y=0;y<this._softwareSkinnedMeshes.length;y++){const v=this._softwareSkinnedMeshes.data[y];v.applySkeleton(v.skeleton)}this.onBeforeRenderTargetsRenderObservable.notifyObservers(this),this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets),a.customRenderTargets&&a.customRenderTargets.length>0&&this._renderTargets.concatWithNoDuplicate(a.customRenderTargets),x&&x.customRenderTargets&&x.customRenderTargets.length>0&&this._renderTargets.concatWithNoDuplicate(x.customRenderTargets),this.environmentTexture&&this.environmentTexture.isRenderTarget&&this._renderTargets.pushNoDuplicate(this.environmentTexture);for(const y of this._gatherActiveCameraRenderTargetsStage)y.action(this._renderTargets);let g=!1;if(this.renderTargetsEnabled){if(this._intermediateRendering=!0,this._renderTargets.length>0){_t.StartPerformanceCounter("Render targets",this._renderTargets.length>0);for(let y=0;y<this._renderTargets.length;y++){const v=this._renderTargets.data[y];if(v._shouldRender()){this._renderId++;const w=v.activeCamera&&v.activeCamera!==this.activeCamera;v.render(w,this.dumpNextRenderTargets),g=!0}}_t.EndPerformanceCounter("Render targets",this._renderTargets.length>0),this._renderId++}for(const y of this._cameraDrawRenderTargetStage)g=y.action(this.activeCamera)||g;this._intermediateRendering=!1}this._engine.currentRenderPassId=a.outputRenderTarget?.renderPassId??a.renderPassId??0,g&&!this.prePass&&(this._bindFrameBuffer(this._activeCamera,!1),this.updateTransformMatrix()),this.onAfterRenderTargetsRenderObservable.notifyObservers(this),this.postProcessManager&&!a._multiviewTexture&&!this.prePass&&this.postProcessManager._prepareFrame();for(const y of this._beforeCameraDrawStage)y.action(this.activeCamera);this.onBeforeDrawPhaseObservable.notifyObservers(this),u.snapshotRendering&&u.snapshotRenderingMode===1&&this.finalizeSceneUbo(),this._renderingManager.render(null,null,!0,!0),this.onAfterDrawPhaseObservable.notifyObservers(this);for(const y of this._afterCameraDrawStage)y.action(this.activeCamera);if(this.postProcessManager&&!a._multiviewTexture){const y=a.outputRenderTarget?a.outputRenderTarget.renderTarget:void 0;this.postProcessManager._finalizeFrame(a.isIntermediate,y)}for(const y of this._afterCameraPostProcessStage)y.action(this.activeCamera);this._renderTargets.reset(),this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera)}_processSubCameras(a,x=!0){if(a.cameraRigMode===0||a._renderingMultiview){a._renderingMultiview&&!this._multiviewSceneUbo&&this._createMultiviewUbo(),this._renderForCamera(a,void 0,x),this.onAfterRenderCameraObservable.notifyObservers(a);return}if(a._useMultiviewToSingleView)this._renderMultiviewToSingleView(a);else{this.onBeforeCameraRenderObservable.notifyObservers(a);for(let c=0;c<a._rigCameras.length;c++)this._renderForCamera(a._rigCameras[c],a)}this._activeCamera=a,this.updateTransformMatrix(),this.onAfterRenderCameraObservable.notifyObservers(a)}_checkIntersections(){for(let a=0;a<this._meshesForIntersections.length;a++){const x=this._meshesForIntersections.data[a];if(x.actionManager)for(let c=0;x.actionManager&&c<x.actionManager.actions.length;c++){const u=x.actionManager.actions[c];if(u.trigger===12||u.trigger===13){const g=u.getTriggerParameter(),y=g.mesh?g.mesh:g,v=y.intersectsMesh(x,g.usePreciseIntersection),w=x._intersectionsInProgress.indexOf(y);v&&w===-1?u.trigger===12?(u._executeCurrent(to.CreateNew(x,void 0,y)),x._intersectionsInProgress.push(y)):u.trigger===13&&x._intersectionsInProgress.push(y):!v&&w>-1&&(u.trigger===13&&u._executeCurrent(to.CreateNew(x,void 0,y)),(!x.actionManager.hasSpecificTrigger(13,B=>{const W=B.mesh?B.mesh:B;return y===W})||u.trigger===13)&&x._intersectionsInProgress.splice(w,1))}}}}_advancePhysicsEngineStep(a){}_animate(a){}animate(){if(this._engine.isDeterministicLockStep()){let a=Math.max(H0.MinDeltaTime,Math.min(this._engine.getDeltaTime(),H0.MaxDeltaTime))+this._timeAccumulator;const x=this._engine.getTimeStep(),c=1e3/x/1e3;let u=0;const g=this._engine.getLockstepMaxSteps();let y=Math.floor(a/x);for(y=Math.min(y,g);a>0&&u<y;)this.onBeforeStepObservable.notifyObservers(this),this._animationRatio=x*c,this._animate(x),this.onAfterAnimationsObservable.notifyObservers(this),this.physicsEnabled&&this._advancePhysicsEngineStep(x),this.onAfterStepObservable.notifyObservers(this),this._currentStepId++,u++,a-=x;this._timeAccumulator=a<0?0:a}else{const a=this.useConstantAnimationDeltaTime?16:Math.max(H0.MinDeltaTime,Math.min(this._engine.getDeltaTime(),H0.MaxDeltaTime));this._animationRatio=a*(60/1e3),this._animate(),this.onAfterAnimationsObservable.notifyObservers(this),this.physicsEnabled&&this._advancePhysicsEngineStep(a)}}_clear(){(this.autoClearDepthAndStencil||this.autoClear)&&this._engine.clear(this.clearColor,this.autoClear||this.forceWireframe||this.forcePointsCloud,this.autoClearDepthAndStencil,this.autoClearDepthAndStencil)}_checkCameraRenderTarget(a){if(a?.outputRenderTarget&&!a?.isRigCamera&&(a.outputRenderTarget._cleared=!1),a?.rigCameras?.length)for(let x=0;x<a.rigCameras.length;++x){const c=a.rigCameras[x].outputRenderTarget;c&&(c._cleared=!1)}}resetDrawCache(a){if(this.meshes)for(const x of this.meshes)x.resetDrawCache(a)}render(a=!0,x=!1){if(this.isDisposed)return;this.onReadyObservable.hasObservers()&&this._executeWhenReadyTimeoutId===null&&this._checkIsReady(),this._frameId++,this._defaultFrameBufferCleared=!1,this._checkCameraRenderTarget(this.activeCamera),this.activeCameras?.length&&this.activeCameras.forEach(this._checkCameraRenderTarget),this._registerTransientComponents(),this._activeParticles.fetchNewFrame(),this._totalVertices.fetchNewFrame(),this._activeIndices.fetchNewFrame(),this._activeBones.fetchNewFrame(),this._meshesForIntersections.reset(),this.resetCachedMaterial(),this.onBeforeAnimationsObservable.notifyObservers(this),this.actionManager&&this.actionManager.processTrigger(11),x||this.animate();for(const g of this._beforeCameraUpdateStage)g.action();if(a){if(this.activeCameras&&this.activeCameras.length>0)for(let g=0;g<this.activeCameras.length;g++){const y=this.activeCameras[g];if(y.update(),y.cameraRigMode!==0)for(let v=0;v<y._rigCameras.length;v++)y._rigCameras[v].update()}else if(this.activeCamera&&(this.activeCamera.update(),this.activeCamera.cameraRigMode!==0))for(let g=0;g<this.activeCamera._rigCameras.length;g++)this.activeCamera._rigCameras[g].update()}this.onBeforeRenderObservable.notifyObservers(this);const c=this.getEngine();this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);const u=this.activeCameras?.length?this.activeCameras[0]:this.activeCamera;if(this.renderTargetsEnabled){_t.StartPerformanceCounter("Custom render targets",this.customRenderTargets.length>0),this._intermediateRendering=!0;for(let g=0;g<this.customRenderTargets.length;g++){const y=this.customRenderTargets[g];if(y._shouldRender()){if(this._renderId++,this.activeCamera=y.activeCamera||this.activeCamera,!this.activeCamera)throw new Error("Active camera not set");c.setViewport(this.activeCamera.viewport),this.updateTransformMatrix(),y.render(u!==this.activeCamera,this.dumpNextRenderTargets)}}_t.EndPerformanceCounter("Custom render targets",this.customRenderTargets.length>0),this._intermediateRendering=!1,this._renderId++}this._engine.currentRenderPassId=u?.renderPassId??0,this.activeCamera=u,this._activeCamera&&this._activeCamera.cameraRigMode!==22&&!this.prePass&&this._bindFrameBuffer(this._activeCamera,!1),this.onAfterRenderTargetsRenderObservable.notifyObservers(this);for(const g of this._beforeClearStage)g.action();this._clearFrameBuffer(this.activeCamera);for(const g of this._gatherRenderTargetsStage)g.action(this._renderTargets);if(this.activeCameras&&this.activeCameras.length>0)for(let g=0;g<this.activeCameras.length;g++)this._processSubCameras(this.activeCameras[g],g>0);else{if(!this.activeCamera)throw new Error("No camera defined");this._processSubCameras(this.activeCamera,!!this.activeCamera.outputRenderTarget)}this._checkIntersections();for(const g of this._afterRenderStage)g.action();if(this.afterRender&&this.afterRender(),this.onAfterRenderObservable.notifyObservers(this),this._toBeDisposed.length){for(let g=0;g<this._toBeDisposed.length;g++){const y=this._toBeDisposed[g];y&&y.dispose()}this._toBeDisposed.length=0}this.dumpNextRenderTargets&&(this.dumpNextRenderTargets=!1),this._activeBones.addCount(0,!0),this._activeIndices.addCount(0,!0),this._activeParticles.addCount(0,!0),this._engine.restoreDefaultFramebuffer()}freezeMaterials(){for(let a=0;a<this.materials.length;a++)this.materials[a].freeze()}unfreezeMaterials(){for(let a=0;a<this.materials.length;a++)this.materials[a].unfreeze()}dispose(){if(this.isDisposed)return;this.beforeRender=null,this.afterRender=null,this.metadata=null,this.skeletons.length=0,this.morphTargetManagers.length=0,this._transientComponents.length=0,this._isReadyForMeshStage.clear(),this._beforeEvaluateActiveMeshStage.clear(),this._evaluateSubMeshStage.clear(),this._preActiveMeshStage.clear(),this._cameraDrawRenderTargetStage.clear(),this._beforeCameraDrawStage.clear(),this._beforeRenderTargetDrawStage.clear(),this._beforeRenderingGroupDrawStage.clear(),this._beforeRenderingMeshStage.clear(),this._afterRenderingMeshStage.clear(),this._afterRenderingGroupDrawStage.clear(),this._afterCameraDrawStage.clear(),this._afterRenderTargetDrawStage.clear(),this._afterRenderStage.clear(),this._beforeCameraUpdateStage.clear(),this._beforeClearStage.clear(),this._gatherRenderTargetsStage.clear(),this._gatherActiveCameraRenderTargetsStage.clear(),this._pointerMoveStage.clear(),this._pointerDownStage.clear(),this._pointerUpStage.clear(),this.importedMeshesFiles=[],this.stopAllAnimations&&(this._activeAnimatables.forEach(g=>{g.onAnimationEndObservable.clear(),g.onAnimationEnd=null}),this.stopAllAnimations()),this.resetCachedMaterial(),this.activeCamera&&(this.activeCamera._activeMeshes.dispose(),this.activeCamera=null),this.activeCameras=null,this._activeMeshes.dispose(),this._renderingManager.dispose(),this._processedMaterials.dispose(),this._activeParticleSystems.dispose(),this._activeSkeletons.dispose(),this._softwareSkinnedMeshes.dispose(),this._renderTargets.dispose(),this._materialsRenderTargets.dispose(),this._registeredForLateAnimationBindings.dispose(),this._meshesForIntersections.dispose(),this._toBeDisposed.length=0;const a=this._activeRequests.slice();for(const g of a)g.abort();this._activeRequests.length=0;try{this.onDisposeObservable.notifyObservers(this)}catch(g){Qt.Error("An error occurred while calling onDisposeObservable!",g)}if(this.detachControl(),this._engine.getInputElement())for(let g=0;g<this.cameras.length;g++)this.cameras[g].detachControl();this._disposeList(this.animationGroups),this._disposeList(this.lights),this._disposeList(this.meshes,g=>g.dispose(!0)),this._disposeList(this.transformNodes,g=>g.dispose(!0));const c=this.cameras;this._disposeList(c),this._defaultMaterial&&this._defaultMaterial.dispose(),this._disposeList(this.multiMaterials),this._disposeList(this.materials),this._disposeList(this.particleSystems),this._disposeList(this.postProcesses),this._disposeList(this.textures),this._disposeList(this.morphTargetManagers),this._sceneUbo.dispose(),this._multiviewSceneUbo&&this._multiviewSceneUbo.dispose(),this.postProcessManager.dispose(),this._disposeList(this._components);let u=this._engine.scenes.indexOf(this);u>-1&&this._engine.scenes.splice(u,1),tr._LastCreatedScene===this&&(this._engine.scenes.length>0?tr._LastCreatedScene=this._engine.scenes[this._engine.scenes.length-1]:tr._LastCreatedScene=null),u=this._engine._virtualScenes.indexOf(this),u>-1&&this._engine._virtualScenes.splice(u,1),this._engine.wipeCaches(!0),this.onDisposeObservable.clear(),this.onBeforeRenderObservable.clear(),this.onAfterRenderObservable.clear(),this.onBeforeRenderTargetsRenderObservable.clear(),this.onAfterRenderTargetsRenderObservable.clear(),this.onAfterStepObservable.clear(),this.onBeforeStepObservable.clear(),this.onBeforeActiveMeshesEvaluationObservable.clear(),this.onAfterActiveMeshesEvaluationObservable.clear(),this.onBeforeParticlesRenderingObservable.clear(),this.onAfterParticlesRenderingObservable.clear(),this.onBeforeDrawPhaseObservable.clear(),this.onAfterDrawPhaseObservable.clear(),this.onBeforeAnimationsObservable.clear(),this.onAfterAnimationsObservable.clear(),this.onDataLoadedObservable.clear(),this.onBeforeRenderingGroupObservable.clear(),this.onAfterRenderingGroupObservable.clear(),this.onMeshImportedObservable.clear(),this.onBeforeCameraRenderObservable.clear(),this.onAfterCameraRenderObservable.clear(),this.onAfterRenderCameraObservable.clear(),this.onReadyObservable.clear(),this.onNewCameraAddedObservable.clear(),this.onCameraRemovedObservable.clear(),this.onNewLightAddedObservable.clear(),this.onLightRemovedObservable.clear(),this.onNewGeometryAddedObservable.clear(),this.onGeometryRemovedObservable.clear(),this.onNewTransformNodeAddedObservable.clear(),this.onTransformNodeRemovedObservable.clear(),this.onNewMeshAddedObservable.clear(),this.onMeshRemovedObservable.clear(),this.onNewSkeletonAddedObservable.clear(),this.onSkeletonRemovedObservable.clear(),this.onNewMaterialAddedObservable.clear(),this.onNewMultiMaterialAddedObservable.clear(),this.onMaterialRemovedObservable.clear(),this.onMultiMaterialRemovedObservable.clear(),this.onNewTextureAddedObservable.clear(),this.onTextureRemovedObservable.clear(),this.onPrePointerObservable.clear(),this.onPointerObservable.clear(),this.onPreKeyboardObservable.clear(),this.onKeyboardObservable.clear(),this.onActiveCameraChanged.clear(),this.onScenePerformancePriorityChangedObservable.clear(),this._isDisposed=!0}_disposeList(a,x){const c=a.slice(0);x=x??(u=>u.dispose());for(const u of c)x(u);a.length=0}get isDisposed(){return this._isDisposed}clearCachedVertexData(){for(let a=0;a<this.meshes.length;a++){const c=this.meshes[a].geometry;c&&c.clearCachedData()}}cleanCachedTextureBuffer(){for(const a of this.textures)a._buffer&&(a._buffer=null)}getWorldExtends(a){const x=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),c=new Ee(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return a=a||(()=>!0),this.meshes.filter(a).forEach(u=>{if(u.computeWorldMatrix(!0),!u.subMeshes||u.subMeshes.length===0||u.infiniteDistance)return;const g=u.getBoundingInfo(),y=g.boundingBox.minimumWorld,v=g.boundingBox.maximumWorld;Ee.CheckExtends(y,x,c),Ee.CheckExtends(v,x,c)}),{min:x,max:c}}createPickingRay(a,x,c,u,g=!1){throw js("Ray")}createPickingRayToRef(a,x,c,u,g,y=!1,v=!1){throw js("Ray")}createPickingRayInCameraSpace(a,x,c){throw js("Ray")}createPickingRayInCameraSpaceToRef(a,x,c,u){throw js("Ray")}get _pickingAvailable(){return!1}pick(a,x,c,u,g,y){const v=js("Ray",!0);return v&&Qt.Warn(v),new am}pickWithBoundingInfo(a,x,c,u,g){const y=js("Ray",!0);return y&&Qt.Warn(y),new am}pickWithRay(a,x,c,u){throw js("Ray")}multiPick(a,x,c,u,g){throw js("Ray")}multiPickWithRay(a,x,c){throw js("Ray")}setPointerOverMesh(a,x,c){this._inputManager.setPointerOverMesh(a,x,c)}getPointerOverMesh(){return this._inputManager.getPointerOverMesh()}_rebuildGeometries(){for(const a of this.geometries)a._rebuild();for(const a of this.meshes)a._rebuild();this.postProcessManager&&this.postProcessManager._rebuild();for(const a of this._components)a.rebuild();for(const a of this.particleSystems)a.rebuild();if(this.spriteManagers)for(const a of this.spriteManagers)a.rebuild()}_rebuildTextures(){for(const a of this.textures)a._rebuild(!0);this.markAllMaterialsAsDirty(1)}_getByTags(a,x,c){if(x===void 0)return a;const u=[];for(const g in a){const y=a[g];Vt&&Vt.MatchesQuery(y,x)&&(!c||c(y))&&u.push(y)}return u}getMeshesByTags(a,x){return this._getByTags(this.meshes,a,x)}getCamerasByTags(a,x){return this._getByTags(this.cameras,a,x)}getLightsByTags(a,x){return this._getByTags(this.lights,a,x)}getMaterialByTags(a,x){return this._getByTags(this.materials,a,x).concat(this._getByTags(this.multiMaterials,a,x))}getTransformNodesByTags(a,x){return this._getByTags(this.transformNodes,a,x)}setRenderingOrder(a,x=null,c=null,u=null){this._renderingManager.setRenderingOrder(a,x,c,u)}setRenderingAutoClearDepthStencil(a,x,c=!0,u=!0){this._renderingManager.setRenderingAutoClearDepthStencil(a,x,c,u)}getAutoClearDepthStencilSetup(a){return this._renderingManager.getAutoClearDepthStencilSetup(a)}_forceBlockMaterialDirtyMechanism(a){this._blockMaterialDirtyMechanism=a}get blockMaterialDirtyMechanism(){return this._blockMaterialDirtyMechanism}set blockMaterialDirtyMechanism(a){this._blockMaterialDirtyMechanism!==a&&(this._blockMaterialDirtyMechanism=a,a||this.markAllMaterialsAsDirty(63))}markAllMaterialsAsDirty(a,x){if(!this._blockMaterialDirtyMechanism)for(const c of this.materials)x&&!x(c)||c.markAsDirty(a)}_loadFile(a,x,c,u,g,y,v){const w=fx(a,x,c,u?this.offlineProvider:void 0,g,y,v);return this._activeRequests.push(w),w.onCompleteObservable.add(B=>{this._activeRequests.splice(this._activeRequests.indexOf(B),1)}),w}_loadFileAsync(a,x,c,u,g){return new Promise((y,v)=>{this._loadFile(a,w=>{y(w)},x,c,u,(w,B)=>{v(B)},g)})}_requestFile(a,x,c,u,g,y,v){const w=X2(a,x,c,u?this.offlineProvider:void 0,g,y,v);return this._activeRequests.push(w),w.onCompleteObservable.add(B=>{this._activeRequests.splice(this._activeRequests.indexOf(B),1)}),w}_requestFileAsync(a,x,c,u,g){return new Promise((y,v)=>{this._requestFile(a,w=>{y(w)},x,c,u,w=>{v(w)},g)})}_readFile(a,x,c,u,g){const y=yl(a,x,c,u,g);return this._activeRequests.push(y),y.onCompleteObservable.add(v=>{this._activeRequests.splice(this._activeRequests.indexOf(v),1)}),y}_readFileAsync(a,x,c){return new Promise((u,g)=>{this._readFile(a,y=>{u(y)},x,c,y=>{g(y)})})}getPerfCollector(){throw js("performanceViewerSceneExtension")}setActiveCameraByID(a){return this.setActiveCameraById(a)}getMaterialByID(a){return this.getMaterialById(a)}getLastMaterialByID(a){return this.getLastMaterialById(a)}getTextureByUniqueID(a){return this.getTextureByUniqueId(a)}getCameraByID(a){return this.getCameraById(a)}getCameraByUniqueID(a){return this.getCameraByUniqueId(a)}getBoneByID(a){return this.getBoneById(a)}getLightByID(a){return this.getLightById(a)}getLightByUniqueID(a){return this.getLightByUniqueId(a)}getParticleSystemByID(a){return this.getParticleSystemById(a)}getGeometryByID(a){return this.getGeometryById(a)}getMeshByID(a){return this.getMeshById(a)}getMeshByUniqueID(a){return this.getMeshByUniqueId(a)}getLastMeshByID(a){return this.getLastMeshById(a)}getMeshesByID(a){return this.getMeshesById(a)}getTransformNodeByID(a){return this.getTransformNodeById(a)}getTransformNodeByUniqueID(a){return this.getTransformNodeByUniqueId(a)}getTransformNodesByID(a){return this.getTransformNodesById(a)}getNodeByID(a){return this.getNodeById(a)}getLastEntryByID(a){return this.getLastEntryById(a)}getLastSkeletonByID(a){return this.getLastSkeletonById(a)}}H0.FOGMODE_NONE=0,H0.FOGMODE_EXP=1,H0.FOGMODE_EXP2=2,H0.FOGMODE_LINEAR=3,H0.MinDeltaTime=1,H0.MaxDeltaTime=1e3;class WP{constructor(){this._doNotSerialize=!1,this._isDisposed=!1,this._sceneRootNodesIndex=-1,this._isEnabled=!0,this._isParentEnabled=!0,this._isReady=!0,this._onEnabledStateChangedObservable=new Jt,this._onClonedObservable=new Jt}}class fa{static AddNodeConstructor(a,x){this._NodeConstructors[a]=x}static Construct(a,x,c,u){const g=this._NodeConstructors[a];return g?g(x,c,u):null}set accessibilityTag(a){this._accessibilityTag=a,this.onAccessibilityTagChangedObservable.notifyObservers(a)}get accessibilityTag(){return this._accessibilityTag}get doNotSerialize(){return this._nodeDataStorage._doNotSerialize?!0:this._parentNode?this._parentNode.doNotSerialize:!1}set doNotSerialize(a){this._nodeDataStorage._doNotSerialize=a}isDisposed(){return this._nodeDataStorage._isDisposed}set parent(a){if(this._parentNode===a)return;const x=this._parentNode;if(this._parentNode&&this._parentNode._children!==void 0&&this._parentNode._children!==null){const c=this._parentNode._children.indexOf(this);c!==-1&&this._parentNode._children.splice(c,1),!a&&!this._nodeDataStorage._isDisposed&&this._addToSceneRootNodes()}this._parentNode=a,this._parentNode&&((this._parentNode._children===void 0||this._parentNode._children===null)&&(this._parentNode._children=new Array),this._parentNode._children.push(this),x||this._removeFromSceneRootNodes()),this._syncParentEnabledState()}get parent(){return this._parentNode}_serializeAsParent(a){a.parentId=this.uniqueId}_addToSceneRootNodes(){this._nodeDataStorage._sceneRootNodesIndex===-1&&(this._nodeDataStorage._sceneRootNodesIndex=this._scene.rootNodes.length,this._scene.rootNodes.push(this))}_removeFromSceneRootNodes(){if(this._nodeDataStorage._sceneRootNodesIndex!==-1){const a=this._scene.rootNodes,x=a.length-1;a[this._nodeDataStorage._sceneRootNodesIndex]=a[x],a[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex=this._nodeDataStorage._sceneRootNodesIndex,this._scene.rootNodes.pop(),this._nodeDataStorage._sceneRootNodesIndex=-1}}get animationPropertiesOverride(){return this._animationPropertiesOverride?this._animationPropertiesOverride:this._scene.animationPropertiesOverride}set animationPropertiesOverride(a){this._animationPropertiesOverride=a}getClassName(){return"Node"}set onDispose(a){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(a)}get onEnabledStateChangedObservable(){return this._nodeDataStorage._onEnabledStateChangedObservable}get onClonedObservable(){return this._nodeDataStorage._onClonedObservable}constructor(a,x=null){this._isDirty=!1,this._nodeDataStorage=new WP,this.state="",this.metadata=null,this.reservedDataStore=null,this._accessibilityTag=null,this.onAccessibilityTagChangedObservable=new Jt,this._parentContainer=null,this.animations=[],this._ranges={},this.onReady=null,this._currentRenderId=-1,this._parentUpdateId=-1,this._childUpdateId=-1,this._waitingParentId=null,this._waitingParentInstanceIndex=null,this._waitingParsedUniqueId=null,this._cache={},this._parentNode=null,this._children=null,this._worldMatrix=vt.Identity(),this._worldMatrixDeterminant=0,this._worldMatrixDeterminantIsDirty=!0,this._animationPropertiesOverride=null,this._isNode=!0,this.onDisposeObservable=new Jt,this._onDisposeObserver=null,this._behaviors=new Array,this.name=a,this.id=a,this._scene=x||tr.LastCreatedScene,this.uniqueId=this._scene.getUniqueId(),this._initCache()}getScene(){return this._scene}getEngine(){return this._scene.getEngine()}addBehavior(a,x=!1){return this._behaviors.indexOf(a)!==-1?this:(a.init(),this._scene.isLoading&&!x?this._scene.onDataLoadedObservable.addOnce(()=>{a.attach(this)}):a.attach(this),this._behaviors.push(a),this)}removeBehavior(a){const x=this._behaviors.indexOf(a);return x===-1?this:(this._behaviors[x].detach(),this._behaviors.splice(x,1),this)}get behaviors(){return this._behaviors}getBehaviorByName(a){for(const x of this._behaviors)if(x.name===a)return x;return null}getWorldMatrix(){return this._currentRenderId!==this._scene.getRenderId()&&this.computeWorldMatrix(),this._worldMatrix}_getWorldMatrixDeterminant(){return this._worldMatrixDeterminantIsDirty&&(this._worldMatrixDeterminantIsDirty=!1,this._worldMatrixDeterminant=this._worldMatrix.determinant()),this._worldMatrixDeterminant}get worldMatrixFromCache(){return this._worldMatrix}_initCache(){this._cache={},this._cache.parent=void 0}updateCache(a){!a&&this.isSynchronized()||(this._cache.parent=this.parent,this._updateCache())}_getActionManagerForTrigger(a,x=!0){return this.parent?this.parent._getActionManagerForTrigger(a,!1):null}_updateCache(a){}_isSynchronized(){return!0}_markSyncedWithParent(){this._parentNode&&(this._parentUpdateId=this._parentNode._childUpdateId)}isSynchronizedWithParent(){return this._parentNode?this._parentNode._isDirty||this._parentUpdateId!==this._parentNode._childUpdateId?!1:this._parentNode.isSynchronized():!0}isSynchronized(){return this._cache.parent!==this._parentNode?(this._cache.parent=this._parentNode,!1):this._parentNode&&!this.isSynchronizedWithParent()?!1:this._isSynchronized()}isReady(a=!1){return this._nodeDataStorage._isReady}markAsDirty(a){return this._currentRenderId=Number.MAX_VALUE,this._isDirty=!0,this}isEnabled(a=!0){return a===!1?this._nodeDataStorage._isEnabled:this._nodeDataStorage._isEnabled?this._nodeDataStorage._isParentEnabled:!1}_syncParentEnabledState(){this._nodeDataStorage._isParentEnabled=this._parentNode?this._parentNode.isEnabled():!0,this._children&&this._children.forEach(a=>{a._syncParentEnabledState()})}setEnabled(a){this._nodeDataStorage._isEnabled!==a&&(this._nodeDataStorage._isEnabled=a,this._syncParentEnabledState(),this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(a))}isDescendantOf(a){return this.parent?this.parent===a?!0:this.parent.isDescendantOf(a):!1}_getDescendants(a,x=!1,c){if(this._children)for(let u=0;u<this._children.length;u++){const g=this._children[u];(!c||c(g))&&a.push(g),x||g._getDescendants(a,!1,c)}}getDescendants(a,x){const c=[];return this._getDescendants(c,a,x),c}getChildMeshes(a,x){const c=[];return this._getDescendants(c,a,u=>(!x||x(u))&&u.cullingStrategy!==void 0),c}getChildren(a,x=!0){return this.getDescendants(x,a)}_setReady(a){if(a!==this._nodeDataStorage._isReady){if(!a){this._nodeDataStorage._isReady=!1;return}this.onReady&&this.onReady(this),this._nodeDataStorage._isReady=!0}}getAnimationByName(a){for(let x=0;x<this.animations.length;x++){const c=this.animations[x];if(c.name===a)return c}return null}createAnimationRange(a,x,c){if(!this._ranges[a]){this._ranges[a]=fa._AnimationRangeFactory(a,x,c);for(let u=0,g=this.animations.length;u<g;u++)this.animations[u]&&this.animations[u].createRange(a,x,c)}}deleteAnimationRange(a,x=!0){for(let c=0,u=this.animations.length;c<u;c++)this.animations[c]&&this.animations[c].deleteRange(a,x);this._ranges[a]=null}getAnimationRange(a){return this._ranges[a]||null}clone(a,x,c){const u=hr.Clone(()=>new fa(a,this.getScene()),this);if(x&&(u.parent=x),!c){const g=this.getDescendants(!0);for(let y=0;y<g.length;y++){const v=g[y];v.clone(a+"."+v.name,u)}}return u}getAnimationRanges(){const a=[];let x;for(x in this._ranges)a.push(this._ranges[x]);return a}beginAnimation(a,x,c,u){const g=this.getAnimationRange(a);return g?this._scene.beginAnimation(this,g.from,g.to,x,c,u):null}serializeAnimationRanges(){const a=[];for(const x in this._ranges){const c=this._ranges[x];if(!c)continue;const u={};u.name=x,u.from=c.from,u.to=c.to,a.push(u)}return a}computeWorldMatrix(a){return this._worldMatrix||(this._worldMatrix=vt.Identity()),this._worldMatrix}dispose(a,x=!1){if(this._nodeDataStorage._isDisposed=!0,!a){const c=this.getDescendants(!0);for(const u of c)u.dispose(a,x)}this.parent?this.parent=null:this._removeFromSceneRootNodes(),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onEnabledStateChangedObservable.clear(),this.onClonedObservable.clear();for(const c of this._behaviors)c.detach();this._behaviors.length=0,this.metadata=null}static ParseAnimationRanges(a,x,c){if(x.ranges)for(let u=0;u<x.ranges.length;u++){const g=x.ranges[u];a.createAnimationRange(g.name,g.from,g.to)}}getHierarchyBoundingVectors(a=!0,x=null){this.getScene().incrementRenderId(),this.computeWorldMatrix(!0);let c,u;const g=this;if(g.getBoundingInfo&&g.subMeshes){const y=g.getBoundingInfo();c=y.boundingBox.minimumWorld.clone(),u=y.boundingBox.maximumWorld.clone()}else c=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),u=new Ee(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);if(a){const y=this.getDescendants(!1);for(const v of y){const w=v;if(w.computeWorldMatrix(!0),x&&!x(w)||!w.getBoundingInfo||w.getTotalVertices()===0)continue;const W=w.getBoundingInfo().boundingBox,ae=W.minimumWorld,ue=W.maximumWorld;Ee.CheckExtends(ae,c,u),Ee.CheckExtends(ue,c,u)}}return{min:c,max:u}}}fa._AnimationRangeFactory=(F,a,x)=>{throw js("AnimationRange")},fa._NodeConstructors={},Ye([ht()],fa.prototype,"name",void 0),Ye([ht()],fa.prototype,"id",void 0),Ye([ht()],fa.prototype,"uniqueId",void 0),Ye([ht()],fa.prototype,"state",void 0),Ye([ht()],fa.prototype,"metadata",void 0);class xm{constructor(a,x,c,u){this.x=a,this.y=x,this.width=c,this.height=u}toGlobal(a,x){return new xm(this.x*a,this.y*x,this.width*a,this.height*x)}toGlobalToRef(a,x,c){return c.x=this.x*a,c.y=this.y*x,c.width=this.width*a,c.height=this.height*x,this}clone(){return new xm(this.x,this.y,this.width,this.height)}}class gr extends fa{get position(){return this._position}set position(a){this._position=a}set upVector(a){this._upVector=a}get upVector(){return this._upVector}get screenArea(){let a=0,x=0;if(this.mode===gr.PERSPECTIVE_CAMERA)this.fovMode===gr.FOVMODE_VERTICAL_FIXED?(x=this.minZ*2*Math.tan(this.fov/2),a=this.getEngine().getAspectRatio(this)*x):(a=this.minZ*2*Math.tan(this.fov/2),x=a/this.getEngine().getAspectRatio(this));else{const c=this.getEngine().getRenderWidth()/2,u=this.getEngine().getRenderHeight()/2;a=(this.orthoRight??c)-(this.orthoLeft??-c),x=(this.orthoTop??u)-(this.orthoBottom??-u)}return a*x}set orthoLeft(a){this._orthoLeft=a;for(const x of this._rigCameras)x.orthoLeft=a}get orthoLeft(){return this._orthoLeft}set orthoRight(a){this._orthoRight=a;for(const x of this._rigCameras)x.orthoRight=a}get orthoRight(){return this._orthoRight}set orthoBottom(a){this._orthoBottom=a;for(const x of this._rigCameras)x.orthoBottom=a}get orthoBottom(){return this._orthoBottom}set orthoTop(a){this._orthoTop=a;for(const x of this._rigCameras)x.orthoTop=a}get orthoTop(){return this._orthoTop}set mode(a){this._mode=a;for(const x of this._rigCameras)x.mode=a}get mode(){return this._mode}get hasMoved(){return this._hasMoved}constructor(a,x,c,u=!0){super(a,c),this._position=Ee.Zero(),this._upVector=Ee.Up(),this.oblique=null,this._orthoLeft=null,this._orthoRight=null,this._orthoBottom=null,this._orthoTop=null,this.fov=.8,this.projectionPlaneTilt=0,this.minZ=1,this.maxZ=1e4,this.inertia=.9,this._mode=gr.PERSPECTIVE_CAMERA,this.isIntermediate=!1,this.viewport=new xm(0,0,1,1),this.layerMask=268435455,this.fovMode=gr.FOVMODE_VERTICAL_FIXED,this.cameraRigMode=gr.RIG_MODE_NONE,this.customRenderTargets=[],this.outputRenderTarget=null,this.onViewMatrixChangedObservable=new Jt,this.onProjectionMatrixChangedObservable=new Jt,this.onAfterCheckInputsObservable=new Jt,this.onRestoreStateObservable=new Jt,this.isRigCamera=!1,this._hasMoved=!1,this._rigCameras=new Array,this._skipRendering=!1,this._projectionMatrix=new vt,this._postProcesses=new Array,this._activeMeshes=new lt(256),this._globalPosition=Ee.Zero(),this._computedViewMatrix=vt.Identity(),this._doNotComputeProjectionMatrix=!1,this._transformMatrix=vt.Zero(),this._refreshFrustumPlanes=!0,this._absoluteRotation=Wi.Identity(),this._isCamera=!0,this._isLeftCamera=!1,this._isRightCamera=!1,this.getScene().addCamera(this),u&&!this.getScene().activeCamera&&(this.getScene().activeCamera=this),this.position=x,this.renderPassId=this.getScene().getEngine().createRenderPassId(`Camera ${a}`)}storeState(){return this._stateStored=!0,this._storedFov=this.fov,this}_restoreStateValues(){return this._stateStored?(this.fov=this._storedFov,!0):!1}restoreState(){return this._restoreStateValues()?(this.onRestoreStateObservable.notifyObservers(this),!0):!1}getClassName(){return"Camera"}toString(a){let x="Name: "+this.name;if(x+=", type: "+this.getClassName(),this.animations)for(let c=0;c<this.animations.length;c++)x+=", animation[0]: "+this.animations[c].toString(a);return x}applyVerticalCorrection(){const a=this.absoluteRotation.toEulerAngles();this.projectionPlaneTilt=this._scene.useRightHandedSystem?-a.x:a.x}get globalPosition(){return this._globalPosition}getActiveMeshes(){return this._activeMeshes}isActiveMesh(a){return this._activeMeshes.indexOf(a)!==-1}isReady(a=!1){if(a){for(const x of this._postProcesses)if(x&&!x.isReady())return!1}return super.isReady(a)}_initCache(){super._initCache(),this._cache.position=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.upVector=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.mode=void 0,this._cache.minZ=void 0,this._cache.maxZ=void 0,this._cache.fov=void 0,this._cache.fovMode=void 0,this._cache.aspectRatio=void 0,this._cache.orthoLeft=void 0,this._cache.orthoRight=void 0,this._cache.orthoBottom=void 0,this._cache.orthoTop=void 0,this._cache.obliqueAngle=void 0,this._cache.obliqueLength=void 0,this._cache.obliqueOffset=void 0,this._cache.renderWidth=void 0,this._cache.renderHeight=void 0}_updateCache(a){a||super._updateCache(),this._cache.position.copyFrom(this.position),this._cache.upVector.copyFrom(this.upVector)}_isSynchronized(){return this._isSynchronizedViewMatrix()&&this._isSynchronizedProjectionMatrix()}_isSynchronizedViewMatrix(){return super._isSynchronized()?this._cache.position.equals(this.position)&&this._cache.upVector.equals(this.upVector)&&this.isSynchronizedWithParent():!1}_isSynchronizedProjectionMatrix(){let a=this._cache.mode===this.mode&&this._cache.minZ===this.minZ&&this._cache.maxZ===this.maxZ;if(!a)return!1;const x=this.getEngine();return this.mode===gr.PERSPECTIVE_CAMERA?a=this._cache.fov===this.fov&&this._cache.fovMode===this.fovMode&&this._cache.aspectRatio===x.getAspectRatio(this)&&this._cache.projectionPlaneTilt===this.projectionPlaneTilt:(a=this._cache.orthoLeft===this.orthoLeft&&this._cache.orthoRight===this.orthoRight&&this._cache.orthoBottom===this.orthoBottom&&this._cache.orthoTop===this.orthoTop&&this._cache.renderWidth===x.getRenderWidth()&&this._cache.renderHeight===x.getRenderHeight(),this.oblique&&(a=a&&this._cache.obliqueAngle===this.oblique.angle&&this._cache.obliqueLength===this.oblique.length&&this._cache.obliqueOffset===this.oblique.offset)),a}attachControl(a,x){}detachControl(a){}update(){this._hasMoved=!1,this._checkInputs(),this.cameraRigMode!==gr.RIG_MODE_NONE&&this._updateRigCameras(),this.getViewMatrix(),this.getProjectionMatrix()}_checkInputs(){this.onAfterCheckInputsObservable.notifyObservers(this)}get rigCameras(){return this._rigCameras}get rigPostProcess(){return this._rigPostProcess}_getFirstPostProcess(){for(let a=0;a<this._postProcesses.length;a++)if(this._postProcesses[a]!==null)return this._postProcesses[a];return null}_cascadePostProcessesToRigCams(){const a=this._getFirstPostProcess();a&&a.markTextureDirty();for(let x=0,c=this._rigCameras.length;x<c;x++){const u=this._rigCameras[x],g=u._rigPostProcess;g?(g.getEffectName()==="pass"&&(u.isIntermediate=this._postProcesses.length===0),u._postProcesses=this._postProcesses.slice(0).concat(g),g.markTextureDirty()):u._postProcesses=this._postProcesses.slice(0)}}attachPostProcess(a,x=null){return!a.isReusable()&&this._postProcesses.indexOf(a)>-1?(Qt.Error("You're trying to reuse a post process not defined as reusable."),0):(x==null||x<0?this._postProcesses.push(a):this._postProcesses[x]===null?this._postProcesses[x]=a:this._postProcesses.splice(x,0,a),this._cascadePostProcessesToRigCams(),this._scene.prePassRenderer&&this._scene.prePassRenderer.markAsDirty(),this._postProcesses.indexOf(a))}detachPostProcess(a){const x=this._postProcesses.indexOf(a);x!==-1&&(this._postProcesses[x]=null),this._scene.prePassRenderer&&this._scene.prePassRenderer.markAsDirty(),this._cascadePostProcessesToRigCams()}getWorldMatrix(){return this._isSynchronizedViewMatrix()?this._worldMatrix:(this.getViewMatrix(),this._worldMatrix)}_getViewMatrix(){return vt.Identity()}getViewMatrix(a){return!a&&this._isSynchronizedViewMatrix()?this._computedViewMatrix:(this._hasMoved=!0,this.updateCache(),this._computedViewMatrix=this._getViewMatrix(),this._currentRenderId=this.getScene().getRenderId(),this._childUpdateId++,this._refreshFrustumPlanes=!0,this._cameraRigParams&&this._cameraRigParams.vrPreViewMatrix&&this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix,this._computedViewMatrix),this.parent&&this.parent.onViewMatrixChangedObservable&&this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent),this.onViewMatrixChangedObservable.notifyObservers(this),this._computedViewMatrix.invertToRef(this._worldMatrix),this._computedViewMatrix)}freezeProjectionMatrix(a){this._doNotComputeProjectionMatrix=!0,a!==void 0&&(this._projectionMatrix=a)}unfreezeProjectionMatrix(){this._doNotComputeProjectionMatrix=!1}getProjectionMatrix(a){if(this._doNotComputeProjectionMatrix||!a&&this._isSynchronizedProjectionMatrix())return this._projectionMatrix;this._cache.mode=this.mode,this._cache.minZ=this.minZ,this._cache.maxZ=this.maxZ,this._refreshFrustumPlanes=!0;const x=this.getEngine(),c=this.getScene(),u=x.useReverseDepthBuffer;if(this.mode===gr.PERSPECTIVE_CAMERA){this._cache.fov=this.fov,this._cache.fovMode=this.fovMode,this._cache.aspectRatio=x.getAspectRatio(this),this._cache.projectionPlaneTilt=this.projectionPlaneTilt,this.minZ<=0&&(this.minZ=.1);let g;c.useRightHandedSystem?g=vt.PerspectiveFovRHToRef:g=vt.PerspectiveFovLHToRef,g(this.fov,x.getAspectRatio(this),u?this.maxZ:this.minZ,u?this.minZ:this.maxZ,this._projectionMatrix,this.fovMode===gr.FOVMODE_VERTICAL_FIXED,x.isNDCHalfZRange,this.projectionPlaneTilt,u)}else{const g=x.getRenderWidth()/2,y=x.getRenderHeight()/2;c.useRightHandedSystem?this.oblique?vt.ObliqueOffCenterRHToRef(this.orthoLeft??-g,this.orthoRight??g,this.orthoBottom??-y,this.orthoTop??y,u?this.maxZ:this.minZ,u?this.minZ:this.maxZ,this.oblique.length,this.oblique.angle,this._computeObliqueDistance(this.oblique.offset),this._projectionMatrix,x.isNDCHalfZRange):vt.OrthoOffCenterRHToRef(this.orthoLeft??-g,this.orthoRight??g,this.orthoBottom??-y,this.orthoTop??y,u?this.maxZ:this.minZ,u?this.minZ:this.maxZ,this._projectionMatrix,x.isNDCHalfZRange):this.oblique?vt.ObliqueOffCenterLHToRef(this.orthoLeft??-g,this.orthoRight??g,this.orthoBottom??-y,this.orthoTop??y,u?this.maxZ:this.minZ,u?this.minZ:this.maxZ,this.oblique.length,this.oblique.angle,this._computeObliqueDistance(this.oblique.offset),this._projectionMatrix,x.isNDCHalfZRange):vt.OrthoOffCenterLHToRef(this.orthoLeft??-g,this.orthoRight??g,this.orthoBottom??-y,this.orthoTop??y,u?this.maxZ:this.minZ,u?this.minZ:this.maxZ,this._projectionMatrix,x.isNDCHalfZRange),this._cache.orthoLeft=this.orthoLeft,this._cache.orthoRight=this.orthoRight,this._cache.orthoBottom=this.orthoBottom,this._cache.orthoTop=this.orthoTop,this._cache.obliqueAngle=this.oblique?.angle,this._cache.obliqueLength=this.oblique?.length,this._cache.obliqueOffset=this.oblique?.offset,this._cache.renderWidth=x.getRenderWidth(),this._cache.renderHeight=x.getRenderHeight()}return this.onProjectionMatrixChangedObservable.notifyObservers(this),this._projectionMatrix}getTransformationMatrix(){return this._computedViewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix),this._transformMatrix}_computeObliqueDistance(a){const x=this,c=this;return(x.radius||(c.target?Ee.Distance(this.position,c.target):this.position.length()))+a}_updateFrustumPlanes(){this._refreshFrustumPlanes&&(this.getTransformationMatrix(),this._frustumPlanes?xl.GetPlanesToRef(this._transformMatrix,this._frustumPlanes):this._frustumPlanes=xl.GetPlanes(this._transformMatrix),this._refreshFrustumPlanes=!1)}isInFrustum(a,x=!1){if(this._updateFrustumPlanes(),x&&this.rigCameras.length>0){let c=!1;return this.rigCameras.forEach(u=>{u._updateFrustumPlanes(),c=c||a.isInFrustum(u._frustumPlanes)}),c}else return a.isInFrustum(this._frustumPlanes)}isCompletelyInFrustum(a){return this._updateFrustumPlanes(),a.isCompletelyInFrustum(this._frustumPlanes)}getForwardRay(a=100,x,c){throw js("Ray")}getForwardRayToRef(a,x=100,c,u){throw js("Ray")}dispose(a,x=!1){for(this.onViewMatrixChangedObservable.clear(),this.onProjectionMatrixChangedObservable.clear(),this.onAfterCheckInputsObservable.clear(),this.onRestoreStateObservable.clear(),this.inputs&&this.inputs.clear(),this.getScene().stopAnimation(this),this.getScene().removeCamera(this);this._rigCameras.length>0;){const u=this._rigCameras.pop();u&&u.dispose()}if(this._parentContainer){const u=this._parentContainer.cameras.indexOf(this);u>-1&&this._parentContainer.cameras.splice(u,1),this._parentContainer=null}if(this._rigPostProcess)this._rigPostProcess.dispose(this),this._rigPostProcess=null,this._postProcesses.length=0;else if(this.cameraRigMode!==gr.RIG_MODE_NONE)this._rigPostProcess=null,this._postProcesses.length=0;else{let u=this._postProcesses.length;for(;--u>=0;){const g=this._postProcesses[u];g&&g.dispose(this)}}let c=this.customRenderTargets.length;for(;--c>=0;)this.customRenderTargets[c].dispose();this.customRenderTargets.length=0,this._activeMeshes.dispose(),this.getScene().getEngine().releaseRenderPassId(this.renderPassId),super.dispose(a,x)}get isLeftCamera(){return this._isLeftCamera}get isRightCamera(){return this._isRightCamera}get leftCamera(){return this._rigCameras.length<1?null:this._rigCameras[0]}get rightCamera(){return this._rigCameras.length<2?null:this._rigCameras[1]}getLeftTarget(){return this._rigCameras.length<1?null:this._rigCameras[0].getTarget()}getRightTarget(){return this._rigCameras.length<2?null:this._rigCameras[1].getTarget()}setCameraRigMode(a,x){if(this.cameraRigMode!==a){for(;this._rigCameras.length>0;){const c=this._rigCameras.pop();c&&c.dispose()}if(this.cameraRigMode=a,this._cameraRigParams={},this._cameraRigParams.interaxialDistance=x.interaxialDistance||.0637,this._cameraRigParams.stereoHalfAngle=_t.ToRadians(this._cameraRigParams.interaxialDistance/.0637),this.cameraRigMode!==gr.RIG_MODE_NONE){const c=this.createRigCamera(this.name+"_L",0);c&&(c._isLeftCamera=!0);const u=this.createRigCamera(this.name+"_R",1);u&&(u._isRightCamera=!0),c&&u&&(this._rigCameras.push(c),this._rigCameras.push(u))}this._setRigMode(x),this._cascadePostProcessesToRigCams(),this.update()}}_setRigMode(a){}_getVRProjectionMatrix(){return vt.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov,this._cameraRigParams.vrMetrics.aspectRatio,this.minZ,this.maxZ,this._cameraRigParams.vrWorkMatrix,!0,this.getEngine().isNDCHalfZRange),this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix,this._projectionMatrix),this._projectionMatrix}setCameraRigParameter(a,x){this._cameraRigParams||(this._cameraRigParams={}),this._cameraRigParams[a]=x,a==="interaxialDistance"&&(this._cameraRigParams.stereoHalfAngle=_t.ToRadians(x/.0637))}createRigCamera(a,x){return null}_updateRigCameras(){for(let a=0;a<this._rigCameras.length;a++)this._rigCameras[a].minZ=this.minZ,this._rigCameras[a].maxZ=this.maxZ,this._rigCameras[a].fov=this.fov,this._rigCameras[a].upVector.copyFrom(this.upVector);this.cameraRigMode===gr.RIG_MODE_STEREOSCOPIC_ANAGLYPH&&(this._rigCameras[0].viewport=this._rigCameras[1].viewport=this.viewport)}_setupInputs(){}serialize(){const a=hr.Serialize(this);return a.uniqueId=this.uniqueId,a.type=this.getClassName(),this.parent&&this.parent._serializeAsParent(a),this.inputs&&this.inputs.serialize(a),hr.AppendSerializedAnimations(this,a),a.ranges=this.serializeAnimationRanges(),a.isEnabled=this.isEnabled(),a}clone(a,x=null){const c=hr.Clone(gr.GetConstructorFromName(this.getClassName(),a,this.getScene(),this.interaxialDistance,this.isStereoscopicSideBySide),this);return c.name=a,c.parent=x,this.onClonedObservable.notifyObservers(c),c}getDirection(a){const x=Ee.Zero();return this.getDirectionToRef(a,x),x}get absoluteRotation(){return this.getWorldMatrix().decompose(void 0,this._absoluteRotation),this._absoluteRotation}getDirectionToRef(a,x){Ee.TransformNormalToRef(a,this.getWorldMatrix(),x)}static GetConstructorFromName(a,x,c,u=0,g=!0){const y=fa.Construct(a,x,c,{interaxial_distance:u,isStereoscopicSideBySide:g});return y||(()=>gr._CreateDefaultParsedCamera(x,c))}computeWorldMatrix(){return this.getWorldMatrix()}static Parse(a,x){const c=a.type,u=gr.GetConstructorFromName(c,a.name,x,a.interaxial_distance,a.isStereoscopicSideBySide),g=hr.Parse(u,a,x);if(a.parentId!==void 0&&(g._waitingParentId=a.parentId),a.parentInstanceIndex!==void 0&&(g._waitingParentInstanceIndex=a.parentInstanceIndex),g.inputs&&(g.inputs.parse(a),g._setupInputs()),a.upVector&&(g.upVector=Ee.FromArray(a.upVector)),g.setPosition&&(g.position.copyFromFloats(0,0,0),g.setPosition(Ee.FromArray(a.position))),a.target&&g.setTarget&&g.setTarget(Ee.FromArray(a.target)),a.cameraRigMode){const y=a.interaxial_distance?{interaxialDistance:a.interaxial_distance}:{};g.setCameraRigMode(a.cameraRigMode,y)}if(a.animations){for(let y=0;y<a.animations.length;y++){const v=a.animations[y],w=Ua("BABYLON.Animation");w&&g.animations.push(w.Parse(v))}fa.ParseAnimationRanges(g,a,x)}return a.autoAnimate&&x.beginAnimation(g,a.autoAnimateFrom,a.autoAnimateTo,a.autoAnimateLoop,a.autoAnimateSpeed||1),a.isEnabled!==void 0&&g.setEnabled(a.isEnabled),g}_calculateHandednessMultiplier(){let a=this.getScene().useRightHandedSystem?-1:1;return this.parent&&this.parent._getWorldMatrixDeterminant()<0&&(a*=-1),a}}gr._CreateDefaultParsedCamera=(F,a)=>{throw js("UniversalCamera")},gr.PERSPECTIVE_CAMERA=0,gr.ORTHOGRAPHIC_CAMERA=1,gr.FOVMODE_VERTICAL_FIXED=0,gr.FOVMODE_HORIZONTAL_FIXED=1,gr.RIG_MODE_NONE=0,gr.RIG_MODE_STEREOSCOPIC_ANAGLYPH=10,gr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL=11,gr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED=12,gr.RIG_MODE_STEREOSCOPIC_OVERUNDER=13,gr.RIG_MODE_STEREOSCOPIC_INTERLACED=14,gr.RIG_MODE_VR=20,gr.RIG_MODE_CUSTOM=22,gr.ForceAttachControlToAlwaysPreventDefault=!1,Ye([En("position")],gr.prototype,"_position",void 0),Ye([En("upVector")],gr.prototype,"_upVector",void 0),Ye([ht()],gr.prototype,"orthoLeft",null),Ye([ht()],gr.prototype,"orthoRight",null),Ye([ht()],gr.prototype,"orthoBottom",null),Ye([ht()],gr.prototype,"orthoTop",null),Ye([ht()],gr.prototype,"fov",void 0),Ye([ht()],gr.prototype,"projectionPlaneTilt",void 0),Ye([ht()],gr.prototype,"minZ",void 0),Ye([ht()],gr.prototype,"maxZ",void 0),Ye([ht()],gr.prototype,"inertia",void 0),Ye([ht()],gr.prototype,"mode",null),Ye([ht()],gr.prototype,"layerMask",void 0),Ye([ht()],gr.prototype,"fovMode",void 0),Ye([ht()],gr.prototype,"cameraRigMode",void 0),Ye([ht()],gr.prototype,"interaxialDistance",void 0),Ye([ht()],gr.prototype,"isStereoscopicSideBySide",void 0);var mn;(function(F){F[F.LOCAL=0]="LOCAL",F[F.WORLD=1]="WORLD",F[F.BONE=2]="BONE"})(mn||(mn={}));class Hh{}Hh.X=new Ee(1,0,0),Hh.Y=new Ee(0,1,0),Hh.Z=new Ee(0,0,1);var Xh;(function(F){F[F.X=0]="X",F[F.Y=1]="Y",F[F.Z=2]="Z"})(Xh||(Xh={})),fa.AddNodeConstructor("TargetCamera",(F,a)=>()=>new X0(F,Ee.Zero(),a));class X0 extends gr{constructor(a,x,c,u=!0){super(a,x,c,u),this._tmpUpVector=Ee.Zero(),this._tmpTargetVector=Ee.Zero(),this.cameraDirection=new Ee(0,0,0),this.cameraRotation=new mr(0,0),this.ignoreParentScaling=!1,this.updateUpVectorFromRotation=!1,this._tmpQuaternion=new Wi,this.rotation=new Ee(0,0,0),this.speed=2,this.noRotationConstraint=!1,this.invertRotation=!1,this.inverseRotationSpeed=.2,this.lockedTarget=null,this._currentTarget=Ee.Zero(),this._initialFocalDistance=1,this._viewMatrix=vt.Zero(),this._camMatrix=vt.Zero(),this._cameraTransformMatrix=vt.Zero(),this._cameraRotationMatrix=vt.Zero(),this._referencePoint=new Ee(0,0,1),this._transformedReferencePoint=Ee.Zero(),this._deferredPositionUpdate=new Ee,this._deferredRotationQuaternionUpdate=new Wi,this._deferredRotationUpdate=new Ee,this._deferredUpdated=!1,this._deferOnly=!1,this._defaultUp=Ee.Up(),this._cachedRotationZ=0,this._cachedQuaternionRotationZ=0}getFrontPosition(a){this.getWorldMatrix();const x=this.getTarget().subtract(this.position);return x.normalize(),x.scaleInPlace(a),this.globalPosition.add(x)}_getLockedTargetPosition(){if(!this.lockedTarget)return null;if(this.lockedTarget.absolutePosition){const a=this.lockedTarget;a.computeWorldMatrix().getTranslationToRef(a.absolutePosition)}return this.lockedTarget.absolutePosition||this.lockedTarget}storeState(){return this._storedPosition=this.position.clone(),this._storedRotation=this.rotation.clone(),this.rotationQuaternion&&(this._storedRotationQuaternion=this.rotationQuaternion.clone()),super.storeState()}_restoreStateValues(){return super._restoreStateValues()?(this.position=this._storedPosition.clone(),this.rotation=this._storedRotation.clone(),this.rotationQuaternion&&(this.rotationQuaternion=this._storedRotationQuaternion.clone()),this.cameraDirection.copyFromFloats(0,0,0),this.cameraRotation.copyFromFloats(0,0),!0):!1}_initCache(){super._initCache(),this._cache.lockedTarget=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotation=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.rotationQuaternion=new Wi(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}_updateCache(a){a||super._updateCache();const x=this._getLockedTargetPosition();x?this._cache.lockedTarget?this._cache.lockedTarget.copyFrom(x):this._cache.lockedTarget=x.clone():this._cache.lockedTarget=null,this._cache.rotation.copyFrom(this.rotation),this.rotationQuaternion&&this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)}_isSynchronizedViewMatrix(){if(!super._isSynchronizedViewMatrix())return!1;const a=this._getLockedTargetPosition();return(this._cache.lockedTarget?this._cache.lockedTarget.equals(a):!a)&&(this.rotationQuaternion?this.rotationQuaternion.equals(this._cache.rotationQuaternion):this._cache.rotation.equals(this.rotation))}_computeLocalCameraSpeed(){const a=this.getEngine();return this.speed*Math.sqrt(a.getDeltaTime()/(a.getFps()*100))}setTarget(a){this.upVector.normalize(),this._initialFocalDistance=a.subtract(this.position).length(),this.position.z===a.z&&(this.position.z+=Mi),this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance),vt.LookAtLHToRef(this.position,a,this._defaultUp,this._camMatrix),this._camMatrix.invert(),this.rotation.x=Math.atan(this._camMatrix.m[6]/this._camMatrix.m[10]);const x=a.subtract(this.position);x.x>=0?this.rotation.y=-Math.atan(x.z/x.x)+Math.PI/2:this.rotation.y=-Math.atan(x.z/x.x)-Math.PI/2,this.rotation.z=0,isNaN(this.rotation.x)&&(this.rotation.x=0),isNaN(this.rotation.y)&&(this.rotation.y=0),isNaN(this.rotation.z)&&(this.rotation.z=0),this.rotationQuaternion&&Wi.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this.rotationQuaternion)}get target(){return this.getTarget()}set target(a){this.setTarget(a)}getTarget(){return this._currentTarget}_decideIfNeedsToMove(){return Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){if(this.parent){this.parent.getWorldMatrix().invertToRef(Yt.Matrix[0]),Ee.TransformNormalToRef(this.cameraDirection,Yt.Matrix[0],Yt.Vector3[0]),this._deferredPositionUpdate.addInPlace(Yt.Vector3[0]),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate);return}this._deferredPositionUpdate.addInPlace(this.cameraDirection),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate)}_checkInputs(){const a=this.invertRotation?-this.inverseRotationSpeed:1,x=this._decideIfNeedsToMove(),c=this.cameraRotation.x||this.cameraRotation.y;this._deferredUpdated=!1,this._deferredRotationUpdate.copyFrom(this.rotation),this._deferredPositionUpdate.copyFrom(this.position),this.rotationQuaternion&&this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion),x&&this._updatePosition(),c&&(this.rotationQuaternion&&this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate),this._deferredRotationUpdate.x+=this.cameraRotation.x*a,this._deferredRotationUpdate.y+=this.cameraRotation.y*a,this.noRotationConstraint||(this._deferredRotationUpdate.x>1.570796&&(this._deferredRotationUpdate.x=1.570796),this._deferredRotationUpdate.x<-1.570796&&(this._deferredRotationUpdate.x=-1.570796)),this._deferOnly?this._deferredUpdated=!0:this.rotation.copyFrom(this._deferredRotationUpdate),this.rotationQuaternion&&this._deferredRotationUpdate.lengthSquared()&&(Wi.RotationYawPitchRollToRef(this._deferredRotationUpdate.y,this._deferredRotationUpdate.x,this._deferredRotationUpdate.z,this._deferredRotationQuaternionUpdate),this._deferOnly?this._deferredUpdated=!0:this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate))),x&&(Math.abs(this.cameraDirection.x)<this.speed*Mi&&(this.cameraDirection.x=0),Math.abs(this.cameraDirection.y)<this.speed*Mi&&(this.cameraDirection.y=0),Math.abs(this.cameraDirection.z)<this.speed*Mi&&(this.cameraDirection.z=0),this.cameraDirection.scaleInPlace(this.inertia)),c&&(Math.abs(this.cameraRotation.x)<this.speed*Mi&&(this.cameraRotation.x=0),Math.abs(this.cameraRotation.y)<this.speed*Mi&&(this.cameraRotation.y=0),this.cameraRotation.scaleInPlace(this.inertia)),super._checkInputs()}_updateCameraRotationMatrix(){this.rotationQuaternion?this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix):vt.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,this._cameraRotationMatrix)}_rotateUpVectorWithCameraRotationMatrix(){return Ee.TransformNormalToRef(this._defaultUp,this._cameraRotationMatrix,this.upVector),this}_getViewMatrix(){return this.lockedTarget&&this.setTarget(this._getLockedTargetPosition()),this._updateCameraRotationMatrix(),this.rotationQuaternion&&this._cachedQuaternionRotationZ!=this.rotationQuaternion.z?(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedQuaternionRotationZ=this.rotationQuaternion.z):this._cachedRotationZ!==this.rotation.z&&(this._rotateUpVectorWithCameraRotationMatrix(),this._cachedRotationZ=this.rotation.z),Ee.TransformCoordinatesToRef(this._referencePoint,this._cameraRotationMatrix,this._transformedReferencePoint),this.position.addToRef(this._transformedReferencePoint,this._currentTarget),this.updateUpVectorFromRotation&&(this.rotationQuaternion?Hh.Y.rotateByQuaternionToRef(this.rotationQuaternion,this.upVector):(Wi.FromEulerVectorToRef(this.rotation,this._tmpQuaternion),Hh.Y.rotateByQuaternionToRef(this._tmpQuaternion,this.upVector))),this._computeViewMatrix(this.position,this._currentTarget,this.upVector),this._viewMatrix}_computeViewMatrix(a,x,c){if(this.ignoreParentScaling){if(this.parent){const u=this.parent.getWorldMatrix();Ee.TransformCoordinatesToRef(a,u,this._globalPosition),Ee.TransformCoordinatesToRef(x,u,this._tmpTargetVector),Ee.TransformNormalToRef(c,u,this._tmpUpVector),this._markSyncedWithParent()}else this._globalPosition.copyFrom(a),this._tmpTargetVector.copyFrom(x),this._tmpUpVector.copyFrom(c);this.getScene().useRightHandedSystem?vt.LookAtRHToRef(this._globalPosition,this._tmpTargetVector,this._tmpUpVector,this._viewMatrix):vt.LookAtLHToRef(this._globalPosition,this._tmpTargetVector,this._tmpUpVector,this._viewMatrix);return}if(this.getScene().useRightHandedSystem?vt.LookAtRHToRef(a,x,c,this._viewMatrix):vt.LookAtLHToRef(a,x,c,this._viewMatrix),this.parent){const u=this.parent.getWorldMatrix();this._viewMatrix.invert(),this._viewMatrix.multiplyToRef(u,this._viewMatrix),this._viewMatrix.getTranslationToRef(this._globalPosition),this._viewMatrix.invert(),this._markSyncedWithParent()}else this._globalPosition.copyFrom(a)}createRigCamera(a,x){if(this.cameraRigMode!==gr.RIG_MODE_NONE){const c=new X0(a,this.position.clone(),this.getScene());return c.isRigCamera=!0,c.rigParent=this,this.cameraRigMode===gr.RIG_MODE_VR&&(this.rotationQuaternion||(this.rotationQuaternion=new Wi),c._cameraRigParams={},c.rotationQuaternion=new Wi),c.mode=this.mode,c.orthoLeft=this.orthoLeft,c.orthoRight=this.orthoRight,c.orthoTop=this.orthoTop,c.orthoBottom=this.orthoBottom,c}return null}_updateRigCameras(){const a=this._rigCameras[0],x=this._rigCameras[1];switch(this.computeWorldMatrix(),this.cameraRigMode){case gr.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case gr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case gr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:case gr.RIG_MODE_STEREOSCOPIC_OVERUNDER:case gr.RIG_MODE_STEREOSCOPIC_INTERLACED:{const c=this.cameraRigMode===gr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?1:-1,u=this.cameraRigMode===gr.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED?-1:1;this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*c,a),this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle*u,x);break}case gr.RIG_MODE_VR:a.rotationQuaternion?(a.rotationQuaternion.copyFrom(this.rotationQuaternion),x.rotationQuaternion.copyFrom(this.rotationQuaternion)):(a.rotation.copyFrom(this.rotation),x.rotation.copyFrom(this.rotation)),a.position.copyFrom(this.position),x.position.copyFrom(this.position);break}super._updateRigCameras()}_getRigCamPositionAndTarget(a,x){this.getTarget().subtractToRef(this.position,X0._TargetFocalPoint),X0._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);const u=X0._TargetFocalPoint.addInPlace(this.position);vt.TranslationToRef(-u.x,-u.y,-u.z,X0._TargetTransformMatrix),X0._TargetTransformMatrix.multiplyToRef(vt.RotationAxis(x.upVector,a),X0._RigCamTransformMatrix),vt.TranslationToRef(u.x,u.y,u.z,X0._TargetTransformMatrix),X0._RigCamTransformMatrix.multiplyToRef(X0._TargetTransformMatrix,X0._RigCamTransformMatrix),Ee.TransformCoordinatesToRef(this.position,X0._RigCamTransformMatrix,x.position),x.setTarget(u)}getClassName(){return"TargetCamera"}}X0._RigCamTransformMatrix=new vt,X0._TargetTransformMatrix=new vt,X0._TargetFocalPoint=new Ee,Ye([En()],X0.prototype,"rotation",void 0),Ye([ht()],X0.prototype,"speed",void 0),Ye([Rx("lockedTargetId")],X0.prototype,"lockedTarget",void 0);var Bl={};class vT{constructor(a){this.attachedToElement=!1,this.attached={},this.camera=a,this.checkInputs=()=>{}}add(a){const x=a.getSimpleName();if(this.attached[x]){Qt.Warn("camera input of type "+x+" already exists on camera");return}this.attached[x]=a,a.camera=this.camera,a.checkInputs&&(this.checkInputs=this._addCheckInputs(a.checkInputs.bind(a))),this.attachedToElement&&a.attachControl(this.noPreventDefault)}remove(a){for(const x in this.attached){const c=this.attached[x];if(c===a){c.detachControl(),c.camera=null,delete this.attached[x],this.rebuildInputCheck();return}}}removeByType(a){for(const x in this.attached){const c=this.attached[x];c.getClassName()===a&&(c.detachControl(),c.camera=null,delete this.attached[x],this.rebuildInputCheck())}}_addCheckInputs(a){const x=this.checkInputs;return()=>{x(),a()}}attachInput(a){this.attachedToElement&&a.attachControl(this.noPreventDefault)}attachElement(a=!1){if(!this.attachedToElement){a=gr.ForceAttachControlToAlwaysPreventDefault?!1:a,this.attachedToElement=!0,this.noPreventDefault=a;for(const x in this.attached)this.attached[x].attachControl(a)}}detachElement(a=!1){for(const x in this.attached)this.attached[x].detachControl(),a&&(this.attached[x].camera=null);this.attachedToElement=!1}rebuildInputCheck(){this.checkInputs=()=>{};for(const a in this.attached){const x=this.attached[a];x.checkInputs&&(this.checkInputs=this._addCheckInputs(x.checkInputs.bind(x)))}}clear(){this.attachedToElement&&this.detachElement(!0),this.attached={},this.attachedToElement=!1,this.checkInputs=()=>{}}serialize(a){const x={};for(const c in this.attached){const u=this.attached[c],g=hr.Serialize(u);x[u.getClassName()]=g}a.inputsmgr=x}parse(a){const x=a.inputsmgr;if(x){this.clear();for(const c in x){const u=Bl[c];if(u){const g=x[c],y=hr.Parse(()=>new u,g,null);this.add(y)}}}else for(const c in this.attached){const u=Bl[this.attached[c].getClassName()];if(u){const g=hr.Parse(()=>new u,a,null);this.remove(this.attached[c]),this.add(g)}}}}class Bx{constructor(){this.keysUp=[38],this.keysUpward=[33],this.keysDown=[40],this.keysDownward=[34],this.keysLeft=[37],this.keysRight=[39],this.rotationSpeed=.5,this.keysRotateLeft=[],this.keysRotateRight=[],this.keysRotateUp=[],this.keysRotateDown=[],this._keys=new Array}attachControl(a){a=_t.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(x=>{const c=x.event;if(!c.metaKey){if(x.type===gu.KEYDOWN)(this.keysUp.indexOf(c.keyCode)!==-1||this.keysDown.indexOf(c.keyCode)!==-1||this.keysLeft.indexOf(c.keyCode)!==-1||this.keysRight.indexOf(c.keyCode)!==-1||this.keysUpward.indexOf(c.keyCode)!==-1||this.keysDownward.indexOf(c.keyCode)!==-1||this.keysRotateLeft.indexOf(c.keyCode)!==-1||this.keysRotateRight.indexOf(c.keyCode)!==-1||this.keysRotateUp.indexOf(c.keyCode)!==-1||this.keysRotateDown.indexOf(c.keyCode)!==-1)&&(this._keys.indexOf(c.keyCode)===-1&&this._keys.push(c.keyCode),a||c.preventDefault());else if(this.keysUp.indexOf(c.keyCode)!==-1||this.keysDown.indexOf(c.keyCode)!==-1||this.keysLeft.indexOf(c.keyCode)!==-1||this.keysRight.indexOf(c.keyCode)!==-1||this.keysUpward.indexOf(c.keyCode)!==-1||this.keysDownward.indexOf(c.keyCode)!==-1||this.keysRotateLeft.indexOf(c.keyCode)!==-1||this.keysRotateRight.indexOf(c.keyCode)!==-1||this.keysRotateUp.indexOf(c.keyCode)!==-1||this.keysRotateDown.indexOf(c.keyCode)!==-1){const u=this._keys.indexOf(c.keyCode);u>=0&&this._keys.splice(u,1),a||c.preventDefault()}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const a=this.camera;for(let x=0;x<this._keys.length;x++){const c=this._keys[x],u=a._computeLocalCameraSpeed();this.keysLeft.indexOf(c)!==-1?a._localDirection.copyFromFloats(-u,0,0):this.keysUp.indexOf(c)!==-1?a._localDirection.copyFromFloats(0,0,u):this.keysRight.indexOf(c)!==-1?a._localDirection.copyFromFloats(u,0,0):this.keysDown.indexOf(c)!==-1?a._localDirection.copyFromFloats(0,0,-u):this.keysUpward.indexOf(c)!==-1?a._localDirection.copyFromFloats(0,u,0):this.keysDownward.indexOf(c)!==-1?a._localDirection.copyFromFloats(0,-u,0):this.keysRotateLeft.indexOf(c)!==-1?(a._localDirection.copyFromFloats(0,0,0),a.cameraRotation.y-=this._getLocalRotation()):this.keysRotateRight.indexOf(c)!==-1?(a._localDirection.copyFromFloats(0,0,0),a.cameraRotation.y+=this._getLocalRotation()):this.keysRotateUp.indexOf(c)!==-1?(a._localDirection.copyFromFloats(0,0,0),a.cameraRotation.x-=this._getLocalRotation()):this.keysRotateDown.indexOf(c)!==-1&&(a._localDirection.copyFromFloats(0,0,0),a.cameraRotation.x+=this._getLocalRotation()),a.getScene().useRightHandedSystem&&(a._localDirection.z*=-1),a.getViewMatrix().invertToRef(a._cameraTransformMatrix),Ee.TransformNormalToRef(a._localDirection,a._cameraTransformMatrix,a._transformedDirection),a.cameraDirection.addInPlace(a._transformedDirection)}}}getClassName(){return"FreeCameraKeyboardMoveInput"}_onLostFocus(){this._keys.length=0}getSimpleName(){return"keyboard"}_getLocalRotation(){const a=this.camera._calculateHandednessMultiplier();return this.rotationSpeed*this._engine.getDeltaTime()/1e3*a}}Ye([ht()],Bx.prototype,"keysUp",void 0),Ye([ht()],Bx.prototype,"keysUpward",void 0),Ye([ht()],Bx.prototype,"keysDown",void 0),Ye([ht()],Bx.prototype,"keysDownward",void 0),Ye([ht()],Bx.prototype,"keysLeft",void 0),Ye([ht()],Bx.prototype,"keysRight",void 0),Ye([ht()],Bx.prototype,"rotationSpeed",void 0),Ye([ht()],Bx.prototype,"keysRotateLeft",void 0),Ye([ht()],Bx.prototype,"keysRotateRight",void 0),Ye([ht()],Bx.prototype,"keysRotateUp",void 0),Ye([ht()],Bx.prototype,"keysRotateDown",void 0),Bl.FreeCameraKeyboardMoveInput=Bx;class Jm{constructor(a=!0){this.touchEnabled=a,this.buttons=[0,1,2],this.angularSensibility=2e3,this._previousPosition=null,this.onPointerMovedObservable=new Jt,this._allowCameraRotation=!0,this._currentActiveButton=-1,this._activePointerId=-1}attachControl(a){a=_t.BackCompatCameraNoPreventDefault(arguments);const x=this.camera.getEngine(),c=x.getInputElement();this._pointerInput||(this._pointerInput=u=>{const g=u.event,y=g.pointerType==="touch";if(!this.touchEnabled&&y||u.type!==dr.POINTERMOVE&&this.buttons.indexOf(g.button)===-1)return;const v=g.target;if(u.type===dr.POINTERDOWN){if(y&&this._activePointerId!==-1||!y&&this._currentActiveButton!==-1)return;this._activePointerId=g.pointerId;try{v?.setPointerCapture(g.pointerId)}catch{}this._currentActiveButton===-1&&(this._currentActiveButton=g.button),this._previousPosition={x:g.clientX,y:g.clientY},a||(g.preventDefault(),c&&c.focus()),x.isPointerLock&&this._onMouseMove&&this._onMouseMove(u.event)}else if(u.type===dr.POINTERUP){if(y&&this._activePointerId!==g.pointerId||!y&&this._currentActiveButton!==g.button)return;try{v?.releasePointerCapture(g.pointerId)}catch{}this._currentActiveButton=-1,this._previousPosition=null,a||g.preventDefault(),this._activePointerId=-1}else if(u.type===dr.POINTERMOVE&&(this._activePointerId===g.pointerId||!y)){if(x.isPointerLock&&this._onMouseMove)this._onMouseMove(u.event);else if(this._previousPosition){const w=this.camera._calculateHandednessMultiplier(),B=(g.clientX-this._previousPosition.x)*w,W=g.clientY-this._previousPosition.y;this._allowCameraRotation&&(this.camera.cameraRotation.y+=B/this.angularSensibility,this.camera.cameraRotation.x+=W/this.angularSensibility),this.onPointerMovedObservable.notifyObservers({offsetX:B,offsetY:W}),this._previousPosition={x:g.clientX,y:g.clientY},a||g.preventDefault()}}}),this._onMouseMove=u=>{if(!x.isPointerLock)return;const g=this.camera._calculateHandednessMultiplier(),y=u.movementX*g;this.camera.cameraRotation.y+=y/this.angularSensibility;const v=u.movementY;this.camera.cameraRotation.x+=v/this.angularSensibility,this._previousPosition=null,a||u.preventDefault()},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,dr.POINTERDOWN|dr.POINTERUP|dr.POINTERMOVE),c&&(this._contextMenuBind=u=>this.onContextMenu(u),c.addEventListener("contextmenu",this._contextMenuBind,!1))}onContextMenu(a){a.preventDefault()}detachControl(){if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._contextMenuBind){const x=this.camera.getEngine().getInputElement();x&&x.removeEventListener("contextmenu",this._contextMenuBind)}this.onPointerMovedObservable&&this.onPointerMovedObservable.clear(),this._observer=null,this._onMouseMove=null,this._previousPosition=null}this._activePointerId=-1,this._currentActiveButton=-1}getClassName(){return"FreeCameraMouseInput"}getSimpleName(){return"mouse"}}Ye([ht()],Jm.prototype,"buttons",void 0),Ye([ht()],Jm.prototype,"angularSensibility",void 0),Bl.FreeCameraMouseInput=Jm;class tg{constructor(){this.wheelPrecisionX=3,this.wheelPrecisionY=3,this.wheelPrecisionZ=3,this.onChangedObservable=new Jt,this._wheelDeltaX=0,this._wheelDeltaY=0,this._wheelDeltaZ=0,this._ffMultiplier=12,this._normalize=120}attachControl(a){a=_t.BackCompatCameraNoPreventDefault(arguments),this._wheel=x=>{if(x.type!==dr.POINTERWHEEL)return;const c=x.event,u=c.deltaMode===_u.DOM_DELTA_LINE?this._ffMultiplier:1;this._wheelDeltaX+=this.wheelPrecisionX*u*c.deltaX/this._normalize,this._wheelDeltaY-=this.wheelPrecisionY*u*c.deltaY/this._normalize,this._wheelDeltaZ+=this.wheelPrecisionZ*u*c.deltaZ/this._normalize,c.preventDefault&&(a||c.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,dr.POINTERWHEEL)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null),this.onChangedObservable&&this.onChangedObservable.clear()}checkInputs(){this.onChangedObservable.notifyObservers({wheelDeltaX:this._wheelDeltaX,wheelDeltaY:this._wheelDeltaY,wheelDeltaZ:this._wheelDeltaZ}),this._wheelDeltaX=0,this._wheelDeltaY=0,this._wheelDeltaZ=0}getClassName(){return"BaseCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}}Ye([ht()],tg.prototype,"wheelPrecisionX",void 0),Ye([ht()],tg.prototype,"wheelPrecisionY",void 0),Ye([ht()],tg.prototype,"wheelPrecisionZ",void 0);var Gn;(function(F){F[F.MoveRelative=0]="MoveRelative",F[F.RotateRelative=1]="RotateRelative",F[F.MoveScene=2]="MoveScene"})(Gn||(Gn={}));class Ul extends tg{constructor(){super(...arguments),this._moveRelative=Ee.Zero(),this._rotateRelative=Ee.Zero(),this._moveScene=Ee.Zero(),this._wheelXAction=Gn.MoveRelative,this._wheelXActionCoordinate=Xh.X,this._wheelYAction=Gn.MoveRelative,this._wheelYActionCoordinate=Xh.Z,this._wheelZAction=null,this._wheelZActionCoordinate=null}getClassName(){return"FreeCameraMouseWheelInput"}set wheelXMoveRelative(a){a===null&&this._wheelXAction!==Gn.MoveRelative||(this._wheelXAction=Gn.MoveRelative,this._wheelXActionCoordinate=a)}get wheelXMoveRelative(){return this._wheelXAction!==Gn.MoveRelative?null:this._wheelXActionCoordinate}set wheelYMoveRelative(a){a===null&&this._wheelYAction!==Gn.MoveRelative||(this._wheelYAction=Gn.MoveRelative,this._wheelYActionCoordinate=a)}get wheelYMoveRelative(){return this._wheelYAction!==Gn.MoveRelative?null:this._wheelYActionCoordinate}set wheelZMoveRelative(a){a===null&&this._wheelZAction!==Gn.MoveRelative||(this._wheelZAction=Gn.MoveRelative,this._wheelZActionCoordinate=a)}get wheelZMoveRelative(){return this._wheelZAction!==Gn.MoveRelative?null:this._wheelZActionCoordinate}set wheelXRotateRelative(a){a===null&&this._wheelXAction!==Gn.RotateRelative||(this._wheelXAction=Gn.RotateRelative,this._wheelXActionCoordinate=a)}get wheelXRotateRelative(){return this._wheelXAction!==Gn.RotateRelative?null:this._wheelXActionCoordinate}set wheelYRotateRelative(a){a===null&&this._wheelYAction!==Gn.RotateRelative||(this._wheelYAction=Gn.RotateRelative,this._wheelYActionCoordinate=a)}get wheelYRotateRelative(){return this._wheelYAction!==Gn.RotateRelative?null:this._wheelYActionCoordinate}set wheelZRotateRelative(a){a===null&&this._wheelZAction!==Gn.RotateRelative||(this._wheelZAction=Gn.RotateRelative,this._wheelZActionCoordinate=a)}get wheelZRotateRelative(){return this._wheelZAction!==Gn.RotateRelative?null:this._wheelZActionCoordinate}set wheelXMoveScene(a){a===null&&this._wheelXAction!==Gn.MoveScene||(this._wheelXAction=Gn.MoveScene,this._wheelXActionCoordinate=a)}get wheelXMoveScene(){return this._wheelXAction!==Gn.MoveScene?null:this._wheelXActionCoordinate}set wheelYMoveScene(a){a===null&&this._wheelYAction!==Gn.MoveScene||(this._wheelYAction=Gn.MoveScene,this._wheelYActionCoordinate=a)}get wheelYMoveScene(){return this._wheelYAction!==Gn.MoveScene?null:this._wheelYActionCoordinate}set wheelZMoveScene(a){a===null&&this._wheelZAction!==Gn.MoveScene||(this._wheelZAction=Gn.MoveScene,this._wheelZActionCoordinate=a)}get wheelZMoveScene(){return this._wheelZAction!==Gn.MoveScene?null:this._wheelZActionCoordinate}checkInputs(){if(this._wheelDeltaX===0&&this._wheelDeltaY===0&&this._wheelDeltaZ==0)return;this._moveRelative.setAll(0),this._rotateRelative.setAll(0),this._moveScene.setAll(0),this._updateCamera(),this.camera.getScene().useRightHandedSystem&&(this._moveRelative.z*=-1);const a=vt.Zero();this.camera.getViewMatrix().invertToRef(a);const x=Ee.Zero();Ee.TransformNormalToRef(this._moveRelative,a,x),this.camera.cameraRotation.x+=this._rotateRelative.x/200,this.camera.cameraRotation.y+=this._rotateRelative.y/200,this.camera.cameraDirection.addInPlace(x),this.camera.cameraDirection.addInPlace(this._moveScene),super.checkInputs()}_updateCamera(){this._updateCameraProperty(this._wheelDeltaX,this._wheelXAction,this._wheelXActionCoordinate),this._updateCameraProperty(this._wheelDeltaY,this._wheelYAction,this._wheelYActionCoordinate),this._updateCameraProperty(this._wheelDeltaZ,this._wheelZAction,this._wheelZActionCoordinate)}_updateCameraProperty(a,x,c){if(a===0||x===null||c===null)return;let u=null;switch(x){case Gn.MoveRelative:u=this._moveRelative;break;case Gn.RotateRelative:u=this._rotateRelative;break;case Gn.MoveScene:u=this._moveScene;break}switch(c){case Xh.X:u.set(a,0,0);break;case Xh.Y:u.set(0,a,0);break;case Xh.Z:u.set(0,0,a);break}}}Ye([ht()],Ul.prototype,"wheelXMoveRelative",null),Ye([ht()],Ul.prototype,"wheelYMoveRelative",null),Ye([ht()],Ul.prototype,"wheelZMoveRelative",null),Ye([ht()],Ul.prototype,"wheelXRotateRelative",null),Ye([ht()],Ul.prototype,"wheelYRotateRelative",null),Ye([ht()],Ul.prototype,"wheelZRotateRelative",null),Ye([ht()],Ul.prototype,"wheelXMoveScene",null),Ye([ht()],Ul.prototype,"wheelYMoveScene",null),Ye([ht()],Ul.prototype,"wheelZMoveScene",null),Bl.FreeCameraMouseWheelInput=Ul;class ag{constructor(a=!1){this.allowMouse=a,this.touchAngularSensibility=2e5,this.touchMoveSensibility=250,this.singleFingerRotate=!1,this._offsetX=null,this._offsetY=null,this._pointerPressed=new Array,this._isSafari=_t.IsSafari()}attachControl(a){a=_t.BackCompatCameraNoPreventDefault(arguments);let x=null;if(this._pointerInput===void 0&&(this._onLostFocus=()=>{this._offsetX=null,this._offsetY=null},this._pointerInput=c=>{const u=c.event,g=u.pointerType==="mouse"||this._isSafari&&typeof u.pointerType>"u";if(!(!this.allowMouse&&g)){if(c.type===dr.POINTERDOWN){if(a||u.preventDefault(),this._pointerPressed.push(u.pointerId),this._pointerPressed.length!==1)return;x={x:u.clientX,y:u.clientY}}else if(c.type===dr.POINTERUP){a||u.preventDefault();const y=this._pointerPressed.indexOf(u.pointerId);if(y===-1||(this._pointerPressed.splice(y,1),y!=0))return;x=null,this._offsetX=null,this._offsetY=null}else if(c.type===dr.POINTERMOVE){if(a||u.preventDefault(),!x||this._pointerPressed.indexOf(u.pointerId)!=0)return;this._offsetX=u.clientX-x.x,this._offsetY=-(u.clientY-x.y)}}}),this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,dr.POINTERDOWN|dr.POINTERUP|dr.POINTERMOVE),this._onLostFocus){const u=this.camera.getEngine().getInputElement();u&&u.addEventListener("blur",this._onLostFocus)}}detachControl(){if(this._pointerInput){if(this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null),this._onLostFocus){const x=this.camera.getEngine().getInputElement();x&&x.removeEventListener("blur",this._onLostFocus),this._onLostFocus=null}this._pointerPressed.length=0,this._offsetX=null,this._offsetY=null}}checkInputs(){if(this._offsetX===null||this._offsetY===null||this._offsetX===0&&this._offsetY===0)return;const a=this.camera,x=a._calculateHandednessMultiplier();if(a.cameraRotation.y=x*this._offsetX/this.touchAngularSensibility,this.singleFingerRotate&&this._pointerPressed.length===1||!this.singleFingerRotate&&this._pointerPressed.length>1)a.cameraRotation.x=-this._offsetY/this.touchAngularSensibility;else{const u=a._computeLocalCameraSpeed(),g=new Ee(0,0,this.touchMoveSensibility!==0?u*this._offsetY/this.touchMoveSensibility:0);vt.RotationYawPitchRollToRef(a.rotation.y,a.rotation.x,0,a._cameraRotationMatrix),a.cameraDirection.addInPlace(Ee.TransformCoordinates(g,a._cameraRotationMatrix))}}getClassName(){return"FreeCameraTouchInput"}getSimpleName(){return"touch"}}Ye([ht()],ag.prototype,"touchAngularSensibility",void 0),Ye([ht()],ag.prototype,"touchMoveSensibility",void 0),Bl.FreeCameraTouchInput=ag;class IT extends vT{constructor(a){super(a),this._mouseInput=null,this._mouseWheelInput=null}addKeyboard(){return this.add(new Bx),this}addMouse(a=!0){return this._mouseInput||(this._mouseInput=new Jm(a),this.add(this._mouseInput)),this}removeMouse(){return this._mouseInput&&this.remove(this._mouseInput),this}addMouseWheel(){return this._mouseWheelInput||(this._mouseWheelInput=new Ul,this.add(this._mouseWheelInput)),this}removeMouseWheel(){return this._mouseWheelInput&&this.remove(this._mouseWheelInput),this}addTouch(){return this.add(new ag),this}clear(){super.clear(),this._mouseInput=null}}class yu extends X0{get angularSensibility(){const a=this.inputs.attached.mouse;return a?a.angularSensibility:0}set angularSensibility(a){const x=this.inputs.attached.mouse;x&&(x.angularSensibility=a)}get keysUp(){const a=this.inputs.attached.keyboard;return a?a.keysUp:[]}set keysUp(a){const x=this.inputs.attached.keyboard;x&&(x.keysUp=a)}get keysUpward(){const a=this.inputs.attached.keyboard;return a?a.keysUpward:[]}set keysUpward(a){const x=this.inputs.attached.keyboard;x&&(x.keysUpward=a)}get keysDown(){const a=this.inputs.attached.keyboard;return a?a.keysDown:[]}set keysDown(a){const x=this.inputs.attached.keyboard;x&&(x.keysDown=a)}get keysDownward(){const a=this.inputs.attached.keyboard;return a?a.keysDownward:[]}set keysDownward(a){const x=this.inputs.attached.keyboard;x&&(x.keysDownward=a)}get keysLeft(){const a=this.inputs.attached.keyboard;return a?a.keysLeft:[]}set keysLeft(a){const x=this.inputs.attached.keyboard;x&&(x.keysLeft=a)}get keysRight(){const a=this.inputs.attached.keyboard;return a?a.keysRight:[]}set keysRight(a){const x=this.inputs.attached.keyboard;x&&(x.keysRight=a)}get keysRotateLeft(){const a=this.inputs.attached.keyboard;return a?a.keysRotateLeft:[]}set keysRotateLeft(a){const x=this.inputs.attached.keyboard;x&&(x.keysRotateLeft=a)}get keysRotateRight(){const a=this.inputs.attached.keyboard;return a?a.keysRotateRight:[]}set keysRotateRight(a){const x=this.inputs.attached.keyboard;x&&(x.keysRotateRight=a)}get keysRotateUp(){const a=this.inputs.attached.keyboard;return a?a.keysRotateUp:[]}set keysRotateUp(a){const x=this.inputs.attached.keyboard;x&&(x.keysRotateUp=a)}get keysRotateDown(){const a=this.inputs.attached.keyboard;return a?a.keysRotateDown:[]}set keysRotateDown(a){const x=this.inputs.attached.keyboard;x&&(x.keysRotateDown=a)}constructor(a,x,c,u=!0){super(a,x,c,u),this.ellipsoid=new Ee(.5,1,.5),this.ellipsoidOffset=new Ee(0,0,0),this.checkCollisions=!1,this.applyGravity=!1,this._needMoveForGravity=!1,this._oldPosition=Ee.Zero(),this._diffPosition=Ee.Zero(),this._newPosition=Ee.Zero(),this._collisionMask=-1,this._onCollisionPositionChange=(g,y,v=null)=>{this._newPosition.copyFrom(y),this._newPosition.subtractToRef(this._oldPosition,this._diffPosition),this._diffPosition.length()>Bt.CollisionsEpsilon&&(this.position.addToRef(this._diffPosition,this._deferredPositionUpdate),this._deferOnly?this._deferredUpdated=!0:this.position.copyFrom(this._deferredPositionUpdate),this.onCollide&&v&&this.onCollide(v))},this.inputs=new IT(this),this.inputs.addKeyboard().addMouse()}attachControl(a,x){x=_t.BackCompatCameraNoPreventDefault(arguments),this.inputs.attachElement(x)}detachControl(){this.inputs.detachElement(),this.cameraDirection=new Ee(0,0,0),this.cameraRotation=new mr(0,0)}get collisionMask(){return this._collisionMask}set collisionMask(a){this._collisionMask=isNaN(a)?-1:a}_collideWithWorld(a){let x;this.parent?x=Ee.TransformCoordinates(this.position,this.parent.getWorldMatrix()):x=this.position,x.subtractFromFloatsToRef(0,this.ellipsoid.y,0,this._oldPosition),this._oldPosition.addInPlace(this.ellipsoidOffset);const c=this.getScene().collisionCoordinator;this._collider||(this._collider=c.createCollider()),this._collider._radius=this.ellipsoid,this._collider.collisionMask=this._collisionMask;let u=a;this.applyGravity&&(u=a.add(this.getScene().gravity)),c.getNewPosition(this._oldPosition,u,this._collider,3,null,this._onCollisionPositionChange,this.uniqueId)}_checkInputs(){this._localDirection||(this._localDirection=Ee.Zero(),this._transformedDirection=Ee.Zero()),this.inputs.checkInputs(),super._checkInputs()}set needMoveForGravity(a){this._needMoveForGravity=a}get needMoveForGravity(){return this._needMoveForGravity}_decideIfNeedsToMove(){return this._needMoveForGravity||Math.abs(this.cameraDirection.x)>0||Math.abs(this.cameraDirection.y)>0||Math.abs(this.cameraDirection.z)>0}_updatePosition(){this.checkCollisions&&this.getScene().collisionsEnabled?this._collideWithWorld(this.cameraDirection):super._updatePosition()}dispose(){this.inputs.clear(),super.dispose()}getClassName(){return"FreeCamera"}}Ye([En()],yu.prototype,"ellipsoid",void 0),Ye([En()],yu.prototype,"ellipsoidOffset",void 0),Ye([ht()],yu.prototype,"checkCollisions",void 0),Ye([ht()],yu.prototype,"applyGravity",void 0),fa.AddNodeConstructor("TouchCamera",(F,a)=>()=>new RT(F,Ee.Zero(),a));class RT extends yu{get touchAngularSensibility(){const a=this.inputs.attached.touch;return a?a.touchAngularSensibility:0}set touchAngularSensibility(a){const x=this.inputs.attached.touch;x&&(x.touchAngularSensibility=a)}get touchMoveSensibility(){const a=this.inputs.attached.touch;return a?a.touchMoveSensibility:0}set touchMoveSensibility(a){const x=this.inputs.attached.touch;x&&(x.touchMoveSensibility=a)}constructor(a,x,c){super(a,x,c),this.inputs.addTouch(),this._setupInputs()}getClassName(){return"TouchCamera"}_setupInputs(){const a=this.inputs.attached.touch,x=this.inputs.attached.mouse;x?x.touchEnabled=!1:a.allowMouse=!0}}class X3{constructor(a,x){this.x=a,this.y=x}}class ao{get isConnected(){return this._isConnected}constructor(a,x,c,u=0,g=1,y=2,v=3){this.id=a,this.index=x,this.browserGamepad=c,this._leftStick={x:0,y:0},this._rightStick={x:0,y:0},this._isConnected=!0,this._invertLeftStickY=!1,this.type=ao.GAMEPAD,this._leftStickAxisX=u,this._leftStickAxisY=g,this._rightStickAxisX=y,this._rightStickAxisY=v,this.browserGamepad.axes.length>=2&&(this._leftStick={x:this.browserGamepad.axes[this._leftStickAxisX],y:this.browserGamepad.axes[this._leftStickAxisY]}),this.browserGamepad.axes.length>=4&&(this._rightStick={x:this.browserGamepad.axes[this._rightStickAxisX],y:this.browserGamepad.axes[this._rightStickAxisY]})}onleftstickchanged(a){this._onleftstickchanged=a}onrightstickchanged(a){this._onrightstickchanged=a}get leftStick(){return this._leftStick}set leftStick(a){this._onleftstickchanged&&(this._leftStick.x!==a.x||this._leftStick.y!==a.y)&&this._onleftstickchanged(a),this._leftStick=a}get rightStick(){return this._rightStick}set rightStick(a){this._onrightstickchanged&&(this._rightStick.x!==a.x||this._rightStick.y!==a.y)&&this._onrightstickchanged(a),this._rightStick=a}update(){this._leftStick&&(this.leftStick={x:this.browserGamepad.axes[this._leftStickAxisX],y:this.browserGamepad.axes[this._leftStickAxisY]},this._invertLeftStickY&&(this.leftStick.y*=-1)),this._rightStick&&(this.rightStick={x:this.browserGamepad.axes[this._rightStickAxisX],y:this.browserGamepad.axes[this._rightStickAxisY]})}dispose(){}}ao.GAMEPAD=0,ao.GENERIC=1,ao.XBOX=2,ao.POSE_ENABLED=3,ao.DUALSHOCK=4;class HP extends ao{onbuttondown(a){this._onbuttondown=a}onbuttonup(a){this._onbuttonup=a}constructor(a,x,c){super(a,x,c),this.onButtonDownObservable=new Jt,this.onButtonUpObservable=new Jt,this.type=ao.GENERIC,this._buttons=new Array(c.buttons.length)}_setButtonValue(a,x,c){return a!==x&&(a===1&&(this._onbuttondown&&this._onbuttondown(c),this.onButtonDownObservable.notifyObservers(c)),a===0&&(this._onbuttonup&&this._onbuttonup(c),this.onButtonUpObservable.notifyObservers(c))),a}update(){super.update();for(let a=0;a<this._buttons.length;a++)this._buttons[a]=this._setButtonValue(this.browserGamepad.buttons[a].value,this._buttons[a],a)}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear()}}var ll;(function(F){F[F.A=0]="A",F[F.B=1]="B",F[F.X=2]="X",F[F.Y=3]="Y",F[F.LB=4]="LB",F[F.RB=5]="RB",F[F.Back=8]="Back",F[F.Start=9]="Start",F[F.LeftStick=10]="LeftStick",F[F.RightStick=11]="RightStick"})(ll||(ll={}));var bu;(function(F){F[F.Up=12]="Up",F[F.Down=13]="Down",F[F.Left=14]="Left",F[F.Right=15]="Right"})(bu||(bu={}));class XP extends ao{constructor(a,x,c,u=!1){super(a,x,c,0,1,2,3),this._leftTrigger=0,this._rightTrigger=0,this.onButtonDownObservable=new Jt,this.onButtonUpObservable=new Jt,this.onPadDownObservable=new Jt,this.onPadUpObservable=new Jt,this._buttonA=0,this._buttonB=0,this._buttonX=0,this._buttonY=0,this._buttonBack=0,this._buttonStart=0,this._buttonLB=0,this._buttonRB=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0,this._isXboxOnePad=!1,this.type=ao.XBOX,this._isXboxOnePad=u}onlefttriggerchanged(a){this._onlefttriggerchanged=a}onrighttriggerchanged(a){this._onrighttriggerchanged=a}get leftTrigger(){return this._leftTrigger}set leftTrigger(a){this._onlefttriggerchanged&&this._leftTrigger!==a&&this._onlefttriggerchanged(a),this._leftTrigger=a}get rightTrigger(){return this._rightTrigger}set rightTrigger(a){this._onrighttriggerchanged&&this._rightTrigger!==a&&this._onrighttriggerchanged(a),this._rightTrigger=a}onbuttondown(a){this._onbuttondown=a}onbuttonup(a){this._onbuttonup=a}ondpaddown(a){this._ondpaddown=a}ondpadup(a){this._ondpadup=a}_setButtonValue(a,x,c){return a!==x&&(a===1&&(this._onbuttondown&&this._onbuttondown(c),this.onButtonDownObservable.notifyObservers(c)),a===0&&(this._onbuttonup&&this._onbuttonup(c),this.onButtonUpObservable.notifyObservers(c))),a}_setDPadValue(a,x,c){return a!==x&&(a===1&&(this._ondpaddown&&this._ondpaddown(c),this.onPadDownObservable.notifyObservers(c)),a===0&&(this._ondpadup&&this._ondpadup(c),this.onPadUpObservable.notifyObservers(c))),a}get buttonA(){return this._buttonA}set buttonA(a){this._buttonA=this._setButtonValue(a,this._buttonA,ll.A)}get buttonB(){return this._buttonB}set buttonB(a){this._buttonB=this._setButtonValue(a,this._buttonB,ll.B)}get buttonX(){return this._buttonX}set buttonX(a){this._buttonX=this._setButtonValue(a,this._buttonX,ll.X)}get buttonY(){return this._buttonY}set buttonY(a){this._buttonY=this._setButtonValue(a,this._buttonY,ll.Y)}get buttonStart(){return this._buttonStart}set buttonStart(a){this._buttonStart=this._setButtonValue(a,this._buttonStart,ll.Start)}get buttonBack(){return this._buttonBack}set buttonBack(a){this._buttonBack=this._setButtonValue(a,this._buttonBack,ll.Back)}get buttonLB(){return this._buttonLB}set buttonLB(a){this._buttonLB=this._setButtonValue(a,this._buttonLB,ll.LB)}get buttonRB(){return this._buttonRB}set buttonRB(a){this._buttonRB=this._setButtonValue(a,this._buttonRB,ll.RB)}get buttonLeftStick(){return this._buttonLeftStick}set buttonLeftStick(a){this._buttonLeftStick=this._setButtonValue(a,this._buttonLeftStick,ll.LeftStick)}get buttonRightStick(){return this._buttonRightStick}set buttonRightStick(a){this._buttonRightStick=this._setButtonValue(a,this._buttonRightStick,ll.RightStick)}get dPadUp(){return this._dPadUp}set dPadUp(a){this._dPadUp=this._setDPadValue(a,this._dPadUp,bu.Up)}get dPadDown(){return this._dPadDown}set dPadDown(a){this._dPadDown=this._setDPadValue(a,this._dPadDown,bu.Down)}get dPadLeft(){return this._dPadLeft}set dPadLeft(a){this._dPadLeft=this._setDPadValue(a,this._dPadLeft,bu.Left)}get dPadRight(){return this._dPadRight}set dPadRight(a){this._dPadRight=this._setDPadValue(a,this._dPadRight,bu.Right)}update(){super.update(),this._isXboxOnePad?(this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value):(this.buttonA=this.browserGamepad.buttons[0].value,this.buttonB=this.browserGamepad.buttons[1].value,this.buttonX=this.browserGamepad.buttons[2].value,this.buttonY=this.browserGamepad.buttons[3].value,this.buttonLB=this.browserGamepad.buttons[4].value,this.buttonRB=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonBack=this.browserGamepad.buttons[8].value,this.buttonStart=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value)}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear(),this.onPadDownObservable.clear(),this.onPadUpObservable.clear()}}var hl;(function(F){F[F.Cross=0]="Cross",F[F.Circle=1]="Circle",F[F.Square=2]="Square",F[F.Triangle=3]="Triangle",F[F.L1=4]="L1",F[F.R1=5]="R1",F[F.Share=8]="Share",F[F.Options=9]="Options",F[F.LeftStick=10]="LeftStick",F[F.RightStick=11]="RightStick"})(hl||(hl={}));var Eu;(function(F){F[F.Up=12]="Up",F[F.Down=13]="Down",F[F.Left=14]="Left",F[F.Right=15]="Right"})(Eu||(Eu={}));class jP extends ao{constructor(a,x,c){super(a.replace("STANDARD GAMEPAD","SONY PLAYSTATION DUALSHOCK"),x,c,0,1,2,3),this._leftTrigger=0,this._rightTrigger=0,this.onButtonDownObservable=new Jt,this.onButtonUpObservable=new Jt,this.onPadDownObservable=new Jt,this.onPadUpObservable=new Jt,this._buttonCross=0,this._buttonCircle=0,this._buttonSquare=0,this._buttonTriangle=0,this._buttonShare=0,this._buttonOptions=0,this._buttonL1=0,this._buttonR1=0,this._buttonLeftStick=0,this._buttonRightStick=0,this._dPadUp=0,this._dPadDown=0,this._dPadLeft=0,this._dPadRight=0,this.type=ao.DUALSHOCK}onlefttriggerchanged(a){this._onlefttriggerchanged=a}onrighttriggerchanged(a){this._onrighttriggerchanged=a}get leftTrigger(){return this._leftTrigger}set leftTrigger(a){this._onlefttriggerchanged&&this._leftTrigger!==a&&this._onlefttriggerchanged(a),this._leftTrigger=a}get rightTrigger(){return this._rightTrigger}set rightTrigger(a){this._onrighttriggerchanged&&this._rightTrigger!==a&&this._onrighttriggerchanged(a),this._rightTrigger=a}onbuttondown(a){this._onbuttondown=a}onbuttonup(a){this._onbuttonup=a}ondpaddown(a){this._ondpaddown=a}ondpadup(a){this._ondpadup=a}_setButtonValue(a,x,c){return a!==x&&(a===1&&(this._onbuttondown&&this._onbuttondown(c),this.onButtonDownObservable.notifyObservers(c)),a===0&&(this._onbuttonup&&this._onbuttonup(c),this.onButtonUpObservable.notifyObservers(c))),a}_setDPadValue(a,x,c){return a!==x&&(a===1&&(this._ondpaddown&&this._ondpaddown(c),this.onPadDownObservable.notifyObservers(c)),a===0&&(this._ondpadup&&this._ondpadup(c),this.onPadUpObservable.notifyObservers(c))),a}get buttonCross(){return this._buttonCross}set buttonCross(a){this._buttonCross=this._setButtonValue(a,this._buttonCross,hl.Cross)}get buttonCircle(){return this._buttonCircle}set buttonCircle(a){this._buttonCircle=this._setButtonValue(a,this._buttonCircle,hl.Circle)}get buttonSquare(){return this._buttonSquare}set buttonSquare(a){this._buttonSquare=this._setButtonValue(a,this._buttonSquare,hl.Square)}get buttonTriangle(){return this._buttonTriangle}set buttonTriangle(a){this._buttonTriangle=this._setButtonValue(a,this._buttonTriangle,hl.Triangle)}get buttonOptions(){return this._buttonOptions}set buttonOptions(a){this._buttonOptions=this._setButtonValue(a,this._buttonOptions,hl.Options)}get buttonShare(){return this._buttonShare}set buttonShare(a){this._buttonShare=this._setButtonValue(a,this._buttonShare,hl.Share)}get buttonL1(){return this._buttonL1}set buttonL1(a){this._buttonL1=this._setButtonValue(a,this._buttonL1,hl.L1)}get buttonR1(){return this._buttonR1}set buttonR1(a){this._buttonR1=this._setButtonValue(a,this._buttonR1,hl.R1)}get buttonLeftStick(){return this._buttonLeftStick}set buttonLeftStick(a){this._buttonLeftStick=this._setButtonValue(a,this._buttonLeftStick,hl.LeftStick)}get buttonRightStick(){return this._buttonRightStick}set buttonRightStick(a){this._buttonRightStick=this._setButtonValue(a,this._buttonRightStick,hl.RightStick)}get dPadUp(){return this._dPadUp}set dPadUp(a){this._dPadUp=this._setDPadValue(a,this._dPadUp,Eu.Up)}get dPadDown(){return this._dPadDown}set dPadDown(a){this._dPadDown=this._setDPadValue(a,this._dPadDown,Eu.Down)}get dPadLeft(){return this._dPadLeft}set dPadLeft(a){this._dPadLeft=this._setDPadValue(a,this._dPadLeft,Eu.Left)}get dPadRight(){return this._dPadRight}set dPadRight(a){this._dPadRight=this._setDPadValue(a,this._dPadRight,Eu.Right)}update(){super.update(),this.buttonCross=this.browserGamepad.buttons[0].value,this.buttonCircle=this.browserGamepad.buttons[1].value,this.buttonSquare=this.browserGamepad.buttons[2].value,this.buttonTriangle=this.browserGamepad.buttons[3].value,this.buttonL1=this.browserGamepad.buttons[4].value,this.buttonR1=this.browserGamepad.buttons[5].value,this.leftTrigger=this.browserGamepad.buttons[6].value,this.rightTrigger=this.browserGamepad.buttons[7].value,this.buttonShare=this.browserGamepad.buttons[8].value,this.buttonOptions=this.browserGamepad.buttons[9].value,this.buttonLeftStick=this.browserGamepad.buttons[10].value,this.buttonRightStick=this.browserGamepad.buttons[11].value,this.dPadUp=this.browserGamepad.buttons[12].value,this.dPadDown=this.browserGamepad.buttons[13].value,this.dPadLeft=this.browserGamepad.buttons[14].value,this.dPadRight=this.browserGamepad.buttons[15].value}dispose(){super.dispose(),this.onButtonDownObservable.clear(),this.onButtonUpObservable.clear(),this.onPadDownObservable.clear(),this.onPadUpObservable.clear()}}class YP{constructor(a){if(this._scene=a,this._babylonGamepads=[],this._oneGamepadConnected=!1,this._isMonitoring=!1,this.onGamepadDisconnectedObservable=new Jt,xa()?(this._gamepadEventSupported="GamepadEvent"in window,this._gamepadSupport=navigator&&navigator.getGamepads):this._gamepadEventSupported=!1,this.onGamepadConnectedObservable=new Jt(x=>{for(const c in this._babylonGamepads){const u=this._babylonGamepads[c];u&&u._isConnected&&this.onGamepadConnectedObservable.notifyObserver(x,u)}}),this._onGamepadConnectedEvent=x=>{const c=x.gamepad;if(c.index in this._babylonGamepads&&this._babylonGamepads[c.index].isConnected)return;let u;this._babylonGamepads[c.index]?(u=this._babylonGamepads[c.index],u.browserGamepad=c,u._isConnected=!0):u=this._addNewGamepad(c),this.onGamepadConnectedObservable.notifyObservers(u),this._startMonitoringGamepads()},this._onGamepadDisconnectedEvent=x=>{const c=x.gamepad;for(const u in this._babylonGamepads)if(this._babylonGamepads[u].index===c.index){const g=this._babylonGamepads[u];g._isConnected=!1,this.onGamepadDisconnectedObservable.notifyObservers(g),g.dispose&&g.dispose();break}},this._gamepadSupport)if(this._updateGamepadObjects(),this._babylonGamepads.length&&this._startMonitoringGamepads(),this._gamepadEventSupported){const x=this._scene?this._scene.getEngine().getHostWindow():window;x&&(x.addEventListener("gamepadconnected",this._onGamepadConnectedEvent,!1),x.addEventListener("gamepaddisconnected",this._onGamepadDisconnectedEvent,!1))}else this._startMonitoringGamepads()}get gamepads(){return this._babylonGamepads}getGamepadByType(a=ao.XBOX){for(const x of this._babylonGamepads)if(x&&x.type===a)return x;return null}dispose(){this._gamepadEventSupported&&(this._onGamepadConnectedEvent&&window.removeEventListener("gamepadconnected",this._onGamepadConnectedEvent),this._onGamepadDisconnectedEvent&&window.removeEventListener("gamepaddisconnected",this._onGamepadDisconnectedEvent),this._onGamepadConnectedEvent=null,this._onGamepadDisconnectedEvent=null),this._babylonGamepads.forEach(a=>{a.dispose()}),this.onGamepadConnectedObservable.clear(),this.onGamepadDisconnectedObservable.clear(),this._oneGamepadConnected=!1,this._stopMonitoringGamepads(),this._babylonGamepads=[]}_addNewGamepad(a){this._oneGamepadConnected||(this._oneGamepadConnected=!0);let x;const c=a.id.search("054c")!==-1&&a.id.search("0ce6")===-1,u=a.id.search("Xbox One")!==-1;return u||a.id.search("Xbox 360")!==-1||a.id.search("xinput")!==-1||a.id.search("045e")!==-1&&a.id.search("Surface Dock")===-1?x=new XP(a.id,a.index,a,u):c?x=new jP(a.id,a.index,a):x=new HP(a.id,a.index,a),this._babylonGamepads[x.index]=x,x}_startMonitoringGamepads(){this._isMonitoring||(this._isMonitoring=!0,this._checkGamepadsStatus())}_stopMonitoringGamepads(){this._isMonitoring=!1}_checkGamepadsStatus(){this._updateGamepadObjects();for(const a in this._babylonGamepads){const x=this._babylonGamepads[a];if(!(!x||!x.isConnected))try{x.update()}catch{this._loggedErrors.indexOf(x.index)===-1&&(_t.Warn(`Error updating gamepad ${x.id}`),this._loggedErrors.push(x.index))}}this._isMonitoring&&Bt.QueueNewFrame(()=>{this._checkGamepadsStatus()})}_updateGamepadObjects(){const a=navigator.getGamepads?navigator.getGamepads():[];for(let x=0;x<a.length;x++){const c=a[x];if(c)if(this._babylonGamepads[c.index])this._babylonGamepads[x].browserGamepad=c,this._babylonGamepads[x].isConnected||(this._babylonGamepads[x]._isConnected=!0,this.onGamepadConnectedObservable.notifyObservers(this._babylonGamepads[x]));else{const u=this._addNewGamepad(c);this.onGamepadConnectedObservable.notifyObservers(u)}}}}class xg{constructor(){this.gamepadAngularSensibility=200,this.gamepadMoveSensibility=40,this.deadzoneDelta=.1,this._yAxisScale=1,this._cameraTransform=vt.Identity(),this._deltaTransform=Ee.Zero(),this._vector3=Ee.Zero(),this._vector2=mr.Zero()}get invertYAxis(){return this._yAxisScale!==1}set invertYAxis(a){this._yAxisScale=a?-1:1}attachControl(){const a=this.camera.getScene().gamepadManager;this._onGamepadConnectedObserver=a.onGamepadConnectedObservable.add(x=>{x.type!==ao.POSE_ENABLED&&(!this.gamepad||x.type===ao.XBOX)&&(this.gamepad=x)}),this._onGamepadDisconnectedObserver=a.onGamepadDisconnectedObservable.add(x=>{this.gamepad===x&&(this.gamepad=null)}),this.gamepad=a.getGamepadByType(ao.XBOX),!this.gamepad&&a.gamepads.length&&(this.gamepad=a.gamepads[0])}detachControl(){this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver),this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver),this.gamepad=null}checkInputs(){if(this.gamepad&&this.gamepad.leftStick){const a=this.camera,x=this.gamepad.leftStick;this.gamepadMoveSensibility!==0&&(x.x=Math.abs(x.x)>this.deadzoneDelta?x.x/this.gamepadMoveSensibility:0,x.y=Math.abs(x.y)>this.deadzoneDelta?x.y/this.gamepadMoveSensibility:0);let c=this.gamepad.rightStick;c&&this.gamepadAngularSensibility!==0?(c.x=Math.abs(c.x)>this.deadzoneDelta?c.x/this.gamepadAngularSensibility:0,c.y=(Math.abs(c.y)>this.deadzoneDelta?c.y/this.gamepadAngularSensibility:0)*this._yAxisScale):c={x:0,y:0},a.rotationQuaternion?a.rotationQuaternion.toRotationMatrix(this._cameraTransform):vt.RotationYawPitchRollToRef(a.rotation.y,a.rotation.x,0,this._cameraTransform);const u=a._computeLocalCameraSpeed()*50;this._vector3.copyFromFloats(x.x*u,0,-x.y*u),Ee.TransformCoordinatesToRef(this._vector3,this._cameraTransform,this._deltaTransform),a.cameraDirection.addInPlace(this._deltaTransform),this._vector2.copyFromFloats(c.y,c.x),a.cameraRotation.addInPlace(this._vector2)}}getClassName(){return"FreeCameraGamepadInput"}getSimpleName(){return"gamepad"}}Ye([ht()],xg.prototype,"gamepadAngularSensibility",void 0),Ye([ht()],xg.prototype,"gamepadMoveSensibility",void 0),Bl.FreeCameraGamepadInput=xg;class MT{constructor(){this._currentActiveButton=-1,this.buttons=[0,1,2]}attachControl(a){a=_t.BackCompatCameraNoPreventDefault(arguments);const x=this.camera.getEngine(),c=x.getInputElement();let u=0,g=null;this._pointA=null,this._pointB=null,this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._pointerInput=v=>{const w=v.event,B=w.pointerType==="touch";if(v.type!==dr.POINTERMOVE&&this.buttons.indexOf(w.button)===-1)return;const W=w.target;if(this._altKey=w.altKey,this._ctrlKey=w.ctrlKey,this._metaKey=w.metaKey,this._shiftKey=w.shiftKey,this._buttonsPressed=w.buttons,x.isPointerLock){const ae=w.movementX,ue=w.movementY;this.onTouch(null,ae,ue),this._pointA=null,this._pointB=null}else{if(v.type!==dr.POINTERDOWN&&B&&this._pointA?.pointerId!==w.pointerId&&this._pointB?.pointerId!==w.pointerId)return;if(v.type===dr.POINTERDOWN&&(this._currentActiveButton===-1||B)){try{W?.setPointerCapture(w.pointerId)}catch{}if(this._pointA===null)this._pointA={x:w.clientX,y:w.clientY,pointerId:w.pointerId,type:w.pointerType};else if(this._pointB===null)this._pointB={x:w.clientX,y:w.clientY,pointerId:w.pointerId,type:w.pointerType};else return;this._currentActiveButton===-1&&!B&&(this._currentActiveButton=w.button),this.onButtonDown(w),a||(w.preventDefault(),c&&c.focus())}else if(v.type===dr.POINTERDOUBLETAP)this.onDoubleTap(w.pointerType);else if(v.type===dr.POINTERUP&&(this._currentActiveButton===w.button||B)){try{W?.releasePointerCapture(w.pointerId)}catch{}B||(this._pointB=null),x._badOS?this._pointA=this._pointB=null:this._pointB&&this._pointA&&this._pointA.pointerId==w.pointerId?(this._pointA=this._pointB,this._pointB=null):this._pointA&&this._pointB&&this._pointB.pointerId==w.pointerId?this._pointB=null:this._pointA=this._pointB=null,(u!==0||g)&&(this.onMultiTouch(this._pointA,this._pointB,u,0,g,null),u=0,g=null),this._currentActiveButton=-1,this.onButtonUp(w),a||w.preventDefault()}else if(v.type===dr.POINTERMOVE){if(a||w.preventDefault(),this._pointA&&this._pointB===null){const ae=w.clientX-this._pointA.x,ue=w.clientY-this._pointA.y;this.onTouch(this._pointA,ae,ue),this._pointA.x=w.clientX,this._pointA.y=w.clientY}else if(this._pointA&&this._pointB){const ae=this._pointA.pointerId===w.pointerId?this._pointA:this._pointB;ae.x=w.clientX,ae.y=w.clientY;const ue=this._pointA.x-this._pointB.x,fe=this._pointA.y-this._pointB.y,Re=ue*ue+fe*fe,_e={x:(this._pointA.x+this._pointB.x)/2,y:(this._pointA.y+this._pointB.y)/2,pointerId:w.pointerId,type:v.type};this.onMultiTouch(this._pointA,this._pointB,u,Re,g,_e),g=_e,u=Re}}}},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,dr.POINTERDOWN|dr.POINTERUP|dr.POINTERMOVE|dr.POINTERDOUBLETAP),this._onLostFocus=()=>{this._pointA=this._pointB=null,u=0,g=null,this.onLostFocus()},this._contextMenuBind=v=>this.onContextMenu(v),c&&c.addEventListener("contextmenu",this._contextMenuBind,!1);const y=this.camera.getScene().getEngine().getHostWindow();y&&_t.RegisterTopRootEvents(y,[{name:"blur",handler:this._onLostFocus}])}detachControl(){if(this._onLostFocus){const a=this.camera.getScene().getEngine().getHostWindow();a&&_t.UnregisterTopRootEvents(a,[{name:"blur",handler:this._onLostFocus}])}if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._contextMenuBind){const a=this.camera.getScene().getEngine().getInputElement();a&&a.removeEventListener("contextmenu",this._contextMenuBind)}this._onLostFocus=null}this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._currentActiveButton=-1}getClassName(){return"BaseCameraPointersInput"}getSimpleName(){return"pointers"}onDoubleTap(a){}onTouch(a,x,c){}onMultiTouch(a,x,c,u,g,y){}onContextMenu(a){a.preventDefault()}onButtonDown(a){}onButtonUp(a){}onLostFocus(){}}Ye([ht()],MT.prototype,"buttons",void 0);class $o extends MT{constructor(){super(...arguments),this.buttons=[0,1,2],this.angularSensibilityX=1e3,this.angularSensibilityY=1e3,this.pinchPrecision=12,this.pinchDeltaPercentage=0,this.useNaturalPinchZoom=!1,this.pinchZoom=!0,this.panningSensibility=1e3,this.multiTouchPanning=!0,this.multiTouchPanAndZoom=!0,this.pinchInwards=!0,this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}getClassName(){return"ArcRotateCameraPointersInput"}_computeMultiTouchPanning(a,x){if(this.panningSensibility!==0&&a&&x){const c=x.x-a.x,u=x.y-a.y;this.camera.inertialPanningX+=-c/this.panningSensibility,this.camera.inertialPanningY+=u/this.panningSensibility}}_computePinchZoom(a,x){const c=this.camera.radius||$o.MinimumRadiusForPinch;this.useNaturalPinchZoom?this.camera.radius=c*Math.sqrt(a)/Math.sqrt(x):this.pinchDeltaPercentage?this.camera.inertialRadiusOffset+=(x-a)*.001*c*this.pinchDeltaPercentage:this.camera.inertialRadiusOffset+=(x-a)/(this.pinchPrecision*(this.pinchInwards?1:-1)*(this.angularSensibilityX+this.angularSensibilityY)/2)}onTouch(a,x,c){this.panningSensibility!==0&&(this._ctrlKey&&this.camera._useCtrlForPanning||this._isPanClick)?(this.camera.inertialPanningX+=-x/this.panningSensibility,this.camera.inertialPanningY+=c/this.panningSensibility):(this.camera.inertialAlphaOffset-=x/this.angularSensibilityX,this.camera.inertialBetaOffset-=c/this.angularSensibilityY)}onDoubleTap(){this.camera.useInputToRestoreState&&this.camera.restoreState()}onMultiTouch(a,x,c,u,g,y){c===0&&g===null||u===0&&y===null||(this.multiTouchPanAndZoom?(this._computePinchZoom(c,u),this._computeMultiTouchPanning(g,y)):this.multiTouchPanning&&this.pinchZoom?(this._twoFingerActivityCount++,this._isPinching||this._twoFingerActivityCount<20&&Math.abs(Math.sqrt(u)-Math.sqrt(c))>this.camera.pinchToPanMaxDistance?(this._computePinchZoom(c,u),this._isPinching=!0):this._computeMultiTouchPanning(g,y)):this.multiTouchPanning?this._computeMultiTouchPanning(g,y):this.pinchZoom&&this._computePinchZoom(c,u))}onButtonDown(a){this._isPanClick=a.button===this.camera._panningMouseButton}onButtonUp(a){this._twoFingerActivityCount=0,this._isPinching=!1}onLostFocus(){this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}}$o.MinimumRadiusForPinch=.001,Ye([ht()],$o.prototype,"buttons",void 0),Ye([ht()],$o.prototype,"angularSensibilityX",void 0),Ye([ht()],$o.prototype,"angularSensibilityY",void 0),Ye([ht()],$o.prototype,"pinchPrecision",void 0),Ye([ht()],$o.prototype,"pinchDeltaPercentage",void 0),Ye([ht()],$o.prototype,"useNaturalPinchZoom",void 0),Ye([ht()],$o.prototype,"pinchZoom",void 0),Ye([ht()],$o.prototype,"panningSensibility",void 0),Ye([ht()],$o.prototype,"multiTouchPanning",void 0),Ye([ht()],$o.prototype,"multiTouchPanAndZoom",void 0),Bl.ArcRotateCameraPointersInput=$o;class Vl{constructor(){this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.keysReset=[220],this.panningSensibility=50,this.zoomingSensibility=25,this.useAltToZoom=!0,this.angularSpeed=.01,this._keys=new Array}attachControl(a){a=_t.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(x=>{const c=x.event;if(!c.metaKey){if(x.type===gu.KEYDOWN)this._ctrlPressed=c.ctrlKey,this._altPressed=c.altKey,(this.keysUp.indexOf(c.keyCode)!==-1||this.keysDown.indexOf(c.keyCode)!==-1||this.keysLeft.indexOf(c.keyCode)!==-1||this.keysRight.indexOf(c.keyCode)!==-1||this.keysReset.indexOf(c.keyCode)!==-1)&&(this._keys.indexOf(c.keyCode)===-1&&this._keys.push(c.keyCode),c.preventDefault&&(a||c.preventDefault()));else if(this.keysUp.indexOf(c.keyCode)!==-1||this.keysDown.indexOf(c.keyCode)!==-1||this.keysLeft.indexOf(c.keyCode)!==-1||this.keysRight.indexOf(c.keyCode)!==-1||this.keysReset.indexOf(c.keyCode)!==-1){const u=this._keys.indexOf(c.keyCode);u>=0&&this._keys.splice(u,1),c.preventDefault&&(a||c.preventDefault())}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const a=this.camera;for(let x=0;x<this._keys.length;x++){const c=this._keys[x];this.keysLeft.indexOf(c)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?a.inertialPanningX-=1/this.panningSensibility:a.inertialAlphaOffset-=this.angularSpeed:this.keysUp.indexOf(c)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?a.inertialPanningY+=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?a.inertialRadiusOffset+=1/this.zoomingSensibility:a.inertialBetaOffset-=this.angularSpeed:this.keysRight.indexOf(c)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?a.inertialPanningX+=1/this.panningSensibility:a.inertialAlphaOffset+=this.angularSpeed:this.keysDown.indexOf(c)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?a.inertialPanningY-=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?a.inertialRadiusOffset-=1/this.zoomingSensibility:a.inertialBetaOffset+=this.angularSpeed:this.keysReset.indexOf(c)!==-1&&a.useInputToRestoreState&&a.restoreState()}}}getClassName(){return"ArcRotateCameraKeyboardMoveInput"}getSimpleName(){return"keyboard"}}Ye([ht()],Vl.prototype,"keysUp",void 0),Ye([ht()],Vl.prototype,"keysDown",void 0),Ye([ht()],Vl.prototype,"keysLeft",void 0),Ye([ht()],Vl.prototype,"keysRight",void 0),Ye([ht()],Vl.prototype,"keysReset",void 0),Ye([ht()],Vl.prototype,"panningSensibility",void 0),Ye([ht()],Vl.prototype,"zoomingSensibility",void 0),Ye([ht()],Vl.prototype,"useAltToZoom",void 0),Ye([ht()],Vl.prototype,"angularSpeed",void 0),Bl.ArcRotateCameraKeyboardMoveInput=Vl;const $P=40;class lm{constructor(){this.wheelPrecision=3,this.zoomToMouseLocation=!1,this.wheelDeltaPercentage=0,this.customComputeDeltaFromMouseWheel=null,this._viewOffset=new Ee(0,0,0),this._globalOffset=new Ee(0,0,0),this._inertialPanning=Ee.Zero()}_computeDeltaFromMouseWheelLegacyEvent(a,x){let c=0;const u=a*.01*this.wheelDeltaPercentage*x;return a>0?c=u/(1+this.wheelDeltaPercentage):c=u*(1+this.wheelDeltaPercentage),c}attachControl(a){a=_t.BackCompatCameraNoPreventDefault(arguments),this._wheel=x=>{if(x.type!==dr.POINTERWHEEL)return;const c=x.event;let u=0;const g=c.deltaMode===_u.DOM_DELTA_LINE?$P:1,y=-(c.deltaY*g);if(this.customComputeDeltaFromMouseWheel)u=this.customComputeDeltaFromMouseWheel(y,this,c);else if(this.wheelDeltaPercentage){if(u=this._computeDeltaFromMouseWheelLegacyEvent(y,this.camera.radius),u>0){let v=this.camera.radius,w=this.camera.inertialRadiusOffset+u;for(let B=0;B<20&&Math.abs(w)>.001;B++)v-=w,w*=this.camera.inertia;v=_n.Clamp(v,0,Number.MAX_VALUE),u=this._computeDeltaFromMouseWheelLegacyEvent(y,v)}}else u=y/(this.wheelPrecision*40);u&&(this.zoomToMouseLocation?(this._hitPlane||this._updateHitPlane(),this._zoomToMouse(u)):this.camera.inertialRadiusOffset+=u),c.preventDefault&&(a||c.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,dr.POINTERWHEEL),this.zoomToMouseLocation&&this._inertialPanning.setAll(0)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null)}checkInputs(){if(!this.zoomToMouseLocation)return;const a=this.camera;0+a.inertialAlphaOffset+a.inertialBetaOffset+a.inertialRadiusOffset&&(this._updateHitPlane(),a.target.addInPlace(this._inertialPanning),this._inertialPanning.scaleInPlace(a.inertia),this._zeroIfClose(this._inertialPanning))}getClassName(){return"ArcRotateCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}_updateHitPlane(){const a=this.camera,x=a.target.subtract(a.position);this._hitPlane=al.FromPositionAndNormal(a.target,x)}_getPosition(){const a=this.camera,x=a.getScene(),c=x.createPickingRay(x.pointerX,x.pointerY,vt.Identity(),a,!1);(a.targetScreenOffset.x!==0||a.targetScreenOffset.y!==0)&&(this._viewOffset.set(a.targetScreenOffset.x,a.targetScreenOffset.y,0),a.getViewMatrix().invertToRef(a._cameraTransformMatrix),this._globalOffset=Ee.TransformNormal(this._viewOffset,a._cameraTransformMatrix),c.origin.addInPlace(this._globalOffset));let u=0;return this._hitPlane&&(u=c.intersectsPlane(this._hitPlane)??0),c.origin.addInPlace(c.direction.scaleInPlace(u))}_zoomToMouse(a){const x=this.camera,c=1-x.inertia;if(x.lowerRadiusLimit){const w=x.lowerRadiusLimit??0;x.radius-(x.inertialRadiusOffset+a)/c<w&&(a=(x.radius-w)*c-x.inertialRadiusOffset)}if(x.upperRadiusLimit){const w=x.upperRadiusLimit??0;x.radius-(x.inertialRadiusOffset+a)/c>w&&(a=(x.radius-w)*c-x.inertialRadiusOffset)}const g=a/c/x.radius,y=this._getPosition(),v=Yt.Vector3[6];y.subtractToRef(x.target,v),v.scaleInPlace(g),v.scaleInPlace(c),this._inertialPanning.addInPlace(v),x.inertialRadiusOffset+=a}_zeroIfClose(a){Math.abs(a.x)<Mi&&(a.x=0),Math.abs(a.y)<Mi&&(a.y=0),Math.abs(a.z)<Mi&&(a.z=0)}}Ye([ht()],lm.prototype,"wheelPrecision",void 0),Ye([ht()],lm.prototype,"zoomToMouseLocation",void 0),Ye([ht()],lm.prototype,"wheelDeltaPercentage",void 0),Bl.ArcRotateCameraMouseWheelInput=lm;class JP extends vT{constructor(a){super(a)}addMouseWheel(){return this.add(new lm),this}addPointers(){return this.add(new $o),this}addKeyboard(){return this.add(new Vl),this}}class lg{constructor(){this.gamepadRotationSensibility=80,this.gamepadMoveSensibility=40,this._yAxisScale=1}get invertYAxis(){return this._yAxisScale!==1}set invertYAxis(a){this._yAxisScale=a?-1:1}attachControl(){const a=this.camera.getScene().gamepadManager;this._onGamepadConnectedObserver=a.onGamepadConnectedObservable.add(x=>{x.type!==ao.POSE_ENABLED&&(!this.gamepad||x.type===ao.XBOX)&&(this.gamepad=x)}),this._onGamepadDisconnectedObserver=a.onGamepadDisconnectedObservable.add(x=>{this.gamepad===x&&(this.gamepad=null)}),this.gamepad=a.getGamepadByType(ao.XBOX),!this.gamepad&&a.gamepads.length&&(this.gamepad=a.gamepads[0])}detachControl(){this.camera.getScene().gamepadManager.onGamepadConnectedObservable.remove(this._onGamepadConnectedObserver),this.camera.getScene().gamepadManager.onGamepadDisconnectedObservable.remove(this._onGamepadDisconnectedObserver),this.gamepad=null}checkInputs(){if(this.gamepad){const a=this.camera,x=this.gamepad.rightStick;if(x){if(x.x!=0){const u=x.x/this.gamepadRotationSensibility;u!=0&&Math.abs(u)>.005&&(a.inertialAlphaOffset+=u)}if(x.y!=0){const u=x.y/this.gamepadRotationSensibility*this._yAxisScale;u!=0&&Math.abs(u)>.005&&(a.inertialBetaOffset+=u)}}const c=this.gamepad.leftStick;if(c&&c.y!=0){const u=c.y/this.gamepadMoveSensibility;u!=0&&Math.abs(u)>.005&&(this.camera.inertialRadiusOffset-=u)}}}getClassName(){return"ArcRotateCameraGamepadInput"}getSimpleName(){return"gamepad"}}Ye([ht()],lg.prototype,"gamepadRotationSensibility",void 0),Ye([ht()],lg.prototype,"gamepadMoveSensibility",void 0),Bl.ArcRotateCameraGamepadInput=lg,Object.defineProperty(H0.prototype,"gamepadManager",{get:function(){if(!this._gamepadManager){this._gamepadManager=new YP(this);let F=this._getComponent(Xs.NAME_GAMEPAD);F||(F=new tO(this),this._addComponent(F))}return this._gamepadManager},enumerable:!0,configurable:!0}),IT.prototype.addGamepad=function(){return this.add(new xg),this},JP.prototype.addGamepad=function(){return this.add(new lg),this};class tO{constructor(a){this.name=Xs.NAME_GAMEPAD,this.scene=a}register(){this.scene._beforeCameraUpdateStage.registerStep(Xs.STEP_BEFORECAMERAUPDATE_GAMEPAD,this,this._beforeCameraUpdate)}rebuild(){}dispose(){const a=this.scene._gamepadManager;a&&(a.dispose(),this.scene._gamepadManager=null)}_beforeCameraUpdate(){const a=this.scene._gamepadManager;a&&a._isMonitoring&&a._checkGamepadsStatus()}}fa.AddNodeConstructor("FreeCamera",(F,a)=>()=>new hg(F,Ee.Zero(),a));class hg extends RT{get gamepadAngularSensibility(){const a=this.inputs.attached.gamepad;return a?a.gamepadAngularSensibility:0}set gamepadAngularSensibility(a){const x=this.inputs.attached.gamepad;x&&(x.gamepadAngularSensibility=a)}get gamepadMoveSensibility(){const a=this.inputs.attached.gamepad;return a?a.gamepadMoveSensibility:0}set gamepadMoveSensibility(a){const x=this.inputs.attached.gamepad;x&&(x.gamepadMoveSensibility=a)}constructor(a,x,c){super(a,x,c),this.inputs.addGamepad()}getClassName(){return"UniversalCamera"}}gr._CreateDefaultParsedCamera=(F,a)=>new hg(F,Ee.Zero(),a);class BT{constructor(a,x,c){this.bu=a,this.bv=x,this.distance=c,this.faceId=0,this.subMeshId=0}}class J2{constructor(a,x,c){this.vectors=Ws.BuildArray(8,Ee.Zero),this.center=Ee.Zero(),this.centerWorld=Ee.Zero(),this.extendSize=Ee.Zero(),this.extendSizeWorld=Ee.Zero(),this.directions=Ws.BuildArray(3,Ee.Zero),this.vectorsWorld=Ws.BuildArray(8,Ee.Zero),this.minimumWorld=Ee.Zero(),this.maximumWorld=Ee.Zero(),this.minimum=Ee.Zero(),this.maximum=Ee.Zero(),this._drawWrapperFront=null,this._drawWrapperBack=null,this.reConstruct(a,x,c)}reConstruct(a,x,c){const u=a.x,g=a.y,y=a.z,v=x.x,w=x.y,B=x.z,W=this.vectors;this.minimum.copyFromFloats(u,g,y),this.maximum.copyFromFloats(v,w,B),W[0].copyFromFloats(u,g,y),W[1].copyFromFloats(v,w,B),W[2].copyFromFloats(v,g,y),W[3].copyFromFloats(u,w,y),W[4].copyFromFloats(u,g,B),W[5].copyFromFloats(v,w,y),W[6].copyFromFloats(u,w,B),W[7].copyFromFloats(v,g,B),x.addToRef(a,this.center).scaleInPlace(.5),x.subtractToRef(a,this.extendSize).scaleInPlace(.5),this._worldMatrix=c||vt.IdentityReadOnly,this._update(this._worldMatrix)}scale(a){const x=J2._TmpVector3,c=this.maximum.subtractToRef(this.minimum,x[0]),u=c.length();c.normalizeFromLength(u);const g=u*a,y=c.scaleInPlace(g*.5),v=this.center.subtractToRef(y,x[1]),w=this.center.addToRef(y,x[2]);return this.reConstruct(v,w,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(a){const x=this.minimumWorld,c=this.maximumWorld,u=this.directions,g=this.vectorsWorld,y=this.vectors;if(a.isIdentity()){x.copyFrom(this.minimum),c.copyFrom(this.maximum);for(let v=0;v<8;++v)g[v].copyFrom(y[v]);this.extendSizeWorld.copyFrom(this.extendSize),this.centerWorld.copyFrom(this.center)}else{x.setAll(Number.MAX_VALUE),c.setAll(-Number.MAX_VALUE);for(let v=0;v<8;++v){const w=g[v];Ee.TransformCoordinatesToRef(y[v],a,w),x.minimizeInPlace(w),c.maximizeInPlace(w)}c.subtractToRef(x,this.extendSizeWorld).scaleInPlace(.5),c.addToRef(x,this.centerWorld).scaleInPlace(.5)}Ee.FromArrayToRef(a.m,0,u[0]),Ee.FromArrayToRef(a.m,4,u[1]),Ee.FromArrayToRef(a.m,8,u[2]),this._worldMatrix=a}isInFrustum(a){return J2.IsInFrustum(this.vectorsWorld,a)}isCompletelyInFrustum(a){return J2.IsCompletelyInFrustum(this.vectorsWorld,a)}intersectsPoint(a){const x=this.minimumWorld,c=this.maximumWorld,u=x.x,g=x.y,y=x.z,v=c.x,w=c.y,B=c.z,W=a.x,ae=a.y,ue=a.z,fe=-Mi;return!(v-W<fe||fe>W-u||w-ae<fe||fe>ae-g||B-ue<fe||fe>ue-y)}intersectsSphere(a){return J2.IntersectsSphere(this.minimumWorld,this.maximumWorld,a.centerWorld,a.radiusWorld)}intersectsMinMax(a,x){const c=this.minimumWorld,u=this.maximumWorld,g=c.x,y=c.y,v=c.z,w=u.x,B=u.y,W=u.z,ae=a.x,ue=a.y,fe=a.z,Re=x.x,_e=x.y,Be=x.z;return!(w<ae||g>Re||B<ue||y>_e||W<fe||v>Be)}dispose(){this._drawWrapperFront?.dispose(),this._drawWrapperBack?.dispose()}static Intersects(a,x){return a.intersectsMinMax(x.minimumWorld,x.maximumWorld)}static IntersectsSphere(a,x,c,u){const g=J2._TmpVector3[0];return Ee.ClampToRef(c,a,x,g),Ee.DistanceSquared(c,g)<=u*u}static IsCompletelyInFrustum(a,x){for(let c=0;c<6;++c){const u=x[c];for(let g=0;g<8;++g)if(u.dotCoordinate(a[g])<0)return!1}return!0}static IsInFrustum(a,x){for(let c=0;c<6;++c){let u=!0;const g=x[c];for(let y=0;y<8;++y)if(g.dotCoordinate(a[y])>=0){u=!1;break}if(u)return!1}return!0}}J2._TmpVector3=Ws.BuildArray(3,Ee.Zero);class jh{constructor(a,x,c){this.center=Ee.Zero(),this.centerWorld=Ee.Zero(),this.minimum=Ee.Zero(),this.maximum=Ee.Zero(),this.reConstruct(a,x,c)}reConstruct(a,x,c){this.minimum.copyFrom(a),this.maximum.copyFrom(x);const u=Ee.Distance(a,x);x.addToRef(a,this.center).scaleInPlace(.5),this.radius=u*.5,this._update(c||vt.IdentityReadOnly)}scale(a){const x=this.radius*a,c=jh._TmpVector3,u=c[0].setAll(x),g=this.center.subtractToRef(u,c[1]),y=this.center.addToRef(u,c[2]);return this.reConstruct(g,y,this._worldMatrix),this}getWorldMatrix(){return this._worldMatrix}_update(a){if(a.isIdentity())this.centerWorld.copyFrom(this.center),this.radiusWorld=this.radius;else{Ee.TransformCoordinatesToRef(this.center,a,this.centerWorld);const x=jh._TmpVector3[0];Ee.TransformNormalFromFloatsToRef(1,1,1,a,x),this.radiusWorld=Math.max(Math.abs(x.x),Math.abs(x.y),Math.abs(x.z))*this.radius}}isInFrustum(a){const x=this.centerWorld,c=this.radiusWorld;for(let u=0;u<6;u++)if(a[u].dotCoordinate(x)<=-c)return!1;return!0}isCenterInFrustum(a){const x=this.centerWorld;for(let c=0;c<6;c++)if(a[c].dotCoordinate(x)<0)return!1;return!0}intersectsPoint(a){const x=Ee.DistanceSquared(this.centerWorld,a);return!(this.radiusWorld*this.radiusWorld<x)}static Intersects(a,x){const c=Ee.DistanceSquared(a.centerWorld,x.centerWorld),u=a.radiusWorld+x.radiusWorld;return!(u*u<c)}static CreateFromCenterAndRadius(a,x,c){this._TmpVector3[0].copyFrom(a),this._TmpVector3[1].copyFromFloats(0,0,x),this._TmpVector3[2].copyFrom(a),this._TmpVector3[0].addInPlace(this._TmpVector3[1]),this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);const u=new jh(this._TmpVector3[0],this._TmpVector3[2]);return c?u._worldMatrix=c:u._worldMatrix=vt.Identity(),u}}jh._TmpVector3=Ws.BuildArray(3,Ee.Zero);const o_={min:0,max:0},x_={min:0,max:0},UT=(F,a,x)=>{const c=Ee.Dot(a.centerWorld,F),u=Math.abs(Ee.Dot(a.directions[0],F))*a.extendSize.x,g=Math.abs(Ee.Dot(a.directions[1],F))*a.extendSize.y,y=Math.abs(Ee.Dot(a.directions[2],F))*a.extendSize.z,v=u+g+y;x.min=c-v,x.max=c+v},Jo=(F,a,x)=>(UT(F,a,o_),UT(F,x,x_),!(o_.min>x_.max||x_.min>o_.max));class tx{constructor(a,x,c){this._isLocked=!1,this.boundingBox=new J2(a,x,c),this.boundingSphere=new jh(a,x,c)}reConstruct(a,x,c){this.boundingBox.reConstruct(a,x,c),this.boundingSphere.reConstruct(a,x,c)}get minimum(){return this.boundingBox.minimum}get maximum(){return this.boundingBox.maximum}get isLocked(){return this._isLocked}set isLocked(a){this._isLocked=a}update(a){this._isLocked||(this.boundingBox._update(a),this.boundingSphere._update(a))}centerOn(a,x){const c=tx._TmpVector3[0].copyFrom(a).subtractInPlace(x),u=tx._TmpVector3[1].copyFrom(a).addInPlace(x);return this.boundingBox.reConstruct(c,u,this.boundingBox.getWorldMatrix()),this.boundingSphere.reConstruct(c,u,this.boundingBox.getWorldMatrix()),this}encapsulate(a){const x=Ee.Minimize(this.minimum,a),c=Ee.Maximize(this.maximum,a);return this.reConstruct(x,c,this.boundingBox.getWorldMatrix()),this}encapsulateBoundingInfo(a){const x=Yt.Matrix[0];this.boundingBox.getWorldMatrix().invertToRef(x);const c=Yt.Vector3[0];return Ee.TransformCoordinatesToRef(a.boundingBox.minimumWorld,x,c),this.encapsulate(c),Ee.TransformCoordinatesToRef(a.boundingBox.maximumWorld,x,c),this.encapsulate(c),this}scale(a){return this.boundingBox.scale(a),this.boundingSphere.scale(a),this}isInFrustum(a,x=0){return(x===2||x===3)&&this.boundingSphere.isCenterInFrustum(a)?!0:this.boundingSphere.isInFrustum(a)?x===1||x===3?!0:this.boundingBox.isInFrustum(a):!1}get diagonalLength(){const a=this.boundingBox;return a.maximumWorld.subtractToRef(a.minimumWorld,tx._TmpVector3[0]).length()}isCompletelyInFrustum(a){return this.boundingBox.isCompletelyInFrustum(a)}_checkCollision(a){return a._canDoCollision(this.boundingSphere.centerWorld,this.boundingSphere.radiusWorld,this.boundingBox.minimumWorld,this.boundingBox.maximumWorld)}intersectsPoint(a){return!(!this.boundingSphere.centerWorld||!this.boundingSphere.intersectsPoint(a)||!this.boundingBox.intersectsPoint(a))}intersects(a,x){if(!jh.Intersects(this.boundingSphere,a.boundingSphere)||!J2.Intersects(this.boundingBox,a.boundingBox))return!1;if(!x)return!0;const c=this.boundingBox,u=a.boundingBox;return!(!Jo(c.directions[0],c,u)||!Jo(c.directions[1],c,u)||!Jo(c.directions[2],c,u)||!Jo(u.directions[0],c,u)||!Jo(u.directions[1],c,u)||!Jo(u.directions[2],c,u)||!Jo(Ee.Cross(c.directions[0],u.directions[0]),c,u)||!Jo(Ee.Cross(c.directions[0],u.directions[1]),c,u)||!Jo(Ee.Cross(c.directions[0],u.directions[2]),c,u)||!Jo(Ee.Cross(c.directions[1],u.directions[0]),c,u)||!Jo(Ee.Cross(c.directions[1],u.directions[1]),c,u)||!Jo(Ee.Cross(c.directions[1],u.directions[2]),c,u)||!Jo(Ee.Cross(c.directions[2],u.directions[0]),c,u)||!Jo(Ee.Cross(c.directions[2],u.directions[1]),c,u)||!Jo(Ee.Cross(c.directions[2],u.directions[2]),c,u))}}tx._TmpVector3=Ws.BuildArray(2,Ee.Zero);class ug{static extractMinAndMaxIndexed(a,x,c,u,g,y){for(let v=c;v<c+u;v++){const w=x[v]*3,B=a[w],W=a[w+1],ae=a[w+2];g.minimizeInPlaceFromFloats(B,W,ae),y.maximizeInPlaceFromFloats(B,W,ae)}}static extractMinAndMax(a,x,c,u,g,y){for(let v=x,w=x*u;v<x+c;v++,w+=u){const B=a[w],W=a[w+1],ae=a[w+2];g.minimizeInPlaceFromFloats(B,W,ae),y.maximizeInPlaceFromFloats(B,W,ae)}}}Ye([Hc.filter((...[F,a])=>!Array.isArray(F)&&!Array.isArray(a))],ug,"extractMinAndMaxIndexed",null),Ye([Hc.filter((...[F])=>!Array.isArray(F))],ug,"extractMinAndMax",null);function aO(F,a,x,c,u=null){const g=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),y=new Ee(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return ug.extractMinAndMaxIndexed(F,a,x,c,g,y),u&&(g.x-=g.x*u.x+u.y,g.y-=g.y*u.x+u.y,g.z-=g.z*u.x+u.y,y.x+=y.x*u.x+u.y,y.y+=y.y*u.x+u.y,y.z+=y.z*u.x+u.y),{minimum:g,maximum:y}}function VT(F,a,x,c=null,u){const g=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),y=new Ee(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return u||(u=3),ug.extractMinAndMax(F,a,x,u,g,y),c&&(g.x-=g.x*c.x+c.y,g.y-=g.y*c.x+c.y,g.z-=g.z*c.x+c.y,y.x+=y.x*c.x+c.y,y.y+=y.y*c.x+c.y,y.z+=y.z*c.x+c.y),{minimum:g,maximum:y}}class ul{get materialDefines(){return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.defines:this._getDrawWrapper()?.defines}set materialDefines(a){const x=this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0);x.defines=a}_getDrawWrapper(a,x=!1){a=a??this._engine.currentRenderPassId;let c=this._drawWrappers[a];return!c&&x&&(this._drawWrappers[a]=c=new Yo(this._mesh.getScene().getEngine())),c}_removeDrawWrapper(a,x=!0){x&&this._drawWrappers[a]?.dispose(),this._drawWrappers[a]=void 0}get effect(){return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.effect:this._getDrawWrapper()?.effect??null}get _drawWrapper(){return this._mainDrawWrapperOverride??this._getDrawWrapper(void 0,!0)}get _drawWrapperOverride(){return this._mainDrawWrapperOverride}_setMainDrawWrapperOverride(a){this._mainDrawWrapperOverride=a}setEffect(a,x=null,c,u=!0){const g=this._drawWrapper;g.setEffect(a,x,u),c!==void 0&&(g.materialContext=c),a||(g.defines=null,g.materialContext=void 0)}resetDrawCache(a){if(this._drawWrappers)if(a!==void 0){this._removeDrawWrapper(a);return}else for(const x of this._drawWrappers)x?.dispose();this._drawWrappers=[]}static AddToMesh(a,x,c,u,g,y,v,w=!0){return new ul(a,x,c,u,g,y,v,w)}constructor(a,x,c,u,g,y,v,w=!0,B=!0){this.materialIndex=a,this.verticesStart=x,this.verticesCount=c,this.indexStart=u,this.indexCount=g,this._mainDrawWrapperOverride=null,this._linesIndexCount=0,this._linesIndexBuffer=null,this._lastColliderWorldVertices=null,this._lastColliderTransformMatrix=null,this._wasDispatched=!1,this._renderId=0,this._alphaIndex=0,this._distanceToCamera=0,this._currentMaterial=null,this._mesh=y,this._renderingMesh=v||y,B&&y.subMeshes.push(this),this._engine=this._mesh.getScene().getEngine(),this.resetDrawCache(),this._trianglePlanes=[],this._id=y.subMeshes.length-1,w&&(this.refreshBoundingInfo(),y.computeWorldMatrix(!0))}get IsGlobal(){return this.verticesStart===0&&this.verticesCount===this._mesh.getTotalVertices()&&this.indexStart===0&&this.indexCount===this._mesh.getTotalIndices()}getBoundingInfo(){return this.IsGlobal||this._mesh.hasThinInstances?this._mesh.getBoundingInfo():this._boundingInfo}setBoundingInfo(a){return this._boundingInfo=a,this}getMesh(){return this._mesh}getRenderingMesh(){return this._renderingMesh}getReplacementMesh(){return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null}getEffectiveMesh(){const a=this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null;return a||this._renderingMesh}getMaterial(a=!0){const x=this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)??this._renderingMesh.material;if(x){if(this._isMultiMaterial(x)){const c=x.getSubMaterial(this.materialIndex);return this._currentMaterial!==c&&(this._currentMaterial=c,this.resetDrawCache()),c}}else return a?this._mesh.getScene().defaultMaterial:null;return x}_isMultiMaterial(a){return a.getSubMaterial!==void 0}refreshBoundingInfo(a=null){if(this._lastColliderWorldVertices=null,this.IsGlobal||!this._renderingMesh||!this._renderingMesh.geometry)return this;if(a||(a=this._renderingMesh.getVerticesData(Ve.PositionKind)),!a)return this._boundingInfo=this._mesh.getBoundingInfo(),this;const x=this._renderingMesh.getIndices();let c;if(this.indexStart===0&&this.indexCount===x.length){const u=this._renderingMesh.getBoundingInfo();c={minimum:u.minimum.clone(),maximum:u.maximum.clone()}}else c=aO(a,x,this.indexStart,this.indexCount,this._renderingMesh.geometry.boundingBias);return this._boundingInfo?this._boundingInfo.reConstruct(c.minimum,c.maximum):this._boundingInfo=new tx(c.minimum,c.maximum),this}_checkCollision(a){return this.getBoundingInfo()._checkCollision(a)}updateBoundingInfo(a){let x=this.getBoundingInfo();return x||(this.refreshBoundingInfo(),x=this.getBoundingInfo()),x&&x.update(a),this}isInFrustum(a){const x=this.getBoundingInfo();return x?x.isInFrustum(a,this._mesh.cullingStrategy):!1}isCompletelyInFrustum(a){const x=this.getBoundingInfo();return x?x.isCompletelyInFrustum(a):!1}render(a){return this._renderingMesh.render(this,a,this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:void 0),this}_getLinesIndexBuffer(a,x){if(!this._linesIndexBuffer){const c=[];for(let u=this.indexStart;u<this.indexStart+this.indexCount;u+=3)c.push(a[u],a[u+1],a[u+1],a[u+2],a[u+2],a[u]);this._linesIndexBuffer=x.createIndexBuffer(c),this._linesIndexCount=c.length}return this._linesIndexBuffer}canIntersects(a){const x=this.getBoundingInfo();return x?a.intersectsBox(x.boundingBox):!1}intersects(a,x,c,u,g){const y=this.getMaterial();if(!y)return null;let v=3,w=!1;switch(y.fillMode){case 3:case 5:case 6:case 8:return null;case 7:v=1,w=!0;break;default:break}return y.fillMode===4?c.length?this._intersectLines(a,x,c,this._mesh.intersectionThreshold,u):this._intersectUnIndexedLines(a,x,c,this._mesh.intersectionThreshold,u):!c.length&&this._mesh._unIndexed?this._intersectUnIndexedTriangles(a,x,c,u,g):this._intersectTriangles(a,x,c,v,w,u,g)}_intersectLines(a,x,c,u,g){let y=null;for(let v=this.indexStart;v<this.indexStart+this.indexCount;v+=2){const w=x[c[v]],B=x[c[v+1]],W=a.intersectionSegment(w,B,u);if(!(W<0)&&(g||!y||W<y.distance)&&(y=new BT(null,null,W),y.faceId=v/2,g))break}return y}_intersectUnIndexedLines(a,x,c,u,g){let y=null;for(let v=this.verticesStart;v<this.verticesStart+this.verticesCount;v+=2){const w=x[v],B=x[v+1],W=a.intersectionSegment(w,B,u);if(!(W<0)&&(g||!y||W<y.distance)&&(y=new BT(null,null,W),y.faceId=v/2,g))break}return y}_intersectTriangles(a,x,c,u,g,y,v){let w=null,B=-1;for(let W=this.indexStart;W<this.indexStart+this.indexCount-(3-u);W+=u){B++;const ae=c[W],ue=c[W+1],fe=c[W+2];if(g&&fe===4294967295){W+=2;continue}const Re=x[ae],_e=x[ue],Be=x[fe];if(!Re||!_e||!Be||v&&!v(Re,_e,Be,a,ae,ue,fe))continue;const tt=a.intersectsTriangle(Re,_e,Be);if(tt){if(tt.distance<0)continue;if((y||!w||tt.distance<w.distance)&&(w=tt,w.faceId=B,y))break}}return w}_intersectUnIndexedTriangles(a,x,c,u,g){let y=null;for(let v=this.verticesStart;v<this.verticesStart+this.verticesCount;v+=3){const w=x[v],B=x[v+1],W=x[v+2];if(g&&!g(w,B,W,a,-1,-1,-1))continue;const ae=a.intersectsTriangle(w,B,W);if(ae){if(ae.distance<0)continue;if((u||!y||ae.distance<y.distance)&&(y=ae,y.faceId=v/3,u))break}}return y}_rebuild(){this._linesIndexBuffer&&(this._linesIndexBuffer=null)}clone(a,x){const c=new ul(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,a,x,!1);if(!this.IsGlobal){const u=this.getBoundingInfo();if(!u)return c;c._boundingInfo=new tx(u.minimum,u.maximum)}return c}dispose(){this._linesIndexBuffer&&(this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=null);const a=this._mesh.subMeshes.indexOf(this);this._mesh.subMeshes.splice(a,1),this.resetDrawCache()}getClassName(){return"SubMesh"}static CreateFromIndices(a,x,c,u,g,y=!0){let v=Number.MAX_VALUE,w=-Number.MAX_VALUE;const W=(g||u).getIndices();for(let ae=x;ae<x+c;ae++){const ue=W[ae];ue<v&&(v=ue),ue>w&&(w=ue)}return new ul(a,v,w-v+1,x,c,u,g,y)}}class tc{constructor(){this.reset()}reset(){this.enabled=!1,this.mask=255,this.func=519,this.funcRef=1,this.funcMask=255,this.opStencilFail=7680,this.opDepthFail=7680,this.opStencilDepthPass=7681}get func(){return this._func}set func(a){this._func=a}get funcRef(){return this._funcRef}set funcRef(a){this._funcRef=a}get funcMask(){return this._funcMask}set funcMask(a){this._funcMask=a}get opStencilFail(){return this._opStencilFail}set opStencilFail(a){this._opStencilFail=a}get opDepthFail(){return this._opDepthFail}set opDepthFail(a){this._opDepthFail=a}get opStencilDepthPass(){return this._opStencilDepthPass}set opStencilDepthPass(a){this._opStencilDepthPass=a}get mask(){return this._mask}set mask(a){this._mask=a}get enabled(){return this._enabled}set enabled(a){this._enabled=a}getClassName(){return"MaterialStencilState"}copyTo(a){hr.Clone(()=>a,this)}serialize(){return hr.Serialize(this)}parse(a,x,c){hr.Parse(()=>this,a,x,c)}}Ye([ht()],tc.prototype,"func",null),Ye([ht()],tc.prototype,"funcRef",null),Ye([ht()],tc.prototype,"funcMask",null),Ye([ht()],tc.prototype,"opStencilFail",null),Ye([ht()],tc.prototype,"opDepthFail",null),Ye([ht()],tc.prototype,"opStencilDepthPass",null),Ye([ht()],tc.prototype,"mask",null),Ye([ht()],tc.prototype,"enabled",null);var bo;(function(F){F[F.Created=1]="Created",F[F.Disposed=2]="Disposed",F[F.GetDefineNames=4]="GetDefineNames",F[F.PrepareUniformBuffer=8]="PrepareUniformBuffer",F[F.IsReadyForSubMesh=16]="IsReadyForSubMesh",F[F.PrepareDefines=32]="PrepareDefines",F[F.BindForSubMesh=64]="BindForSubMesh",F[F.PrepareEffect=128]="PrepareEffect",F[F.GetAnimatables=256]="GetAnimatables",F[F.GetActiveTextures=512]="GetActiveTextures",F[F.HasTexture=1024]="HasTexture",F[F.FillRenderTargetTextures=2048]="FillRenderTargetTextures",F[F.HasRenderTargetTextures=4096]="HasRenderTargetTextures",F[F.HardBindForSubMesh=8192]="HardBindForSubMesh"})(bo||(bo={}));function dg(F){F.indexOf("vClipPlane")===-1&&F.push("vClipPlane"),F.indexOf("vClipPlane2")===-1&&F.push("vClipPlane2"),F.indexOf("vClipPlane3")===-1&&F.push("vClipPlane3"),F.indexOf("vClipPlane4")===-1&&F.push("vClipPlane4"),F.indexOf("vClipPlane5")===-1&&F.push("vClipPlane5"),F.indexOf("vClipPlane6")===-1&&F.push("vClipPlane6")}function l_(F,a,x){const c=!!(F.clipPlane??a.clipPlane),u=!!(F.clipPlane2??a.clipPlane2),g=!!(F.clipPlane3??a.clipPlane3),y=!!(F.clipPlane4??a.clipPlane4),v=!!(F.clipPlane5??a.clipPlane5),w=!!(F.clipPlane6??a.clipPlane6);c&&x.push("#define CLIPPLANE"),u&&x.push("#define CLIPPLANE2"),g&&x.push("#define CLIPPLANE3"),y&&x.push("#define CLIPPLANE4"),v&&x.push("#define CLIPPLANE5"),w&&x.push("#define CLIPPLANE6")}function xO(F,a,x){let c=!1;const u=!!(F.clipPlane??a.clipPlane),g=!!(F.clipPlane2??a.clipPlane2),y=!!(F.clipPlane3??a.clipPlane3),v=!!(F.clipPlane4??a.clipPlane4),w=!!(F.clipPlane5??a.clipPlane5),B=!!(F.clipPlane6??a.clipPlane6);return x.CLIPPLANE!==u&&(x.CLIPPLANE=u,c=!0),x.CLIPPLANE2!==g&&(x.CLIPPLANE2=g,c=!0),x.CLIPPLANE3!==y&&(x.CLIPPLANE3=y,c=!0),x.CLIPPLANE4!==v&&(x.CLIPPLANE4=v,c=!0),x.CLIPPLANE5!==w&&(x.CLIPPLANE5=w,c=!0),x.CLIPPLANE6!==B&&(x.CLIPPLANE6=B,c=!0),c}function fg(F,a,x){let c=a.clipPlane??x.clipPlane;vu(F,"vClipPlane",c),c=a.clipPlane2??x.clipPlane2,vu(F,"vClipPlane2",c),c=a.clipPlane3??x.clipPlane3,vu(F,"vClipPlane3",c),c=a.clipPlane4??x.clipPlane4,vu(F,"vClipPlane4",c),c=a.clipPlane5??x.clipPlane5,vu(F,"vClipPlane5",c),c=a.clipPlane6??x.clipPlane6,vu(F,"vClipPlane6",c)}function vu(F,a,x){x&&F.setFloat4(a,x.normal.x,x.normal.y,x.normal.z,x.d)}const WT=Bs.Black(),HT={NUM_MORPH_INFLUENCERS:0};function XT(F,a,x){if(!F||F.LOGARITHMICDEPTH||F.indexOf&&F.indexOf("LOGARITHMICDEPTH")>=0){const c=x.activeCamera;c.mode===1&&Qt.Error("Logarithmic depth is not compatible with orthographic cameras!",20),a.setFloat("logarithmicDepthConstant",2/(Math.log(c.maxZ+1)/Math.LN2))}}function jT(F,a,x,c=!1){x&&F.fogEnabled&&(!a||a.applyFog)&&F.fogMode!==0&&(x.setFloat4("vFogInfos",F.fogMode,F.fogStart,F.fogEnd,F.fogDensity),c?(F.fogColor.toLinearSpaceToRef(WT,F.getEngine().useExactSrgbConversions),x.setColor3("vFogColor",WT)):x.setColor3("vFogColor",F.fogColor))}function YT(F,a,x){HT.NUM_MORPH_INFLUENCERS=x,$T(F,a,HT)}function $T(F,a,x){const c=x.NUM_MORPH_INFLUENCERS;if(c>0&&tr.LastCreatedEngine){const u=tr.LastCreatedEngine.getCaps().maxVertexAttribs,g=a.morphTargetManager;if(g?.isUsingTextureForTargets)return;const y=g&&g.supportsNormals&&x.NORMAL,v=g&&g.supportsTangents&&x.TANGENT,w=g&&g.supportsUVs&&x.UV1;for(let B=0;B<c;B++)F.push("position"+B),y&&F.push("normal"+B),v&&F.push("tangent"+B),w&&F.push("uv_"+B),F.length>u&&Qt.Error("Cannot add more vertex attributes for mesh "+a.name)}}function mg(F,a=!1){F.push("world0"),F.push("world1"),F.push("world2"),F.push("world3"),a&&(F.push("previousWorld0"),F.push("previousWorld1"),F.push("previousWorld2"),F.push("previousWorld3"))}function gg(F,a){const x=F.morphTargetManager;!F||!x||a.setFloatArray("morphTargetInfluences",x.influences)}function c_(F,a){a.bindToEffect(F,"Scene")}function $a(F,a,x){a._needUVs=!0,a[x]=!0,F.optimizeUVAllocation&&F.getTextureMatrix().isIdentityAs3x2()?(a[x+"DIRECTUV"]=F.coordinatesIndex+1,a["MAINUV"+(F.coordinatesIndex+1)]=!0):a[x+"DIRECTUV"]=0}function ba(F,a,x){const c=F.getTextureMatrix();a.updateMatrix(x+"Matrix",c)}function JT(F,a,x){x.BAKED_VERTEX_ANIMATION_TEXTURE&&x.INSTANCES&&F.push("bakedVertexAnimationSettingsInstanced")}function lO(F,a){return a.set(F),a}function tb(F,a,x){if(!(!a||!F)&&(F.computeBonesUsingShaders&&a._bonesComputationForcedToCPU&&(F.computeBonesUsingShaders=!1),F.useBones&&F.computeBonesUsingShaders&&F.skeleton)){const c=F.skeleton;if(c.isUsingTextureForMatrices&&a.getUniformIndex("boneTextureWidth")>-1){const u=c.getTransformMatrixTexture(F);a.setTexture("boneSampler",u),a.setFloat("boneTextureWidth",4*(c.bones.length+1))}else{const u=c.getTransformMatrices(F);u&&(a.setMatrices("mBones",u),x&&F.getScene().prePassRenderer&&F.getScene().prePassRenderer.getIndex(2)&&(x.previousBones[F.uniqueId]||(x.previousBones[F.uniqueId]=u.slice()),a.setMatrices("mPreviousBones",x.previousBones[F.uniqueId]),lO(u,x.previousBones[F.uniqueId])))}}}function j3(F,a,x){F.transferToEffect(a,x+"")}function hO(F,a,x,c,u,g=!0){F._bindLight(a,x,c,u,g)}function uO(F,a,x,c,u=4){const g=Math.min(a.lightSources.length,u);for(let y=0;y<g;y++){const v=a.lightSources[y];hO(v,y,F,x,typeof c=="boolean"?c:c.SPECULARTERM,a.receiveShadows)}}function dO(F,a,x,c){x.NUM_BONE_INFLUENCERS>0&&(c.addCPUSkinningFallback(0,a),F.push("matricesIndices"),F.push("matricesWeights"),x.NUM_BONE_INFLUENCERS>4&&(F.push("matricesIndicesExtra"),F.push("matricesWeightsExtra")))}function fO(F,a){(a.INSTANCES||a.THIN_INSTANCES)&&mg(F,!!a.PREPASS_VELOCITY),a.INSTANCESCOLOR&&F.push("instanceColor")}function mO(F,a,x=4,c=0){let u=0;for(let g=0;g<x&&F["LIGHT"+g];g++)g>0&&(u=c+g,a.addFallback(u,"LIGHT"+g)),F.SHADOWS||(F["SHADOW"+g]&&a.addFallback(c,"SHADOW"+g),F["SHADOWPCF"+g]&&a.addFallback(c,"SHADOWPCF"+g),F["SHADOWPCSS"+g]&&a.addFallback(c,"SHADOWPCSS"+g),F["SHADOWPOISSON"+g]&&a.addFallback(c,"SHADOWPOISSON"+g),F["SHADOWESM"+g]&&a.addFallback(c,"SHADOWESM"+g),F["SHADOWCLOSEESM"+g]&&a.addFallback(c,"SHADOWCLOSEESM"+g));return u++}function gO(F,a){return a.fogEnabled&&F.applyFog&&a.fogMode!==0}function _O(F,a,x,c,u,g,y,v=!1){y._areMiscDirty&&(y.LOGARITHMICDEPTH=x,y.POINTSIZE=c,y.FOG=u&&gO(F,a),y.NONUNIFORMSCALING=F.nonUniformScaling,y.ALPHATEST=g,y.DECAL_AFTER_DETAIL=v)}function yO(F,a,x,c,u=4,g=!1){if(!x._areLightsDirty)return x._needNormals;let y=0;const v={needNormals:x._needNormals,needRebuild:!1,lightmapMode:!1,shadowEnabled:!1,specularEnabled:!1};if(F.lightsEnabled&&!g){for(const B of a.lightSources)if(bO(F,a,B,y,x,c,v),y++,y===u)break}x.SPECULARTERM=v.specularEnabled,x.SHADOWS=v.shadowEnabled;for(let B=y;B<u;B++)x["LIGHT"+B]!==void 0&&(x["LIGHT"+B]=!1,x["HEMILIGHT"+B]=!1,x["POINTLIGHT"+B]=!1,x["DIRLIGHT"+B]=!1,x["SPOTLIGHT"+B]=!1,x["SHADOW"+B]=!1,x["SHADOWCSM"+B]=!1,x["SHADOWCSMDEBUG"+B]=!1,x["SHADOWCSMNUM_CASCADES"+B]=!1,x["SHADOWCSMUSESHADOWMAXZ"+B]=!1,x["SHADOWCSMNOBLEND"+B]=!1,x["SHADOWCSM_RIGHTHANDED"+B]=!1,x["SHADOWPCF"+B]=!1,x["SHADOWPCSS"+B]=!1,x["SHADOWPOISSON"+B]=!1,x["SHADOWESM"+B]=!1,x["SHADOWCLOSEESM"+B]=!1,x["SHADOWCUBE"+B]=!1,x["SHADOWLOWQUALITY"+B]=!1,x["SHADOWMEDIUMQUALITY"+B]=!1);const w=F.getEngine().getCaps();return x.SHADOWFLOAT===void 0&&(v.needRebuild=!0),x.SHADOWFLOAT=v.shadowEnabled&&(w.textureFloatRender&&w.textureFloatLinearFiltering||w.textureHalfFloatRender&&w.textureHalfFloatLinearFiltering),x.LIGHTMAPEXCLUDED=v.lightmapMode,v.needRebuild&&x.rebuild(),v.needNormals}function bO(F,a,x,c,u,g,y){switch(y.needNormals=!0,u["LIGHT"+c]===void 0&&(y.needRebuild=!0),u["LIGHT"+c]=!0,u["SPOTLIGHT"+c]=!1,u["HEMILIGHT"+c]=!1,u["POINTLIGHT"+c]=!1,u["DIRLIGHT"+c]=!1,x.prepareLightSpecificDefines(u,c),u["LIGHT_FALLOFF_PHYSICAL"+c]=!1,u["LIGHT_FALLOFF_GLTF"+c]=!1,u["LIGHT_FALLOFF_STANDARD"+c]=!1,x.falloffType){case vn.FALLOFF_GLTF:u["LIGHT_FALLOFF_GLTF"+c]=!0;break;case vn.FALLOFF_PHYSICAL:u["LIGHT_FALLOFF_PHYSICAL"+c]=!0;break;case vn.FALLOFF_STANDARD:u["LIGHT_FALLOFF_STANDARD"+c]=!0;break}if(g&&!x.specular.equalsFloats(0,0,0)&&(y.specularEnabled=!0),u["SHADOW"+c]=!1,u["SHADOWCSM"+c]=!1,u["SHADOWCSMDEBUG"+c]=!1,u["SHADOWCSMNUM_CASCADES"+c]=!1,u["SHADOWCSMUSESHADOWMAXZ"+c]=!1,u["SHADOWCSMNOBLEND"+c]=!1,u["SHADOWCSM_RIGHTHANDED"+c]=!1,u["SHADOWPCF"+c]=!1,u["SHADOWPCSS"+c]=!1,u["SHADOWPOISSON"+c]=!1,u["SHADOWESM"+c]=!1,u["SHADOWCLOSEESM"+c]=!1,u["SHADOWCUBE"+c]=!1,u["SHADOWLOWQUALITY"+c]=!1,u["SHADOWMEDIUMQUALITY"+c]=!1,a&&a.receiveShadows&&F.shadowsEnabled&&x.shadowEnabled){const v=x.getShadowGenerator(F.activeCamera)??x.getShadowGenerator();if(v){const w=v.getShadowMap();w&&w.renderList&&w.renderList.length>0&&(y.shadowEnabled=!0,v.prepareDefines(u,c))}}x.lightmapMode!=vn.LIGHTMAP_DEFAULT?(y.lightmapMode=!0,u["LIGHTMAPEXCLUDED"+c]=!0,u["LIGHTMAPNOSPECULAR"+c]=x.lightmapMode==vn.LIGHTMAP_SHADOWSONLY):(u["LIGHTMAPEXCLUDED"+c]=!1,u["LIGHTMAPNOSPECULAR"+c]=!1)}function EO(F,a,x,c,u,g=null,y=!1){let v=WO(F,c);g!==!1&&(v=xO(x,F,c)),c.DEPTHPREPASS!==!a.getColorWrite()&&(c.DEPTHPREPASS=!c.DEPTHPREPASS,v=!0),c.INSTANCES!==u&&(c.INSTANCES=u,v=!0),c.THIN_INSTANCES!==y&&(c.THIN_INSTANCES=y,v=!0),v&&c.markAsUnprocessed()}function vO(F,a){if(F.useBones&&F.computeBonesUsingShaders&&F.skeleton){a.NUM_BONE_INFLUENCERS=F.numBoneInfluencers;const x=a.BONETEXTURE!==void 0;if(F.skeleton.isUsingTextureForMatrices&&x)a.BONETEXTURE=!0;else{a.BonesPerMesh=F.skeleton.bones.length+1,a.BONETEXTURE=x?!1:void 0;const c=F.getScene().prePassRenderer;if(c&&c.enabled){const u=c.excludedSkinnedMesh.indexOf(F)===-1;a.BONES_VELOCITY_ENABLED=u}}}else a.NUM_BONE_INFLUENCERS=0,a.BonesPerMesh=0,a.BONETEXTURE!==void 0&&(a.BONETEXTURE=!1)}function IO(F,a){const x=F.morphTargetManager;x?(a.MORPHTARGETS_UV=x.supportsUVs&&a.UV1,a.MORPHTARGETS_TANGENT=x.supportsTangents&&a.TANGENT,a.MORPHTARGETS_NORMAL=x.supportsNormals&&a.NORMAL,a.NUM_MORPH_INFLUENCERS=x.numMaxInfluencers||x.numInfluencers,a.MORPHTARGETS=a.NUM_MORPH_INFLUENCERS>0,a.MORPHTARGETS_TEXTURE=x.isUsingTextureForTargets):(a.MORPHTARGETS_UV=!1,a.MORPHTARGETS_TANGENT=!1,a.MORPHTARGETS_NORMAL=!1,a.MORPHTARGETS=!1,a.NUM_MORPH_INFLUENCERS=0)}function RO(F,a){const x=F.bakedVertexAnimationManager;a.BAKED_VERTEX_ANIMATION_TEXTURE=!!(x&&x.isEnabled)}function MO(F,a,x,c,u=!1,g=!0,y=!0){if(!a._areAttributesDirty&&a._needNormals===a._normals&&a._needUVs===a._uvs)return!1;a._normals=a._needNormals,a._uvs=a._needUVs,a.NORMAL=a._needNormals&&F.isVerticesDataPresent("normal"),a._needNormals&&F.isVerticesDataPresent("tangent")&&(a.TANGENT=!0);for(let v=1;v<=6;++v)a["UV"+v]=a._needUVs?F.isVerticesDataPresent(`uv${v===1?"":v}`):!1;if(x){const v=F.useVertexColors&&F.isVerticesDataPresent("color");a.VERTEXCOLOR=v,a.VERTEXALPHA=F.hasVertexAlpha&&v&&g}return F.isVerticesDataPresent("instanceColor")&&(F.hasInstances||F.hasThinInstances)&&(a.INSTANCESCOLOR=!0),c&&vO(F,a),u&&IO(F,a),y&&RO(F,a),!0}function BO(F,a){if(F.activeCamera){const x=a.MULTIVIEW;a.MULTIVIEW=F.activeCamera.outputRenderTarget!==null&&F.activeCamera.outputRenderTarget.getViewCount()>1,a.MULTIVIEW!=x&&a.markAsUnprocessed()}}function UO(F,a,x){const c=a.ORDER_INDEPENDENT_TRANSPARENCY,u=a.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;a.ORDER_INDEPENDENT_TRANSPARENCY=F.useOrderIndependentTransparency&&x,a.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!F.getEngine().getCaps().textureFloatLinearFiltering,(c!==a.ORDER_INDEPENDENT_TRANSPARENCY||u!==a.ORDER_INDEPENDENT_TRANSPARENCY_16BITS)&&a.markAsUnprocessed()}function VO(F,a,x){const c=a.PREPASS;if(!a._arePrePassDirty)return;const u=[{type:1,define:"PREPASS_POSITION",index:"PREPASS_POSITION_INDEX"},{type:2,define:"PREPASS_VELOCITY",index:"PREPASS_VELOCITY_INDEX"},{type:3,define:"PREPASS_REFLECTIVITY",index:"PREPASS_REFLECTIVITY_INDEX"},{type:0,define:"PREPASS_IRRADIANCE",index:"PREPASS_IRRADIANCE_INDEX"},{type:7,define:"PREPASS_ALBEDO_SQRT",index:"PREPASS_ALBEDO_SQRT_INDEX"},{type:5,define:"PREPASS_DEPTH",index:"PREPASS_DEPTH_INDEX"},{type:6,define:"PREPASS_NORMAL",index:"PREPASS_NORMAL_INDEX"}];if(F.prePassRenderer&&F.prePassRenderer.enabled&&x){a.PREPASS=!0,a.SCENE_MRT_COUNT=F.prePassRenderer.mrtCount,a.PREPASS_NORMAL_WORLDSPACE=F.prePassRenderer.generateNormalsInWorldSpace;for(let g=0;g<u.length;g++){const y=F.prePassRenderer.getIndex(u[g].type);y!==-1?(a[u[g].define]=!0,a[u[g].index]=y):a[u[g].define]=!1}}else{a.PREPASS=!1;for(let g=0;g<u.length;g++)a[u[g].define]=!1}a.PREPASS!=c&&(a.markAsUnprocessed(),a.markAsImageProcessingDirty())}function WO(F,a){let x=!1;if(F.activeCamera){const c=a.CAMERA_ORTHOGRAPHIC?1:0,u=a.CAMERA_PERSPECTIVE?1:0,g=F.activeCamera.mode===1?1:0,y=F.activeCamera.mode===0?1:0;(c^g||u^y)&&(a.CAMERA_ORTHOGRAPHIC=g===1,a.CAMERA_PERSPECTIVE=y===1,x=!0)}return x}function HO(F,a,x,c,u=null,g=!1){u&&u.push("Light"+F),!g&&(a.push("vLightData"+F,"vLightDiffuse"+F,"vLightSpecular"+F,"vLightDirection"+F,"vLightFalloff"+F,"vLightGround"+F,"lightMatrix"+F,"shadowsInfo"+F,"depthValues"+F),x.push("shadowSampler"+F),x.push("depthSampler"+F),a.push("viewFrustumZ"+F,"cascadeBlendFactor"+F,"lightSizeUVCorrection"+F,"depthCorrection"+F,"penumbraDarkness"+F,"frustumLengths"+F),c&&(x.push("projectionLightSampler"+F),a.push("textureProjectionMatrix"+F)))}function XO(F,a,x,c=4){let u,g=null;if(F.uniformsNames){const y=F;u=y.uniformsNames,g=y.uniformBuffersNames,a=y.samplers,x=y.defines,c=y.maxSimultaneousLights||0}else u=F,a||(a=[]);for(let y=0;y<c&&x["LIGHT"+y];y++)HO(y,u,a,x["PROJECTEDLIGHTTEXTURE"+y],g);x.NUM_MORPH_INFLUENCERS&&(u.push("morphTargetInfluences"),u.push("morphTargetCount")),x.BAKED_VERTEX_ANIMATION_TEXTURE&&(u.push("bakedVertexAnimationSettings"),u.push("bakedVertexAnimationTextureSizeInverted"),u.push("bakedVertexAnimationTime"),a.push("bakedVertexAnimationTexture"))}class ui{get canRenderToMRT(){return!1}set alpha(a){if(this._alpha===a)return;const x=this._alpha;this._alpha=a,(x===1||a===1)&&this.markAsDirty(ui.MiscDirtyFlag+ui.PrePassDirtyFlag)}get alpha(){return this._alpha}set backFaceCulling(a){this._backFaceCulling!==a&&(this._backFaceCulling=a,this.markAsDirty(ui.TextureDirtyFlag))}get backFaceCulling(){return this._backFaceCulling}set cullBackFaces(a){this._cullBackFaces!==a&&(this._cullBackFaces=a,this.markAsDirty(ui.TextureDirtyFlag))}get cullBackFaces(){return this._cullBackFaces}get blockDirtyMechanism(){return this._blockDirtyMechanism}set blockDirtyMechanism(a){this._blockDirtyMechanism!==a&&(this._blockDirtyMechanism=a,a||this.markDirty())}atomicMaterialsUpdate(a){this.blockDirtyMechanism=!0;try{a(this)}finally{this.blockDirtyMechanism=!1}}get hasRenderTargetTextures(){return this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._eventInfo.hasRenderTargetTextures}set onDispose(a){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(a)}get onBindObservable(){return this._onBindObservable||(this._onBindObservable=new Jt),this._onBindObservable}set onBind(a){this._onBindObserver&&this.onBindObservable.remove(this._onBindObserver),this._onBindObserver=this.onBindObservable.add(a)}get onUnBindObservable(){return this._onUnBindObservable||(this._onUnBindObservable=new Jt),this._onUnBindObservable}get onEffectCreatedObservable(){return this._onEffectCreatedObservable||(this._onEffectCreatedObservable=new Jt),this._onEffectCreatedObservable}set alphaMode(a){this._alphaMode!==a&&(this._alphaMode=a,this.markAsDirty(ui.TextureDirtyFlag))}get alphaMode(){return this._alphaMode}set needDepthPrePass(a){this._needDepthPrePass!==a&&(this._needDepthPrePass=a,this._needDepthPrePass&&(this.checkReadyOnEveryCall=!0))}get needDepthPrePass(){return this._needDepthPrePass}get isPrePassCapable(){return!1}set fogEnabled(a){this._fogEnabled!==a&&(this._fogEnabled=a,this.markAsDirty(ui.MiscDirtyFlag))}get fogEnabled(){return this._fogEnabled}get wireframe(){switch(this._fillMode){case ui.WireFrameFillMode:case ui.LineListDrawMode:case ui.LineLoopDrawMode:case ui.LineStripDrawMode:return!0}return this._scene.forceWireframe}set wireframe(a){this.fillMode=a?ui.WireFrameFillMode:ui.TriangleFillMode}get pointsCloud(){switch(this._fillMode){case ui.PointFillMode:case ui.PointListDrawMode:return!0}return this._scene.forcePointsCloud}set pointsCloud(a){this.fillMode=a?ui.PointFillMode:ui.TriangleFillMode}get fillMode(){return this._fillMode}set fillMode(a){this._fillMode!==a&&(this._fillMode=a,this.markAsDirty(ui.MiscDirtyFlag))}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(a){const x=this.getScene().getEngine().getCaps().fragmentDepthSupported;a&&!x&&Qt.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it."),this._useLogarithmicDepth=a&&x,this._markAllSubMeshesAsMiscDirty()}_getDrawWrapper(){return this._drawWrapper}_setDrawWrapper(a){this._drawWrapper=a}constructor(a,x,c){this.shadowDepthWrapper=null,this.allowShaderHotSwapping=!0,this.metadata=null,this.reservedDataStore=null,this.checkReadyOnEveryCall=!1,this.checkReadyOnlyOnce=!1,this.state="",this._alpha=1,this._backFaceCulling=!0,this._cullBackFaces=!0,this._blockDirtyMechanism=!1,this.onCompiled=null,this.onError=null,this.getRenderTargetTextures=null,this.doNotSerialize=!1,this._storeEffectOnSubMeshes=!1,this.animations=null,this.onDisposeObservable=new Jt,this._onDisposeObserver=null,this._onUnBindObservable=null,this._onBindObserver=null,this._alphaMode=2,this._needDepthPrePass=!1,this.disableDepthWrite=!1,this.disableColorWrite=!1,this.forceDepthWrite=!1,this.depthFunction=0,this.separateCullingPass=!1,this._fogEnabled=!0,this.pointSize=1,this.zOffset=0,this.zOffsetUnits=0,this.stencil=new tc,this._useUBO=!1,this._fillMode=ui.TriangleFillMode,this._cachedDepthWriteState=!1,this._cachedColorWriteState=!1,this._cachedDepthFunctionState=0,this._indexInSceneMaterialArray=-1,this.meshMap=null,this._parentContainer=null,this._uniformBufferLayoutBuilt=!1,this._eventInfo={},this._callbackPluginEventGeneric=()=>{},this._callbackPluginEventIsReadyForSubMesh=()=>{},this._callbackPluginEventPrepareDefines=()=>{},this._callbackPluginEventPrepareDefinesBeforeAttributes=()=>{},this._callbackPluginEventHardBindForSubMesh=()=>{},this._callbackPluginEventBindForSubMesh=()=>{},this._callbackPluginEventHasRenderTargetTextures=()=>{},this._callbackPluginEventFillRenderTargetTextures=()=>{},this._forceAlphaTest=!1,this._transparencyMode=null,this.name=a;const u=x||tr.LastCreatedScene;u&&(this._scene=u,this._dirtyCallbacks={},this._dirtyCallbacks[1]=this._markAllSubMeshesAsTexturesDirty.bind(this),this._dirtyCallbacks[2]=this._markAllSubMeshesAsLightsDirty.bind(this),this._dirtyCallbacks[4]=this._markAllSubMeshesAsFresnelDirty.bind(this),this._dirtyCallbacks[8]=this._markAllSubMeshesAsAttributesDirty.bind(this),this._dirtyCallbacks[16]=this._markAllSubMeshesAsMiscDirty.bind(this),this._dirtyCallbacks[32]=this._markAllSubMeshesAsPrePassDirty.bind(this),this._dirtyCallbacks[63]=this._markAllSubMeshesAsAllDirty.bind(this),this.id=a||_t.RandomId(),this.uniqueId=this._scene.getUniqueId(),this._materialContext=this._scene.getEngine().createMaterialContext(),this._drawWrapper=new Yo(this._scene.getEngine(),!1),this._drawWrapper.materialContext=this._materialContext,this._scene.useRightHandedSystem?this.sideOrientation=ui.ClockWiseSideOrientation:this.sideOrientation=ui.CounterClockWiseSideOrientation,this._uniformBuffer=new ys(this._scene.getEngine(),void 0,void 0,a),this._useUBO=this.getScene().getEngine().supportsUniformBuffers,c||this._scene.addMaterial(this),this._scene.useMaterialMeshMap&&(this.meshMap={}),ui.OnEventObservable.notifyObservers(this,bo.Created))}toString(a){return"Name: "+this.name}getClassName(){return"Material"}get _isMaterial(){return!0}get isFrozen(){return this.checkReadyOnlyOnce}freeze(){this.markDirty(),this.checkReadyOnlyOnce=!0}unfreeze(){this.markDirty(),this.checkReadyOnlyOnce=!1}isReady(a,x){return!0}isReadyForSubMesh(a,x,c){const u=x.materialDefines;return u?(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=u,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),this._eventInfo.isReadyForSubMesh):!1}getEffect(){return this._drawWrapper.effect}getScene(){return this._scene}get transparencyMode(){return this._transparencyMode}set transparencyMode(a){this._transparencyMode!==a&&(this._transparencyMode=a,this._forceAlphaTest=a===ui.MATERIAL_ALPHATESTANDBLEND,this._markAllSubMeshesAsTexturesAndMiscDirty())}get _disableAlphaBlending(){return this._transparencyMode===ui.MATERIAL_OPAQUE||this._transparencyMode===ui.MATERIAL_ALPHATEST}needAlphaBlending(){return this._disableAlphaBlending?!1:this.alpha<1}needAlphaBlendingForMesh(a){return a.visibility<1?!0:this._disableAlphaBlending?!1:a.hasVertexAlpha||this.needAlphaBlending()}needAlphaTesting(){return!!this._forceAlphaTest}_shouldTurnAlphaTestOn(a){return!this.needAlphaBlendingForMesh(a)&&this.needAlphaTesting()}getAlphaTestTexture(){return null}markDirty(a=!1){const x=this.getScene().meshes;for(const c of x)if(c.subMeshes){for(const u of c.subMeshes)if(u.getMaterial()===this)for(const g of u._drawWrappers)g&&this._materialContext===g.materialContext&&(g._wasPreviouslyReady=!1,g._wasPreviouslyUsingInstances=null,g._forceRebindOnNextCall=a)}a&&this.markAsDirty(ui.AllDirtyFlag)}_preBind(a,x=null){const c=this._scene.getEngine(),g=(x??this.sideOrientation)===ui.ClockWiseSideOrientation;return c.enableEffect(a||this._getDrawWrapper()),c.setState(this.backFaceCulling,this.zOffset,!1,g,this._scene._mirroredCameraPosition?!this.cullBackFaces:this.cullBackFaces,this.stencil,this.zOffsetUnits),g}bind(a,x){}buildUniformLayout(){const a=this._uniformBuffer;this._eventInfo.ubo=a,this._callbackPluginEventGeneric(bo.PrepareUniformBuffer,this._eventInfo),a.create(),this._uniformBufferLayoutBuilt=!0}bindForSubMesh(a,x,c){const u=c._drawWrapper;this._eventInfo.subMesh=c,this._callbackPluginEventBindForSubMesh(this._eventInfo),u._forceRebindOnNextCall=!1}bindOnlyWorldMatrix(a){}bindView(a){this._useUBO?this._needToBindSceneUbo=!0:a.setMatrix("view",this.getScene().getViewMatrix())}bindViewProjection(a){this._useUBO?this._needToBindSceneUbo=!0:(a.setMatrix("viewProjection",this.getScene().getTransformMatrix()),a.setMatrix("projection",this.getScene().getProjectionMatrix()))}bindEyePosition(a,x){this._useUBO?this._needToBindSceneUbo=!0:this._scene.bindEyePosition(a,x)}_afterBind(a,x=null,c){if(this._scene._cachedMaterial=this,this._needToBindSceneUbo&&x&&(this._needToBindSceneUbo=!1,c_(x,this.getScene().getSceneUniformBuffer()),this._scene.finalizeSceneUbo()),a?this._scene._cachedVisibility=a.visibility:this._scene._cachedVisibility=1,this._onBindObservable&&a&&this._onBindObservable.notifyObservers(a),this.disableDepthWrite){const u=this._scene.getEngine();this._cachedDepthWriteState=u.getDepthWrite(),u.setDepthWrite(!1)}if(this.disableColorWrite){const u=this._scene.getEngine();this._cachedColorWriteState=u.getColorWrite(),u.setColorWrite(!1)}if(this.depthFunction!==0){const u=this._scene.getEngine();this._cachedDepthFunctionState=u.getDepthFunction()||0,u.setDepthFunction(this.depthFunction)}}unbind(){this._onUnBindObservable&&this._onUnBindObservable.notifyObservers(this),this.depthFunction!==0&&this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState),this.disableDepthWrite&&this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState),this.disableColorWrite&&this._scene.getEngine().setColorWrite(this._cachedColorWriteState)}getAnimatables(){return this._eventInfo.animatables=[],this._callbackPluginEventGeneric(bo.GetAnimatables,this._eventInfo),this._eventInfo.animatables}getActiveTextures(){return this._eventInfo.activeTextures=[],this._callbackPluginEventGeneric(bo.GetActiveTextures,this._eventInfo),this._eventInfo.activeTextures}hasTexture(a){return this._eventInfo.hasTexture=!1,this._eventInfo.texture=a,this._callbackPluginEventGeneric(bo.HasTexture,this._eventInfo),this._eventInfo.hasTexture}clone(a){return null}_clonePlugins(a,x){const c={};if(this._serializePlugins(c),ui._ParsePlugins(c,a,this._scene,x),this.pluginManager)for(const u of this.pluginManager._plugins){const g=a.pluginManager.getPlugin(u.name);g&&u.copyTo(g)}}getBindedMeshes(){if(this.meshMap){const a=[];for(const x in this.meshMap){const c=this.meshMap[x];c&&a.push(c)}return a}else return this._scene.meshes.filter(x=>x.material===this)}forceCompilation(a,x,c,u){const g={clipPlane:!1,useInstances:!1,...c},y=this.getScene(),v=this.allowShaderHotSwapping;this.allowShaderHotSwapping=!1;const w=()=>{if(!this._scene||!this._scene.getEngine())return;const B=y.clipPlane;if(g.clipPlane&&(y.clipPlane=new al(0,0,0,1)),this._storeEffectOnSubMeshes){let W=!0,ae=null;if(a.subMeshes){const ue=new ul(0,0,0,0,0,a,void 0,!1,!1);ue.materialDefines&&(ue.materialDefines._renderId=-1),this.isReadyForSubMesh(a,ue,g.useInstances)||(ue.effect&&ue.effect.getCompilationError()&&ue.effect.allFallbacksProcessed()?ae=ue.effect.getCompilationError():(W=!1,setTimeout(w,16)))}W&&(this.allowShaderHotSwapping=v,ae&&u&&u(ae),x&&x(this))}else this.isReady()?(this.allowShaderHotSwapping=v,x&&x(this)):setTimeout(w,16);g.clipPlane&&(y.clipPlane=B)};w()}forceCompilationAsync(a,x){return new Promise((c,u)=>{this.forceCompilation(a,()=>{c()},x,g=>{u(g)})})}markAsDirty(a){this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism||(ui._DirtyCallbackArray.length=0,a&ui.TextureDirtyFlag&&ui._DirtyCallbackArray.push(ui._TextureDirtyCallBack),a&ui.LightDirtyFlag&&ui._DirtyCallbackArray.push(ui._LightsDirtyCallBack),a&ui.FresnelDirtyFlag&&ui._DirtyCallbackArray.push(ui._FresnelDirtyCallBack),a&ui.AttributesDirtyFlag&&ui._DirtyCallbackArray.push(ui._AttributeDirtyCallBack),a&ui.MiscDirtyFlag&&ui._DirtyCallbackArray.push(ui._MiscDirtyCallBack),a&ui.PrePassDirtyFlag&&ui._DirtyCallbackArray.push(ui._PrePassDirtyCallBack),ui._DirtyCallbackArray.length&&this._markAllSubMeshesAsDirty(ui._RunDirtyCallBacks),this.getScene().resetCachedMaterial())}resetDrawCache(){const a=this.getScene().meshes;for(const x of a)if(x.subMeshes)for(const c of x.subMeshes)c.getMaterial()===this&&c.resetDrawCache()}_markAllSubMeshesAsDirty(a){if(this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const x=this.getScene().meshes;for(const c of x)if(c.subMeshes){for(const u of c.subMeshes)if(u.getMaterial(!1)===this)for(const g of u._drawWrappers)!g||!g.defines||!g.defines.markAllAsDirty||this._materialContext===g.materialContext&&a(g.defines)}}_markScenePrePassDirty(){if(this.getScene().blockMaterialDirtyMechanism||this._blockDirtyMechanism)return;const a=this.getScene().enablePrePassRenderer();a&&a.markAsDirty()}_markAllSubMeshesAsAllDirty(){this._markAllSubMeshesAsDirty(ui._AllDirtyCallBack)}_markAllSubMeshesAsImageProcessingDirty(){this._markAllSubMeshesAsDirty(ui._ImageProcessingDirtyCallBack)}_markAllSubMeshesAsTexturesDirty(){this._markAllSubMeshesAsDirty(ui._TextureDirtyCallBack)}_markAllSubMeshesAsFresnelDirty(){this._markAllSubMeshesAsDirty(ui._FresnelDirtyCallBack)}_markAllSubMeshesAsFresnelAndMiscDirty(){this._markAllSubMeshesAsDirty(ui._FresnelAndMiscDirtyCallBack)}_markAllSubMeshesAsLightsDirty(){this._markAllSubMeshesAsDirty(ui._LightsDirtyCallBack)}_markAllSubMeshesAsAttributesDirty(){this._markAllSubMeshesAsDirty(ui._AttributeDirtyCallBack)}_markAllSubMeshesAsMiscDirty(){this._markAllSubMeshesAsDirty(ui._MiscDirtyCallBack)}_markAllSubMeshesAsPrePassDirty(){this._markAllSubMeshesAsDirty(ui._MiscDirtyCallBack)}_markAllSubMeshesAsTexturesAndMiscDirty(){this._markAllSubMeshesAsDirty(ui._TextureAndMiscDirtyCallBack)}_checkScenePerformancePriority(){if(this._scene.performancePriority!==g2.BackwardCompatible){this.checkReadyOnlyOnce=!0;const a=this._scene.onScenePerformancePriorityChangedObservable.addOnce(()=>{this.checkReadyOnlyOnce=!1});this.onDisposeObservable.add(()=>{this._scene.onScenePerformancePriorityChangedObservable.remove(a)})}}setPrePassRenderer(a){return!1}dispose(a,x,c){const u=this.getScene();if(u.stopAnimation(this),u.freeProcessedMaterials(),u.removeMaterial(this),this._eventInfo.forceDisposeTextures=x,this._callbackPluginEventGeneric(bo.Disposed,this._eventInfo),this._parentContainer){const g=this._parentContainer.materials.indexOf(this);g>-1&&this._parentContainer.materials.splice(g,1),this._parentContainer=null}if(c!==!0)if(this.meshMap)for(const g in this.meshMap){const y=this.meshMap[g];y&&(y.material=null,this.releaseVertexArrayObject(y,a))}else{const g=u.meshes;for(const y of g)y.material===this&&!y.sourceMesh&&(y.material=null,this.releaseVertexArrayObject(y,a))}this._uniformBuffer.dispose(),a&&this._drawWrapper.effect&&(this._storeEffectOnSubMeshes||this._drawWrapper.effect.dispose(),this._drawWrapper.effect=null),this.metadata=null,this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this._onBindObservable&&this._onBindObservable.clear(),this._onUnBindObservable&&this._onUnBindObservable.clear(),this._onEffectCreatedObservable&&this._onEffectCreatedObservable.clear(),this._eventInfo&&(this._eventInfo={})}releaseVertexArrayObject(a,x){const c=a.geometry;if(c)if(this._storeEffectOnSubMeshes){if(a.subMeshes)for(const u of a.subMeshes)c._releaseVertexArrayObject(u.effect),x&&u.effect&&u.effect.dispose()}else c._releaseVertexArrayObject(this._drawWrapper.effect)}serialize(){const a=hr.Serialize(this);return a.stencil=this.stencil.serialize(),a.uniqueId=this.uniqueId,this._serializePlugins(a),a}_serializePlugins(a){if(a.plugins={},this.pluginManager)for(const x of this.pluginManager._plugins)a.plugins[x.getClassName()]=x.serialize()}static Parse(a,x,c){if(!a.customType)a.customType="BABYLON.StandardMaterial";else if(a.customType==="BABYLON.PBRMaterial"&&a.overloadedAlbedo&&(a.customType="BABYLON.LegacyPBRMaterial",!BABYLON.LegacyPBRMaterial))return Qt.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."),null;const g=_t.Instantiate(a.customType).Parse(a,x,c);return g._loadedUniqueId=a.uniqueId,g}static _ParsePlugins(a,x,c,u){if(a.plugins)for(const g in a.plugins){const y=a.plugins[g];let v=x.pluginManager?.getPlugin(y.name);if(!v){const w=_t.Instantiate("BABYLON."+g);w&&(v=new w(x))}v?.parse(y,c,u)}}}ui.TriangleFillMode=0,ui.WireFrameFillMode=1,ui.PointFillMode=2,ui.PointListDrawMode=3,ui.LineListDrawMode=4,ui.LineLoopDrawMode=5,ui.LineStripDrawMode=6,ui.TriangleStripDrawMode=7,ui.TriangleFanDrawMode=8,ui.ClockWiseSideOrientation=0,ui.CounterClockWiseSideOrientation=1,ui.TextureDirtyFlag=1,ui.LightDirtyFlag=2,ui.FresnelDirtyFlag=4,ui.AttributesDirtyFlag=8,ui.MiscDirtyFlag=16,ui.PrePassDirtyFlag=32,ui.AllDirtyFlag=63,ui.MATERIAL_OPAQUE=0,ui.MATERIAL_ALPHATEST=1,ui.MATERIAL_ALPHABLEND=2,ui.MATERIAL_ALPHATESTANDBLEND=3,ui.MATERIAL_NORMALBLENDMETHOD_WHITEOUT=0,ui.MATERIAL_NORMALBLENDMETHOD_RNM=1,ui.OnEventObservable=new Jt,ui._AllDirtyCallBack=F=>F.markAllAsDirty(),ui._ImageProcessingDirtyCallBack=F=>F.markAsImageProcessingDirty(),ui._TextureDirtyCallBack=F=>F.markAsTexturesDirty(),ui._FresnelDirtyCallBack=F=>F.markAsFresnelDirty(),ui._MiscDirtyCallBack=F=>F.markAsMiscDirty(),ui._PrePassDirtyCallBack=F=>F.markAsPrePassDirty(),ui._LightsDirtyCallBack=F=>F.markAsLightDirty(),ui._AttributeDirtyCallBack=F=>F.markAsAttributesDirty(),ui._FresnelAndMiscDirtyCallBack=F=>{ui._FresnelDirtyCallBack(F),ui._MiscDirtyCallBack(F)},ui._TextureAndMiscDirtyCallBack=F=>{ui._TextureDirtyCallBack(F),ui._MiscDirtyCallBack(F)},ui._DirtyCallbackArray=[],ui._RunDirtyCallBacks=F=>{for(const a of ui._DirtyCallbackArray)a(F)},Ye([ht()],ui.prototype,"id",void 0),Ye([ht()],ui.prototype,"uniqueId",void 0),Ye([ht()],ui.prototype,"name",void 0),Ye([ht()],ui.prototype,"metadata",void 0),Ye([ht()],ui.prototype,"checkReadyOnEveryCall",void 0),Ye([ht()],ui.prototype,"checkReadyOnlyOnce",void 0),Ye([ht()],ui.prototype,"state",void 0),Ye([ht("alpha")],ui.prototype,"_alpha",void 0),Ye([ht("backFaceCulling")],ui.prototype,"_backFaceCulling",void 0),Ye([ht("cullBackFaces")],ui.prototype,"_cullBackFaces",void 0),Ye([ht()],ui.prototype,"sideOrientation",void 0),Ye([ht("alphaMode")],ui.prototype,"_alphaMode",void 0),Ye([ht()],ui.prototype,"_needDepthPrePass",void 0),Ye([ht()],ui.prototype,"disableDepthWrite",void 0),Ye([ht()],ui.prototype,"disableColorWrite",void 0),Ye([ht()],ui.prototype,"forceDepthWrite",void 0),Ye([ht()],ui.prototype,"depthFunction",void 0),Ye([ht()],ui.prototype,"separateCullingPass",void 0),Ye([ht("fogEnabled")],ui.prototype,"_fogEnabled",void 0),Ye([ht()],ui.prototype,"pointSize",void 0),Ye([ht()],ui.prototype,"zOffset",void 0),Ye([ht()],ui.prototype,"zOffsetUnits",void 0),Ye([ht()],ui.prototype,"pointsCloud",null),Ye([ht()],ui.prototype,"fillMode",null),Ye([ht()],ui.prototype,"useLogarithmicDepth",null),Ye([ht()],ui.prototype,"transparencyMode",null);class Ux{constructor(a,x){this.width=a,this.height=x}toString(){return`{W: ${this.width}, H: ${this.height}}`}getClassName(){return"Size"}getHashCode(){let a=this.width|0;return a=a*397^(this.height|0),a}copyFrom(a){this.width=a.width,this.height=a.height}copyFromFloats(a,x){return this.width=a,this.height=x,this}set(a,x){return this.copyFromFloats(a,x)}multiplyByFloats(a,x){return new Ux(this.width*a,this.height*x)}clone(){return new Ux(this.width,this.height)}equals(a){return a?this.width===a.width&&this.height===a.height:!1}get surface(){return this.width*this.height}static Zero(){return new Ux(0,0)}add(a){return new Ux(this.width+a.width,this.height+a.height)}subtract(a){return new Ux(this.width-a.width,this.height-a.height)}scale(a){return new Ux(this.width*a,this.height*a)}static Lerp(a,x,c){const u=a.width+(x.width-a.width)*c,g=a.height+(x.height-a.height)*c;return new Ux(u,g)}}class h_{get wrapU(){return this._wrapU}set wrapU(a){this._wrapU=a}get wrapV(){return this._wrapV}set wrapV(a){this._wrapV=a}get coordinatesMode(){return 0}get isCube(){return this._texture?this._texture.isCube:!1}set isCube(a){this._texture&&(this._texture.isCube=a)}get is3D(){return this._texture?this._texture.is3D:!1}set is3D(a){this._texture&&(this._texture.is3D=a)}get is2DArray(){return this._texture?this._texture.is2DArray:!1}set is2DArray(a){this._texture&&(this._texture.is2DArray=a)}getClassName(){return"ThinTexture"}static _IsRenderTargetWrapper(a){return a?._shareDepth!==void 0}constructor(a){this._wrapU=1,this._wrapV=1,this.wrapR=1,this.anisotropicFilteringLevel=4,this.delayLoadState=0,this._texture=null,this._engine=null,this._cachedSize=Ux.Zero(),this._cachedBaseSize=Ux.Zero(),this._initialSamplingMode=2,this._texture=h_._IsRenderTargetWrapper(a)?a.texture:a,this._texture&&(this._engine=this._texture.getEngine())}isReady(){return this.delayLoadState===4?(this.delayLoad(),!1):this._texture?this._texture.isReady:!1}delayLoad(){}getInternalTexture(){return this._texture}getSize(){if(this._texture){if(this._texture.width)return this._cachedSize.width=this._texture.width,this._cachedSize.height=this._texture.height,this._cachedSize;if(this._texture._size)return this._cachedSize.width=this._texture._size,this._cachedSize.height=this._texture._size,this._cachedSize}return this._cachedSize}getBaseSize(){return!this.isReady()||!this._texture?(this._cachedBaseSize.width=0,this._cachedBaseSize.height=0,this._cachedBaseSize):this._texture._size?(this._cachedBaseSize.width=this._texture._size,this._cachedBaseSize.height=this._texture._size,this._cachedBaseSize):(this._cachedBaseSize.width=this._texture.baseWidth,this._cachedBaseSize.height=this._texture.baseHeight,this._cachedBaseSize)}get samplingMode(){return this._texture?this._texture.samplingMode:this._initialSamplingMode}updateSamplingMode(a){this._texture&&this._engine&&this._engine.updateTextureSamplingMode(a,this._texture)}releaseInternalTexture(){this._texture&&(this._texture.dispose(),this._texture=null)}dispose(){this._texture&&(this.releaseInternalTexture(),this._engine=null)}}class Un extends h_{set hasAlpha(a){this._hasAlpha!==a&&(this._hasAlpha=a,this._scene&&this._scene.markAllMaterialsAsDirty(1,x=>x.hasTexture(this)))}get hasAlpha(){return this._hasAlpha}set getAlphaFromRGB(a){this._getAlphaFromRGB!==a&&(this._getAlphaFromRGB=a,this._scene&&this._scene.markAllMaterialsAsDirty(1,x=>x.hasTexture(this)))}get getAlphaFromRGB(){return this._getAlphaFromRGB}set coordinatesIndex(a){this._coordinatesIndex!==a&&(this._coordinatesIndex=a,this._scene&&this._scene.markAllMaterialsAsDirty(1,x=>x.hasTexture(this)))}get coordinatesIndex(){return this._coordinatesIndex}set coordinatesMode(a){this._coordinatesMode!==a&&(this._coordinatesMode=a,this._scene&&this._scene.markAllMaterialsAsDirty(1,x=>x.hasTexture(this)))}get coordinatesMode(){return this._coordinatesMode}get wrapU(){return this._wrapU}set wrapU(a){this._wrapU=a}get wrapV(){return this._wrapV}set wrapV(a){this._wrapV=a}get isCube(){return this._texture?this._texture.isCube:this._isCube}set isCube(a){this._texture?this._texture.isCube=a:this._isCube=a}get is3D(){return this._texture?this._texture.is3D:!1}set is3D(a){this._texture&&(this._texture.is3D=a)}get is2DArray(){return this._texture?this._texture.is2DArray:!1}set is2DArray(a){this._texture&&(this._texture.is2DArray=a)}get gammaSpace(){if(this._texture)this._texture._gammaSpace===null&&(this._texture._gammaSpace=this._gammaSpace);else return this._gammaSpace;return this._texture._gammaSpace&&!this._texture._useSRGBBuffer}set gammaSpace(a){if(this._texture){if(this._texture._gammaSpace===a)return;this._texture._gammaSpace=a}else{if(this._gammaSpace===a)return;this._gammaSpace=a}this.getScene()?.markAllMaterialsAsDirty(1,x=>x.hasTexture(this))}get isRGBD(){return this._texture!=null&&this._texture._isRGBD}set isRGBD(a){a!==this.isRGBD&&(this._texture&&(this._texture._isRGBD=a),this.getScene()?.markAllMaterialsAsDirty(1,x=>x.hasTexture(this)))}get noMipmap(){return!1}get lodGenerationOffset(){return this._texture?this._texture._lodGenerationOffset:0}set lodGenerationOffset(a){this._texture&&(this._texture._lodGenerationOffset=a)}get lodGenerationScale(){return this._texture?this._texture._lodGenerationScale:0}set lodGenerationScale(a){this._texture&&(this._texture._lodGenerationScale=a)}get linearSpecularLOD(){return this._texture?this._texture._linearSpecularLOD:!1}set linearSpecularLOD(a){this._texture&&(this._texture._linearSpecularLOD=a)}get irradianceTexture(){return this._texture?this._texture._irradianceTexture:null}set irradianceTexture(a){this._texture&&(this._texture._irradianceTexture=a)}get uid(){return this._uid||(this._uid=v0()),this._uid}toString(){return this.name}getClassName(){return"BaseTexture"}set onDispose(a){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(a)}get isBlocking(){return!0}get loadingError(){return this._loadingError}get errorObject(){return this._errorObject}constructor(a,x=null){super(null),this.metadata=null,this.reservedDataStore=null,this._hasAlpha=!1,this._getAlphaFromRGB=!1,this.level=1,this._coordinatesIndex=0,this.optimizeUVAllocation=!0,this._coordinatesMode=0,this.wrapR=1,this.anisotropicFilteringLevel=Un.DEFAULT_ANISOTROPIC_FILTERING_LEVEL,this._isCube=!1,this._gammaSpace=!0,this.invertZ=!1,this.lodLevelInAlpha=!1,this.isRenderTarget=!1,this._prefiltered=!1,this._forceSerialize=!1,this.animations=[],this.onDisposeObservable=new Jt,this._onDisposeObserver=null,this._scene=null,this._uid=null,this._parentContainer=null,this._loadingError=!1,a?Un._IsScene(a)?this._scene=a:this._engine=a:this._scene=tr.LastCreatedScene,this._scene&&(this.uniqueId=this._scene.getUniqueId(),this._scene.addTexture(this),this._engine=this._scene.getEngine()),this._texture=x,this._uid=null}getScene(){return this._scene}_getEngine(){return this._engine}checkTransformsAreIdentical(a){return a!==null}getTextureMatrix(){return vt.IdentityReadOnly}getReflectionTextureMatrix(){return vt.IdentityReadOnly}getRefractionTextureMatrix(){return this.getReflectionTextureMatrix()}isReadyOrNotBlocking(){return!this.isBlocking||this.isReady()||this.loadingError}scale(a){}get canRescale(){return!1}_getFromCache(a,x,c,u,g,y){const v=this._getEngine();if(!v)return null;const w=v._getUseSRGBBuffer(!!g,x),B=v.getLoadedTexturesCache();for(let W=0;W<B.length;W++){const ae=B[W];if((g===void 0||w===ae._useSRGBBuffer)&&(u===void 0||u===ae.invertY)&&ae.url===a&&ae.generateMipMaps===!x&&(!c||c===ae.samplingMode)&&(y===void 0||y===ae.isCube))return ae.incrementReferences(),ae}return null}_rebuild(a=!1){}clone(){return null}get textureType(){return this._texture&&this._texture.type!==void 0?this._texture.type:0}get textureFormat(){return this._texture&&this._texture.format!==void 0?this._texture.format:5}_markAllSubMeshesAsTexturesDirty(){const a=this.getScene();a&&a.markAllMaterialsAsDirty(1)}readPixels(a=0,x=0,c=null,u=!0,g=!1,y=0,v=0,w=Number.MAX_VALUE,B=Number.MAX_VALUE){if(!this._texture)return null;const W=this._getEngine();if(!W)return null;const ae=this.getSize();let ue=ae.width,fe=ae.height;x!==0&&(ue=ue/Math.pow(2,x),fe=fe/Math.pow(2,x),ue=Math.round(ue),fe=Math.round(fe)),w=Math.min(ue,w),B=Math.min(fe,B);try{return this._texture.isCube?W._readTexturePixels(this._texture,w,B,a,x,c,u,g,y,v):W._readTexturePixels(this._texture,w,B,-1,x,c,u,g,y,v)}catch{return null}}_readPixelsSync(a=0,x=0,c=null,u=!0,g=!1){if(!this._texture)return null;const y=this.getSize();let v=y.width,w=y.height;const B=this._getEngine();if(!B)return null;x!=0&&(v=v/Math.pow(2,x),w=w/Math.pow(2,x),v=Math.round(v),w=Math.round(w));try{return this._texture.isCube?B._readTexturePixelsSync(this._texture,v,w,a,x,c,u,g):B._readTexturePixelsSync(this._texture,v,w,-1,x,c,u,g)}catch{return null}}get _lodTextureHigh(){return this._texture?this._texture._lodTextureHigh:null}get _lodTextureMid(){return this._texture?this._texture._lodTextureMid:null}get _lodTextureLow(){return this._texture?this._texture._lodTextureLow:null}dispose(){if(this._scene){this._scene.stopAnimation&&this._scene.stopAnimation(this),this._scene.removePendingData(this);const a=this._scene.textures.indexOf(this);if(a>=0&&this._scene.textures.splice(a,1),this._scene.onTextureRemovedObservable.notifyObservers(this),this._scene=null,this._parentContainer){const x=this._parentContainer.textures.indexOf(this);x>-1&&this._parentContainer.textures.splice(x,1),this._parentContainer=null}}this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.metadata=null,super.dispose()}serialize(a=!1){if(!this.name&&!a)return null;const x=hr.Serialize(this);return hr.AppendSerializedAnimations(this,x),x}static WhenAllReady(a,x){let c=a.length;if(c===0){x();return}for(let u=0;u<a.length;u++){const g=a[u];if(g.isReady())--c===0&&x();else{const y=g.onLoadObservable;y?y.addOnce(()=>{--c===0&&x()}):--c===0&&x()}}}static _IsScene(a){return a.getClassName()==="Scene"}}Un.DEFAULT_ANISOTROPIC_FILTERING_LEVEL=4,Ye([ht()],Un.prototype,"uniqueId",void 0),Ye([ht()],Un.prototype,"name",void 0),Ye([ht()],Un.prototype,"metadata",void 0),Ye([ht("hasAlpha")],Un.prototype,"_hasAlpha",void 0),Ye([ht("getAlphaFromRGB")],Un.prototype,"_getAlphaFromRGB",void 0),Ye([ht()],Un.prototype,"level",void 0),Ye([ht("coordinatesIndex")],Un.prototype,"_coordinatesIndex",void 0),Ye([ht()],Un.prototype,"optimizeUVAllocation",void 0),Ye([ht("coordinatesMode")],Un.prototype,"_coordinatesMode",void 0),Ye([ht()],Un.prototype,"wrapU",null),Ye([ht()],Un.prototype,"wrapV",null),Ye([ht()],Un.prototype,"wrapR",void 0),Ye([ht()],Un.prototype,"anisotropicFilteringLevel",void 0),Ye([ht()],Un.prototype,"isCube",null),Ye([ht()],Un.prototype,"is3D",null),Ye([ht()],Un.prototype,"is2DArray",null),Ye([ht()],Un.prototype,"gammaSpace",null),Ye([ht()],Un.prototype,"invertZ",void 0),Ye([ht()],Un.prototype,"lodLevelInAlpha",void 0),Ye([ht()],Un.prototype,"lodGenerationOffset",null),Ye([ht()],Un.prototype,"lodGenerationScale",null),Ye([ht()],Un.prototype,"linearSpecularLOD",null),Ye([gn()],Un.prototype,"irradianceTexture",null),Ye([ht()],Un.prototype,"isRenderTarget",void 0);function u_(F,a,x=!1){const c=a.width,u=a.height;if(F instanceof Float32Array){let B=F.byteLength/F.BYTES_PER_ELEMENT;const W=new Uint8Array(B);for(;--B>=0;){let ae=F[B];ae<0?ae=0:ae>1&&(ae=1),W[B]=ae*255}F=W}const g=document.createElement("canvas");g.width=c,g.height=u;const y=g.getContext("2d");if(!y)return null;const v=y.createImageData(c,u);if(v.data.set(F),y.putImageData(v,0,0),x){const B=document.createElement("canvas");B.width=c,B.height=u;const W=B.getContext("2d");return W?(W.translate(0,u),W.scale(1,-1),W.drawImage(g,0,0),B.toDataURL("image/png")):null}return g.toDataURL("image/png")}function ab(F,a=0,x=0){const c=F.getInternalTexture();if(!c)return null;const u=F._readPixelsSync(a,x);return u?u_(u,F.getSize(),c.invertY):null}async function xb(F,a=0,x=0){const c=F.getInternalTexture();if(!c)return null;const u=await F.readPixels(a,x);return u?u_(u,F.getSize(),c.invertY):null}const Y3={GenerateBase64StringFromPixelData:u_,GenerateBase64StringFromTexture:ab,GenerateBase64StringFromTextureAsync:xb};class ac{}ac.UseOpenGLOrientationForUV=!1;class fi extends Un{static _CreateVideoTexture(a,x,c,u=!1,g=!1,y=fi.TRILINEAR_SAMPLINGMODE,v={},w,B=5){throw js("VideoTexture")}get noMipmap(){return this._noMipmap}get mimeType(){return this._mimeType}set isBlocking(a){this._isBlocking=a}get isBlocking(){return this._isBlocking}get invertY(){return this._invertY}constructor(a,x,c,u,g=fi.TRILINEAR_SAMPLINGMODE,y=null,v=null,w=null,B=!1,W,ae,ue,fe,Re){super(x),this.url=null,this.uOffset=0,this.vOffset=0,this.uScale=1,this.vScale=1,this.uAng=0,this.vAng=0,this.wAng=0,this.uRotationCenter=.5,this.vRotationCenter=.5,this.wRotationCenter=.5,this.homogeneousRotationInUVTransform=!1,this.inspectableCustomProperties=null,this._noMipmap=!1,this._invertY=!1,this._rowGenerationMatrix=null,this._cachedTextureMatrix=null,this._projectionModeMatrix=null,this._t0=null,this._t1=null,this._t2=null,this._cachedUOffset=-1,this._cachedVOffset=-1,this._cachedUScale=0,this._cachedVScale=0,this._cachedUAng=-1,this._cachedVAng=-1,this._cachedWAng=-1,this._cachedReflectionProjectionMatrixId=-1,this._cachedURotationCenter=-1,this._cachedVRotationCenter=-1,this._cachedWRotationCenter=-1,this._cachedHomogeneousRotationInUVTransform=!1,this._cachedReflectionTextureMatrix=null,this._cachedReflectionUOffset=-1,this._cachedReflectionVOffset=-1,this._cachedReflectionUScale=0,this._cachedReflectionVScale=0,this._cachedReflectionCoordinatesMode=-1,this._buffer=null,this._deleteBuffer=!1,this._format=null,this._delayedOnLoad=null,this._delayedOnError=null,this.onLoadObservable=new Jt,this._isBlocking=!0,this.name=a||"",this.url=a;let _e,Be=!1,tt=null,$e=!0;typeof c=="object"&&c!==null?(_e=c.noMipmap??!1,u=c.invertY??!ac.UseOpenGLOrientationForUV,g=c.samplingMode??fi.TRILINEAR_SAMPLINGMODE,y=c.onLoad??null,v=c.onError??null,w=c.buffer??null,B=c.deleteBuffer??!1,W=c.format,ae=c.mimeType,ue=c.loaderOptions,fe=c.creationFlags,Be=c.useSRGBBuffer??!1,tt=c.internalTexture??null,$e=c.gammaSpace??$e):_e=!!c,this._gammaSpace=$e,this._noMipmap=_e,this._invertY=u===void 0?!ac.UseOpenGLOrientationForUV:u,this._initialSamplingMode=g,this._buffer=w,this._deleteBuffer=B,this._mimeType=ae,this._loaderOptions=ue,this._creationFlags=fe,this._useSRGBBuffer=Be,this._forcedExtension=Re,W&&(this._format=W);const Et=this.getScene(),ft=this._getEngine();if(!ft)return;ft.onBeforeTextureInitObservable.notifyObservers(this);const dt=()=>{this._texture&&(this._texture._invertVScale&&(this.vScale*=-1,this.vOffset+=1),this._texture._cachedWrapU!==null&&(this.wrapU=this._texture._cachedWrapU,this._texture._cachedWrapU=null),this._texture._cachedWrapV!==null&&(this.wrapV=this._texture._cachedWrapV,this._texture._cachedWrapV=null),this._texture._cachedWrapR!==null&&(this.wrapR=this._texture._cachedWrapR,this._texture._cachedWrapR=null)),this.onLoadObservable.hasObservers()&&this.onLoadObservable.notifyObservers(this),y&&y(),!this.isBlocking&&Et&&Et.resetCachedMaterial()},ut=(Mt,ai)=>{this._loadingError=!0,this._errorObject={message:Mt,exception:ai},v&&v(Mt,ai),fi.OnTextureLoadErrorObservable.notifyObservers(this)};if(!this.url&&!tt){this._delayedOnLoad=dt,this._delayedOnError=ut;return}if(this._texture=tt??this._getFromCache(this.url,_e,g,this._invertY,Be,this.isCube),this._texture)if(this._texture.isReady)d2.SetImmediate(()=>dt());else{const Mt=this._texture.onLoadedObservable.add(dt);this._texture.onErrorObservable.add(ai=>{ut(ai.message,ai.exception),this._texture?.onLoadedObservable.remove(Mt)})}else if(!Et||!Et.useDelayedTextureLoading){try{this._texture=ft.createTexture(this.url,_e,this._invertY,Et,g,dt,ut,this._buffer,void 0,this._format,this._forcedExtension,ae,ue,fe,Be)}catch(Mt){throw ut("error loading",Mt),Mt}B&&(this._buffer=null)}else this.delayLoadState=4,this._delayedOnLoad=dt,this._delayedOnError=ut}updateURL(a,x=null,c,u){this.url&&(this.releaseInternalTexture(),this.getScene().markAllMaterialsAsDirty(1,g=>g.hasTexture(this))),(!this.name||this.name.startsWith("data:"))&&(this.name=a),this.url=a,this._buffer=x,this._forcedExtension=u,this.delayLoadState=4,c&&(this._delayedOnLoad=c),this.delayLoad()}delayLoad(){if(this.delayLoadState!==4)return;const a=this.getScene();a&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap,this.samplingMode,this._invertY,this._useSRGBBuffer,this.isCube),this._texture?this._delayedOnLoad&&(this._texture.isReady?d2.SetImmediate(this._delayedOnLoad):this._texture.onLoadedObservable.add(this._delayedOnLoad)):(this._texture=a.getEngine().createTexture(this.url,this._noMipmap,this._invertY,a,this.samplingMode,this._delayedOnLoad,this._delayedOnError,this._buffer,null,this._format,this._forcedExtension,this._mimeType,this._loaderOptions,this._creationFlags,this._useSRGBBuffer),this._deleteBuffer&&(this._buffer=null)),this._delayedOnLoad=null,this._delayedOnError=null)}_prepareRowForTextureGeneration(a,x,c,u){a*=this._cachedUScale,x*=this._cachedVScale,a-=this.uRotationCenter*this._cachedUScale,x-=this.vRotationCenter*this._cachedVScale,c-=this.wRotationCenter,Ee.TransformCoordinatesFromFloatsToRef(a,x,c,this._rowGenerationMatrix,u),u.x+=this.uRotationCenter*this._cachedUScale+this._cachedUOffset,u.y+=this.vRotationCenter*this._cachedVScale+this._cachedVOffset,u.z+=this.wRotationCenter}checkTransformsAreIdentical(a){return a!==null&&this.uOffset===a.uOffset&&this.vOffset===a.vOffset&&this.uScale===a.uScale&&this.vScale===a.vScale&&this.uAng===a.uAng&&this.vAng===a.vAng&&this.wAng===a.wAng}getTextureMatrix(a=1){if(this.uOffset===this._cachedUOffset&&this.vOffset===this._cachedVOffset&&this.uScale*a===this._cachedUScale&&this.vScale===this._cachedVScale&&this.uAng===this._cachedUAng&&this.vAng===this._cachedVAng&&this.wAng===this._cachedWAng&&this.uRotationCenter===this._cachedURotationCenter&&this.vRotationCenter===this._cachedVRotationCenter&&this.wRotationCenter===this._cachedWRotationCenter&&this.homogeneousRotationInUVTransform===this._cachedHomogeneousRotationInUVTransform)return this._cachedTextureMatrix;this._cachedUOffset=this.uOffset,this._cachedVOffset=this.vOffset,this._cachedUScale=this.uScale*a,this._cachedVScale=this.vScale,this._cachedUAng=this.uAng,this._cachedVAng=this.vAng,this._cachedWAng=this.wAng,this._cachedURotationCenter=this.uRotationCenter,this._cachedVRotationCenter=this.vRotationCenter,this._cachedWRotationCenter=this.wRotationCenter,this._cachedHomogeneousRotationInUVTransform=this.homogeneousRotationInUVTransform,(!this._cachedTextureMatrix||!this._rowGenerationMatrix)&&(this._cachedTextureMatrix=vt.Zero(),this._rowGenerationMatrix=new vt,this._t0=Ee.Zero(),this._t1=Ee.Zero(),this._t2=Ee.Zero()),vt.RotationYawPitchRollToRef(this.vAng,this.uAng,this.wAng,this._rowGenerationMatrix),this.homogeneousRotationInUVTransform?(vt.TranslationToRef(-this._cachedURotationCenter,-this._cachedVRotationCenter,-this._cachedWRotationCenter,Yt.Matrix[0]),vt.TranslationToRef(this._cachedURotationCenter,this._cachedVRotationCenter,this._cachedWRotationCenter,Yt.Matrix[1]),vt.ScalingToRef(this._cachedUScale,this._cachedVScale,0,Yt.Matrix[2]),vt.TranslationToRef(this._cachedUOffset,this._cachedVOffset,0,Yt.Matrix[3]),Yt.Matrix[0].multiplyToRef(this._rowGenerationMatrix,this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(Yt.Matrix[1],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(Yt.Matrix[2],this._cachedTextureMatrix),this._cachedTextureMatrix.multiplyToRef(Yt.Matrix[3],this._cachedTextureMatrix),this._cachedTextureMatrix.setRowFromFloats(2,this._cachedTextureMatrix.m[12],this._cachedTextureMatrix.m[13],this._cachedTextureMatrix.m[14],1)):(this._prepareRowForTextureGeneration(0,0,0,this._t0),this._prepareRowForTextureGeneration(1,0,0,this._t1),this._prepareRowForTextureGeneration(0,1,0,this._t2),this._t1.subtractInPlace(this._t0),this._t2.subtractInPlace(this._t0),vt.FromValuesToRef(this._t1.x,this._t1.y,this._t1.z,0,this._t2.x,this._t2.y,this._t2.z,0,this._t0.x,this._t0.y,this._t0.z,0,0,0,0,1,this._cachedTextureMatrix));const x=this.getScene();return x?(this.optimizeUVAllocation&&x.markAllMaterialsAsDirty(1,c=>c.hasTexture(this)),this._cachedTextureMatrix):this._cachedTextureMatrix}getReflectionTextureMatrix(){const a=this.getScene();if(!a)return this._cachedReflectionTextureMatrix;if(this.uOffset===this._cachedReflectionUOffset&&this.vOffset===this._cachedReflectionVOffset&&this.uScale===this._cachedReflectionUScale&&this.vScale===this._cachedReflectionVScale&&this.coordinatesMode===this._cachedReflectionCoordinatesMode)if(this.coordinatesMode===fi.PROJECTION_MODE){if(this._cachedReflectionProjectionMatrixId===a.getProjectionMatrix().updateFlag)return this._cachedReflectionTextureMatrix}else return this._cachedReflectionTextureMatrix;this._cachedReflectionTextureMatrix||(this._cachedReflectionTextureMatrix=vt.Zero()),this._projectionModeMatrix||(this._projectionModeMatrix=vt.Zero());const x=this._cachedReflectionCoordinatesMode!==this.coordinatesMode;switch(this._cachedReflectionUOffset=this.uOffset,this._cachedReflectionVOffset=this.vOffset,this._cachedReflectionUScale=this.uScale,this._cachedReflectionVScale=this.vScale,this._cachedReflectionCoordinatesMode=this.coordinatesMode,this.coordinatesMode){case fi.PLANAR_MODE:{vt.IdentityToRef(this._cachedReflectionTextureMatrix),this._cachedReflectionTextureMatrix[0]=this.uScale,this._cachedReflectionTextureMatrix[5]=this.vScale,this._cachedReflectionTextureMatrix[12]=this.uOffset,this._cachedReflectionTextureMatrix[13]=this.vOffset;break}case fi.PROJECTION_MODE:{vt.FromValuesToRef(.5,0,0,0,0,-.5,0,0,0,0,0,0,.5,.5,1,1,this._projectionModeMatrix);const c=a.getProjectionMatrix();this._cachedReflectionProjectionMatrixId=c.updateFlag,c.multiplyToRef(this._projectionModeMatrix,this._cachedReflectionTextureMatrix);break}default:vt.IdentityToRef(this._cachedReflectionTextureMatrix);break}return x&&a.markAllMaterialsAsDirty(1,c=>c.hasTexture(this)),this._cachedReflectionTextureMatrix}clone(){const a={noMipmap:this._noMipmap,invertY:this._invertY,samplingMode:this.samplingMode,onLoad:void 0,onError:void 0,buffer:this._texture?this._texture._buffer:void 0,deleteBuffer:this._deleteBuffer,format:this.textureFormat,mimeType:this.mimeType,loaderOptions:this._loaderOptions,creationFlags:this._creationFlags,useSRGBBuffer:this._useSRGBBuffer};return hr.Clone(()=>new fi(this._texture?this._texture.url:null,this.getScene(),a),this)}serialize(){const a=this.name;fi.SerializeBuffers||this.name.startsWith("data:")&&(this.name=""),this.name.startsWith("data:")&&this.url===this.name&&(this.url="");const x=super.serialize(fi._SerializeInternalTextureUniqueId);return x?((fi.SerializeBuffers||fi.ForceSerializeBuffers)&&(typeof this._buffer=="string"&&this._buffer.substr(0,5)==="data:"?(x.base64String=this._buffer,x.name=x.name.replace("data:","")):this.url&&this.url.startsWith("data:")&&this._buffer instanceof Uint8Array?x.base64String="data:image/png;base64,"+h2(this._buffer):(fi.ForceSerializeBuffers||this.url&&this.url.startsWith("blob:")||this._forceSerialize)&&(x.base64String=!this._engine||this._engine._features.supportSyncTextureRead?ab(this):xb(this))),x.invertY=this._invertY,x.samplingMode=this.samplingMode,x._creationFlags=this._creationFlags,x._useSRGBBuffer=this._useSRGBBuffer,fi._SerializeInternalTextureUniqueId&&(x.internalTextureUniqueId=this._texture?.uniqueId??void 0),x.noMipmap=this._noMipmap,this.name=a,x):null}getClassName(){return"Texture"}dispose(){super.dispose(),this.onLoadObservable.clear(),this._delayedOnLoad=null,this._delayedOnError=null,this._buffer=null}static Parse(a,x,c){if(a.customType){const B=E0.Instantiate(a.customType).Parse(a,x,c);return a.samplingMode&&B.updateSamplingMode&&B._samplingMode&&B._samplingMode!==a.samplingMode&&B.updateSamplingMode(a.samplingMode),B}if(a.isCube&&!a.isRenderTarget)return fi._CubeTextureParser(a,x,c);const u=a.internalTextureUniqueId!==void 0;if(!a.name&&!a.isRenderTarget&&!u)return null;let g;if(u){const w=x.getEngine().getLoadedTexturesCache();for(const B of w)if(B.uniqueId===a.internalTextureUniqueId){g=B;break}}const y=w=>{if(w&&w._texture&&(w._texture._cachedWrapU=null,w._texture._cachedWrapV=null,w._texture._cachedWrapR=null),a.samplingMode){const B=a.samplingMode;w&&w.samplingMode!==B&&w.updateSamplingMode(B)}if(w&&a.animations)for(let B=0;B<a.animations.length;B++){const W=a.animations[B],ae=Ua("BABYLON.Animation");ae&&w.animations.push(ae.Parse(W))}u&&!g&&w?._texture?._setUniqueId(a.internalTextureUniqueId)};return hr.Parse(()=>{let w=!0;if(a.noMipmap&&(w=!1),a.mirrorPlane){const B=fi._CreateMirror(a.name,a.renderTargetSize,x,w);return B._waitingRenderList=a.renderList,B.mirrorPlane=al.FromArray(a.mirrorPlane),y(B),B}else if(a.isRenderTarget){let B=null;if(a.isCube){if(x.reflectionProbes)for(let W=0;W<x.reflectionProbes.length;W++){const ae=x.reflectionProbes[W];if(ae.name===a.name)return ae.cubeTexture}}else B=fi._CreateRenderTargetTexture(a.name,a.renderTargetSize,x,w,a._creationFlags??0),B._waitingRenderList=a.renderList;return y(B),B}else if(a.isVideo){const B=fi._CreateVideoTexture(c+(a.url||a.name),c+(a.src||a.url),x,w,a.invertY,a.samplingMode,a.settings||{});return y(B),B}else{let B;if(a.base64String&&!g)B=fi.CreateFromBase64String(a.base64String,a.base64String,x,!w,a.invertY,a.samplingMode,()=>{y(B)},a._creationFlags??0,a._useSRGBBuffer??!1),B.name=a.name;else{let W;a.name&&(a.name.indexOf("://")>0||a.name.startsWith("data:"))?W=a.name:W=c+a.name,a.url&&(a.url.startsWith("data:")||fi.UseSerializedUrlIfAny)&&(W=a.url);const ae={noMipmap:!w,invertY:a.invertY,samplingMode:a.samplingMode,onLoad:()=>{y(B)},internalTexture:g};B=new fi(W,x,ae)}return B}},a,x)}static CreateFromBase64String(a,x,c,u,g,y=fi.TRILINEAR_SAMPLINGMODE,v=null,w=null,B=5,W){return new fi("data:"+x,c,u,g,y,v,w,a,!1,B,void 0,void 0,W)}static LoadFromDataString(a,x,c,u=!1,g,y=!0,v=fi.TRILINEAR_SAMPLINGMODE,w=null,B=null,W=5,ae){return a.substr(0,5)!=="data:"&&(a="data:"+a),new fi(a,c,g,y,v,w,B,x,u,W,void 0,void 0,ae)}}fi.SerializeBuffers=!0,fi.ForceSerializeBuffers=!1,fi.OnTextureLoadErrorObservable=new Jt,fi._SerializeInternalTextureUniqueId=!1,fi._CubeTextureParser=(F,a,x)=>{throw js("CubeTexture")},fi._CreateMirror=(F,a,x,c)=>{throw js("MirrorTexture")},fi._CreateRenderTargetTexture=(F,a,x,c,u)=>{throw js("RenderTargetTexture")},fi.NEAREST_SAMPLINGMODE=1,fi.NEAREST_NEAREST_MIPLINEAR=8,fi.BILINEAR_SAMPLINGMODE=2,fi.LINEAR_LINEAR_MIPNEAREST=11,fi.TRILINEAR_SAMPLINGMODE=3,fi.LINEAR_LINEAR_MIPLINEAR=3,fi.NEAREST_NEAREST_MIPNEAREST=4,fi.NEAREST_LINEAR_MIPNEAREST=5,fi.NEAREST_LINEAR_MIPLINEAR=6,fi.NEAREST_LINEAR=7,fi.NEAREST_NEAREST=1,fi.LINEAR_NEAREST_MIPNEAREST=9,fi.LINEAR_NEAREST_MIPLINEAR=10,fi.LINEAR_LINEAR=2,fi.LINEAR_NEAREST=12,fi.EXPLICIT_MODE=0,fi.SPHERICAL_MODE=1,fi.PLANAR_MODE=2,fi.CUBIC_MODE=3,fi.PROJECTION_MODE=4,fi.SKYBOX_MODE=5,fi.INVCUBIC_MODE=6,fi.EQUIRECTANGULAR_MODE=7,fi.FIXED_EQUIRECTANGULAR_MODE=8,fi.FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,fi.CLAMP_ADDRESSMODE=0,fi.WRAP_ADDRESSMODE=1,fi.MIRROR_ADDRESSMODE=2,fi.UseSerializedUrlIfAny=!1,Ye([ht()],fi.prototype,"url",void 0),Ye([ht()],fi.prototype,"uOffset",void 0),Ye([ht()],fi.prototype,"vOffset",void 0),Ye([ht()],fi.prototype,"uScale",void 0),Ye([ht()],fi.prototype,"vScale",void 0),Ye([ht()],fi.prototype,"uAng",void 0),Ye([ht()],fi.prototype,"vAng",void 0),Ye([ht()],fi.prototype,"wAng",void 0),Ye([ht()],fi.prototype,"uRotationCenter",void 0),Ye([ht()],fi.prototype,"vRotationCenter",void 0),Ye([ht()],fi.prototype,"wRotationCenter",void 0),Ye([ht()],fi.prototype,"homogeneousRotationInUVTransform",void 0),Ye([ht()],fi.prototype,"isBlocking",null),as("BABYLON.Texture",fi),hr._TextureParser=fi.Parse;class jO{constructor(a){this.name=Xs.NAME_LAYER,this.scene=a||tr.LastCreatedScene,this.scene&&(this._engine=this.scene.getEngine(),this.scene.layers=[])}register(){this.scene._beforeCameraDrawStage.registerStep(Xs.STEP_BEFORECAMERADRAW_LAYER,this,this._drawCameraBackground),this.scene._afterCameraDrawStage.registerStep(Xs.STEP_AFTERCAMERADRAW_LAYER,this,this._drawCameraForegroundWithPostProcessing),this.scene._afterCameraPostProcessStage.registerStep(Xs.STEP_AFTERCAMERAPOSTPROCESS_LAYER,this,this._drawCameraForegroundWithoutPostProcessing),this.scene._beforeRenderTargetDrawStage.registerStep(Xs.STEP_BEFORERENDERTARGETDRAW_LAYER,this,this._drawRenderTargetBackground),this.scene._afterRenderTargetDrawStage.registerStep(Xs.STEP_AFTERRENDERTARGETDRAW_LAYER,this,this._drawRenderTargetForegroundWithPostProcessing),this.scene._afterRenderTargetPostProcessStage.registerStep(Xs.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER,this,this._drawRenderTargetForegroundWithoutPostProcessing)}rebuild(){const a=this.scene.layers;for(const x of a)x._rebuild()}dispose(){const a=this.scene.layers;for(;a.length;)a[0].dispose()}_draw(a){const x=this.scene.layers;if(x.length){this._engine.setDepthBuffer(!1);for(const c of x)a(c)&&c.render();this._engine.setDepthBuffer(!0)}}_drawCameraPredicate(a,x,c,u){return!a.renderOnlyInRenderTargetTextures&&a.isBackground===x&&a.applyPostProcess===c&&(a.layerMask&u)!==0}_drawCameraBackground(a){this._draw(x=>this._drawCameraPredicate(x,!0,!0,a.layerMask))}_drawCameraForegroundWithPostProcessing(a){this._draw(x=>this._drawCameraPredicate(x,!1,!0,a.layerMask))}_drawCameraForegroundWithoutPostProcessing(a){this._draw(x=>this._drawCameraPredicate(x,!1,!1,a.layerMask))}_drawRenderTargetPredicate(a,x,c,u,g){return a.renderTargetTextures.length>0&&a.isBackground===x&&a.applyPostProcess===c&&a.renderTargetTextures.indexOf(g)>-1&&(a.layerMask&u)!==0}_drawRenderTargetBackground(a){this._draw(x=>this._drawRenderTargetPredicate(x,!0,!0,this.scene.activeCamera.layerMask,a))}_drawRenderTargetForegroundWithPostProcessing(a){this._draw(x=>this._drawRenderTargetPredicate(x,!1,!0,this.scene.activeCamera.layerMask,a))}_drawRenderTargetForegroundWithoutPostProcessing(a){this._draw(x=>this._drawRenderTargetPredicate(x,!1,!1,this.scene.activeCamera.layerMask,a))}addFromContainer(a){a.layers&&a.layers.forEach(x=>{this.scene.layers.push(x)})}removeFromContainer(a,x=!1){a.layers&&a.layers.forEach(c=>{const u=this.scene.layers.indexOf(c);u!==-1&&this.scene.layers.splice(u,1),x&&c.dispose()})}}const lb="helperFunctions",hb=`const float PI=3.1415926535897932384626433832795;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
mat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{return value*value;}
vec3 square(vec3 value)
{return value*value;}
float pow5(float value) {float sq=value*value;return sq*sq*value;}
float getLuminance(vec3 color)
{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}
float getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}
float dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}
const float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }
vec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
`;hi.IncludesShadersStore[lb]=hb;const $3={name:lb,shader:hb},ub="layerPixelShader",db=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec4 color;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
vec4 baseColor=texture2D(textureSampler,vUV);
#ifdef LINEAR
baseColor.rgb=toGammaSpace(baseColor.rgb);
#endif
#ifdef ALPHATEST
if (baseColor.a<0.4)
discard;
#endif
gl_FragColor=baseColor*color;
#define CUSTOM_FRAGMENT_MAIN_END
}`;hi.ShadersStore[ub]=db;const J3={name:ub,shader:db},fb="layerVertexShader",mb=`attribute vec2 position;uniform vec2 scale;uniform vec2 offset;uniform mat4 textureMatrix;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec2 shiftedPosition=position*scale+offset;vUV=vec2(textureMatrix*vec4(shiftedPosition*madd+madd,1.0,0.0));gl_Position=vec4(shiftedPosition,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;hi.ShadersStore[fb]=mb;const tB={name:fb,shader:mb};class YO{set applyPostProcess(a){this._applyPostProcess=a}get applyPostProcess(){return this.isBackground||this._applyPostProcess}set onDispose(a){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(a)}set onBeforeRender(a){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(a)}set onAfterRender(a){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(a)}constructor(a,x,c,u,g){this.name=a,this._applyPostProcess=!0,this.scale=new mr(1,1),this.offset=new mr(0,0),this.alphaBlendingMode=2,this.layerMask=268435455,this.renderTargetTextures=[],this.renderOnlyInRenderTargetTextures=!1,this.isEnabled=!0,this._vertexBuffers={},this.onDisposeObservable=new Jt,this.onBeforeRenderObservable=new Jt,this.onAfterRenderObservable=new Jt,this.texture=x?new fi(x,c,!0):null,this.isBackground=u===void 0?!0:u,this.color=g===void 0?new Yr(1,1,1,1):g,this._scene=c||tr.LastCreatedScene;let y=this._scene._getComponent(Xs.NAME_LAYER);y||(y=new jO(this._scene),this._scene._addComponent(y)),this._scene.layers.push(this);const v=this._scene.getEngine();this._drawWrapper=new Yo(v);const w=[];w.push(1,1),w.push(-1,1),w.push(-1,-1),w.push(1,-1);const B=new Ve(v,w,Ve.PositionKind,!1,!1,2);this._vertexBuffers[Ve.PositionKind]=B,this._createIndexBuffer()}_createIndexBuffer(){const a=this._scene.getEngine(),x=[];x.push(0),x.push(1),x.push(2),x.push(0),x.push(2),x.push(3),this._indexBuffer=a.createIndexBuffer(x)}_rebuild(){const a=this._vertexBuffers[Ve.PositionKind];a&&a._rebuild(),this._createIndexBuffer()}isReady(){const a=this._scene.getEngine();let x="";return this.alphaTest&&(x="#define ALPHATEST"),this.texture&&!this.texture.gammaSpace&&(x+=`
#define LINEAR`),this._previousDefines!==x&&(this._previousDefines=x,this._drawWrapper.effect=a.createEffect("layer",[Ve.PositionKind],["textureMatrix","color","scale","offset"],["textureSampler"],x)),this._drawWrapper.effect?.isReady()&&this.texture?.isReady()}render(){if(!this.isEnabled)return;const a=this._scene.getEngine();if(!this.isReady())return;const x=this._drawWrapper.effect;this.onBeforeRenderObservable.notifyObservers(this),a.enableEffect(this._drawWrapper),a.setState(!1),x.setTexture("textureSampler",this.texture),x.setMatrix("textureMatrix",this.texture.getTextureMatrix()),x.setFloat4("color",this.color.r,this.color.g,this.color.b,this.color.a),x.setVector2("offset",this.offset),x.setVector2("scale",this.scale),a.bindBuffers(this._vertexBuffers,this._indexBuffer,x),this.alphaTest?a.drawElementsType(ui.TriangleFillMode,0,6):(a.setAlphaMode(this.alphaBlendingMode),a.drawElementsType(ui.TriangleFillMode,0,6),a.setAlphaMode(0)),this.onAfterRenderObservable.notifyObservers(this)}dispose(){const a=this._vertexBuffers[Ve.PositionKind];a&&(a.dispose(),this._vertexBuffers[Ve.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null),this.texture&&(this.texture.dispose(),this.texture=null),this.renderTargetTextures=[];const x=this._scene.layers.indexOf(this);this._scene.layers.splice(x,1),this.onDisposeObservable.notifyObservers(this),this.onDisposeObservable.clear(),this.onAfterRenderObservable.clear(),this.onBeforeRenderObservable.clear()}}function d_(F,a,x){try{const c=F.next();c.done?a(c):c.value?c.value.then(()=>{c.value=void 0,a(c)},x):a(c)}catch(c){x(c)}}function $O(F=25){let a;return(x,c,u)=>{const g=performance.now();a===void 0||g-a>F?(a=g,setTimeout(()=>{d_(x,c,u)},0)):d_(x,c,u)}}function gb(F,a,x,c,u){const g=()=>{let y;const v=w=>{w.done?x(w.value):y===void 0?y=!0:g()};do y=void 0,!u||!u.aborted?a(F,v,c):c(new Error("Aborted")),y===void 0&&(y=!1);while(y)};g()}function f_(F,a){let x;return gb(F,d_,c=>x=c,c=>{throw c},a),x}function _b(F,a,x){return new Promise((c,u)=>{gb(F,a,c,u,x)})}function JO(F,a){return(...x)=>f_(F(...x),a)}function aB(F,a,x){return(...c)=>_b(F(...c),a,x)}class p_{}class fr{constructor(){this.uniqueId=0,this.metadata={},this._applyTo=JO(this._applyToCoroutine.bind(this)),this.uniqueId=fr._UniqueIDGenerator,fr._UniqueIDGenerator++}set(a,x){switch(a.length||Qt.Warn(`Setting vertex data kind '${x}' with an empty array`),x){case Ve.PositionKind:this.positions=a;break;case Ve.NormalKind:this.normals=a;break;case Ve.TangentKind:this.tangents=a;break;case Ve.UVKind:this.uvs=a;break;case Ve.UV2Kind:this.uvs2=a;break;case Ve.UV3Kind:this.uvs3=a;break;case Ve.UV4Kind:this.uvs4=a;break;case Ve.UV5Kind:this.uvs5=a;break;case Ve.UV6Kind:this.uvs6=a;break;case Ve.ColorKind:this.colors=a;break;case Ve.MatricesIndicesKind:this.matricesIndices=a;break;case Ve.MatricesWeightsKind:this.matricesWeights=a;break;case Ve.MatricesIndicesExtraKind:this.matricesIndicesExtra=a;break;case Ve.MatricesWeightsExtraKind:this.matricesWeightsExtra=a;break}}applyToMesh(a,x){return this._applyTo(a,x,!1),this}applyToGeometry(a,x){return this._applyTo(a,x,!1),this}updateMesh(a){return this._update(a),this}updateGeometry(a){return this._update(a),this}*_applyToCoroutine(a,x=!1,c){if(this.positions&&(a.setVerticesData(Ve.PositionKind,this.positions,x),c&&(yield)),this.normals&&(a.setVerticesData(Ve.NormalKind,this.normals,x),c&&(yield)),this.tangents&&(a.setVerticesData(Ve.TangentKind,this.tangents,x),c&&(yield)),this.uvs&&(a.setVerticesData(Ve.UVKind,this.uvs,x),c&&(yield)),this.uvs2&&(a.setVerticesData(Ve.UV2Kind,this.uvs2,x),c&&(yield)),this.uvs3&&(a.setVerticesData(Ve.UV3Kind,this.uvs3,x),c&&(yield)),this.uvs4&&(a.setVerticesData(Ve.UV4Kind,this.uvs4,x),c&&(yield)),this.uvs5&&(a.setVerticesData(Ve.UV5Kind,this.uvs5,x),c&&(yield)),this.uvs6&&(a.setVerticesData(Ve.UV6Kind,this.uvs6,x),c&&(yield)),this.colors&&(a.setVerticesData(Ve.ColorKind,this.colors,x),this.hasVertexAlpha&&a.hasVertexAlpha!==void 0&&(a.hasVertexAlpha=!0),c&&(yield)),this.matricesIndices&&(a.setVerticesData(Ve.MatricesIndicesKind,this.matricesIndices,x),c&&(yield)),this.matricesWeights&&(a.setVerticesData(Ve.MatricesWeightsKind,this.matricesWeights,x),c&&(yield)),this.matricesIndicesExtra&&(a.setVerticesData(Ve.MatricesIndicesExtraKind,this.matricesIndicesExtra,x),c&&(yield)),this.matricesWeightsExtra&&(a.setVerticesData(Ve.MatricesWeightsExtraKind,this.matricesWeightsExtra,x),c&&(yield)),this.indices?(a.setIndices(this.indices,null,x),c&&(yield)):a.setIndices([],null),a.subMeshes&&this.materialInfos&&this.materialInfos.length>1){const u=a;u.subMeshes=[];for(const g of this.materialInfos)new ul(g.materialIndex,g.verticesStart,g.verticesCount,g.indexStart,g.indexCount,u)}return this}_update(a,x,c){return this.positions&&a.updateVerticesData(Ve.PositionKind,this.positions,x,c),this.normals&&a.updateVerticesData(Ve.NormalKind,this.normals,x,c),this.tangents&&a.updateVerticesData(Ve.TangentKind,this.tangents,x,c),this.uvs&&a.updateVerticesData(Ve.UVKind,this.uvs,x,c),this.uvs2&&a.updateVerticesData(Ve.UV2Kind,this.uvs2,x,c),this.uvs3&&a.updateVerticesData(Ve.UV3Kind,this.uvs3,x,c),this.uvs4&&a.updateVerticesData(Ve.UV4Kind,this.uvs4,x,c),this.uvs5&&a.updateVerticesData(Ve.UV5Kind,this.uvs5,x,c),this.uvs6&&a.updateVerticesData(Ve.UV6Kind,this.uvs6,x,c),this.colors&&a.updateVerticesData(Ve.ColorKind,this.colors,x,c),this.matricesIndices&&a.updateVerticesData(Ve.MatricesIndicesKind,this.matricesIndices,x,c),this.matricesWeights&&a.updateVerticesData(Ve.MatricesWeightsKind,this.matricesWeights,x,c),this.matricesIndicesExtra&&a.updateVerticesData(Ve.MatricesIndicesExtraKind,this.matricesIndicesExtra,x,c),this.matricesWeightsExtra&&a.updateVerticesData(Ve.MatricesWeightsExtraKind,this.matricesWeightsExtra,x,c),this.indices&&a.setIndices(this.indices,null),this}static _TransformVector3Coordinates(a,x,c=0,u=a.length){const g=Yt.Vector3[0],y=Yt.Vector3[1];for(let v=c;v<c+u;v+=3)Ee.FromArrayToRef(a,v,g),Ee.TransformCoordinatesToRef(g,x,y),a[v]=y.x,a[v+1]=y.y,a[v+2]=y.z}static _TransformVector3Normals(a,x,c=0,u=a.length){const g=Yt.Vector3[0],y=Yt.Vector3[1];for(let v=c;v<c+u;v+=3)Ee.FromArrayToRef(a,v,g),Ee.TransformNormalToRef(g,x,y),a[v]=y.x,a[v+1]=y.y,a[v+2]=y.z}static _TransformVector4Normals(a,x,c=0,u=a.length){const g=Yt.Vector4[0],y=Yt.Vector4[1];for(let v=c;v<c+u;v+=4)an.FromArrayToRef(a,v,g),an.TransformNormalToRef(g,x,y),a[v]=y.x,a[v+1]=y.y,a[v+2]=y.z,a[v+3]=y.w}static _FlipFaces(a,x=0,c=a.length){for(let u=x;u<x+c;u+=3){const g=a[u+1];a[u+1]=a[u+2],a[u+2]=g}}transform(a){const x=a.determinant()<0;return this.positions&&fr._TransformVector3Coordinates(this.positions,a),this.normals&&fr._TransformVector3Normals(this.normals,a),this.tangents&&fr._TransformVector4Normals(this.tangents,a),x&&this.indices&&fr._FlipFaces(this.indices),this}splitBasedOnMaterialID(){if(!this.materialInfos||this.materialInfos.length<2)return[this];const a=[];for(const x of this.materialInfos){const c=new fr;if(this.positions&&(c.positions=this.positions.slice(x.verticesStart*3,(x.verticesCount+x.verticesStart)*3)),this.normals&&(c.normals=this.normals.slice(x.verticesStart*3,(x.verticesCount+x.verticesStart)*3)),this.tangents&&(c.tangents=this.tangents.slice(x.verticesStart*4,(x.verticesCount+x.verticesStart)*4)),this.colors&&(c.colors=this.colors.slice(x.verticesStart*4,(x.verticesCount+x.verticesStart)*4)),this.uvs&&(c.uvs=this.uvs.slice(x.verticesStart*2,(x.verticesCount+x.verticesStart)*2)),this.uvs2&&(c.uvs2=this.uvs2.slice(x.verticesStart*2,(x.verticesCount+x.verticesStart)*2)),this.uvs3&&(c.uvs3=this.uvs3.slice(x.verticesStart*2,(x.verticesCount+x.verticesStart)*2)),this.uvs4&&(c.uvs4=this.uvs4.slice(x.verticesStart*2,(x.verticesCount+x.verticesStart)*2)),this.uvs5&&(c.uvs5=this.uvs5.slice(x.verticesStart*2,(x.verticesCount+x.verticesStart)*2)),this.uvs6&&(c.uvs6=this.uvs6.slice(x.verticesStart*2,(x.verticesCount+x.verticesStart)*2)),this.matricesIndices&&(c.matricesIndices=this.matricesIndices.slice(x.verticesStart*4,(x.verticesCount+x.verticesStart)*4)),this.matricesIndicesExtra&&(c.matricesIndicesExtra=this.matricesIndicesExtra.slice(x.verticesStart*4,(x.verticesCount+x.verticesStart)*4)),this.matricesWeights&&(c.matricesWeights=this.matricesWeights.slice(x.verticesStart*4,(x.verticesCount+x.verticesStart)*4)),this.matricesWeightsExtra&&(c.matricesWeightsExtra=this.matricesWeightsExtra.slice(x.verticesStart*4,(x.verticesCount+x.verticesStart)*4)),this.indices){c.indices=[];for(let g=x.indexStart;g<x.indexStart+x.indexCount;g++)c.indices.push(this.indices[g]-x.verticesStart)}const u=new p_;u.indexStart=0,u.indexCount=c.indices?c.indices.length:0,u.materialIndex=x.materialIndex,u.verticesStart=0,u.verticesCount=(c.positions?c.positions.length:0)/3,c.materialInfos=[u],a.push(c)}return a}merge(a,x=!1,c=!1,u=!1,g=!1){const y=Array.isArray(a)?a.map(v=>({vertexData:v})):[{vertexData:a}];return f_(this._mergeCoroutine(void 0,y,x,!1,c,u,g))}*_mergeCoroutine(a,x,c=!1,u,g,y=!1,v=!1){this._validate();let w=x.map(fe=>fe.vertexData),B=this;if(v)for(const fe of w)fe&&(fe._validate(),!this.normals&&fe.normals&&(this.normals=new Float32Array(this.positions.length)),!this.tangents&&fe.tangents&&(this.tangents=new Float32Array(this.positions.length/3*4)),!this.uvs&&fe.uvs&&(this.uvs=new Float32Array(this.positions.length/3*2)),!this.uvs2&&fe.uvs2&&(this.uvs2=new Float32Array(this.positions.length/3*2)),!this.uvs3&&fe.uvs3&&(this.uvs3=new Float32Array(this.positions.length/3*2)),!this.uvs4&&fe.uvs4&&(this.uvs4=new Float32Array(this.positions.length/3*2)),!this.uvs5&&fe.uvs5&&(this.uvs5=new Float32Array(this.positions.length/3*2)),!this.uvs6&&fe.uvs6&&(this.uvs6=new Float32Array(this.positions.length/3*2)),!this.colors&&fe.colors&&(this.colors=new Float32Array(this.positions.length/3*4),this.colors.fill(1)),!this.matricesIndices&&fe.matricesIndices&&(this.matricesIndices=new Float32Array(this.positions.length/3*4)),!this.matricesWeights&&fe.matricesWeights&&(this.matricesWeights=new Float32Array(this.positions.length/3*4)),!this.matricesIndicesExtra&&fe.matricesIndicesExtra&&(this.matricesIndicesExtra=new Float32Array(this.positions.length/3*4)),!this.matricesWeightsExtra&&fe.matricesWeightsExtra&&(this.matricesWeightsExtra=new Float32Array(this.positions.length/3*4)));for(const fe of w)if(fe){if(v)this.normals&&!fe.normals&&(fe.normals=new Float32Array(fe.positions.length)),this.tangents&&!fe.tangents&&(fe.tangents=new Float32Array(fe.positions.length/3*4)),this.uvs&&!fe.uvs&&(fe.uvs=new Float32Array(fe.positions.length/3*2)),this.uvs2&&!fe.uvs2&&(fe.uvs2=new Float32Array(fe.positions.length/3*2)),this.uvs3&&!fe.uvs3&&(fe.uvs3=new Float32Array(fe.positions.length/3*2)),this.uvs4&&!fe.uvs4&&(fe.uvs4=new Float32Array(fe.positions.length/3*2)),this.uvs5&&!fe.uvs5&&(fe.uvs5=new Float32Array(fe.positions.length/3*2)),this.uvs6&&!fe.uvs6&&(fe.uvs6=new Float32Array(fe.positions.length/3*2)),this.colors&&!fe.colors&&(fe.colors=new Float32Array(fe.positions.length/3*4),fe.colors.fill(1)),this.matricesIndices&&!fe.matricesIndices&&(fe.matricesIndices=new Float32Array(fe.positions.length/3*4)),this.matricesWeights&&!fe.matricesWeights&&(fe.matricesWeights=new Float32Array(fe.positions.length/3*4)),this.matricesIndicesExtra&&!fe.matricesIndicesExtra&&(fe.matricesIndicesExtra=new Float32Array(fe.positions.length/3*4)),this.matricesWeightsExtra&&!fe.matricesWeightsExtra&&(fe.matricesWeightsExtra=new Float32Array(fe.positions.length/3*4));else if(fe._validate(),!this.normals!=!fe.normals||!this.tangents!=!fe.tangents||!this.uvs!=!fe.uvs||!this.uvs2!=!fe.uvs2||!this.uvs3!=!fe.uvs3||!this.uvs4!=!fe.uvs4||!this.uvs5!=!fe.uvs5||!this.uvs6!=!fe.uvs6||!this.colors!=!fe.colors||!this.matricesIndices!=!fe.matricesIndices||!this.matricesWeights!=!fe.matricesWeights||!this.matricesIndicesExtra!=!fe.matricesIndicesExtra||!this.matricesWeightsExtra!=!fe.matricesWeightsExtra)throw new Error("Cannot merge vertex data that do not have the same set of attributes")}if(y){let fe=0,Re=0,_e=0;const Be=[];let tt=null;const $e=[];for(const ft of this.splitBasedOnMaterialID())$e.push({vertexData:ft,transform:a});for(const ft of x)if(ft.vertexData)for(const dt of ft.vertexData.splitBasedOnMaterialID())$e.push({vertexData:dt,transform:ft.transform});$e.sort((ft,dt)=>{const ut=ft.vertexData.materialInfos?ft.vertexData.materialInfos[0].materialIndex:0,Mt=dt.vertexData.materialInfos?dt.vertexData.materialInfos[0].materialIndex:0;return ut>Mt?1:ut===Mt?0:-1});for(const ft of $e){const dt=ft.vertexData;if(dt.materialInfos?fe=dt.materialInfos[0].materialIndex:fe=0,tt&&tt.materialIndex===fe)tt.indexCount+=dt.indices.length,tt.verticesCount+=dt.positions.length/3;else{const ut=new p_;ut.materialIndex=fe,ut.indexStart=Re,ut.indexCount=dt.indices.length,ut.verticesStart=_e,ut.verticesCount=dt.positions.length/3,Be.push(ut),tt=ut}Re+=dt.indices.length,_e+=dt.positions.length/3}const Et=$e.splice(0,1)[0];B=Et.vertexData,a=Et.transform,w=$e.map(ft=>ft.vertexData),x=$e,this.materialInfos=Be}const W=w.reduce((fe,Re)=>fe+(Re.indices?.length??0),B.indices?.length??0);let ue=g||w.some(fe=>fe.indices===B.indices)?B.indices?.slice():B.indices;if(W>0){let fe=ue?.length??0;if(ue||(ue=new Array(W)),ue.length!==W){if(Array.isArray(ue))ue.length=W;else{const _e=c||ue instanceof Uint32Array?new Uint32Array(W):new Uint16Array(W);_e.set(ue),ue=_e}a&&a.determinant()<0&&fr._FlipFaces(ue,0,fe)}let Re=B.positions?B.positions.length/3:0;for(const{vertexData:_e,transform:Be}of x)if(_e.indices){for(let tt=0;tt<_e.indices.length;tt++)ue[fe+tt]=_e.indices[tt]+Re;Be&&Be.determinant()<0&&fr._FlipFaces(ue,fe,_e.indices.length),Re+=_e.positions.length/3,fe+=_e.indices.length,u&&(yield)}}return this.indices=ue,this.positions=fr._MergeElement(Ve.PositionKind,B.positions,a,x.map(fe=>[fe.vertexData.positions,fe.transform])),u&&(yield),B.normals&&(this.normals=fr._MergeElement(Ve.NormalKind,B.normals,a,x.map(fe=>[fe.vertexData.normals,fe.transform])),u&&(yield)),B.tangents&&(this.tangents=fr._MergeElement(Ve.TangentKind,B.tangents,a,x.map(fe=>[fe.vertexData.tangents,fe.transform])),u&&(yield)),B.uvs&&(this.uvs=fr._MergeElement(Ve.UVKind,B.uvs,a,x.map(fe=>[fe.vertexData.uvs,fe.transform])),u&&(yield)),B.uvs2&&(this.uvs2=fr._MergeElement(Ve.UV2Kind,B.uvs2,a,x.map(fe=>[fe.vertexData.uvs2,fe.transform])),u&&(yield)),B.uvs3&&(this.uvs3=fr._MergeElement(Ve.UV3Kind,B.uvs3,a,x.map(fe=>[fe.vertexData.uvs3,fe.transform])),u&&(yield)),B.uvs4&&(this.uvs4=fr._MergeElement(Ve.UV4Kind,B.uvs4,a,x.map(fe=>[fe.vertexData.uvs4,fe.transform])),u&&(yield)),B.uvs5&&(this.uvs5=fr._MergeElement(Ve.UV5Kind,B.uvs5,a,x.map(fe=>[fe.vertexData.uvs5,fe.transform])),u&&(yield)),B.uvs6&&(this.uvs6=fr._MergeElement(Ve.UV6Kind,B.uvs6,a,x.map(fe=>[fe.vertexData.uvs6,fe.transform])),u&&(yield)),B.colors&&(this.colors=fr._MergeElement(Ve.ColorKind,B.colors,a,x.map(fe=>[fe.vertexData.colors,fe.transform])),(B.hasVertexAlpha!==void 0||x.some(fe=>fe.vertexData.hasVertexAlpha!==void 0))&&(this.hasVertexAlpha=B.hasVertexAlpha||x.some(fe=>fe.vertexData.hasVertexAlpha)),u&&(yield)),B.matricesIndices&&(this.matricesIndices=fr._MergeElement(Ve.MatricesIndicesKind,B.matricesIndices,a,x.map(fe=>[fe.vertexData.matricesIndices,fe.transform])),u&&(yield)),B.matricesWeights&&(this.matricesWeights=fr._MergeElement(Ve.MatricesWeightsKind,B.matricesWeights,a,x.map(fe=>[fe.vertexData.matricesWeights,fe.transform])),u&&(yield)),B.matricesIndicesExtra&&(this.matricesIndicesExtra=fr._MergeElement(Ve.MatricesIndicesExtraKind,B.matricesIndicesExtra,a,x.map(fe=>[fe.vertexData.matricesIndicesExtra,fe.transform])),u&&(yield)),B.matricesWeightsExtra&&(this.matricesWeightsExtra=fr._MergeElement(Ve.MatricesWeightsExtraKind,B.matricesWeightsExtra,a,x.map(fe=>[fe.vertexData.matricesWeightsExtra,fe.transform]))),this}static _MergeElement(a,x,c,u){const g=u.filter(w=>w[0]!==null&&w[0]!==void 0);if(!x&&g.length==0)return x;if(!x)return this._MergeElement(a,g[0][0],g[0][1],g.slice(1));const y=g.reduce((w,B)=>w+B[0].length,x.length),v=a===Ve.PositionKind?fr._TransformVector3Coordinates:a===Ve.NormalKind?fr._TransformVector3Normals:a===Ve.TangentKind?fr._TransformVector4Normals:()=>{};if(x instanceof Float32Array){const w=new Float32Array(y);w.set(x),c&&v(w,c,0,x.length);let B=x.length;for(const[W,ae]of g)w.set(W,B),ae&&v(w,ae,B,W.length),B+=W.length;return w}else{const w=new Array(y);for(let W=0;W<x.length;W++)w[W]=x[W];c&&v(w,c,0,x.length);let B=x.length;for(const[W,ae]of g){for(let ue=0;ue<W.length;ue++)w[B+ue]=W[ue];ae&&v(w,ae,B,W.length),B+=W.length}return w}}_validate(){if(!this.positions)throw new Xo("Positions are required",Ho.MeshInvalidPositionsError);const a=(u,g)=>{const y=Ve.DeduceStride(u);if(g.length%y!==0)throw new Error("The "+u+"s array count must be a multiple of "+y);return g.length/y},x=a(Ve.PositionKind,this.positions),c=(u,g)=>{const y=a(u,g);if(y!==x)throw new Error("The "+u+"s element count ("+y+") does not match the positions count ("+x+")")};this.normals&&c(Ve.NormalKind,this.normals),this.tangents&&c(Ve.TangentKind,this.tangents),this.uvs&&c(Ve.UVKind,this.uvs),this.uvs2&&c(Ve.UV2Kind,this.uvs2),this.uvs3&&c(Ve.UV3Kind,this.uvs3),this.uvs4&&c(Ve.UV4Kind,this.uvs4),this.uvs5&&c(Ve.UV5Kind,this.uvs5),this.uvs6&&c(Ve.UV6Kind,this.uvs6),this.colors&&c(Ve.ColorKind,this.colors),this.matricesIndices&&c(Ve.MatricesIndicesKind,this.matricesIndices),this.matricesWeights&&c(Ve.MatricesWeightsKind,this.matricesWeights),this.matricesIndicesExtra&&c(Ve.MatricesIndicesExtraKind,this.matricesIndicesExtra),this.matricesWeightsExtra&&c(Ve.MatricesWeightsExtraKind,this.matricesWeightsExtra)}clone(){const a=this.serialize();return fr.Parse(a)}serialize(){const a={};if(this.positions&&(a.positions=Array.from(this.positions)),this.normals&&(a.normals=Array.from(this.normals)),this.tangents&&(a.tangents=Array.from(this.tangents)),this.uvs&&(a.uvs=Array.from(this.uvs)),this.uvs2&&(a.uvs2=Array.from(this.uvs2)),this.uvs3&&(a.uvs3=Array.from(this.uvs3)),this.uvs4&&(a.uvs4=Array.from(this.uvs4)),this.uvs5&&(a.uvs5=Array.from(this.uvs5)),this.uvs6&&(a.uvs6=Array.from(this.uvs6)),this.colors&&(a.colors=Array.from(this.colors),a.hasVertexAlpha=this.hasVertexAlpha),this.matricesIndices&&(a.matricesIndices=Array.from(this.matricesIndices),a.matricesIndices._isExpanded=!0),this.matricesWeights&&(a.matricesWeights=Array.from(this.matricesWeights)),this.matricesIndicesExtra&&(a.matricesIndicesExtra=Array.from(this.matricesIndicesExtra),a.matricesIndicesExtra._isExpanded=!0),this.matricesWeightsExtra&&(a.matricesWeightsExtra=Array.from(this.matricesWeightsExtra)),a.indices=Array.from(this.indices),this.materialInfos){a.materialInfos=[];for(const x of this.materialInfos){const c={indexStart:x.indexStart,indexCount:x.indexCount,materialIndex:x.materialIndex,verticesStart:x.verticesStart,verticesCount:x.verticesCount};a.materialInfos.push(c)}}return a}static ExtractFromMesh(a,x,c){return fr._ExtractFrom(a,x,c)}static ExtractFromGeometry(a,x,c){return fr._ExtractFrom(a,x,c)}static _ExtractFrom(a,x,c){const u=new fr;return a.isVerticesDataPresent(Ve.PositionKind)&&(u.positions=a.getVerticesData(Ve.PositionKind,x,c)),a.isVerticesDataPresent(Ve.NormalKind)&&(u.normals=a.getVerticesData(Ve.NormalKind,x,c)),a.isVerticesDataPresent(Ve.TangentKind)&&(u.tangents=a.getVerticesData(Ve.TangentKind,x,c)),a.isVerticesDataPresent(Ve.UVKind)&&(u.uvs=a.getVerticesData(Ve.UVKind,x,c)),a.isVerticesDataPresent(Ve.UV2Kind)&&(u.uvs2=a.getVerticesData(Ve.UV2Kind,x,c)),a.isVerticesDataPresent(Ve.UV3Kind)&&(u.uvs3=a.getVerticesData(Ve.UV3Kind,x,c)),a.isVerticesDataPresent(Ve.UV4Kind)&&(u.uvs4=a.getVerticesData(Ve.UV4Kind,x,c)),a.isVerticesDataPresent(Ve.UV5Kind)&&(u.uvs5=a.getVerticesData(Ve.UV5Kind,x,c)),a.isVerticesDataPresent(Ve.UV6Kind)&&(u.uvs6=a.getVerticesData(Ve.UV6Kind,x,c)),a.isVerticesDataPresent(Ve.ColorKind)&&(u.colors=a.getVerticesData(Ve.ColorKind,x,c)),a.isVerticesDataPresent(Ve.MatricesIndicesKind)&&(u.matricesIndices=a.getVerticesData(Ve.MatricesIndicesKind,x,c)),a.isVerticesDataPresent(Ve.MatricesWeightsKind)&&(u.matricesWeights=a.getVerticesData(Ve.MatricesWeightsKind,x,c)),a.isVerticesDataPresent(Ve.MatricesIndicesExtraKind)&&(u.matricesIndicesExtra=a.getVerticesData(Ve.MatricesIndicesExtraKind,x,c)),a.isVerticesDataPresent(Ve.MatricesWeightsExtraKind)&&(u.matricesWeightsExtra=a.getVerticesData(Ve.MatricesWeightsExtraKind,x,c)),u.indices=a.getIndices(x,c),u}static CreateRibbon(a){throw js("ribbonBuilder")}static CreateBox(a){throw js("boxBuilder")}static CreateTiledBox(a){throw js("tiledBoxBuilder")}static CreateTiledPlane(a){throw js("tiledPlaneBuilder")}static CreateSphere(a){throw js("sphereBuilder")}static CreateCylinder(a){throw js("cylinderBuilder")}static CreateTorus(a){throw js("torusBuilder")}static CreateLineSystem(a){throw js("linesBuilder")}static CreateDashedLines(a){throw js("linesBuilder")}static CreateGround(a){throw js("groundBuilder")}static CreateTiledGround(a){throw js("groundBuilder")}static CreateGroundFromHeightMap(a){throw js("groundBuilder")}static CreatePlane(a){throw js("planeBuilder")}static CreateDisc(a){throw js("discBuilder")}static CreatePolygon(a,x,c,u,g,y,v){throw js("polygonBuilder")}static CreateIcoSphere(a){throw js("icoSphereBuilder")}static CreatePolyhedron(a){throw js("polyhedronBuilder")}static CreateCapsule(a={orientation:Ee.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){throw js("capsuleBuilder")}static CreateTorusKnot(a){throw js("torusKnotBuilder")}static ComputeNormals(a,x,c,u){let g=0,y=0,v=0,w=0,B=0,W=0,ae=0,ue=0,fe=0,Re=0,_e=0,Be=0,tt=0,$e=0,Et=0,ft=0,dt=0,ut=0,Mt=0,ai=0,Yi=!1,Vi=!1,Js=!1,Rr=!1,_r=1,Vr=0,Ja=null;u&&(Yi=!!u.facetNormals,Vi=!!u.facetPositions,Js=!!u.facetPartitioning,_r=u.useRightHandedSystem===!0?-1:1,Vr=u.ratio||0,Rr=!!u.depthSort,Ja=u.distanceTo,Rr&&Ja===void 0&&(Ja=Ee.Zero()));let ta=0,ja=0,k0=0,B0=0;for(Js&&u&&u.bbSize&&(ta=u.subDiv.X*Vr/u.bbSize.x,ja=u.subDiv.Y*Vr/u.bbSize.y,k0=u.subDiv.Z*Vr/u.bbSize.z,B0=u.subDiv.max*u.subDiv.max,u.facetPartitioning.length=0),g=0;g<a.length;g++)c[g]=0;const Hx=x.length/3|0;for(g=0;g<Hx;g++){if(Be=x[g*3]*3,tt=Be+1,$e=Be+2,Et=x[g*3+1]*3,ft=Et+1,dt=Et+2,ut=x[g*3+2]*3,Mt=ut+1,ai=ut+2,y=a[Be]-a[Et],v=a[tt]-a[ft],w=a[$e]-a[dt],B=a[ut]-a[Et],W=a[Mt]-a[ft],ae=a[ai]-a[dt],ue=_r*(v*ae-w*W),fe=_r*(w*B-y*ae),Re=_r*(y*W-v*B),_e=Math.sqrt(ue*ue+fe*fe+Re*Re),_e=_e===0?1:_e,ue/=_e,fe/=_e,Re/=_e,Yi&&u&&(u.facetNormals[g].x=ue,u.facetNormals[g].y=fe,u.facetNormals[g].z=Re),Vi&&u&&(u.facetPositions[g].x=(a[Be]+a[Et]+a[ut])/3,u.facetPositions[g].y=(a[tt]+a[ft]+a[Mt])/3,u.facetPositions[g].z=(a[$e]+a[dt]+a[ai])/3),Js&&u){const Ex=Math.floor((u.facetPositions[g].x-u.bInfo.minimum.x*Vr)*ta),E2=Math.floor((u.facetPositions[g].y-u.bInfo.minimum.y*Vr)*ja),dh=Math.floor((u.facetPositions[g].z-u.bInfo.minimum.z*Vr)*k0),t_=Math.floor((a[Be]-u.bInfo.minimum.x*Vr)*ta),i_=Math.floor((a[tt]-u.bInfo.minimum.y*Vr)*ja),s_=Math.floor((a[$e]-u.bInfo.minimum.z*Vr)*k0),Vy=Math.floor((a[Et]-u.bInfo.minimum.x*Vr)*ta),Wy=Math.floor((a[ft]-u.bInfo.minimum.y*Vr)*ja),Hy=Math.floor((a[dt]-u.bInfo.minimum.z*Vr)*k0),Xy=Math.floor((a[ut]-u.bInfo.minimum.x*Vr)*ta),jy=Math.floor((a[Mt]-u.bInfo.minimum.y*Vr)*ja),Yy=Math.floor((a[ai]-u.bInfo.minimum.z*Vr)*k0),mc=t_+u.subDiv.max*i_+B0*s_,gc=Vy+u.subDiv.max*Wy+B0*Hy,_c=Xy+u.subDiv.max*jy+B0*Yy,yc=Ex+u.subDiv.max*E2+B0*dh;u.facetPartitioning[yc]=u.facetPartitioning[yc]?u.facetPartitioning[yc]:new Array,u.facetPartitioning[mc]=u.facetPartitioning[mc]?u.facetPartitioning[mc]:new Array,u.facetPartitioning[gc]=u.facetPartitioning[gc]?u.facetPartitioning[gc]:new Array,u.facetPartitioning[_c]=u.facetPartitioning[_c]?u.facetPartitioning[_c]:new Array,u.facetPartitioning[mc].push(g),gc!=mc&&u.facetPartitioning[gc].push(g),_c==gc||_c==mc||u.facetPartitioning[_c].push(g),yc==mc||yc==gc||yc==_c||u.facetPartitioning[yc].push(g)}if(Rr&&u&&u.facetPositions){const Ex=u.depthSortedFacets[g];Ex.ind=g*3,Ex.sqDistance=Ee.DistanceSquared(u.facetPositions[g],Ja)}c[Be]+=ue,c[tt]+=fe,c[$e]+=Re,c[Et]+=ue,c[ft]+=fe,c[dt]+=Re,c[ut]+=ue,c[Mt]+=fe,c[ai]+=Re}for(g=0;g<c.length/3;g++)ue=c[g*3],fe=c[g*3+1],Re=c[g*3+2],_e=Math.sqrt(ue*ue+fe*fe+Re*Re),_e=_e===0?1:_e,ue/=_e,fe/=_e,Re/=_e,c[g*3]=ue,c[g*3+1]=fe,c[g*3+2]=Re}static _ComputeSides(a,x,c,u,g,y,v){const w=c.length,B=u.length;let W,ae;switch(a=a||fr.DEFAULTSIDE,a){case fr.FRONTSIDE:break;case fr.BACKSIDE:for(W=0;W<w;W+=3){const ue=c[W];c[W]=c[W+2],c[W+2]=ue}for(ae=0;ae<B;ae++)u[ae]=-u[ae];break;case fr.DOUBLESIDE:{const ue=x.length,fe=ue/3;for(let Be=0;Be<ue;Be++)x[ue+Be]=x[Be];for(W=0;W<w;W+=3)c[W+w]=c[W+2]+fe,c[W+1+w]=c[W+1]+fe,c[W+2+w]=c[W]+fe;for(ae=0;ae<B;ae++)u[B+ae]=-u[ae];const Re=g.length;let _e=0;for(_e=0;_e<Re;_e++)g[_e+Re]=g[_e];for(y=y||new an(0,0,1,1),v=v||new an(0,0,1,1),_e=0,W=0;W<Re/2;W++)g[_e]=y.x+(y.z-y.x)*g[_e],g[_e+1]=y.y+(y.w-y.y)*g[_e+1],g[_e+Re]=v.x+(v.z-v.x)*g[_e+Re],g[_e+Re+1]=v.y+(v.w-v.y)*g[_e+Re+1],_e+=2;break}}}static Parse(a){const x=new fr,c=a.positions;c&&x.set(c,Ve.PositionKind);const u=a.normals;u&&x.set(u,Ve.NormalKind);const g=a.tangents;g&&x.set(g,Ve.TangentKind);const y=a.uvs;y&&x.set(y,Ve.UVKind);const v=a.uvs2;v&&x.set(v,Ve.UV2Kind);const w=a.uvs3;w&&x.set(w,Ve.UV3Kind);const B=a.uvs4;B&&x.set(B,Ve.UV4Kind);const W=a.uvs5;W&&x.set(W,Ve.UV5Kind);const ae=a.uvs6;ae&&x.set(ae,Ve.UV6Kind);const ue=a.colors;ue&&(x.set(Yr.CheckColors4(ue,c.length/3),Ve.ColorKind),a.hasVertexAlpha!==void 0&&(x.hasVertexAlpha=a.hasVertexAlpha));const fe=a.matricesIndices;fe&&x.set(fe,Ve.MatricesIndicesKind);const Re=a.matricesWeights;Re&&x.set(Re,Ve.MatricesWeightsKind);const _e=a.indices;_e&&(x.indices=_e);const Be=a.materialInfos;if(Be){x.materialInfos=[];for(const tt of Be){const $e=new p_;$e.indexCount=tt.indexCount,$e.indexStart=tt.indexStart,$e.verticesCount=tt.verticesCount,$e.verticesStart=tt.verticesStart,$e.materialIndex=tt.materialIndex,x.materialInfos.push($e)}}return x}static ImportVertexData(a,x){const c=fr.Parse(a);x.setAllVerticesData(c,a.updatable)}}fr.FRONTSIDE=0,fr.BACKSIDE=1,fr.DOUBLESIDE=2,fr.DEFAULTSIDE=0,fr._UniqueIDGenerator=0,Ye([Hc.filter((...[F])=>!Array.isArray(F))],fr,"_TransformVector3Coordinates",null),Ye([Hc.filter((...[F])=>!Array.isArray(F))],fr,"_TransformVector3Normals",null),Ye([Hc.filter((...[F])=>!Array.isArray(F))],fr,"_TransformVector4Normals",null),Ye([Hc.filter((...[F])=>!Array.isArray(F))],fr,"_FlipFaces",null);const tD=vt.Compose(Ee.One(),Wi.FromEulerAngles(0,Math.PI,0),Ee.Zero());class $s extends fa{get billboardMode(){return this._billboardMode}set billboardMode(a){this._billboardMode!==a&&(this._billboardMode=a,this._cache.useBillboardPosition=(this._billboardMode&$s.BILLBOARDMODE_USE_POSITION)!==0,this._computeUseBillboardPath())}get preserveParentRotationForBillboard(){return this._preserveParentRotationForBillboard}set preserveParentRotationForBillboard(a){a!==this._preserveParentRotationForBillboard&&(this._preserveParentRotationForBillboard=a,this._computeUseBillboardPath())}_computeUseBillboardPath(){this._cache.useBillboardPath=this._billboardMode!==$s.BILLBOARDMODE_NONE&&!this.preserveParentRotationForBillboard}get infiniteDistance(){return this._infiniteDistance}set infiniteDistance(a){this._infiniteDistance!==a&&(this._infiniteDistance=a)}constructor(a,x=null,c=!0){super(a,x),this._forward=new Ee(0,0,1),this._up=new Ee(0,1,0),this._right=new Ee(1,0,0),this._position=Ee.Zero(),this._rotation=Ee.Zero(),this._rotationQuaternion=null,this._scaling=Ee.One(),this._transformToBoneReferal=null,this._isAbsoluteSynced=!1,this._billboardMode=$s.BILLBOARDMODE_NONE,this._preserveParentRotationForBillboard=!1,this.scalingDeterminant=1,this._infiniteDistance=!1,this.ignoreNonUniformScaling=!1,this.reIntegrateRotationIntoRotationQuaternion=!1,this._poseMatrix=null,this._localMatrix=vt.Zero(),this._usePivotMatrix=!1,this._absolutePosition=Ee.Zero(),this._absoluteScaling=Ee.Zero(),this._absoluteRotationQuaternion=Wi.Identity(),this._pivotMatrix=vt.Identity(),this._postMultiplyPivotMatrix=!1,this._isWorldMatrixFrozen=!1,this._indexInSceneTransformNodesArray=-1,this.onAfterWorldMatrixUpdateObservable=new Jt,this._nonUniformScaling=!1,c&&this.getScene().addTransformNode(this)}getClassName(){return"TransformNode"}get position(){return this._position}set position(a){this._position=a,this._isDirty=!0}isUsingPivotMatrix(){return this._usePivotMatrix}isUsingPostMultiplyPivotMatrix(){return this._postMultiplyPivotMatrix}get rotation(){return this._rotation}set rotation(a){this._rotation=a,this._rotationQuaternion=null,this._isDirty=!0}get scaling(){return this._scaling}set scaling(a){this._scaling=a,this._isDirty=!0}get rotationQuaternion(){return this._rotationQuaternion}set rotationQuaternion(a){this._rotationQuaternion=a,a&&this._rotation.setAll(0),this._isDirty=!0}get forward(){return Ee.TransformNormalFromFloatsToRef(0,0,this.getScene().useRightHandedSystem?-1:1,this.getWorldMatrix(),this._forward),this._forward.normalize()}get up(){return Ee.TransformNormalFromFloatsToRef(0,1,0,this.getWorldMatrix(),this._up),this._up.normalize()}get right(){return Ee.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem?-1:1,0,0,this.getWorldMatrix(),this._right),this._right.normalize()}updatePoseMatrix(a){return this._poseMatrix?(this._poseMatrix.copyFrom(a),this):(this._poseMatrix=a.clone(),this)}getPoseMatrix(){return this._poseMatrix||(this._poseMatrix=vt.Identity()),this._poseMatrix}_isSynchronized(){const a=this._cache;return!(this._billboardMode!==a.billboardMode||this._billboardMode!==$s.BILLBOARDMODE_NONE||a.pivotMatrixUpdated||this._infiniteDistance||this._position._isDirty||this._scaling._isDirty||this._rotationQuaternion&&this._rotationQuaternion._isDirty||this._rotation._isDirty)}_initCache(){super._initCache();const a=this._cache;a.localMatrixUpdated=!1,a.billboardMode=-1,a.infiniteDistance=!1,a.useBillboardPosition=!1,a.useBillboardPath=!1}get absolutePosition(){return this.getAbsolutePosition()}get absoluteScaling(){return this._syncAbsoluteScalingAndRotation(),this._absoluteScaling}get absoluteRotationQuaternion(){return this._syncAbsoluteScalingAndRotation(),this._absoluteRotationQuaternion}setPreTransformMatrix(a){return this.setPivotMatrix(a,!1)}setPivotMatrix(a,x=!0){return this._pivotMatrix.copyFrom(a),this._usePivotMatrix=!this._pivotMatrix.isIdentity(),this._cache.pivotMatrixUpdated=!0,this._postMultiplyPivotMatrix=x,this._postMultiplyPivotMatrix&&(this._pivotMatrixInverse?this._pivotMatrix.invertToRef(this._pivotMatrixInverse):this._pivotMatrixInverse=vt.Invert(this._pivotMatrix)),this}getPivotMatrix(){return this._pivotMatrix}instantiateHierarchy(a=null,x,c){const u=this.clone("Clone of "+(this.name||this.id),a||this.parent,!0);u&&c&&c(this,u);for(const g of this.getChildTransformNodes(!0))g.instantiateHierarchy(u,x,c);return u}freezeWorldMatrix(a=null,x=!1){return a?x?(this._rotation.setAll(0),this._rotationQuaternion=this._rotationQuaternion||Wi.Identity(),a.decompose(this._scaling,this._rotationQuaternion,this._position),this.computeWorldMatrix(!0)):(this._worldMatrix=a,this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._afterComputeWorldMatrix()):(this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0)),this._isDirty=!1,this._isWorldMatrixFrozen=!0,this}unfreezeWorldMatrix(){return this._isWorldMatrixFrozen=!1,this.computeWorldMatrix(!0),this}get isWorldMatrixFrozen(){return this._isWorldMatrixFrozen}getAbsolutePosition(){return this.computeWorldMatrix(),this._absolutePosition}setAbsolutePosition(a){if(!a)return this;let x,c,u;if(a.x===void 0){if(arguments.length<3)return this;x=arguments[0],c=arguments[1],u=arguments[2]}else x=a.x,c=a.y,u=a.z;if(this.parent){const g=Yt.Matrix[0];this.parent.getWorldMatrix().invertToRef(g),Ee.TransformCoordinatesFromFloatsToRef(x,c,u,g,this.position)}else this.position.x=x,this.position.y=c,this.position.z=u;return this._absolutePosition.copyFrom(a),this}setPositionWithLocalVector(a){return this.computeWorldMatrix(),this.position=Ee.TransformNormal(a,this._localMatrix),this}getPositionExpressedInLocalSpace(){this.computeWorldMatrix();const a=Yt.Matrix[0];return this._localMatrix.invertToRef(a),Ee.TransformNormal(this.position,a)}locallyTranslate(a){return this.computeWorldMatrix(!0),this.position=Ee.TransformCoordinates(a,this._localMatrix),this}lookAt(a,x=0,c=0,u=0,g=mn.LOCAL){const y=$s._LookAtVectorCache,v=g===mn.LOCAL?this.position:this.getAbsolutePosition();if(a.subtractToRef(v,y),this.setDirection(y,x,c,u),g===mn.WORLD&&this.parent)if(this.rotationQuaternion){const w=Yt.Matrix[0];this.rotationQuaternion.toRotationMatrix(w);const B=Yt.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(B),B.invert(),w.multiplyToRef(B,w),this.rotationQuaternion.fromRotationMatrix(w)}else{const w=Yt.Quaternion[0];Wi.FromEulerVectorToRef(this.rotation,w);const B=Yt.Matrix[0];w.toRotationMatrix(B);const W=Yt.Matrix[1];this.parent.getWorldMatrix().getRotationMatrixToRef(W),W.invert(),B.multiplyToRef(W,B),w.fromRotationMatrix(B),w.toEulerAnglesToRef(this.rotation)}return this}getDirection(a){const x=Ee.Zero();return this.getDirectionToRef(a,x),x}getDirectionToRef(a,x){return Ee.TransformNormalToRef(a,this.getWorldMatrix(),x),this}setDirection(a,x=0,c=0,u=0){const g=-Math.atan2(a.z,a.x)+Math.PI/2,y=Math.sqrt(a.x*a.x+a.z*a.z),v=-Math.atan2(a.y,y);return this.rotationQuaternion?Wi.RotationYawPitchRollToRef(g+x,v+c,u,this.rotationQuaternion):(this.rotation.x=v+c,this.rotation.y=g+x,this.rotation.z=u),this}setPivotPoint(a,x=mn.LOCAL){this.getScene().getRenderId()==0&&this.computeWorldMatrix(!0);const c=this.getWorldMatrix();if(x==mn.WORLD){const u=Yt.Matrix[0];c.invertToRef(u),a=Ee.TransformCoordinates(a,u)}return this.setPivotMatrix(vt.Translation(-a.x,-a.y,-a.z),!0)}getPivotPoint(){const a=Ee.Zero();return this.getPivotPointToRef(a),a}getPivotPointToRef(a){return a.x=-this._pivotMatrix.m[12],a.y=-this._pivotMatrix.m[13],a.z=-this._pivotMatrix.m[14],this}getAbsolutePivotPoint(){const a=Ee.Zero();return this.getAbsolutePivotPointToRef(a),a}getAbsolutePivotPointToRef(a){return this.getPivotPointToRef(a),Ee.TransformCoordinatesToRef(a,this.getWorldMatrix(),a),this}markAsDirty(a){if(this._isDirty)return this;if(this._children)for(const x of this._children)x.markAsDirty(a);return super.markAsDirty(a)}setParent(a,x=!1,c=!1){if(!a&&!this.parent)return this;const u=Yt.Quaternion[0],g=Yt.Vector3[0],y=Yt.Vector3[1],v=Yt.Matrix[1];vt.IdentityToRef(v);const w=Yt.Matrix[0];this.computeWorldMatrix(!0);let B=this.rotationQuaternion;return B||(B=$s._TmpRotation,Wi.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,B)),vt.ComposeToRef(this.scaling,B,this.position,w),this.parent&&w.multiplyToRef(this.parent.computeWorldMatrix(!0),w),a&&(a.computeWorldMatrix(!0).invertToRef(v),w.multiplyToRef(v,w)),w.decompose(y,u,g,x?this:void 0),this.rotationQuaternion?this.rotationQuaternion.copyFrom(u):u.toEulerAnglesToRef(this.rotation),this.scaling.copyFrom(y),this.position.copyFrom(g),this.parent=a,c&&this.setPivotMatrix(vt.Identity()),this}get nonUniformScaling(){return this._nonUniformScaling}_updateNonUniformScalingState(a){return this._nonUniformScaling===a?!1:(this._nonUniformScaling=a,!0)}attachToBone(a,x){return this._currentParentWhenAttachingToBone=this.parent,this._transformToBoneReferal=x,this.parent=a,a.getSkeleton().prepare(!0),a.getFinalMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this}detachFromBone(a=!1){return this.parent?(this.parent.getWorldMatrix().determinant()<0&&(this.scalingDeterminant*=-1),this._transformToBoneReferal=null,a?this.parent=this._currentParentWhenAttachingToBone:this.parent=null,this):(a&&(this.parent=this._currentParentWhenAttachingToBone),this)}rotate(a,x,c){a.normalize(),this.rotationQuaternion||(this.rotationQuaternion=this.rotation.toQuaternion(),this.rotation.setAll(0));let u;if(!c||c===mn.LOCAL)u=Wi.RotationAxisToRef(a,x,$s._RotationAxisCache),this.rotationQuaternion.multiplyToRef(u,this.rotationQuaternion);else{if(this.parent){const g=this.parent.getWorldMatrix(),y=Yt.Matrix[0];g.invertToRef(y),a=Ee.TransformNormal(a,y),g.determinant()<0&&(x*=-1)}u=Wi.RotationAxisToRef(a,x,$s._RotationAxisCache),u.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion)}return this}rotateAround(a,x,c){x.normalize(),this.rotationQuaternion||(this.rotationQuaternion=Wi.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z),this.rotation.setAll(0));const u=Yt.Vector3[0],g=Yt.Vector3[1],y=Yt.Vector3[2],v=Yt.Quaternion[0],w=Yt.Matrix[0],B=Yt.Matrix[1],W=Yt.Matrix[2],ae=Yt.Matrix[3];return a.subtractToRef(this.position,u),vt.TranslationToRef(u.x,u.y,u.z,w),vt.TranslationToRef(-u.x,-u.y,-u.z,B),vt.RotationAxisToRef(x,c,W),B.multiplyToRef(W,ae),ae.multiplyToRef(w,ae),ae.decompose(g,v,y),this.position.addInPlace(y),v.multiplyToRef(this.rotationQuaternion,this.rotationQuaternion),this}translate(a,x,c){const u=a.scale(x);if(!c||c===mn.LOCAL){const g=this.getPositionExpressedInLocalSpace().add(u);this.setPositionWithLocalVector(g)}else this.setAbsolutePosition(this.getAbsolutePosition().add(u));return this}addRotation(a,x,c){let u;this.rotationQuaternion?u=this.rotationQuaternion:(u=Yt.Quaternion[1],Wi.RotationYawPitchRollToRef(this.rotation.y,this.rotation.x,this.rotation.z,u));const g=Yt.Quaternion[0];return Wi.RotationYawPitchRollToRef(x,a,c,g),u.multiplyInPlace(g),this.rotationQuaternion||u.toEulerAnglesToRef(this.rotation),this}_getEffectiveParent(){return this.parent}isWorldMatrixCameraDependent(){return this._infiniteDistance&&!this.parent||this._billboardMode!==$s.BILLBOARDMODE_NONE&&!this.preserveParentRotationForBillboard}computeWorldMatrix(a=!1,x=null){if(this._isWorldMatrixFrozen&&!this._isDirty)return this._worldMatrix;const c=this.getScene().getRenderId();if(!this._isDirty&&!a&&(this._currentRenderId===c||this.isSynchronized()))return this._currentRenderId=c,this._worldMatrix;x=x||this.getScene().activeCamera,this._updateCache();const u=this._cache;u.pivotMatrixUpdated=!1,u.billboardMode=this.billboardMode,u.infiniteDistance=this.infiniteDistance,u.parent=this._parentNode,this._currentRenderId=c,this._childUpdateId+=1,this._isDirty=!1,this._position._isDirty=!1,this._rotation._isDirty=!1,this._scaling._isDirty=!1;const g=this._getEffectiveParent(),y=$s._TmpScaling;let v=this._position;if(this._infiniteDistance&&!this.parent&&x){const B=x.getWorldMatrix(),W=new Ee(B.m[12],B.m[13],B.m[14]);v=$s._TmpTranslation,v.copyFromFloats(this._position.x+W.x,this._position.y+W.y,this._position.z+W.z)}y.copyFromFloats(this._scaling.x*this.scalingDeterminant,this._scaling.y*this.scalingDeterminant,this._scaling.z*this.scalingDeterminant);let w;if(this._rotationQuaternion?(this._rotationQuaternion._isDirty=!1,w=this._rotationQuaternion,this.reIntegrateRotationIntoRotationQuaternion&&this.rotation.lengthSquared()&&(this._rotationQuaternion.multiplyInPlace(Wi.RotationYawPitchRoll(this._rotation.y,this._rotation.x,this._rotation.z)),this._rotation.copyFromFloats(0,0,0))):(w=$s._TmpRotation,Wi.RotationYawPitchRollToRef(this._rotation.y,this._rotation.x,this._rotation.z,w)),this._usePivotMatrix){const B=Yt.Matrix[1];vt.ScalingToRef(y.x,y.y,y.z,B);const W=Yt.Matrix[0];w.toRotationMatrix(W),this._pivotMatrix.multiplyToRef(B,Yt.Matrix[4]),Yt.Matrix[4].multiplyToRef(W,this._localMatrix),this._postMultiplyPivotMatrix&&this._localMatrix.multiplyToRef(this._pivotMatrixInverse,this._localMatrix),this._localMatrix.addTranslationFromFloats(v.x,v.y,v.z)}else vt.ComposeToRef(y,w,v,this._localMatrix);if(g&&g.getWorldMatrix){if(a&&g.computeWorldMatrix(a),u.useBillboardPath){if(this._transformToBoneReferal){const ue=this.parent;ue.getSkeleton().prepare(),ue.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),Yt.Matrix[7])}else Yt.Matrix[7].copyFrom(g.getWorldMatrix());const B=Yt.Vector3[5],W=Yt.Vector3[6],ae=Yt.Quaternion[0];Yt.Matrix[7].decompose(W,ae,B),vt.ScalingToRef(W.x,W.y,W.z,Yt.Matrix[7]),Yt.Matrix[7].setTranslation(B),$s.BillboardUseParentOrientation&&(this._position.applyRotationQuaternionToRef(ae,B),this._localMatrix.setTranslation(B)),this._localMatrix.multiplyToRef(Yt.Matrix[7],this._worldMatrix)}else if(this._transformToBoneReferal){const B=this.parent;B.getSkeleton().prepare(),this._localMatrix.multiplyToRef(B.getFinalMatrix(),Yt.Matrix[6]),Yt.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(),this._worldMatrix)}else this._localMatrix.multiplyToRef(g.getWorldMatrix(),this._worldMatrix);this._markSyncedWithParent()}else this._worldMatrix.copyFrom(this._localMatrix);if(u.useBillboardPath&&x&&this.billboardMode&&!u.useBillboardPosition){const B=Yt.Vector3[0];if(this._worldMatrix.getTranslationToRef(B),Yt.Matrix[1].copyFrom(x.getViewMatrix()),this._scene.useRightHandedSystem&&Yt.Matrix[1].multiplyToRef(tD,Yt.Matrix[1]),Yt.Matrix[1].setTranslationFromFloats(0,0,0),Yt.Matrix[1].invertToRef(Yt.Matrix[0]),(this.billboardMode&$s.BILLBOARDMODE_ALL)!==$s.BILLBOARDMODE_ALL){Yt.Matrix[0].decompose(void 0,Yt.Quaternion[0],void 0);const W=Yt.Vector3[1];Yt.Quaternion[0].toEulerAnglesToRef(W),(this.billboardMode&$s.BILLBOARDMODE_X)!==$s.BILLBOARDMODE_X&&(W.x=0),(this.billboardMode&$s.BILLBOARDMODE_Y)!==$s.BILLBOARDMODE_Y&&(W.y=0),(this.billboardMode&$s.BILLBOARDMODE_Z)!==$s.BILLBOARDMODE_Z&&(W.z=0),vt.RotationYawPitchRollToRef(W.y,W.x,W.z,Yt.Matrix[0])}this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(Yt.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(Yt.Vector3[0])}else if(u.useBillboardPath&&x&&u.useBillboardPosition){const B=Yt.Vector3[0];this._worldMatrix.getTranslationToRef(B);const W=x.globalPosition;this._worldMatrix.invertToRef(Yt.Matrix[1]);const ae=Yt.Vector3[1];Ee.TransformCoordinatesToRef(W,Yt.Matrix[1],ae),ae.normalize();const ue=-Math.atan2(ae.z,ae.x)+Math.PI/2,fe=Math.sqrt(ae.x*ae.x+ae.z*ae.z),Re=-Math.atan2(ae.y,fe);if(Wi.RotationYawPitchRollToRef(ue,Re,0,Yt.Quaternion[0]),(this.billboardMode&$s.BILLBOARDMODE_ALL)!==$s.BILLBOARDMODE_ALL){const _e=Yt.Vector3[1];Yt.Quaternion[0].toEulerAnglesToRef(_e),(this.billboardMode&$s.BILLBOARDMODE_X)!==$s.BILLBOARDMODE_X&&(_e.x=0),(this.billboardMode&$s.BILLBOARDMODE_Y)!==$s.BILLBOARDMODE_Y&&(_e.y=0),(this.billboardMode&$s.BILLBOARDMODE_Z)!==$s.BILLBOARDMODE_Z&&(_e.z=0),vt.RotationYawPitchRollToRef(_e.y,_e.x,_e.z,Yt.Matrix[0])}else vt.FromQuaternionToRef(Yt.Quaternion[0],Yt.Matrix[0]);this._worldMatrix.setTranslationFromFloats(0,0,0),this._worldMatrix.multiplyToRef(Yt.Matrix[0],this._worldMatrix),this._worldMatrix.setTranslation(Yt.Vector3[0])}return this.ignoreNonUniformScaling?this._updateNonUniformScalingState(!1):this._scaling.isNonUniformWithinEpsilon(1e-6)?this._updateNonUniformScalingState(!0):g&&g._nonUniformScaling?this._updateNonUniformScalingState(g._nonUniformScaling):this._updateNonUniformScalingState(!1),this._afterComputeWorldMatrix(),this._absolutePosition.copyFromFloats(this._worldMatrix.m[12],this._worldMatrix.m[13],this._worldMatrix.m[14]),this._isAbsoluteSynced=!1,this.onAfterWorldMatrixUpdateObservable.notifyObservers(this),this._poseMatrix||(this._poseMatrix=vt.Invert(this._worldMatrix)),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix}resetLocalMatrix(a=!0){if(this.computeWorldMatrix(),a){const x=this.getChildren();for(let c=0;c<x.length;++c){const u=x[c];if(u){u.computeWorldMatrix();const g=Yt.Matrix[0];u._localMatrix.multiplyToRef(this._localMatrix,g);const y=Yt.Quaternion[0];g.decompose(u.scaling,y,u.position),u.rotationQuaternion?u.rotationQuaternion.copyFrom(y):y.toEulerAnglesToRef(u.rotation)}}}this.scaling.copyFromFloats(1,1,1),this.position.copyFromFloats(0,0,0),this.rotation.copyFromFloats(0,0,0),this.rotationQuaternion&&(this.rotationQuaternion=Wi.Identity()),this._worldMatrix=vt.Identity()}_afterComputeWorldMatrix(){}registerAfterWorldMatrixUpdate(a){return this.onAfterWorldMatrixUpdateObservable.add(a),this}unregisterAfterWorldMatrixUpdate(a){return this.onAfterWorldMatrixUpdateObservable.removeCallback(a),this}getPositionInCameraSpace(a=null){return a||(a=this.getScene().activeCamera),Ee.TransformCoordinates(this.getAbsolutePosition(),a.getViewMatrix())}getDistanceToCamera(a=null){return a||(a=this.getScene().activeCamera),this.getAbsolutePosition().subtract(a.globalPosition).length()}clone(a,x,c){const u=hr.Clone(()=>new $s(a,this.getScene()),this);if(u.name=a,u.id=a,x&&(u.parent=x),!c){const g=this.getDescendants(!0);for(let y=0;y<g.length;y++){const v=g[y];v.clone&&v.clone(a+"."+v.name,u)}}return u}serialize(a){const x=hr.Serialize(this,a);return x.type=this.getClassName(),x.uniqueId=this.uniqueId,this.parent&&this.parent._serializeAsParent(x),x.localMatrix=this.getPivotMatrix().asArray(),x.isEnabled=this.isEnabled(),hr.AppendSerializedAnimations(this,x),x.ranges=this.serializeAnimationRanges(),x}static Parse(a,x,c){const u=hr.Parse(()=>new $s(a.name,x),a,x,c);if(a.localMatrix?u.setPreTransformMatrix(vt.FromArray(a.localMatrix)):a.pivotMatrix&&u.setPivotMatrix(vt.FromArray(a.pivotMatrix)),u.setEnabled(a.isEnabled),u._waitingParsedUniqueId=a.uniqueId,a.parentId!==void 0&&(u._waitingParentId=a.parentId),a.parentInstanceIndex!==void 0&&(u._waitingParentInstanceIndex=a.parentInstanceIndex),a.animations){for(let g=0;g<a.animations.length;g++){const y=a.animations[g],v=Ua("BABYLON.Animation");v&&u.animations.push(v.Parse(y))}fa.ParseAnimationRanges(u,a,x)}return a.autoAnimate&&x.beginAnimation(u,a.autoAnimateFrom,a.autoAnimateTo,a.autoAnimateLoop,a.autoAnimateSpeed||1),u}getChildTransformNodes(a,x){const c=[];return this._getDescendants(c,a,u=>(!x||x(u))&&u instanceof $s),c}dispose(a,x=!1){if(this.getScene().stopAnimation(this),this.getScene().removeTransformNode(this),this._parentContainer){const c=this._parentContainer.transformNodes.indexOf(this);c>-1&&this._parentContainer.transformNodes.splice(c,1),this._parentContainer=null}if(this.onAfterWorldMatrixUpdateObservable.clear(),a){const c=this.getChildTransformNodes(!0);for(const u of c)u.parent=null,u.computeWorldMatrix(!0)}super.dispose(a,x)}normalizeToUnitCube(a=!0,x=!1,c){let u=null,g=null;x&&(this.rotationQuaternion?(g=this.rotationQuaternion.clone(),this.rotationQuaternion.copyFromFloats(0,0,0,1)):this.rotation&&(u=this.rotation.clone(),this.rotation.copyFromFloats(0,0,0)));const y=this.getHierarchyBoundingVectors(a,c),v=y.max.subtract(y.min),w=Math.max(v.x,v.y,v.z);if(w===0)return this;const B=1/w;return this.scaling.scaleInPlace(B),x&&(this.rotationQuaternion&&g?this.rotationQuaternion.copyFrom(g):this.rotation&&u&&this.rotation.copyFrom(u)),this}_syncAbsoluteScalingAndRotation(){this._isAbsoluteSynced||(this._worldMatrix.decompose(this._absoluteScaling,this._absoluteRotationQuaternion),this._isAbsoluteSynced=!0)}}$s.BILLBOARDMODE_NONE=0,$s.BILLBOARDMODE_X=1,$s.BILLBOARDMODE_Y=2,$s.BILLBOARDMODE_Z=4,$s.BILLBOARDMODE_ALL=7,$s.BILLBOARDMODE_USE_POSITION=128,$s.BillboardUseParentOrientation=!1,$s._TmpRotation=Wi.Zero(),$s._TmpScaling=Ee.Zero(),$s._TmpTranslation=Ee.Zero(),$s._LookAtVectorCache=new Ee(0,0,0),$s._RotationAxisCache=new Wi,Ye([En("position")],$s.prototype,"_position",void 0),Ye([En("rotation")],$s.prototype,"_rotation",void 0),Ye([yP("rotationQuaternion")],$s.prototype,"_rotationQuaternion",void 0),Ye([En("scaling")],$s.prototype,"_scaling",void 0),Ye([ht("billboardMode")],$s.prototype,"_billboardMode",void 0),Ye([ht()],$s.prototype,"scalingDeterminant",void 0),Ye([ht("infiniteDistance")],$s.prototype,"_infiniteDistance",void 0),Ye([ht()],$s.prototype,"ignoreNonUniformScaling",void 0),Ye([ht()],$s.prototype,"reIntegrateRotationIntoRotationQuaternion",void 0);class m_{constructor(){this._defines={},this._currentRank=32,this._maxRank=-1,this._mesh=null}unBindMesh(){this._mesh=null}addFallback(a,x){this._defines[a]||(a<this._currentRank&&(this._currentRank=a),a>this._maxRank&&(this._maxRank=a),this._defines[a]=new Array),this._defines[a].push(x)}addCPUSkinningFallback(a,x){this._mesh=x,a<this._currentRank&&(this._currentRank=a),a>this._maxRank&&(this._maxRank=a)}get hasMoreFallbacks(){return this._currentRank<=this._maxRank}reduce(a,x){if(this._mesh&&this._mesh.computeBonesUsingShaders&&this._mesh.numBoneInfluencers>0){this._mesh.computeBonesUsingShaders=!1,a=a.replace("#define NUM_BONE_INFLUENCERS "+this._mesh.numBoneInfluencers,"#define NUM_BONE_INFLUENCERS 0"),x._bonesComputationForcedToCPU=!0;const c=this._mesh.getScene();for(let u=0;u<c.meshes.length;u++){const g=c.meshes[u];if(!g.material){!this._mesh.material&&g.computeBonesUsingShaders&&g.numBoneInfluencers>0&&(g.computeBonesUsingShaders=!1);continue}if(!(!g.computeBonesUsingShaders||g.numBoneInfluencers===0)){if(g.material.getEffect()===x)g.computeBonesUsingShaders=!1;else if(g.subMeshes){for(const y of g.subMeshes)if(y.effect===x){g.computeBonesUsingShaders=!1;break}}}}}else{const c=this._defines[this._currentRank];if(c)for(let u=0;u<c.length;u++)a=a.replace("#define "+c[u],"");this._currentRank++}return a}}class yb extends ui{constructor(a,x,c=!0){super(a,x),this._normalMatrix=new vt,this._storeEffectOnSubMeshes=c}getEffect(){return this._storeEffectOnSubMeshes?this._activeEffect:super.getEffect()}isReady(a,x){return a?!this._storeEffectOnSubMeshes||!a.subMeshes||a.subMeshes.length===0?!0:this.isReadyForSubMesh(a,a.subMeshes[0],x):!1}_isReadyForSubMesh(a){const x=a.materialDefines;return!!(!this.checkReadyOnEveryCall&&a.effect&&x&&x._renderId===this.getScene().getRenderId())}bindOnlyWorldMatrix(a){this._activeEffect.setMatrix("world",a)}bindOnlyNormalMatrix(a){this._activeEffect.setMatrix("normalMatrix",a)}bind(a,x){x&&this.bindForSubMesh(a,x,x.subMeshes[0])}_afterBind(a,x=null,c){super._afterBind(a,x,c),this.getScene()._cachedEffect=x,c?c._drawWrapper._forceRebindOnNextCall=!1:this._drawWrapper._forceRebindOnNextCall=!1}_mustRebind(a,x,c,u=1){return c._drawWrapper._forceRebindOnNextCall||a.isCachedMaterialInvalid(this,x,u)}dispose(a,x,c){this._activeEffect=void 0,super.dispose(a,x,c)}}const g_={effect:null,subMesh:null};class Wl extends yb{constructor(a,x,c,u={},g=!0){super(a,x,g),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new vt,this._cachedWorldViewProjectionMatrix=new vt,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=c,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...u}}get shaderPath(){return this._shaderPath}set shaderPath(a){this._shaderPath=a}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(a){this._options.uniforms.indexOf(a)===-1&&this._options.uniforms.push(a)}setTexture(a,x){return this._options.samplers.indexOf(a)===-1&&this._options.samplers.push(a),this._textures[a]=x,this}setTextureArray(a,x){return this._options.samplers.indexOf(a)===-1&&this._options.samplers.push(a),this._checkUniform(a),this._textureArrays[a]=x,this}setExternalTexture(a,x){return this._options.externalTextures.indexOf(a)===-1&&this._options.externalTextures.push(a),this._externalTextures[a]=x,this}setFloat(a,x){return this._checkUniform(a),this._floats[a]=x,this}setInt(a,x){return this._checkUniform(a),this._ints[a]=x,this}setUInt(a,x){return this._checkUniform(a),this._uints[a]=x,this}setFloats(a,x){return this._checkUniform(a),this._floatsArrays[a]=x,this}setColor3(a,x){return this._checkUniform(a),this._colors3[a]=x,this}setColor3Array(a,x){return this._checkUniform(a),this._colors3Arrays[a]=x.reduce((c,u)=>(u.toArray(c,c.length),c),[]),this}setColor4(a,x){return this._checkUniform(a),this._colors4[a]=x,this}setColor4Array(a,x){return this._checkUniform(a),this._colors4Arrays[a]=x.reduce((c,u)=>(u.toArray(c,c.length),c),[]),this}setVector2(a,x){return this._checkUniform(a),this._vectors2[a]=x,this}setVector3(a,x){return this._checkUniform(a),this._vectors3[a]=x,this}setVector4(a,x){return this._checkUniform(a),this._vectors4[a]=x,this}setQuaternion(a,x){return this._checkUniform(a),this._quaternions[a]=x,this}setQuaternionArray(a,x){return this._checkUniform(a),this._quaternionsArrays[a]=x.reduce((c,u)=>(u.toArray(c,c.length),c),[]),this}setMatrix(a,x){return this._checkUniform(a),this._matrices[a]=x,this}setMatrices(a,x){this._checkUniform(a);const c=new Float32Array(x.length*16);for(let u=0;u<x.length;u++)x[u].copyToArray(c,u*16);return this._matrixArrays[a]=c,this}setMatrix3x3(a,x){return this._checkUniform(a),this._matrices3x3[a]=x,this}setMatrix2x2(a,x){return this._checkUniform(a),this._matrices2x2[a]=x,this}setArray2(a,x){return this._checkUniform(a),this._vectors2Arrays[a]=x,this}setArray3(a,x){return this._checkUniform(a),this._vectors3Arrays[a]=x,this}setArray4(a,x){return this._checkUniform(a),this._vectors4Arrays[a]=x,this}setUniformBuffer(a,x){return this._options.uniformBuffers.indexOf(a)===-1&&this._options.uniformBuffers.push(a),this._uniformBuffers[a]=x,this}setTextureSampler(a,x){return this._options.samplerObjects.indexOf(a)===-1&&this._options.samplerObjects.push(a),this._textureSamplers[a]=x,this}setStorageBuffer(a,x){return this._options.storageBuffers.indexOf(a)===-1&&this._options.storageBuffers.push(a),this._storageBuffers[a]=x,this}setDefine(a,x){const c=a.trimEnd()+" ",u=this.options.defines.findIndex(g=>g===a||g.startsWith(c));return u>=0&&this.options.defines.splice(u,1),(typeof x!="boolean"||x)&&this.options.defines.push(c+x),this}isReadyForSubMesh(a,x,c){return this.isReady(a,c,x)}isReady(a,x,c){const u=c&&this._storeEffectOnSubMeshes;if(this.isFrozen){const dt=u?c._drawWrapper:this._drawWrapper;if(dt.effect&&dt._wasPreviouslyReady&&dt._wasPreviouslyUsingInstances===x)return!0}const g=this.getScene(),y=g.getEngine(),v=[],w=[],B=new m_;let W=this._shaderPath,ae=this._options.uniforms,ue=this._options.uniformBuffers,fe=this._options.samplers;y.getCaps().multiview&&g.activeCamera&&g.activeCamera.outputRenderTarget&&g.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,v.push("#define MULTIVIEW"),ae.indexOf("viewProjection")!==-1&&ae.indexOf("viewProjectionR")===-1&&ae.push("viewProjectionR"));for(let dt=0;dt<this._options.defines.length;dt++){const ut=this._options.defines[dt].indexOf("#define")===0?this._options.defines[dt]:`#define ${this._options.defines[dt]}`;v.push(ut)}for(let dt=0;dt<this._options.attributes.length;dt++)w.push(this._options.attributes[dt]);if(a&&a.isVerticesDataPresent(Ve.ColorKind)&&(w.indexOf(Ve.ColorKind)===-1&&w.push(Ve.ColorKind),v.push("#define VERTEXCOLOR")),x&&(v.push("#define INSTANCES"),mg(w,this._materialHelperNeedsPreviousMatrices),a?.hasThinInstances&&(v.push("#define THIN_INSTANCES"),a&&a.isVerticesDataPresent(Ve.ColorInstanceKind)&&(w.push(Ve.ColorInstanceKind),v.push("#define INSTANCESCOLOR")))),a&&a.useBones&&a.computeBonesUsingShaders&&a.skeleton){w.push(Ve.MatricesIndicesKind),w.push(Ve.MatricesWeightsKind),a.numBoneInfluencers>4&&(w.push(Ve.MatricesIndicesExtraKind),w.push(Ve.MatricesWeightsExtraKind));const dt=a.skeleton;v.push("#define NUM_BONE_INFLUENCERS "+a.numBoneInfluencers),B.addCPUSkinningFallback(0,a),dt.isUsingTextureForMatrices?(v.push("#define BONETEXTURE"),ae.indexOf("boneTextureWidth")===-1&&ae.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(v.push("#define BonesPerMesh "+(dt.bones.length+1)),ae.indexOf("mBones")===-1&&ae.push("mBones"))}else v.push("#define NUM_BONE_INFLUENCERS 0");let Re=0;const _e=a?a.morphTargetManager:null;if(_e){const dt=_e.supportsUVs&&v.indexOf("#define UV1")!==-1,ut=_e.supportsTangents&&v.indexOf("#define TANGENT")!==-1,Mt=_e.supportsNormals&&v.indexOf("#define NORMAL")!==-1;Re=_e.numMaxInfluencers||_e.numInfluencers,dt&&v.push("#define MORPHTARGETS_UV"),ut&&v.push("#define MORPHTARGETS_TANGENT"),Mt&&v.push("#define MORPHTARGETS_NORMAL"),Re>0&&v.push("#define MORPHTARGETS"),_e.isUsingTextureForTargets&&(v.push("#define MORPHTARGETS_TEXTURE"),ae.indexOf("morphTargetTextureIndices")===-1&&ae.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),v.push("#define NUM_MORPH_INFLUENCERS "+Re);for(let ai=0;ai<Re;ai++)w.push(Ve.PositionKind+ai),Mt&&w.push(Ve.NormalKind+ai),ut&&w.push(Ve.TangentKind+ai),dt&&w.push(Ve.UVKind+"_"+ai);Re>0&&(ae=ae.slice(),ae.push("morphTargetInfluences"),ae.push("morphTargetCount"),ae.push("morphTargetTextureInfo"),ae.push("morphTargetTextureIndices"))}else v.push("#define NUM_MORPH_INFLUENCERS 0");if(a){const dt=a.bakedVertexAnimationManager;dt&&dt.isEnabled&&(v.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),ae.indexOf("bakedVertexAnimationSettings")===-1&&ae.push("bakedVertexAnimationSettings"),ae.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&ae.push("bakedVertexAnimationTextureSizeInverted"),ae.indexOf("bakedVertexAnimationTime")===-1&&ae.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture")),JT(w,a,v)}for(const dt in this._textures)if(!this._textures[dt].isReady())return!1;a&&this._shouldTurnAlphaTestOn(a)&&v.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(dg(ae),l_(this,g,v)),g.fogEnabled&&a?.applyFog&&g.fogMode!==H0.FOGMODE_NONE&&(v.push("#define FOG"),ae.indexOf("view")===-1&&ae.push("view"),ae.indexOf("vFogInfos")===-1&&ae.push("vFogInfos"),ae.indexOf("vFogColor")===-1&&ae.push("vFogColor")),this._useLogarithmicDepth&&(v.push("#define LOGARITHMICDEPTH"),ae.indexOf("logarithmicDepthConstant")===-1&&ae.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(ae=ae.slice(),ue=ue.slice(),fe=fe.slice(),W=this.customShaderNameResolve(W,ae,ue,fe,v,w));const Be=u?c._getDrawWrapper(void 0,!0):this._drawWrapper,tt=Be?.effect??null,$e=Be?.defines??null,Et=v.join(`
`);let ft=tt;return $e!==Et&&(ft=y.createEffect(W,{attributes:w,uniformsNames:ae,uniformBuffersNames:ue,samplers:fe,defines:Et,fallbacks:B,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:Re},shaderLanguage:this._options.shaderLanguage},y),u?c.setEffect(ft,Et,this._materialContext):Be&&Be.setEffect(ft,Et),this._onEffectCreatedObservable&&(g_.effect=ft,g_.subMesh=c??a?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(g_))),Be._wasPreviouslyUsingInstances=!!x,ft?.isReady()?(tt!==ft&&g.resetCachedMaterial(),Be._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(a,x){const c=this.getScene(),u=x??this.getEffect();u&&(this._options.uniforms.indexOf("world")!==-1&&u.setMatrix("world",a),this._options.uniforms.indexOf("worldView")!==-1&&(a.multiplyToRef(c.getViewMatrix(),this._cachedWorldViewMatrix),u.setMatrix("worldView",this._cachedWorldViewMatrix)),this._options.uniforms.indexOf("worldViewProjection")!==-1&&(a.multiplyToRef(c.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),u.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),this._options.uniforms.indexOf("view")!==-1&&u.setMatrix("view",c.getViewMatrix()))}bindForSubMesh(a,x,c){this.bind(a,x,c._drawWrapperOverride?.effect,c)}bind(a,x,c,u){const g=u&&this._storeEffectOnSubMeshes,y=c??(g?u.effect:this.getEffect());if(!y)return;const v=this.getScene();this._activeEffect=y,this.bindOnlyWorldMatrix(a,c);const w=this._options.uniformBuffers;let B=!1;if(y&&w&&w.length>0&&v.getEngine().supportsUniformBuffers)for(let ae=0;ae<w.length;++ae)switch(w[ae]){case"Mesh":x&&(x.getMeshUniformBuffer().bindToEffect(y,"Mesh"),x.transferToEffect(a));break;case"Scene":c_(y,v.getSceneUniformBuffer()),v.finalizeSceneUbo(),B=!0;break}const W=x&&g?this._mustRebind(v,y,u,x.visibility):v.getCachedMaterial()!==this;if(y&&W){!B&&this._options.uniforms.indexOf("view")!==-1&&y.setMatrix("view",v.getViewMatrix()),!B&&this._options.uniforms.indexOf("projection")!==-1&&y.setMatrix("projection",v.getProjectionMatrix()),!B&&this._options.uniforms.indexOf("viewProjection")!==-1&&(y.setMatrix("viewProjection",v.getTransformMatrix()),this._multiview&&y.setMatrix("viewProjectionR",v._transformMatrixR)),v.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&y.setVector3("cameraPosition",v.activeCamera.globalPosition),tb(x,y),fg(y,this,v),this._useLogarithmicDepth&&XT(g?u.materialDefines:y.defines,y,v),x&&jT(v,x,y);let ae;for(ae in this._textures)y.setTexture(ae,this._textures[ae]);for(ae in this._textureArrays)y.setTextureArray(ae,this._textureArrays[ae]);for(ae in this._externalTextures)y.setExternalTexture(ae,this._externalTextures[ae]);for(ae in this._ints)y.setInt(ae,this._ints[ae]);for(ae in this._uints)y.setUInt(ae,this._uints[ae]);for(ae in this._floats)y.setFloat(ae,this._floats[ae]);for(ae in this._floatsArrays)y.setArray(ae,this._floatsArrays[ae]);for(ae in this._colors3)y.setColor3(ae,this._colors3[ae]);for(ae in this._colors3Arrays)y.setArray3(ae,this._colors3Arrays[ae]);for(ae in this._colors4){const ue=this._colors4[ae];y.setFloat4(ae,ue.r,ue.g,ue.b,ue.a)}for(ae in this._colors4Arrays)y.setArray4(ae,this._colors4Arrays[ae]);for(ae in this._vectors2)y.setVector2(ae,this._vectors2[ae]);for(ae in this._vectors3)y.setVector3(ae,this._vectors3[ae]);for(ae in this._vectors4)y.setVector4(ae,this._vectors4[ae]);for(ae in this._quaternions)y.setQuaternion(ae,this._quaternions[ae]);for(ae in this._matrices)y.setMatrix(ae,this._matrices[ae]);for(ae in this._matrixArrays)y.setMatrices(ae,this._matrixArrays[ae]);for(ae in this._matrices3x3)y.setMatrix3x3(ae,this._matrices3x3[ae]);for(ae in this._matrices2x2)y.setMatrix2x2(ae,this._matrices2x2[ae]);for(ae in this._vectors2Arrays)y.setArray2(ae,this._vectors2Arrays[ae]);for(ae in this._vectors3Arrays)y.setArray3(ae,this._vectors3Arrays[ae]);for(ae in this._vectors4Arrays)y.setArray4(ae,this._vectors4Arrays[ae]);for(ae in this._quaternionsArrays)y.setArray4(ae,this._quaternionsArrays[ae]);for(ae in this._uniformBuffers){const ue=this._uniformBuffers[ae].getBuffer();ue&&y.bindUniformBuffer(ue,ae)}for(ae in this._textureSamplers)y.setTextureSampler(ae,this._textureSamplers[ae]);for(ae in this._storageBuffers)y.setStorageBuffer(ae,this._storageBuffers[ae])}if(y&&x&&(W||!this.isFrozen)){const ae=x.morphTargetManager;ae&&ae.numInfluencers>0&&gg(x,y);const ue=x.bakedVertexAnimationManager;if(ue&&ue.isEnabled){const fe=g?u._drawWrapper:this._drawWrapper;x.bakedVertexAnimationManager?.bind(y,!!fe._wasPreviouslyUsingInstances)}}this._afterBind(x,y,u)}getActiveTextures(){const a=super.getActiveTextures();for(const x in this._textures)a.push(this._textures[x]);for(const x in this._textureArrays){const c=this._textureArrays[x];for(let u=0;u<c.length;u++)a.push(c[u])}return a}hasTexture(a){if(super.hasTexture(a))return!0;for(const x in this._textures)if(this._textures[x]===a)return!0;for(const x in this._textureArrays){const c=this._textureArrays[x];for(let u=0;u<c.length;u++)if(c[u]===a)return!0}return!1}clone(a){const x=hr.Clone(()=>new Wl(a,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);x.name=a,x.id=a,typeof x._shaderPath=="object"&&(x._shaderPath={...x._shaderPath}),this._options={...this._options},Object.keys(this._options).forEach(c=>{const u=this._options[c];Array.isArray(u)&&(this._options[c]=u.slice(0))}),this.stencil.copyTo(x.stencil);for(const c in this._textures)x.setTexture(c,this._textures[c]);for(const c in this._textureArrays)x.setTextureArray(c,this._textureArrays[c]);for(const c in this._externalTextures)x.setExternalTexture(c,this._externalTextures[c]);for(const c in this._ints)x.setInt(c,this._ints[c]);for(const c in this._uints)x.setUInt(c,this._uints[c]);for(const c in this._floats)x.setFloat(c,this._floats[c]);for(const c in this._floatsArrays)x.setFloats(c,this._floatsArrays[c]);for(const c in this._colors3)x.setColor3(c,this._colors3[c]);for(const c in this._colors3Arrays)x._colors3Arrays[c]=this._colors3Arrays[c];for(const c in this._colors4)x.setColor4(c,this._colors4[c]);for(const c in this._colors4Arrays)x._colors4Arrays[c]=this._colors4Arrays[c];for(const c in this._vectors2)x.setVector2(c,this._vectors2[c]);for(const c in this._vectors3)x.setVector3(c,this._vectors3[c]);for(const c in this._vectors4)x.setVector4(c,this._vectors4[c]);for(const c in this._quaternions)x.setQuaternion(c,this._quaternions[c]);for(const c in this._quaternionsArrays)x._quaternionsArrays[c]=this._quaternionsArrays[c];for(const c in this._matrices)x.setMatrix(c,this._matrices[c]);for(const c in this._matrixArrays)x._matrixArrays[c]=this._matrixArrays[c].slice();for(const c in this._matrices3x3)x.setMatrix3x3(c,this._matrices3x3[c]);for(const c in this._matrices2x2)x.setMatrix2x2(c,this._matrices2x2[c]);for(const c in this._vectors2Arrays)x.setArray2(c,this._vectors2Arrays[c]);for(const c in this._vectors3Arrays)x.setArray3(c,this._vectors3Arrays[c]);for(const c in this._vectors4Arrays)x.setArray4(c,this._vectors4Arrays[c]);for(const c in this._uniformBuffers)x.setUniformBuffer(c,this._uniformBuffers[c]);for(const c in this._textureSamplers)x.setTextureSampler(c,this._textureSamplers[c]);for(const c in this._storageBuffers)x.setStorageBuffer(c,this._storageBuffers[c]);return x}dispose(a,x,c){if(x){let u;for(u in this._textures)this._textures[u].dispose();for(u in this._textureArrays){const g=this._textureArrays[u];for(let y=0;y<g.length;y++)g[y].dispose()}}this._textures={},super.dispose(a,x,c)}serialize(){const a=hr.Serialize(this);a.customType="BABYLON.ShaderMaterial",a.uniqueId=this.uniqueId,a.options=this._options,a.shaderPath=this._shaderPath,a.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let x;a.stencil=this.stencil.serialize(),a.textures={};for(x in this._textures)a.textures[x]=this._textures[x].serialize();a.textureArrays={};for(x in this._textureArrays){a.textureArrays[x]=[];const c=this._textureArrays[x];for(let u=0;u<c.length;u++)a.textureArrays[x].push(c[u].serialize())}a.ints={};for(x in this._ints)a.ints[x]=this._ints[x];a.uints={};for(x in this._uints)a.uints[x]=this._uints[x];a.floats={};for(x in this._floats)a.floats[x]=this._floats[x];a.floatsArrays={};for(x in this._floatsArrays)a.floatsArrays[x]=this._floatsArrays[x];a.colors3={};for(x in this._colors3)a.colors3[x]=this._colors3[x].asArray();a.colors3Arrays={};for(x in this._colors3Arrays)a.colors3Arrays[x]=this._colors3Arrays[x];a.colors4={};for(x in this._colors4)a.colors4[x]=this._colors4[x].asArray();a.colors4Arrays={};for(x in this._colors4Arrays)a.colors4Arrays[x]=this._colors4Arrays[x];a.vectors2={};for(x in this._vectors2)a.vectors2[x]=this._vectors2[x].asArray();a.vectors3={};for(x in this._vectors3)a.vectors3[x]=this._vectors3[x].asArray();a.vectors4={};for(x in this._vectors4)a.vectors4[x]=this._vectors4[x].asArray();a.quaternions={};for(x in this._quaternions)a.quaternions[x]=this._quaternions[x].asArray();a.matrices={};for(x in this._matrices)a.matrices[x]=this._matrices[x].asArray();a.matrixArray={};for(x in this._matrixArrays)a.matrixArray[x]=this._matrixArrays[x];a.matrices3x3={};for(x in this._matrices3x3)a.matrices3x3[x]=this._matrices3x3[x];a.matrices2x2={};for(x in this._matrices2x2)a.matrices2x2[x]=this._matrices2x2[x];a.vectors2Arrays={};for(x in this._vectors2Arrays)a.vectors2Arrays[x]=this._vectors2Arrays[x];a.vectors3Arrays={};for(x in this._vectors3Arrays)a.vectors3Arrays[x]=this._vectors3Arrays[x];a.vectors4Arrays={};for(x in this._vectors4Arrays)a.vectors4Arrays[x]=this._vectors4Arrays[x];a.quaternionsArrays={};for(x in this._quaternionsArrays)a.quaternionsArrays[x]=this._quaternionsArrays[x];return a}static Parse(a,x,c){const u=hr.Parse(()=>new Wl(a.name,x,a.shaderPath,a.options,a.storeEffectOnSubMeshes),a,x,c);let g;a.stencil&&u.stencil.parse(a.stencil,x,c);for(g in a.textures)u.setTexture(g,fi.Parse(a.textures[g],x,c));for(g in a.textureArrays){const y=a.textureArrays[g],v=[];for(let w=0;w<y.length;w++)v.push(fi.Parse(y[w],x,c));u.setTextureArray(g,v)}for(g in a.ints)u.setInt(g,a.ints[g]);for(g in a.uints)u.setUInt(g,a.uints[g]);for(g in a.floats)u.setFloat(g,a.floats[g]);for(g in a.floatsArrays)u.setFloats(g,a.floatsArrays[g]);for(g in a.colors3)u.setColor3(g,Bs.FromArray(a.colors3[g]));for(g in a.colors3Arrays){const y=a.colors3Arrays[g].reduce((v,w,B)=>(B%3===0?v.push([w]):v[v.length-1].push(w),v),[]).map(v=>Bs.FromArray(v));u.setColor3Array(g,y)}for(g in a.colors4)u.setColor4(g,Yr.FromArray(a.colors4[g]));for(g in a.colors4Arrays){const y=a.colors4Arrays[g].reduce((v,w,B)=>(B%4===0?v.push([w]):v[v.length-1].push(w),v),[]).map(v=>Yr.FromArray(v));u.setColor4Array(g,y)}for(g in a.vectors2)u.setVector2(g,mr.FromArray(a.vectors2[g]));for(g in a.vectors3)u.setVector3(g,Ee.FromArray(a.vectors3[g]));for(g in a.vectors4)u.setVector4(g,an.FromArray(a.vectors4[g]));for(g in a.quaternions)u.setQuaternion(g,Wi.FromArray(a.quaternions[g]));for(g in a.matrices)u.setMatrix(g,vt.FromArray(a.matrices[g]));for(g in a.matrixArray)u._matrixArrays[g]=new Float32Array(a.matrixArray[g]);for(g in a.matrices3x3)u.setMatrix3x3(g,a.matrices3x3[g]);for(g in a.matrices2x2)u.setMatrix2x2(g,a.matrices2x2[g]);for(g in a.vectors2Arrays)u.setArray2(g,a.vectors2Arrays[g]);for(g in a.vectors3Arrays)u.setArray3(g,a.vectors3Arrays[g]);for(g in a.vectors4Arrays)u.setArray4(g,a.vectors4Arrays[g]);for(g in a.quaternionsArrays)u.setArray4(g,a.quaternionsArrays[g]);return u}static ParseFromFileAsync(a,x,c,u=""){return new Promise((g,y)=>{const v=new da;v.addEventListener("readystatechange",()=>{if(v.readyState==4)if(v.status==200){const w=JSON.parse(v.responseText),B=this.Parse(w,c||tr.LastCreatedScene,u);a&&(B.name=a),g(B)}else y("Unable to load the ShaderMaterial")}),v.open("GET",x),v.send()})}static ParseFromSnippetAsync(a,x,c=""){return new Promise((u,g)=>{const y=new da;y.addEventListener("readystatechange",()=>{if(y.readyState==4)if(y.status==200){const v=JSON.parse(JSON.parse(y.responseText).jsonPayload),w=JSON.parse(v.shaderMaterial),B=this.Parse(w,x||tr.LastCreatedScene,c);B.snippetId=a,u(B)}else g("Unable to load the snippet "+a)}),y.open("GET",this.SnippetUrl+"/"+a.replace(/#/g,"/")),y.send()})}}Wl.SnippetUrl="https://snippet.babylonjs.com",Wl.CreateFromSnippetAsync=Wl.ParseFromSnippetAsync,as("BABYLON.ShaderMaterial",Wl);const bb="bonesDeclaration",Eb=`#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform highp sampler2D boneSampler;uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#endif
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}
#endif
#endif
#endif
`;hi.IncludesShadersStore[bb]=Eb;const xB={name:bb,shader:Eb},vb="bonesVertex",Ib=`#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;hi.IncludesShadersStore[vb]=Ib;const lB={name:vb,shader:Ib},Rb="clipPlaneVertexDeclaration",Mb=`#ifdef CLIPPLANE
uniform vec4 vClipPlane;varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;varying float fClipDistance6;
#endif
`;hi.IncludesShadersStore[Rb]=Mb;const hB={name:Rb,shader:Mb},Bb="clipPlaneVertex",Ub=`#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;hi.IncludesShadersStore[Bb]=Ub;const uB={name:Bb,shader:Ub},Vb="instancesDeclaration",Wb=`#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;hi.IncludesShadersStore[Vb]=Wb;const dB={name:Vb,shader:Wb},Hb="instancesVertex",Xb=`#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;hi.IncludesShadersStore[Hb]=Xb;const fB={name:Hb,shader:Xb},jb="clipPlaneFragmentDeclaration",Yb=`#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;hi.IncludesShadersStore[jb]=Yb;const mB={name:jb,shader:Yb},$b="clipPlaneFragment",Jb=`#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{discard;}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{discard;}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{discard;}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{discard;}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{discard;}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{discard;}
#endif
`;hi.IncludesShadersStore[$b]=Jb;const gB={name:$b,shader:Jb};class tE extends bi{constructor(a,x,c=1){super(a,x,["image"],{},`
            precision mediump float;
            varying vec2 xy;
            uniform vec2 wh;
            uniform sampler2D image;
            void main() {
                float res = texture2D(image, xy).r;
                for (int x = -`+c+"; x <= "+c+`; x++)
                    for (int y = -`+c+"; y <= "+c+`; y++)
                        res = max(res, texture2D(image, xy + vec2(x, y) / wh).r);
                gl_FragColor = vec4(res, res, res, 1.0);
            }`,void 0,!0)}}const _g=.5,aD=64,aE=8,xD=40.1,lD=`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform vec4 rect;
    uniform sampler2D image;
    uniform sampler2D mask;

    float readMask(vec2 xy0, vec2 dxyI) {
        return texture2D(mask, (xy0 + dxyI / wh - rect.xy) / rect.zw).r;
    }

    vec4 readProp(vec2 xy0, vec2 dxyI, vec2 ddxyI) {
        return abs(dxyI.x) + abs(dxyI.y) < `+xD+` &&
            readMask(xy0, ddxyI) < `+_g+` ?
            texture2D(image, xy0 + ddxyI / wh) :
            texture2D(image, xy0 + dxyI / wh);
    }

    float traverse(vec2 xy0, vec2 dxyI) {
        bool bg = false;
        float d = 1.0;
        for (int di = 1; di < `+aD+`; di++) {
            d = bg ? d : float(di * `+aE+`);
            bg = bg || readMask(xy0, d * dxyI) < `+_g+`;
        }
        bool bg1 = bg;
        for (int di = 1; di < `+aE+`; di++) {
            float d1 = d - 1.0;
            bg1 = bg1 && readMask(xy0, d1 * dxyI) < `+_g+`;
            d = bg1 ? d1 : d;
        }
        return bg ? d : -1.0;
    }

    void main() {
        bool bg = texture2D(mask, (xy - rect.xy) / (rect.zw)).r < `+_g+`;
        bool bg1;
        vec4 color = texture2D(image, xy);
        if (bg) {
            gl_FragColor = color;
            return;
        }

        float x0 = traverse(xy, vec2(-1.0, 0.0));
        bg = x0 > 0.0;
        vec4 cx0 = bg ? readProp(xy, vec2(-x0, 0.0),
            vec2(-x0 * 2.0 + 1.0, 0.0)) : color;
        x0 = bg ? 1.0 / x0 : 0.0;

        float x1 = traverse(xy, vec2(1.0, 0.0));
        bg = x1 > 0.0;
        vec4 cx1 = bg ? readProp(xy, vec2(x1, 0.0),
            vec2(x1 * 2.0 - 1.0, 0.0)) : color;
        x1 = bg ? 1.0 / x1 : 0.0;

        float y0 = traverse(xy, vec2(0.0, -1.0));
        bg = y0 > 0.0;
        vec4 cy0 = bg ? readProp(xy, vec2(0.0, -y0),
            vec2(0.0, -2.0 * y0 + 1.0)) : color;
        y0 = bg ? 1.0 / y0 : 0.0;

        float y1 = traverse(xy, vec2(0.0, 1.0));
        bg = y1 > 0.0;
        vec4 cy1 = bg ? readProp(xy, vec2(0.0, y1),
            vec2(0.0, 2.0 * y1 + 1.0)) : color;
        y1 = bg ? 1.0 / y1 : 0.0;

        float s = 1.0 / (x0 + x1 + y0 + y1);
        color = cx0 * x0 * s + cx1 * x1 * s + cy0 * y0 * s + cy1 * y1 * s;
        gl_FragColor = color;
    }
`;class _B extends jr{constructor(a=2){super(["image","mask"],{rect:"4f"},lD),this.dilationR=a,this.ordinal=xs.PostRender}async load(a){const x=a instanceof $t&&a.shaderCtx;if(this.loaded||!x)return;const c={width:256,height:256};return this.maskTexture=new mi(x,c,!0),this.dilationR>=1&&(this.dilationShader=new tE(x,c,this.dilationR)),super.load(a)}unload(){var a,x;this.loaded&&((a=this.dilationShader)==null||a.dispose(),delete this.dilationShader,(x=this.maskTexture)==null||x.dispose(),delete this.maskTexture,super.unload())}async process(a,x){const c=a.poses.length>0&&a.poses[0].mask,{maskTexture:u,dilationShader:g,shader:y}=this;if(!c||!u||!y)return!1;const v=Yh(c.box),w=u.update(c.buffer),B=g?.process([w])||w;return y.process([x,B],{rect:v}),!0}}function Yh(F){return[F[0][0],F[0][1],F[1][0]-F[0][0],F[1][1]-F[0][1]]}const __=.5,hD=`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform sampler2D mask;

    void main() {
        vec2 xyI = floor(xy * wh);
        vec4 val0 = texture2D(mask, xyI / wh);
        if (val0.r > `+__+`) {
            gl_FragColor = val0;
            return;
        }
        float val[25];
        for (int i = 0; i < 5; i++)
            for (int j = 0; j < 5; j++)
                val[j * 5 + i] = texture2D(mask,
                    (xyI + vec2(i, j) - 2.0) / wh).r;
        bool fg[25];
        int fgCount = 0;
        for (int i = 0; i < 25; i++) {
            fg[i] = val[i] > `+__+`;
            fgCount += int(fg[i]);
        }
        bool fg3[9];
        fg3[0] = fg[0] || fg[1] || fg[5] || fg[6];
        fg3[1] = fg[1] || fg[2] || fg[3] || fg[7];
        fg3[2] = fg[3] || fg[4] || fg[8] || fg[9];
        fg3[3] = fg[5] || fg[10] || fg[11] || fg[15];
        fg3[4] = fg[12];
        fg3[5] = fg[9] || fg[13] || fg[14] || fg[19];
        fg3[6] = fg[15] || fg[16] || fg[20] || fg[21];
        fg3[7] = fg[17] || fg[21] || fg[22] || fg[23];
        fg3[8] = fg[18] || fg[19] || fg[23] || fg[24];
        float valMax0 = max(
            max(max(val[0], val[1]), max(val[2], val[3])),
            max(max(val[4], val[5]), max(val[6], val[7])));
        float valMax1 = max(
            max(max(val[8], val[9]), max(val[10], val[11])),
            max(max(val[12], val[13]), max(val[14], val[15])));
        float valMax2 = max(
            max(max(val[16], val[17]), max(val[18], val[19])),
            max(max(val[20], val[21]), max(val[22], val[23])));
        float valMax = max(max(val[24], valMax0), max(valMax1, valMax2));
        if (fg3[0] && fg3[8] || fg3[1] && fg3[7] ||
            fg3[2] && fg3[6] || fg3[3] && fg3[5]) {
            gl_FragColor = vec4(valMax, 1, 0, 1);
            return;
        }
        gl_FragColor = val0;
    }
`,xE=`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform vec4 rect;
    uniform sampler2D image;
    uniform sampler2D mask;

    vec4 avgColor(vec2 xyMask, vec2 whPix) {
        vec2 xy = xyMask * rect.zw + rect.xy;
        vec2 dxy = whPix * rect.zw / 4.0;
        vec4 color = vec4(0.0);
        for (int i = 0; i < 4; i++)
            for (int j = 0; j < 4; j++)
                color += texture2D(image, xy + vec2(i, j) * dxy);
        return color / 16.0;
    }

    float minDiff(vec2 xyI, vec4 color) {
        // vec4 c = avgColor(xyI / wh, 1.0 / wh);
        // vec3 diff = color.rgb - c.rgb;
        // float ra = 0.5 * (color.r + c.r);
        // diff = diff * diff;
        // return (2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b;
        vec2 xyMask = xyI / wh;
        vec2 whPix = 1.0 / (2.0 * wh);
        float dist = 100.0;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                vec4 c = avgColor(xyMask + vec2(i, j) * whPix, whPix);
                vec3 diff = color.rgb - c.rgb;
                float ra = 0.5 * (color.r + c.r);
                diff = diff * diff;
                dist = min((2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b, dist);
            }
        }
        return dist;
    }

    void main() {
        vec2 xyI = floor(xy * wh);
        float val[9];
        for (int i = 0; i < 3; i++)
            for (int j = 0; j < 3; j++)
                val[j * 3 + i] = texture2D(mask,
                    (xyI + vec2(i, j) - 1.0) / wh).r;
        bool fg[9];
        int fgCount = 0;
        for (int i = 0; i < 9; i++) {
            fg[i] = val[i] > `+__+`;
            fgCount += int(fg[i]);
        }
        if (fgCount <= 0) {
            float valMin = min(val[0], min(
                min(min(val[1], val[2]), min(val[3], val[4])),
                min(min(val[5], val[6]), min(val[7], val[8]))));
            gl_FragColor = vec4(valMin, 0, 0, 1);
            return;
        }
        if (fgCount >= 9) {
            float valMax = max(val[0], max(
                max(max(val[1], val[2]), max(val[3], val[4])),
                max(max(val[5], val[6]), max(val[7], val[8]))));
            gl_FragColor = vec4(valMax, 0, 0, 1);
            return;
        }
        vec2 dxyI = vec2(0.0);
        int count = 0;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (!fg[j * 3 + i] || i == 1 && j == 1)
                    continue;
                dxyI += vec2(i, j) - 1.0;
                count++;
            }
        }
        if (count <= 0) {
            gl_FragColor = fg[4] ? vec4(1, 0, 0, 1) : vec4(0, 0, 0, 1);
            return;
        }
        dxyI = sign(dxyI);
        // vec4 color = texture2D(image, xyMask * rect.zw + rect.xy);
        vec4 color = avgColor(xyI / wh, 1.0 / wh);
        float fgDiff = minDiff(xyI + (fg[4] ? 1.0 : 2.0) * dxyI, color);
        float bgDiff = minDiff(xyI - (fg[4] ? 2.0 : 1.0) * dxyI, color);
        if (bgDiff < fgDiff) {
            gl_FragColor = vec4(0, 1, 0, 1);
            return;
        }
        gl_FragColor = vec4(1, 1, 0, 1);
    }
`;class uD{load(a){const[x,c]=[256,256];this.maskTexture=new mi(a,{width:x,height:c},!0),this.fillShaderX2=new bi(a,{width:x*2,height:c*2},["mask"],{},hD),this.edgeShaderX2=new bi(a,{width:x*2,height:c*2},["image","mask"],{rect:"4f"},xE),this.edgeShaderX4=new bi(a,{width:x*4,height:c*4},["image","mask"],{rect:"4f"},xE)}unload(){var a,x,c,u;(a=this.maskTexture)==null||a.dispose(),delete this.maskTexture,(x=this.fillShaderX2)==null||x.dispose(),delete this.fillShaderX2,(c=this.edgeShaderX2)==null||c.dispose(),delete this.edgeShaderX2,(u=this.edgeShaderX4)==null||u.dispose(),delete this.edgeShaderX4}upscale(a,x){const{maskTexture:c,edgeShaderX2:u,edgeShaderX4:g,fillShaderX2:y}=this;if(!c||!u||!g||!y)return!1;c.update(a.buffer);const v=Yh(a.box);return u.process([x,c.texture()],{rect:v}),y.process([u.output()]),g.process([x,y.output()],{rect:v}),!0}mask(){var a;return((a=this.edgeShaderX4)==null?void 0:a.output())||null}}class dD extends Ei{constructor(){super(),this.upscaler=new uD,this.ordinal=xs.Process}async load(a){const x=a instanceof $t&&a.shaderCtx;if(!(this.loaded||!x))return this.upscaler.load(x),super.load(a)}unload(){this.loaded&&(this.upscaler.unload(),super.unload())}async update(a,x){var c;const{renderer:u}=this;if(!this.loaded||!(u instanceof $t))return;const g=(c=u.input)==null?void 0:c.texture(),y="poses"in a&&a.poses.length>0&&a.poses[0]||"faces"in a&&a.faces.length>0&&a.faces[0]||"masks"in a&&a.masks.length>0&&a.masks[0];if(!y||!y.mask||!g)return;const v=this.upscaler.upscale(y.mask,g)&&this.upscaler.mask();v&&(y.maskHD={texture:v,size:{width:1024,height:1024},box:y.mask.box})}}class yB extends null{async load(a){var x;await super.load(a),(x=this.dilationShader)==null||x.resize({width:1024,height:1024})}async process(a,x){const c=a.poses.length>0&&a.poses[0].maskHD,{dilationShader:u,shader:g}=this;if(!c||!u||!g)return!1;const y=Yh(c.box),v=c.texture,w=u?.process([v])||v;return g.process([x,w],{rect:y}),!0}}class fD extends Ei{constructor(a,x=.5,c=.1,u={minCutOff:.05,minCutOffD:.1,beta:.05}){super(),this.callback=a,this.rangeMax=x,this.rangeMin=c,this.filterParams=u,this.gl=null,this.texture=null,this.frameBuffer=null,this.size={width:0,height:0},this.levels=1,this.ordinal=xs.PreRender,this.rangeRatio=(1-c)/(x-c)}async load(a){if(this.loaded||!(a instanceof $t)||!a.shaderCtx)return;const{shaderCtx:x}=a;if(this.frameBuffer=x.createFramebuffer(),!!this.frameBuffer)return this.gl=x,this.setupVideo(this.size),super.load(a)}unload(){if(!this.loaded)return;const{gl:a}=this;a?.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,a?.deleteTexture(this.texture),this.texture=null,this.gl=null,super.unload()}async update(a,x){const{gl:c,texture:u,size:{width:g,height:y},levels:v}=this;if(!this.loaded||!c||!u)return;const w=c.getParameter(c.TEXTURE_BINDING_2D),B=c.getParameter(c.FRAMEBUFFER_BINDING);c.bindTexture(c.TEXTURE_2D,this.texture),c.texSubImage2D(c.TEXTURE_2D,0,0,0,g,y,c.RGBA,c.UNSIGNED_BYTE,x),c.generateMipmap(c.TEXTURE_2D),c.bindFramebuffer(c.FRAMEBUFFER,this.frameBuffer),c.framebufferTexture2D(c.FRAMEBUFFER,c.COLOR_ATTACHMENT0,c.TEXTURE_2D,this.texture,v-1);const W=new Uint8Array(4);c.readPixels(0,0,1,1,c.RGBA,c.UNSIGNED_BYTE,W);let ae=(.299*W[0]+.587*W[1]+.114*W[2])/255;ae=this.filter(ae),ae=Math.min(Math.max(ae,this.rangeMin),this.rangeMax),ae=(ae-this.rangeMin)*this.rangeRatio+this.rangeMin,this.callback&&this.callback(ae),c.bindTexture(c.TEXTURE_2D,w),c.bindFramebuffer(c.FRAMEBUFFER,B)}setupVideo(a){const{width:x,height:c}=a;if(x===this.size.width&&c===this.size.height&&this.texture)return!0;const{gl:u}=this;if(!u||(u.deleteTexture(this.texture),this.texture=null,(x>0||c>0)&&(this.texture=u.createTexture()),!this.texture))return!1;const g=u.getParameter(u.TEXTURE_BINDING_2D);return u.bindTexture(u.TEXTURE_2D,this.texture),this.size={width:x,height:c},this.levels=1+Math.floor(Math.log2(Math.max(x,c))),u.texStorage2D(u.TEXTURE_2D,this.levels,u.RGBA8,x,c),u.bindTexture(u.TEXTURE_2D,g),!0}setCallback(a){this.callback=a}filter(a){if(!this.smooth)return this.smooth={val:a,der:0,time:Date.now()/1e3},a;const{smooth:x,filterParams:c}=this,u=Date.now()/1e3;if(u<=x.time)return a;const g=1/(u-x.time);x.time=u;const y=(a-x.val)*g,v=W=>1/(1+g/(2*Math.PI*W)),w=v(c.minCutOffD);x.der=x.der+w*(y-x.der);const B=v(c.minCutOff+c.beta*Math.abs(x.der));return x.val=x.val+B*(a-x.val),x.val}}class bB extends Ei{constructor(a){super(),this.callback=a,this.ordinal=xs.PostProcess}async update(a,x){if(this.loaded)return this.callback(a),super.update(a,x)}}class EB extends null{}class vB extends null{}class IB extends Ei{constructor(a){super(),this.predicate=a,this.ordinal=xs.PreProcess}async update(a,x){this.loaded&&(a.poses=a.poses.filter(this.predicate))}}class RB extends Ei{constructor(a){super(),this.predicate=a,this.ordinal=xs.PreProcess}async update(a,x){if(this.loaded)return a.faces=a.faces.filter(this.predicate),super.update(a,x)}}class MB extends jr{constructor(a=7,x=.05){super(["image"],{},lE("y",a,x)),this.smooth=a,this.sense=x,this.gaussian=[];const c=a**2,u=1/(a*Math.sqrt(2*Math.PI)),g=Math.floor(2*a);let y=u;this.gaussian.push(y);for(let v=1;v<=g;v++){const w=u*Math.exp(-.5*v*v/c);this.gaussian.push(w),this.gaussian.unshift(w),y+=2*w}for(let v=0;v<2*g+1;v++)this.gaussian[v]/=y}async load(a){var x;const c=a instanceof $t&&a.shaderCtx;if(this.loaded||!c)return;this.xpass=new bi(c,this.size,["image"],{},lE("x",this.smooth,this.sense)),await super.load(a);const u=c.getParameter(c.CURRENT_PROGRAM);[(x=this.shader)==null?void 0:x.program(),this.xpass.program()].forEach(g=>{if(!g)return;c.useProgram(g);const y=c.getUniformLocation(g,"kernel");c.uniform1fv(y,this.gaussian)}),c.useProgram(u)}unload(){var a;this.loaded&&((a=this.xpass)==null||a.dispose(),delete this.xpass,super.unload())}async process(a,x){const{xpass:c,shader:u}=this;return!c||!u?!1:(c.process([x]),u.process([c.output()]),!0)}setupVideo(a){var x;super.setupVideo(a),(x=this.xpass)==null||x.resize(a)}}function lE(F,a,x){const c=F==="x"?["x","x","0"]:["y","0","y"],u=Math.floor(2*a);return`
            precision mediump float;
            varying vec2 xy;
            uniform sampler2D image;
            uniform vec2 wh;
            uniform float kernel[`+(2*u+1)+`];

            void main() {
                vec3 center = texture2D(image, xy).rgb;
                vec3 result = vec3(0.0);
                float norm = 0.0;
                for (int `+c[0]+" = "+-u+"; "+c[0]+" <= "+u+"; "+c[0]+`++) {
                    vec3 pixel = texture2D(image, xy + vec2(`+c[1]+", "+c[2]+`) / wh).rgb;
                    vec3 diff = center - pixel;
                    float kc = `+1/(x*Math.sqrt(2*Math.PI))+` *
                        exp(-0.5 * dot(diff, diff) / `+x*x+`);
                    float k = kernel[`+c[0]+" + "+u+`] * kc;
                    result += k * pixel;
                    norm += k;
                }
                gl_FragColor = vec4(result / norm, 1.0);
            }`}class BB extends Ei{constructor(a){super(),this.callback=a,this.fpsStart=Date.now(),this.fpsCount=0,this.ordinal=xs.PostRender}async load(a){return this.fpsStart=Date.now(),this.fpsCount=0,super.load(a)}async update(a,x){if(this.loaded){if(this.fpsCount++,this.fpsCount>=30){const c=Date.now(),u=this.fpsCount*1e3/(c-this.fpsStart);this.fpsCount=0,this.fpsStart=c,this.callback(u)}return super.update(a,x)}}}class mD{get depthStencilTexture(){return this._depthStencilTexture}get depthStencilTextureWithStencil(){return this._depthStencilTextureWithStencil}get isCube(){return this._isCube}get isMulti(){return this._isMulti}get is2DArray(){return this.layers>0}get size(){return this.width}get width(){return this._size.width||this._size}get height(){return this._size.height||this._size}get layers(){return this._size.layers||0}get texture(){return this._textures?.[0]??null}get textures(){return this._textures}get faceIndices(){return this._faceIndices}get layerIndices(){return this._layerIndices}get samples(){return this._samples}setSamples(a,x=!0,c=!1){if(this.samples===a&&!c)return a;const u=this._isMulti?this._engine.updateMultipleRenderTargetTextureSampleCount(this,a,x):this._engine.updateRenderTargetTextureSampleCount(this,a);return this._samples=a,u}constructor(a,x,c,u,g){this._textures=null,this._faceIndices=null,this._layerIndices=null,this._samples=1,this._attachments=null,this._generateStencilBuffer=!1,this._generateDepthBuffer=!1,this._depthStencilTextureWithStencil=!1,this._isMulti=a,this._isCube=x,this._size=c,this._engine=u,this._depthStencilTexture=null,this.label=g}setTextures(a){Array.isArray(a)?this._textures=a:a?this._textures=[a]:this._textures=null}setTexture(a,x=0,c=!0){this._textures||(this._textures=[]),this._textures[x]!==a&&(this._textures[x]&&c&&this._textures[x].dispose(),this._textures[x]=a)}setLayerAndFaceIndices(a,x){this._layerIndices=a,this._faceIndices=x}setLayerAndFaceIndex(a=0,x,c){this._layerIndices||(this._layerIndices=[]),this._faceIndices||(this._faceIndices=[]),x!==void 0&&x>=0&&(this._layerIndices[a]=x),c!==void 0&&c>=0&&(this._faceIndices[a]=c)}createDepthStencilTexture(a=0,x=!0,c=!1,u=1,g=14,y){return this._depthStencilTexture?.dispose(),this._depthStencilTextureWithStencil=c,this._depthStencilTextureLabel=y,this._depthStencilTexture=this._engine.createDepthStencilTexture(this._size,{bilinearFiltering:x,comparisonFunction:a,generateStencil:c,isCube:this._isCube,samples:u,depthTextureFormat:g,label:y},this),this._depthStencilTexture}_shareDepth(a){this._depthStencilTexture&&(a._depthStencilTexture&&a._depthStencilTexture.dispose(),a._depthStencilTexture=this._depthStencilTexture,this._depthStencilTexture.incrementReferences())}_swapAndDie(a){this.texture&&this.texture._swapAndDie(a),this._textures=null,this.dispose(!0)}_cloneRenderTargetWrapper(){let a=null;if(this._isMulti){const x=this.textures;if(x&&x.length>0){let c=!1,u=x.length,g=-1;const y=x[x.length-1]._source;(y===hn.Depth||y===hn.DepthStencil)&&(c=!0,g=x[x.length-1].format,u--);const v=[],w=[],B=[],W=[],ae=[],ue=[],fe=[],Re={};for(let tt=0;tt<u;++tt){const $e=x[tt];v.push($e.samplingMode),w.push($e.type),B.push($e.format),Re[$e.uniqueId]!==void 0?(W.push(-1),fe.push(0)):(Re[$e.uniqueId]=tt,$e.is2DArray?(W.push(35866),fe.push($e.depth)):$e.isCube?(W.push(34067),fe.push(0)):$e.is3D?(W.push(32879),fe.push($e.depth)):(W.push(3553),fe.push(0))),this._faceIndices&&ae.push(this._faceIndices[tt]??0),this._layerIndices&&ue.push(this._layerIndices[tt]??0)}const _e={samplingModes:v,generateMipMaps:x[0].generateMipMaps,generateDepthBuffer:this._generateDepthBuffer,generateStencilBuffer:this._generateStencilBuffer,generateDepthTexture:c,depthTextureFormat:g,types:w,formats:B,textureCount:u,targetTypes:W,faceIndex:ae,layerIndex:ue,layerCounts:fe,label:this.label},Be={width:this.width,height:this.height};a=this._engine.createMultipleRenderTarget(Be,_e);for(let tt=0;tt<u;++tt){if(W[tt]!==-1)continue;const $e=Re[x[tt].uniqueId];a.setTexture(a.textures[$e],tt)}}}else{const x={};if(x.generateDepthBuffer=this._generateDepthBuffer,x.generateMipMaps=this.texture?.generateMipMaps??!1,x.generateStencilBuffer=this._generateStencilBuffer,x.samplingMode=this.texture?.samplingMode,x.type=this.texture?.type,x.format=this.texture?.format,x.noColorAttachment=!this._textures,x.label=this.label,this.isCube)a=this._engine.createRenderTargetCubeTexture(this.width,x);else{const c={width:this.width,height:this.height,layers:this.is2DArray?this.texture?.depth:void 0};a=this._engine.createRenderTargetTexture(c,x)}a.texture&&(a.texture.isReady=!0)}return a}_swapRenderTargetWrapper(a){if(this._textures&&a._textures)for(let x=0;x<this._textures.length;++x)this._textures[x]._swapAndDie(a._textures[x],!1),a._textures[x].isReady=!0;this._depthStencilTexture&&a._depthStencilTexture&&(this._depthStencilTexture._swapAndDie(a._depthStencilTexture),a._depthStencilTexture.isReady=!0),this._textures=null,this._depthStencilTexture=null}_rebuild(){const a=this._cloneRenderTargetWrapper();if(a){if(this._depthStencilTexture){const x=this._depthStencilTexture.samplingMode,c=this._depthStencilTexture.format,u=x===2||x===3||x===11;a.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction,u,this._depthStencilTextureWithStencil,this._depthStencilTexture.samples,c,this._depthStencilTextureLabel)}this.samples>1&&a.setSamples(this.samples),a._swapRenderTargetWrapper(this),a.dispose()}}releaseTextures(){if(this._textures)for(let a=0;a<this._textures?.length;++a)this._textures[a].dispose();this._textures=null}dispose(a=!1){a||(this._depthStencilTexture?.dispose(),this._depthStencilTexture=null,this.releaseTextures()),this._engine._releaseRenderTargetWrapper(this)}}class gD extends mD{constructor(a,x,c,u,g){super(a,x,c,u),this._framebuffer=null,this._depthStencilBuffer=null,this._MSAAFramebuffer=null,this._colorTextureArray=null,this._depthStencilTextureArray=null,this._disposeOnlyFramebuffers=!1,this._currentLOD=0,this._context=g}_cloneRenderTargetWrapper(){let a=null;return this._colorTextureArray&&this._depthStencilTextureArray?(a=this._engine.createMultiviewRenderTargetTexture(this.width,this.height),a.texture.isReady=!0):a=super._cloneRenderTargetWrapper(),a}_swapRenderTargetWrapper(a){super._swapRenderTargetWrapper(a),a._framebuffer=this._framebuffer,a._depthStencilBuffer=this._depthStencilBuffer,a._MSAAFramebuffer=this._MSAAFramebuffer,a._colorTextureArray=this._colorTextureArray,a._depthStencilTextureArray=this._depthStencilTextureArray,this._framebuffer=this._depthStencilBuffer=this._MSAAFramebuffer=this._colorTextureArray=this._depthStencilTextureArray=null}createDepthStencilTexture(a=0,x=!0,c=!1,u=1,g=14,y){if(this._depthStencilBuffer){const v=this._engine._currentFramebuffer,w=this._context;this._engine._bindUnboundFramebuffer(this._framebuffer),w.framebufferRenderbuffer(w.FRAMEBUFFER,w.DEPTH_STENCIL_ATTACHMENT,w.RENDERBUFFER,null),w.framebufferRenderbuffer(w.FRAMEBUFFER,w.DEPTH_ATTACHMENT,w.RENDERBUFFER,null),w.framebufferRenderbuffer(w.FRAMEBUFFER,w.STENCIL_ATTACHMENT,w.RENDERBUFFER,null),this._engine._bindUnboundFramebuffer(v),w.deleteRenderbuffer(this._depthStencilBuffer),this._depthStencilBuffer=null}return super.createDepthStencilTexture(a,x,c,u,g,y)}_shareDepth(a){super._shareDepth(a);const x=this._context,c=this._depthStencilBuffer,u=a._MSAAFramebuffer||a._framebuffer;a._depthStencilBuffer&&a._depthStencilBuffer!==c&&x.deleteRenderbuffer(a._depthStencilBuffer),a._depthStencilBuffer=c;const g=a._generateStencilBuffer?x.DEPTH_STENCIL_ATTACHMENT:x.DEPTH_ATTACHMENT;this._engine._bindUnboundFramebuffer(u),x.framebufferRenderbuffer(x.FRAMEBUFFER,g,x.RENDERBUFFER,c),this._engine._bindUnboundFramebuffer(null)}_bindTextureRenderTarget(a,x=0,c,u=0){if(!a._hardwareTexture)return;const g=this._framebuffer,y=this._engine._currentFramebuffer;if(this._engine._bindUnboundFramebuffer(g),this._engine.webGLVersion>1){const v=this._context,w=v["COLOR_ATTACHMENT"+x];a.is2DArray||a.is3D?(c=c??this.layerIndices?.[x]??0,v.framebufferTextureLayer(v.FRAMEBUFFER,w,a._hardwareTexture.underlyingResource,u,c)):a.isCube?(c=c??this.faceIndices?.[x]??0,v.framebufferTexture2D(v.FRAMEBUFFER,w,v.TEXTURE_CUBE_MAP_POSITIVE_X+c,a._hardwareTexture.underlyingResource,u)):v.framebufferTexture2D(v.FRAMEBUFFER,w,v.TEXTURE_2D,a._hardwareTexture.underlyingResource,u)}else{const v=this._context,w=v["COLOR_ATTACHMENT"+x+"_WEBGL"],B=c!==void 0?v.TEXTURE_CUBE_MAP_POSITIVE_X+c:v.TEXTURE_2D;v.framebufferTexture2D(v.FRAMEBUFFER,w,B,a._hardwareTexture.underlyingResource,u)}this._engine._bindUnboundFramebuffer(y)}setTexture(a,x=0,c=!0){super.setTexture(a,x,c),this._bindTextureRenderTarget(a,x)}setLayerAndFaceIndices(a,x){if(super.setLayerAndFaceIndices(a,x),!this.textures||!this.layerIndices||!this.faceIndices)return;const c=this._attachments?.length??this.textures.length;for(let u=0;u<c;u++){const g=this.textures[u];g&&(g.is2DArray||g.is3D?this._bindTextureRenderTarget(g,u,this.layerIndices[u]):g.isCube?this._bindTextureRenderTarget(g,u,this.faceIndices[u]):this._bindTextureRenderTarget(g,u))}}setLayerAndFaceIndex(a=0,x,c){if(super.setLayerAndFaceIndex(a,x,c),!this.textures||!this.layerIndices||!this.faceIndices)return;const u=this.textures[a];u.is2DArray||u.is3D?this._bindTextureRenderTarget(this.textures[a],a,this.layerIndices[a]):u.isCube&&this._bindTextureRenderTarget(this.textures[a],a,this.faceIndices[a])}dispose(a=this._disposeOnlyFramebuffers){const x=this._context;a||(this._colorTextureArray&&(this._context.deleteTexture(this._colorTextureArray),this._colorTextureArray=null),this._depthStencilTextureArray&&(this._context.deleteTexture(this._depthStencilTextureArray),this._depthStencilTextureArray=null)),this._framebuffer&&(x.deleteFramebuffer(this._framebuffer),this._framebuffer=null),this._depthStencilBuffer&&(x.deleteRenderbuffer(this._depthStencilBuffer),this._depthStencilBuffer=null),this._MSAAFramebuffer&&(x.deleteFramebuffer(this._MSAAFramebuffer),this._MSAAFramebuffer=null),super.dispose(a)}}Es.prototype._createHardwareRenderTargetWrapper=function(F,a,x){const c=new gD(F,a,x,this,this._gl);return this._renderTargetWrapperCache.push(c),c},Es.prototype.createRenderTargetTexture=function(F,a){const x=this._createHardwareRenderTargetWrapper(!1,!1,F);let c=!0,u=!1,g=!1,y,v=1,w;a!==void 0&&typeof a=="object"&&(c=a.generateDepthBuffer??!0,u=!!a.generateStencilBuffer,g=!!a.noColorAttachment,y=a.colorAttachment,v=a.samples??1,w=a.label);const B=y||(g?null:this._createInternalTexture(F,a,!0,hn.RenderTarget)),W=F.width||F,ae=F.height||F,ue=this._currentFramebuffer,fe=this._gl,Re=fe.createFramebuffer();return this._bindUnboundFramebuffer(Re),x._depthStencilBuffer=this._setupFramebufferDepthAttachments(u,c,W,ae),B&&!B.is2DArray&&fe.framebufferTexture2D(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,fe.TEXTURE_2D,B._hardwareTexture.underlyingResource,0),this._bindUnboundFramebuffer(ue),x.label=w??"RenderTargetWrapper",x._framebuffer=Re,x._generateDepthBuffer=c,x._generateStencilBuffer=u,x.setTextures(B),this.updateRenderTargetTextureSampleCount(x,v),x},Es.prototype.createDepthStencilTexture=function(F,a,x){if(a.isCube){const c=F.width||F;return this._createDepthStencilCubeTexture(c,a)}else return this._createDepthStencilTexture(F,a,x)},Es.prototype._createDepthStencilTexture=function(F,a){const x=this._gl,c=F.layers||0,u=c!==0?x.TEXTURE_2D_ARRAY:x.TEXTURE_2D,g=new a0(this,hn.DepthStencil);if(g.label=a.label,!this._caps.depthTextureExtension)return Qt.Error("Depth texture is not supported by your browser or hardware."),g;const y={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...a};if(this._bindTextureDirectly(u,g,!0),this._setupDepthStencilTexture(g,F,y.generateStencil,y.comparisonFunction===0?!1:y.bilinearFiltering,y.comparisonFunction,y.samples),y.depthTextureFormat!==void 0){if(y.depthTextureFormat!==15&&y.depthTextureFormat!==16&&y.depthTextureFormat!==17&&y.depthTextureFormat!==13&&y.depthTextureFormat!==14&&y.depthTextureFormat!==18)return Qt.Error("Depth texture format is not supported."),g;g.format=y.depthTextureFormat}else g.format=y.generateStencil?13:16;const v=g.format===17||g.format===13||g.format===18;let w=x.UNSIGNED_INT;g.format===15?w=x.UNSIGNED_SHORT:g.format===17||g.format===13?w=x.UNSIGNED_INT_24_8:g.format===14?w=x.FLOAT:g.format===18&&(w=x.FLOAT_32_UNSIGNED_INT_24_8_REV);const B=v?x.DEPTH_STENCIL:x.DEPTH_COMPONENT;let W=B;return this.webGLVersion>1&&(g.format===15?W=x.DEPTH_COMPONENT16:g.format===16?W=x.DEPTH_COMPONENT24:g.format===17||g.format===13?W=x.DEPTH24_STENCIL8:g.format===14?W=x.DEPTH_COMPONENT32F:g.format===18&&(W=x.DEPTH32F_STENCIL8)),g.is2DArray?x.texImage3D(u,0,W,g.width,g.height,c,0,B,w,null):x.texImage2D(u,0,W,g.width,g.height,0,B,w,null),this._bindTextureDirectly(u,null),this._internalTexturesCache.push(g),g},Es.prototype.updateRenderTargetTextureSampleCount=function(F,a){if(this.webGLVersion<2||!F||!F.texture)return 1;if(F.samples===a)return a;const x=this._gl;a=Math.min(a,this.getCaps().maxMSAASamples),F._depthStencilBuffer&&(x.deleteRenderbuffer(F._depthStencilBuffer),F._depthStencilBuffer=null),F._MSAAFramebuffer&&(x.deleteFramebuffer(F._MSAAFramebuffer),F._MSAAFramebuffer=null);const c=F.texture._hardwareTexture;if(c.releaseMSAARenderBuffers(),a>1&&typeof x.renderbufferStorageMultisample=="function"){const u=x.createFramebuffer();if(!u)throw new Error("Unable to create multi sampled framebuffer");F._MSAAFramebuffer=u,this._bindUnboundFramebuffer(F._MSAAFramebuffer);const g=this._createRenderBuffer(F.texture.width,F.texture.height,a,-1,this._getRGBABufferInternalSizedFormat(F.texture.type,F.texture.format,F.texture._useSRGBBuffer),x.COLOR_ATTACHMENT0,!1);if(!g)throw new Error("Unable to create multi sampled framebuffer");c.addMSAARenderBuffer(g)}else this._bindUnboundFramebuffer(F._framebuffer);return F.texture.samples=a,F._samples=a,F._depthStencilBuffer=this._setupFramebufferDepthAttachments(F._generateStencilBuffer,F._generateDepthBuffer,F.texture.width,F.texture.height,a),this._bindUnboundFramebuffer(null),a},Es.prototype.createRenderTargetCubeTexture=function(F,a){const x=this._createHardwareRenderTargetWrapper(!1,!0,F),c={generateMipMaps:!0,generateDepthBuffer:!0,generateStencilBuffer:!1,type:0,samplingMode:3,format:5,...a};c.generateStencilBuffer=c.generateDepthBuffer&&c.generateStencilBuffer,(c.type===1&&!this._caps.textureFloatLinearFiltering||c.type===2&&!this._caps.textureHalfFloatLinearFiltering)&&(c.samplingMode=1);const u=this._gl,g=new a0(this,hn.RenderTarget);this._bindTextureDirectly(u.TEXTURE_CUBE_MAP,g,!0);const y=this._getSamplingParameters(c.samplingMode,c.generateMipMaps);c.type===1&&!this._caps.textureFloat&&(c.type=0,Qt.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type")),u.texParameteri(u.TEXTURE_CUBE_MAP,u.TEXTURE_MAG_FILTER,y.mag),u.texParameteri(u.TEXTURE_CUBE_MAP,u.TEXTURE_MIN_FILTER,y.min),u.texParameteri(u.TEXTURE_CUBE_MAP,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_CUBE_MAP,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE);for(let w=0;w<6;w++)u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X+w,0,this._getRGBABufferInternalSizedFormat(c.type,c.format),F,F,0,this._getInternalFormat(c.format),this._getWebGLTextureType(c.type),null);const v=u.createFramebuffer();return this._bindUnboundFramebuffer(v),x._depthStencilBuffer=this._setupFramebufferDepthAttachments(c.generateStencilBuffer,c.generateDepthBuffer,F,F),c.generateMipMaps&&u.generateMipmap(u.TEXTURE_CUBE_MAP),this._bindTextureDirectly(u.TEXTURE_CUBE_MAP,null),this._bindUnboundFramebuffer(null),x._framebuffer=v,x._generateDepthBuffer=c.generateDepthBuffer,x._generateStencilBuffer=c.generateStencilBuffer,g.width=F,g.height=F,g.isReady=!0,g.isCube=!0,g.samples=1,g.generateMipMaps=c.generateMipMaps,g.samplingMode=c.samplingMode,g.type=c.type,g.format=c.format,this._internalTexturesCache.push(g),x.setTextures(g),x};const hE="postprocessVertexShader",uE=`attribute vec2 position;uniform vec2 scale;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;hi.ShadersStore[hE]=uE;const UB={name:hE,shader:uE},y_={positions:[1,1,-1,1,-1,-1,1,-1],indices:[0,1,2,0,2,3]};class _D{constructor(a,x=y_){this._fullscreenViewport=new xm(0,0,1,1);const c=x.positions??y_.positions,u=x.indices??y_.indices;this.engine=a,this._vertexBuffers={[Ve.PositionKind]:new Ve(a,c,Ve.PositionKind,!1,!1,2)},this._indexBuffer=a.createIndexBuffer(u),this._onContextRestoredObserver=a.onContextRestoredObservable.add(()=>{this._indexBuffer=a.createIndexBuffer(u);for(const g in this._vertexBuffers)this._vertexBuffers[g]._rebuild()})}setViewport(a=this._fullscreenViewport){this.engine.setViewport(a)}bindBuffers(a){this.engine.bindBuffers(this._vertexBuffers,this._indexBuffer,a)}applyEffectWrapper(a){this.engine.setState(!0),this.engine.depthCullingState.depthTest=!1,this.engine.stencilState.stencilTest=!1,this.engine.enableEffect(a._drawWrapper),this.bindBuffers(a.effect),a.onApplyObservable.notifyObservers({})}saveStates(){this._savedStateDepthTest=this.engine.depthCullingState.depthTest,this._savedStateStencilTest=this.engine.stencilState.stencilTest}restoreStates(){this.engine.depthCullingState.depthTest=this._savedStateDepthTest,this.engine.stencilState.stencilTest=this._savedStateStencilTest}draw(){this.engine.drawElementsType(0,0,6)}_isRenderTargetTexture(a){return a.renderTarget!==void 0}render(a,x=null){if(!a.effect.isReady())return;this.saveStates(),this.setViewport();const c=x===null?null:this._isRenderTargetTexture(x)?x.renderTarget:x;c&&this.engine.bindFramebuffer(c),this.applyEffectWrapper(a),this.draw(),c&&this.engine.unBindFramebuffer(c),this.restoreStates()}dispose(){const a=this._vertexBuffers[Ve.PositionKind];a&&(a.dispose(),delete this._vertexBuffers[Ve.PositionKind]),this._indexBuffer&&this.engine._releaseBuffer(this._indexBuffer),this._onContextRestoredObserver&&(this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}}class yD{get effect(){return this._drawWrapper.effect}set effect(a){this._drawWrapper.effect=a}constructor(a){this.onApplyObservable=new Jt;let x;const c=a.uniformNames||[];a.vertexShader?x={fragmentSource:a.fragmentShader,vertexSource:a.vertexShader,spectorName:a.name||"effectWrapper"}:(c.push("scale"),x={fragmentSource:a.fragmentShader,vertex:"postprocess",spectorName:a.name||"effectWrapper"},this.onApplyObservable.add(()=>{this.effect.setFloat2("scale",1,1)}));const u=a.defines?a.defines.join(`
`):"";this._drawWrapper=new Yo(a.engine),a.useShaderStore?(x.fragment=x.fragmentSource,x.vertex||(x.vertex=x.vertexSource),delete x.fragmentSource,delete x.vertexSource,this.effect=a.engine.createEffect(x,a.attributeNames||["position"],c,a.samplerNames,u,void 0,a.onCompiled,void 0,void 0,a.shaderLanguage)):(this.effect=new Yn(x,a.attributeNames||["position"],c,a.samplerNames,a.engine,u,void 0,a.onCompiled,void 0,void 0,void 0,a.shaderLanguage),this._onContextRestoredObserver=a.engine.onContextRestoredObservable.add(()=>{this.effect._pipelineContext=null,this.effect._prepareEffect()}))}dispose(){this._onContextRestoredObserver&&(this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null),this.effect.dispose()}}const dE="passPixelShader",fE=`varying vec2 vUV;uniform sampler2D textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=texture2D(textureSampler,vUV);}`;hi.ShadersStore[dE]=fE;const mE={name:dE,shader:fE};class Mo{static _CreateDumpRenderer(){if(!Mo._DumpToolsEngine){let a,x=null;const c={preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};try{a=new OffscreenCanvas(100,100),x=new Es(a,!1,c)}catch{a=document.createElement("canvas"),x=new Es(a,!1,c)}x.getCaps().parallelShaderCompile=void 0;const u=new _D(x),g=new yD({engine:x,name:mE.name,fragmentShader:mE.shader,samplerNames:["textureSampler"]});Mo._DumpToolsEngine={canvas:a,engine:x,renderer:u,wrapper:g}}return Mo._DumpToolsEngine}static async DumpFramebuffer(a,x,c,u,g="image/png",y,v){const w=await c.readPixels(0,0,a,x),B=new Uint8Array(w.buffer);Mo.DumpData(a,x,B,u,g,y,!0,void 0,v)}static DumpDataAsync(a,x,c,u="image/png",g,y=!1,v=!1,w){return new Promise(B=>{Mo.DumpData(a,x,c,W=>B(W),u,g,y,v,w)})}static DumpData(a,x,c,u,g="image/png",y,v=!1,w=!1,B){const W=Mo._CreateDumpRenderer();if(W.engine.setSize(a,x,!0),c instanceof Float32Array){const ue=new Uint8Array(c.length);let fe=c.length;for(;fe--;){const Re=c[fe];ue[fe]=Math.round(_n.Clamp(Re)*255)}c=ue}const ae=W.engine.createRawTexture(c,a,x,5,!1,!v,1);W.renderer.setViewport(),W.renderer.applyEffectWrapper(W.wrapper),W.wrapper.effect._bindTexture("textureSampler",ae),W.renderer.draw(),w?_t.ToBlob(W.canvas,ue=>{const fe=new FileReader;fe.onload=Re=>{const _e=Re.target.result;u&&u(_e)},fe.readAsArrayBuffer(ue)},g,B):_t.EncodeScreenshotCanvasData(W.canvas,u,g,y,B),ae.dispose()}static Dispose(){Mo._DumpToolsEngine&&(Mo._DumpToolsEngine.wrapper.dispose(),Mo._DumpToolsEngine.renderer.dispose(),Mo._DumpToolsEngine.engine.dispose()),Mo._DumpToolsEngine=null}}(()=>{_t.DumpData=Mo.DumpData,_t.DumpDataAsync=Mo.DumpDataAsync,_t.DumpFramebuffer=Mo.DumpFramebuffer})();class Bo extends fi{get renderList(){return this._renderList}set renderList(a){this._unObserveRenderList&&(this._unObserveRenderList(),this._unObserveRenderList=null),a&&(this._unObserveRenderList=Mn(a,this._renderListHasChanged)),this._renderList=a}get postProcesses(){return this._postProcesses}get _prePassEnabled(){return!!this._prePassRenderTarget&&this._prePassRenderTarget.enabled}set onAfterUnbind(a){this._onAfterUnbindObserver&&this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=this.onAfterUnbindObservable.add(a)}set onBeforeRender(a){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(a)}set onAfterRender(a){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(a)}set onClear(a){this._onClearObserver&&this.onClearObservable.remove(this._onClearObserver),this._onClearObserver=this.onClearObservable.add(a)}get renderPassIds(){return this._renderPassIds}get currentRefreshId(){return this._currentRefreshId}setMaterialForRendering(a,x){let c;Array.isArray(a)?c=a:c=[a];for(let u=0;u<c.length;++u)for(let g=0;g<this._renderPassIds.length;++g)c[u].setMaterialForRenderPass(this._renderPassIds[g],x!==void 0?Array.isArray(x)?x[g]:x:void 0)}get isMulti(){return this._renderTarget?.isMulti??!1}get renderTargetOptions(){return this._renderTargetOptions}get renderTarget(){return this._renderTarget}_onRatioRescale(){this._sizeRatio&&this.resize(this._initialSizeParameter)}set boundingBoxSize(a){if(this._boundingBoxSize&&this._boundingBoxSize.equals(a))return;this._boundingBoxSize=a;const x=this.getScene();x&&x.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}get depthStencilTexture(){return this._renderTarget?._depthStencilTexture??null}constructor(a,x,c,u=!1,g=!0,y=0,v=!1,w=fi.TRILINEAR_SAMPLINGMODE,B=!0,W=!1,ae=!1,ue=5,fe=!1,Re,_e,Be=!1,tt=!1){let $e,Et=!0;if(typeof u=="object"){const dt=u;u=!!dt.generateMipMaps,g=dt.doNotChangeAspectRatio??!0,y=dt.type??0,v=!!dt.isCube,w=dt.samplingMode??fi.TRILINEAR_SAMPLINGMODE,B=dt.generateDepthBuffer??!0,W=!!dt.generateStencilBuffer,ae=!!dt.isMulti,ue=dt.format??5,fe=!!dt.delayAllocation,Re=dt.samples,_e=dt.creationFlags,Be=!!dt.noColorAttachment,tt=!!dt.useSRGBBuffer,$e=dt.colorAttachment,Et=dt.gammaSpace??Et}if(super(null,c,!u,void 0,w,void 0,void 0,void 0,void 0,ue),this._unObserveRenderList=null,this._renderListHasChanged=(dt,ut)=>{const Mt=this._renderList?this._renderList.length:0;(ut===0&&Mt>0||Mt===0)&&this.getScene()?.meshes.forEach(ai=>{ai._markSubMeshesAsLightDirty()})},this.renderParticles=!0,this.renderSprites=!1,this.forceLayerMaskCheck=!1,this.ignoreCameraViewport=!1,this.onBeforeBindObservable=new Jt,this.onAfterUnbindObservable=new Jt,this.onBeforeRenderObservable=new Jt,this.onAfterRenderObservable=new Jt,this.onClearObservable=new Jt,this.onResizeObservable=new Jt,this._cleared=!1,this.skipInitialClear=!1,this._currentRefreshId=-1,this._refreshRate=1,this._samples=1,this._canRescale=!0,this._renderTarget=null,this.boundingBoxPosition=Ee.Zero(),c=this.getScene(),!c)return;const ft=this.getScene().getEngine();this._gammaSpace=Et,this._coordinatesMode=fi.PROJECTION_MODE,this.renderList=[],this.name=a,this.isRenderTarget=!0,this._initialSizeParameter=x,this._renderPassIds=[],this._isCubeData=v,this._processSizeParameter(x),this.renderPassId=this._renderPassIds[0],this._resizeObserver=ft.onResizeObservable.add(()=>{}),this._generateMipMaps=!!u,this._doNotChangeAspectRatio=g,this._renderingManager=new io(c),this._renderingManager._useSceneAutoClearSetup=!0,!ae&&(this._renderTargetOptions={generateMipMaps:u,type:y,format:this._format??void 0,samplingMode:this.samplingMode,generateDepthBuffer:B,generateStencilBuffer:W,samples:Re,creationFlags:_e,noColorAttachment:Be,useSRGBBuffer:tt,colorAttachment:$e,label:this.name},this.samplingMode===fi.NEAREST_SAMPLINGMODE&&(this.wrapU=fi.CLAMP_ADDRESSMODE,this.wrapV=fi.CLAMP_ADDRESSMODE),fe||(v?(this._renderTarget=c.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions),this.coordinatesMode=fi.INVCUBIC_MODE,this._textureMatrix=vt.Identity()):this._renderTarget=c.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,Re!==void 0&&(this.samples=Re)))}createDepthStencilTexture(a=0,x=!0,c=!1,u=1,g=14){this._renderTarget?.createDepthStencilTexture(a,x,c,u,g)}_releaseRenderPassId(){if(this._scene){const a=this._scene.getEngine();for(let x=0;x<this._renderPassIds.length;++x)a.releaseRenderPassId(this._renderPassIds[x])}this._renderPassIds=[]}_createRenderPassId(){this._releaseRenderPassId();const a=this._scene.getEngine(),x=this._isCubeData?6:this.getRenderLayers()||1;for(let c=0;c<x;++c)this._renderPassIds[c]=a.createRenderPassId(`RenderTargetTexture - ${this.name}#${c}`)}_processSizeParameter(a,x=!0){if(a.ratio){this._sizeRatio=a.ratio;const c=this._getEngine();this._size={width:this._bestReflectionRenderTargetDimension(c.getRenderWidth(),this._sizeRatio),height:this._bestReflectionRenderTargetDimension(c.getRenderHeight(),this._sizeRatio)}}else this._size=a;x&&this._createRenderPassId()}get samples(){return this._renderTarget?.samples??this._samples}set samples(a){this._renderTarget&&(this._samples=this._renderTarget.setSamples(a))}resetRefreshCounter(){this._currentRefreshId=-1}get refreshRate(){return this._refreshRate}set refreshRate(a){this._refreshRate=a,this.resetRefreshCounter()}addPostProcess(a){if(!this._postProcessManager){const x=this.getScene();if(!x)return;this._postProcessManager=new Ym(x),this._postProcesses=new Array}this._postProcesses.push(a),this._postProcesses[0].autoClear=!1}clearPostProcesses(a=!1){if(this._postProcesses){if(a)for(const x of this._postProcesses)x.dispose();this._postProcesses=[]}}removePostProcess(a){if(!this._postProcesses)return;const x=this._postProcesses.indexOf(a);x!==-1&&(this._postProcesses.splice(x,1),this._postProcesses.length>0&&(this._postProcesses[0].autoClear=!1))}_shouldRender(){return this._currentRefreshId===-1?(this._currentRefreshId=1,!0):this.refreshRate===this._currentRefreshId?(this._currentRefreshId=1,!0):(this._currentRefreshId++,!1)}getRenderSize(){return this.getRenderWidth()}getRenderWidth(){return this._size.width?this._size.width:this._size}getRenderHeight(){return this._size.width?this._size.height:this._size}getRenderLayers(){const a=this._size.layers;return a||0}disableRescaling(){this._canRescale=!1}get canRescale(){return this._canRescale}scale(a){const x=Math.max(1,this.getRenderSize()*a);this.resize(x)}getReflectionTextureMatrix(){return this.isCube?this._textureMatrix:super.getReflectionTextureMatrix()}resize(a){const x=this.isCube;this._renderTarget?.dispose(),this._renderTarget=null;const c=this.getScene();c&&(this._processSizeParameter(a,!1),x?this._renderTarget=c.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions):this._renderTarget=c.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,this._renderTargetOptions.samples!==void 0&&(this.samples=this._renderTargetOptions.samples),this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this))}render(a=!1,x=!1){this._render(a,x)}isReadyForRendering(){return this._render(!1,!1,!0)}_render(a=!1,x=!1,c=!1){const u=this.getScene();if(!u)return c;const g=u.getEngine();if(this.useCameraPostProcesses!==void 0&&(a=this.useCameraPostProcesses),this._waitingRenderList){if(!this.renderListPredicate){this.renderList=[];for(let W=0;W<this._waitingRenderList.length;W++){const ae=this._waitingRenderList[W],ue=u.getMeshById(ae);ue&&this.renderList.push(ue)}}this._waitingRenderList=void 0}if(this.renderListPredicate){this.renderList?this.renderList.length=0:this.renderList=[];const W=this.getScene();if(!W)return c;const ae=W.meshes;for(let ue=0;ue<ae.length;ue++){const fe=ae[ue];this.renderListPredicate(fe)&&this.renderList.push(fe)}}const y=g.currentRenderPassId;this.onBeforeBindObservable.notifyObservers(this);const v=this.activeCamera??u.activeCamera,w=u.activeCamera;v&&(v!==u.activeCamera&&(u.setTransformMatrix(v.getViewMatrix(),v.getProjectionMatrix(!0)),u.activeCamera=v),g.setViewport(v.rigParent?v.rigParent.viewport:v.viewport,this.getRenderWidth(),this.getRenderHeight())),this._defaultRenderListPrepared=!1;let B=c;if(c){u.getViewMatrix()||u.updateTransformMatrix();const W=this.is2DArray?this.getRenderLayers():this.isCube?6:1;for(let ae=0;ae<W&&B;ae++){let ue=null;const fe=this.renderList?this.renderList:u.getActiveMeshes().data,Re=this.renderList?this.renderList.length:u.getActiveMeshes().length;g.currentRenderPassId=this._renderPassIds[ae],this.onBeforeRenderObservable.notifyObservers(ae),this.getCustomRenderList&&(ue=this.getCustomRenderList(ae,fe,Re)),ue||(ue=fe),this._doNotChangeAspectRatio||u.updateTransformMatrix(!0);for(let _e=0;_e<ue.length&&B;++_e){const Be=ue[_e];if(!(!Be.isEnabled()||Be.isBlocked||!Be.isVisible||!Be.subMeshes)){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(Be,this.refreshRate,c)){B=!1;continue}}else if(!Be.isReady(!0)){B=!1;continue}}}this.onAfterRenderObservable.notifyObservers(ae),(this.is2DArray||this.isCube)&&(u.incrementRenderId(),u.resetCachedMaterial())}}else if(this.is2DArray&&!this.isMulti)for(let W=0;W<this.getRenderLayers();W++)this._renderToTarget(0,a,x,W,v),u.incrementRenderId(),u.resetCachedMaterial();else if(this.isCube&&!this.isMulti)for(let W=0;W<6;W++)this._renderToTarget(W,a,x,void 0,v),u.incrementRenderId(),u.resetCachedMaterial();else this._renderToTarget(0,a,x,void 0,v);return this.onAfterUnbindObservable.notifyObservers(this),g.currentRenderPassId=y,w&&(u.activeCamera=w,this.activeCamera&&this.activeCamera!==u.activeCamera&&u.setTransformMatrix(u.activeCamera.getViewMatrix(),u.activeCamera.getProjectionMatrix(!0)),g.setViewport(u.activeCamera.viewport)),u.resetCachedMaterial(),B}_bestReflectionRenderTargetDimension(a,x){const u=a*x,g=Bt.NearestPOT(u+128*128/(128+u));return Math.min(Bt.FloorPOT(a),g)}_prepareRenderingManager(a,x,c,u){const g=this.getScene();if(!g)return;this._renderingManager.reset();const y=g.getRenderId();for(let v=0;v<x;v++){const w=a[v];if(w&&!w.isBlocked){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(w,this.refreshRate,!1)){this.resetRefreshCounter();continue}}else if(!w.isReady(this.refreshRate===0)){this.resetRefreshCounter();continue}if(!w._internalAbstractMeshDataInfo._currentLODIsUpToDate&&g.activeCamera&&(w._internalAbstractMeshDataInfo._currentLOD=g.customLODSelector?g.customLODSelector(w,this.activeCamera||g.activeCamera):w.getLOD(this.activeCamera||g.activeCamera),w._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0),!w._internalAbstractMeshDataInfo._currentLOD)continue;let B=w._internalAbstractMeshDataInfo._currentLOD;B._preActivateForIntermediateRendering(y);let W;if(u&&c?W=(w.layerMask&c.layerMask)===0:W=!1,w.isEnabled()&&w.isVisible&&w.subMeshes&&!W&&(B!==w&&B._activate(y,!0),w._activate(y,!0)&&w.subMeshes.length)){w.isAnInstance?w._internalAbstractMeshDataInfo._actAsRegularMesh&&(B=w):B._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!1,B._internalAbstractMeshDataInfo._isActiveIntermediate=!0;for(let ae=0;ae<B.subMeshes.length;ae++){const ue=B.subMeshes[ae];this._renderingManager.dispatch(ue,B)}}}}for(let v=0;v<g.particleSystems.length;v++){const w=g.particleSystems[v],B=w.emitter;!w.isStarted()||!B||B.position&&!B.isEnabled()||this._renderingManager.dispatchParticles(w)}}_bindFrameBuffer(a=0,x=0){const c=this.getScene();if(!c)return;const u=c.getEngine();this._renderTarget&&u.bindFramebuffer(this._renderTarget,this.isCube?a:void 0,void 0,void 0,this.ignoreCameraViewport,0,x)}_unbindFrameBuffer(a,x){this._renderTarget&&a.unBindFramebuffer(this._renderTarget,this.isCube,()=>{this.onAfterRenderObservable.notifyObservers(x)})}_prepareFrame(a,x,c,u){this._postProcessManager?this._prePassEnabled||this._postProcessManager._prepareFrame(this._texture,this._postProcesses):(!u||!a.postProcessManager._prepareFrame(this._texture))&&this._bindFrameBuffer(x,c)}_renderToTarget(a,x,c,u=0,g=null){const y=this.getScene();if(!y)return;const v=y.getEngine();if(v._debugPushGroup?.(`render to face #${a} layer #${u}`,1),this._prepareFrame(y,a,u,x),this.is2DArray?(v.currentRenderPassId=this._renderPassIds[u],this.onBeforeRenderObservable.notifyObservers(u)):(v.currentRenderPassId=this._renderPassIds[a],this.onBeforeRenderObservable.notifyObservers(a)),v.snapshotRendering&&v.snapshotRenderingMode===1)this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(v):this.skipInitialClear||v.clear(this.clearColor||y.clearColor,!0,!0,!0);else{let B=null;const W=this.renderList?this.renderList:y.getActiveMeshes().data,ae=this.renderList?this.renderList.length:y.getActiveMeshes().length;this.getCustomRenderList&&(B=this.getCustomRenderList(this.is2DArray?u:a,W,ae)),B?this._prepareRenderingManager(B,B.length,g,this.forceLayerMaskCheck):(this._defaultRenderListPrepared||(this._prepareRenderingManager(W,ae,g,!this.renderList||this.forceLayerMaskCheck),this._defaultRenderListPrepared=!0),B=W);for(const fe of y._beforeRenderTargetClearStage)fe.action(this,a,u);this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(v):this.skipInitialClear||v.clear(this.clearColor||y.clearColor,!0,!0,!0),this._doNotChangeAspectRatio||y.updateTransformMatrix(!0);for(const fe of y._beforeRenderTargetDrawStage)fe.action(this,a,u);this._renderingManager.render(this.customRenderFunction,B,this.renderParticles,this.renderSprites);for(const fe of y._afterRenderTargetDrawStage)fe.action(this,a,u);const ue=this._texture?.generateMipMaps??!1;this._texture&&(this._texture.generateMipMaps=!1),this._postProcessManager?this._postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,a,this._postProcesses,this.ignoreCameraViewport):x&&y.postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,a);for(const fe of y._afterRenderTargetPostProcessStage)fe.action(this,a,u);this._texture&&(this._texture.generateMipMaps=ue),this._doNotChangeAspectRatio||y.updateTransformMatrix(!0),c&&Mo.DumpFramebuffer(this.getRenderWidth(),this.getRenderHeight(),v)}this._unbindFrameBuffer(v,a),this._texture&&this.isCube&&a===5&&v.generateMipMapsForCubemap(this._texture),v._debugPopGroup?.(1)}setRenderingOrder(a,x=null,c=null,u=null){this._renderingManager.setRenderingOrder(a,x,c,u)}setRenderingAutoClearDepthStencil(a,x){this._renderingManager.setRenderingAutoClearDepthStencil(a,x),this._renderingManager._useSceneAutoClearSetup=!1}clone(){const a=this.getSize(),x=new Bo(this.name,a,this.getScene(),this._renderTargetOptions.generateMipMaps,this._doNotChangeAspectRatio,this._renderTargetOptions.type,this.isCube,this._renderTargetOptions.samplingMode,this._renderTargetOptions.generateDepthBuffer,this._renderTargetOptions.generateStencilBuffer,void 0,this._renderTargetOptions.format,void 0,this._renderTargetOptions.samples);return x.hasAlpha=this.hasAlpha,x.level=this.level,x.coordinatesMode=this.coordinatesMode,this.renderList&&(x.renderList=this.renderList.slice(0)),x}serialize(){if(!this.name)return null;const a=super.serialize();if(a.renderTargetSize=this.getRenderSize(),a.renderList=[],this.renderList)for(let x=0;x<this.renderList.length;x++)a.renderList.push(this.renderList[x].id);return a}disposeFramebufferObjects(){this._renderTarget?.dispose(!0)}releaseInternalTexture(){this._renderTarget?.releaseTextures(),this._texture=null}dispose(){this.onResizeObservable.clear(),this.onClearObservable.clear(),this.onAfterRenderObservable.clear(),this.onAfterUnbindObservable.clear(),this.onBeforeBindObservable.clear(),this.onBeforeRenderObservable.clear(),this._postProcessManager&&(this._postProcessManager.dispose(),this._postProcessManager=null),this._prePassRenderTarget&&this._prePassRenderTarget.dispose(),this._releaseRenderPassId(),this.clearPostProcesses(!0),this._resizeObserver&&(this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null),this.renderList=null;const a=this.getScene();if(!a)return;let x=a.customRenderTargets.indexOf(this);x>=0&&a.customRenderTargets.splice(x,1);for(const c of a.cameras)x=c.customRenderTargets.indexOf(this),x>=0&&c.customRenderTargets.splice(x,1);this._renderTarget?.dispose(),this._renderTarget=null,this._texture=null,super.dispose()}_rebuild(){this.refreshRate===Bo.REFRESHRATE_RENDER_ONCE&&(this.refreshRate=Bo.REFRESHRATE_RENDER_ONCE),this._postProcessManager&&this._postProcessManager._rebuild()}freeRenderingGroups(){this._renderingManager&&this._renderingManager.freeRenderingGroups()}getViewCount(){return 1}}Bo.REFRESHRATE_RENDER_ONCE=0,Bo.REFRESHRATE_RENDER_ONEVERYFRAME=1,Bo.REFRESHRATE_RENDER_ONEVERYTWOFRAMES=2,fi._CreateRenderTargetTexture=(F,a,x,c,u)=>new Bo(F,a,x,c);class bD{constructor(){this._checkCollisions=!1,this._collisionMask=-1,this._collisionGroup=-1,this._surroundingMeshes=null,this._collider=null,this._oldPositionForCollisions=new Ee(0,0,0),this._diffPositionForCollisions=new Ee(0,0,0),this._collisionResponse=!0}}class ED{constructor(){this.facetNb=0,this.partitioningSubdivisions=10,this.partitioningBBoxRatio=1.01,this.facetDataEnabled=!1,this.facetParameters={},this.bbSize=Ee.Zero(),this.subDiv={max:1,X:1,Y:1,Z:1},this.facetDepthSort=!1,this.facetDepthSortEnabled=!1}}class vD{constructor(){this._hasVertexAlpha=!1,this._useVertexColors=!0,this._numBoneInfluencers=4,this._applyFog=!0,this._receiveShadows=!1,this._facetData=new ED,this._visibility=1,this._skeleton=null,this._layerMask=268435455,this._computeBonesUsingShaders=!0,this._isActive=!1,this._onlyForInstances=!1,this._isActiveIntermediate=!1,this._onlyForInstancesIntermediate=!1,this._actAsRegularMesh=!1,this._currentLOD=null,this._currentLODIsUpToDate=!1,this._collisionRetryCount=3,this._morphTargetManager=null,this._renderingGroupId=0,this._bakedVertexAnimationManager=null,this._material=null,this._positions=null,this._pointerOverDisableMeshTesting=!1,this._meshCollisionData=new bD,this._enableDistantPicking=!1,this._rawBoundingInfo=null}}class mo extends $s{static get BILLBOARDMODE_NONE(){return $s.BILLBOARDMODE_NONE}static get BILLBOARDMODE_X(){return $s.BILLBOARDMODE_X}static get BILLBOARDMODE_Y(){return $s.BILLBOARDMODE_Y}static get BILLBOARDMODE_Z(){return $s.BILLBOARDMODE_Z}static get BILLBOARDMODE_ALL(){return $s.BILLBOARDMODE_ALL}static get BILLBOARDMODE_USE_POSITION(){return $s.BILLBOARDMODE_USE_POSITION}get facetNb(){return this._internalAbstractMeshDataInfo._facetData.facetNb}get partitioningSubdivisions(){return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions}set partitioningSubdivisions(a){this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions=a}get partitioningBBoxRatio(){return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio}set partitioningBBoxRatio(a){this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio=a}get mustDepthSortFacets(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSort}set mustDepthSortFacets(a){this._internalAbstractMeshDataInfo._facetData.facetDepthSort=a}get facetDepthSortFrom(){return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom}set facetDepthSortFrom(a){this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom=a}get collisionRetryCount(){return this._internalAbstractMeshDataInfo._collisionRetryCount}set collisionRetryCount(a){this._internalAbstractMeshDataInfo._collisionRetryCount=a}get isFacetDataEnabled(){return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled}get morphTargetManager(){return this._internalAbstractMeshDataInfo._morphTargetManager}set morphTargetManager(a){this._internalAbstractMeshDataInfo._morphTargetManager!==a&&(this._internalAbstractMeshDataInfo._morphTargetManager=a,this._syncGeometryWithMorphTargetManager())}get bakedVertexAnimationManager(){return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager}set bakedVertexAnimationManager(a){this._internalAbstractMeshDataInfo._bakedVertexAnimationManager!==a&&(this._internalAbstractMeshDataInfo._bakedVertexAnimationManager=a,this._markSubMeshesAsAttributesDirty())}_syncGeometryWithMorphTargetManager(){}_updateNonUniformScalingState(a){return super._updateNonUniformScalingState(a)?(this._markSubMeshesAsMiscDirty(),!0):!1}get rawBoundingInfo(){return this._internalAbstractMeshDataInfo._rawBoundingInfo}set rawBoundingInfo(a){this._internalAbstractMeshDataInfo._rawBoundingInfo=a}set onCollide(a){this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver&&this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver=this.onCollideObservable.add(a)}set onCollisionPositionChange(a){this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver&&this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver),this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver=this.onCollisionPositionChangeObservable.add(a)}get visibility(){return this._internalAbstractMeshDataInfo._visibility}set visibility(a){if(this._internalAbstractMeshDataInfo._visibility===a)return;const x=this._internalAbstractMeshDataInfo._visibility;this._internalAbstractMeshDataInfo._visibility=a,(x===1&&a!==1||x!==1&&a===1)&&this._markSubMeshesAsDirty(c=>{c.markAsMiscDirty(),c.markAsPrePassDirty()})}get pointerOverDisableMeshTesting(){return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting}set pointerOverDisableMeshTesting(a){this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting=a}get renderingGroupId(){return this._internalAbstractMeshDataInfo._renderingGroupId}set renderingGroupId(a){this._internalAbstractMeshDataInfo._renderingGroupId=a}get material(){return this._internalAbstractMeshDataInfo._material}set material(a){this._internalAbstractMeshDataInfo._material!==a&&(this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),this._internalAbstractMeshDataInfo._material=a,a&&a.meshMap&&(a.meshMap[this.uniqueId]=this),this.onMaterialChangedObservable.hasObservers()&&this.onMaterialChangedObservable.notifyObservers(this),this.subMeshes&&(this.resetDrawCache(),this._unBindEffect()))}getMaterialForRenderPass(a){return this._internalAbstractMeshDataInfo._materialForRenderPass?.[a]}setMaterialForRenderPass(a,x){this.resetDrawCache(a),this._internalAbstractMeshDataInfo._materialForRenderPass||(this._internalAbstractMeshDataInfo._materialForRenderPass=[]),this._internalAbstractMeshDataInfo._materialForRenderPass[a]=x}get receiveShadows(){return this._internalAbstractMeshDataInfo._receiveShadows}set receiveShadows(a){this._internalAbstractMeshDataInfo._receiveShadows!==a&&(this._internalAbstractMeshDataInfo._receiveShadows=a,this._markSubMeshesAsLightDirty())}get hasVertexAlpha(){return this._internalAbstractMeshDataInfo._hasVertexAlpha}set hasVertexAlpha(a){this._internalAbstractMeshDataInfo._hasVertexAlpha!==a&&(this._internalAbstractMeshDataInfo._hasVertexAlpha=a,this._markSubMeshesAsAttributesDirty(),this._markSubMeshesAsMiscDirty())}get useVertexColors(){return this._internalAbstractMeshDataInfo._useVertexColors}set useVertexColors(a){this._internalAbstractMeshDataInfo._useVertexColors!==a&&(this._internalAbstractMeshDataInfo._useVertexColors=a,this._markSubMeshesAsAttributesDirty())}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(a){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==a&&(this._internalAbstractMeshDataInfo._computeBonesUsingShaders=a,this._markSubMeshesAsAttributesDirty())}get numBoneInfluencers(){return this._internalAbstractMeshDataInfo._numBoneInfluencers}set numBoneInfluencers(a){this._internalAbstractMeshDataInfo._numBoneInfluencers!==a&&(this._internalAbstractMeshDataInfo._numBoneInfluencers=a,this._markSubMeshesAsAttributesDirty())}get applyFog(){return this._internalAbstractMeshDataInfo._applyFog}set applyFog(a){this._internalAbstractMeshDataInfo._applyFog!==a&&(this._internalAbstractMeshDataInfo._applyFog=a,this._markSubMeshesAsMiscDirty())}get enableDistantPicking(){return this._internalAbstractMeshDataInfo._enableDistantPicking}set enableDistantPicking(a){this._internalAbstractMeshDataInfo._enableDistantPicking=a}get layerMask(){return this._internalAbstractMeshDataInfo._layerMask}set layerMask(a){a!==this._internalAbstractMeshDataInfo._layerMask&&(this._internalAbstractMeshDataInfo._layerMask=a,this._resyncLightSources())}get collisionMask(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask}set collisionMask(a){this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask=isNaN(a)?-1:a}get collisionResponse(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse}set collisionResponse(a){this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse=a}get collisionGroup(){return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup}set collisionGroup(a){this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup=isNaN(a)?-1:a}get surroundingMeshes(){return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes}set surroundingMeshes(a){this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes=a}get lightSources(){return this._lightSources}get _positions(){return null}set skeleton(a){const x=this._internalAbstractMeshDataInfo._skeleton;x&&x.needInitialSkinMatrix&&x._unregisterMeshWithPoseMatrix(this),a&&a.needInitialSkinMatrix&&a._registerMeshWithPoseMatrix(this),this._internalAbstractMeshDataInfo._skeleton=a,this._internalAbstractMeshDataInfo._skeleton||(this._bonesTransformMatrices=null),this._markSubMeshesAsAttributesDirty()}get skeleton(){return this._internalAbstractMeshDataInfo._skeleton}constructor(a,x=null){switch(super(a,x,!1),this._internalAbstractMeshDataInfo=new vD,this._waitingMaterialId=null,this.cullingStrategy=mo.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY,this.onCollideObservable=new Jt,this.onCollisionPositionChangeObservable=new Jt,this.onMaterialChangedObservable=new Jt,this.definedFacingForward=!0,this._occlusionQuery=null,this._renderingGroup=null,this.alphaIndex=Number.MAX_VALUE,this.isVisible=!0,this.isPickable=!0,this.isNearPickable=!1,this.isNearGrabbable=!1,this.showSubMeshesBoundingBox=!1,this.isBlocker=!1,this.enablePointerMoveEvents=!1,this.outlineColor=Bs.Red(),this.outlineWidth=.02,this.overlayColor=Bs.Red(),this.overlayAlpha=.5,this.useOctreeForRenderingSelection=!0,this.useOctreeForPicking=!0,this.useOctreeForCollisions=!0,this.alwaysSelectAsActiveMesh=!1,this.doNotSyncBoundingInfo=!1,this.actionManager=null,this.ellipsoid=new Ee(.5,1,.5),this.ellipsoidOffset=new Ee(0,0,0),this.edgesWidth=1,this.edgesColor=new Yr(1,0,0,1),this._edgesRenderer=null,this._masterMesh=null,this._boundingInfo=null,this._boundingInfoIsDirty=!0,this._renderId=0,this._intersectionsInProgress=new Array,this._unIndexed=!1,this._lightSources=new Array,this._waitingData={lods:null,actions:null,freezeWorldMatrix:null},this._bonesTransformMatrices=null,this._transformMatrixTexture=null,this.onRebuildObservable=new Jt,this._onCollisionPositionChange=(c,u,g=null)=>{u.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length()>Bt.CollisionsEpsilon&&this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),g&&this.onCollideObservable.notifyObservers(g),this.onCollisionPositionChangeObservable.notifyObservers(this.position)},x=this.getScene(),x.addMesh(this),this._resyncLightSources(),this._uniformBuffer=new ys(this.getScene().getEngine(),void 0,void 0,a,!this.getScene().getEngine().isWebGPU),this._buildUniformLayout(),x.performancePriority){case g2.Aggressive:this.doNotSyncBoundingInfo=!0;case g2.Intermediate:this.alwaysSelectAsActiveMesh=!0,this.isPickable=!1;break}}_buildUniformLayout(){this._uniformBuffer.addUniform("world",16),this._uniformBuffer.addUniform("visibility",1),this._uniformBuffer.create()}transferToEffect(a){const x=this._uniformBuffer;x.updateMatrix("world",a),x.updateFloat("visibility",this._internalAbstractMeshDataInfo._visibility),x.update()}getMeshUniformBuffer(){return this._uniformBuffer}getClassName(){return"AbstractMesh"}toString(a){let x="Name: "+this.name+", isInstance: "+(this.getClassName()!=="InstancedMesh"?"YES":"NO");x+=", # of submeshes: "+(this.subMeshes?this.subMeshes.length:0);const c=this._internalAbstractMeshDataInfo._skeleton;return c&&(x+=", skeleton: "+c.name),a&&(x+=", billboard mode: "+["NONE","X","Y",null,"Z",null,null,"ALL"][this.billboardMode],x+=", freeze wrld mat: "+(this._isWorldMatrixFrozen||this._waitingData.freezeWorldMatrix?"YES":"NO")),x}_getEffectiveParent(){return this._masterMesh&&this.billboardMode!==$s.BILLBOARDMODE_NONE?this._masterMesh:super._getEffectiveParent()}_getActionManagerForTrigger(a,x=!0){if(this.actionManager&&(x||this.actionManager.isRecursive))if(a){if(this.actionManager.hasSpecificTrigger(a))return this.actionManager}else return this.actionManager;return this.parent?this.parent._getActionManagerForTrigger(a,!1):null}_rebuild(a=!1){if(this.onRebuildObservable.notifyObservers(this),this._occlusionQuery!==null&&(this._occlusionQuery=null),!!this.subMeshes){for(const x of this.subMeshes)x._rebuild();this.resetDrawCache()}}_resyncLightSources(){this._lightSources.length=0;for(const a of this.getScene().lights)a.isEnabled()&&a.canAffectMesh(this)&&this._lightSources.push(a);this._markSubMeshesAsLightDirty()}_resyncLightSource(a){const x=a.isEnabled()&&a.canAffectMesh(this),c=this._lightSources.indexOf(a);let u=!1;if(c===-1){if(!x)return;this._lightSources.push(a)}else{if(x)return;u=!0,this._lightSources.splice(c,1)}this._markSubMeshesAsLightDirty(u)}_unBindEffect(){for(const a of this.subMeshes)a.setEffect(null)}_removeLightSource(a,x){const c=this._lightSources.indexOf(a);c!==-1&&(this._lightSources.splice(c,1),this._markSubMeshesAsLightDirty(x))}_markSubMeshesAsDirty(a){if(this.subMeshes)for(const x of this.subMeshes)for(let c=0;c<x._drawWrappers.length;++c){const u=x._drawWrappers[c];!u||!u.defines||!u.defines.markAllAsDirty||a(u.defines)}}_markSubMeshesAsLightDirty(a=!1){this._markSubMeshesAsDirty(x=>x.markAsLightDirty(a))}_markSubMeshesAsAttributesDirty(){this._markSubMeshesAsDirty(a=>a.markAsAttributesDirty())}_markSubMeshesAsMiscDirty(){this._markSubMeshesAsDirty(a=>a.markAsMiscDirty())}markAsDirty(a){return this._currentRenderId=Number.MAX_VALUE,this._isDirty=!0,this}resetDrawCache(a){if(this.subMeshes)for(const x of this.subMeshes)x.resetDrawCache(a)}get isBlocked(){return!1}getLOD(a){return this}getTotalVertices(){return 0}getTotalIndices(){return 0}getIndices(){return null}getVerticesData(a){return null}setVerticesData(a,x,c,u){return this}updateVerticesData(a,x,c,u){return this}setIndices(a,x){return this}isVerticesDataPresent(a){return!1}getBoundingInfo(){return this._masterMesh?this._masterMesh.getBoundingInfo():(this._boundingInfoIsDirty&&(this._boundingInfoIsDirty=!1,this._updateBoundingInfo()),this._boundingInfo)}getRawBoundingInfo(){return this.rawBoundingInfo??this.getBoundingInfo()}setBoundingInfo(a){return this._boundingInfo=a,this}get hasBoundingInfo(){return this._boundingInfo!==null}buildBoundingInfo(a,x,c){return this._boundingInfo=new tx(a,x,c),this._boundingInfo}normalizeToUnitCube(a=!0,x=!1,c){return super.normalizeToUnitCube(a,x,c)}get useBones(){return this.skeleton&&this.getScene().skeletonsEnabled&&this.isVerticesDataPresent(Ve.MatricesIndicesKind)&&this.isVerticesDataPresent(Ve.MatricesWeightsKind)}_preActivate(){}_preActivateForIntermediateRendering(a){}_activate(a,x){return this._renderId=a,!0}_postActivate(){}_freeze(){}_unFreeze(){}getWorldMatrix(){return this._masterMesh&&this.billboardMode===$s.BILLBOARDMODE_NONE?this._masterMesh.getWorldMatrix():super.getWorldMatrix()}_getWorldMatrixDeterminant(){return this._masterMesh?this._masterMesh._getWorldMatrixDeterminant():super._getWorldMatrixDeterminant()}get isAnInstance(){return!1}get hasInstances(){return!1}get hasThinInstances(){return!1}movePOV(a,x,c){return this.position.addInPlace(this.calcMovePOV(a,x,c)),this}calcMovePOV(a,x,c){const u=new vt;(this.rotationQuaternion?this.rotationQuaternion:Wi.RotationYawPitchRoll(this.rotation.y,this.rotation.x,this.rotation.z)).toRotationMatrix(u);const y=Ee.Zero(),v=this.definedFacingForward?-1:1;return Ee.TransformCoordinatesFromFloatsToRef(a*v,x,c*v,u,y),y}rotatePOV(a,x,c){return this.rotation.addInPlace(this.calcRotatePOV(a,x,c)),this}calcRotatePOV(a,x,c){const u=this.definedFacingForward?1:-1;return new Ee(a*u,x,c*u)}refreshBoundingInfo(a=!1,x=!1){return this._boundingInfo&&this._boundingInfo.isLocked?this:(this._refreshBoundingInfo(this._getPositionData(a,x),null),this)}_refreshBoundingInfo(a,x){if(a){const c=VT(a,0,this.getTotalVertices(),x);this._boundingInfo?this._boundingInfo.reConstruct(c.minimum,c.maximum):this._boundingInfo=new tx(c.minimum,c.maximum)}if(this.subMeshes)for(let c=0;c<this.subMeshes.length;c++)this.subMeshes[c].refreshBoundingInfo(a);this._updateBoundingInfo()}_getData(a=!1,x=!1,c,u=Ve.PositionKind){if(c=c??this.getVerticesData(u).slice(),c&&x&&this.morphTargetManager){let g=0,y=0;for(let v=0;v<c.length;v++){let w=c[v];for(let B=0;B<this.morphTargetManager.numTargets;B++){const W=this.morphTargetManager.getTarget(B),ae=W.influence;if(ae!==0){let ue=null;switch(u){case Ve.PositionKind:ue=W.getPositions();break;case Ve.NormalKind:ue=W.getNormals();break;case Ve.TangentKind:ue=W.getTangents();break;case Ve.UVKind:ue=W.getUVs();break}ue&&(w+=(ue[v]-c[v])*ae)}}if(c[v]=w,g++,u===Ve.PositionKind&&this._positions&&g===3){g=0;const B=y*3;this._positions[y++].copyFromFloats(c[B],c[B+1],c[B+2])}}}if(c&&a&&this.skeleton){const g=this.getVerticesData(Ve.MatricesIndicesKind),y=this.getVerticesData(Ve.MatricesWeightsKind);if(y&&g){const v=this.numBoneInfluencers>4,w=v?this.getVerticesData(Ve.MatricesIndicesExtraKind):null,B=v?this.getVerticesData(Ve.MatricesWeightsExtraKind):null,W=this.skeleton.getTransformMatrices(this),ae=Yt.Vector3[0],ue=Yt.Matrix[0],fe=Yt.Matrix[1];let Re=0;for(let _e=0;_e<c.length;_e+=3,Re+=4){ue.reset();let Be,tt;for(Be=0;Be<4;Be++)tt=y[Re+Be],tt>0&&(vt.FromFloat32ArrayToRefScaled(W,Math.floor(g[Re+Be]*16),tt,fe),ue.addToSelf(fe));if(v)for(Be=0;Be<4;Be++)tt=B[Re+Be],tt>0&&(vt.FromFloat32ArrayToRefScaled(W,Math.floor(w[Re+Be]*16),tt,fe),ue.addToSelf(fe));u===Ve.NormalKind?Ee.TransformNormalFromFloatsToRef(c[_e],c[_e+1],c[_e+2],ue,ae):Ee.TransformCoordinatesFromFloatsToRef(c[_e],c[_e+1],c[_e+2],ue,ae),ae.toArray(c,_e),u===Ve.PositionKind&&this._positions&&this._positions[_e/3].copyFrom(ae)}}}return c}getNormalsData(a=!1,x=!1){return this._getData(a,x,null,Ve.NormalKind)}getPositionData(a=!1,x=!1,c){return this._getData(a,x,c,Ve.PositionKind)}_getPositionData(a,x){let c=this.getVerticesData(Ve.PositionKind);if(this._internalAbstractMeshDataInfo._positions&&(this._internalAbstractMeshDataInfo._positions=null),c&&(a&&this.skeleton||x&&this.morphTargetManager)){if(c=c.slice(),this._generatePointsArray(),this._positions){const u=this._positions;this._internalAbstractMeshDataInfo._positions=new Array(u.length);for(let g=0;g<u.length;g++)this._internalAbstractMeshDataInfo._positions[g]=u[g]?.clone()||new Ee}return this.getPositionData(a,x,c)}return c}_updateBoundingInfo(){return this._boundingInfo?this._boundingInfo.update(this.worldMatrixFromCache):this._boundingInfo=new tx(Ee.Zero(),Ee.Zero(),this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}_updateSubMeshesBoundingInfo(a){if(!this.subMeshes)return this;const x=this.subMeshes.length;for(let c=0;c<x;c++){const u=this.subMeshes[c];(x>1||!u.IsGlobal)&&u.updateBoundingInfo(a)}return this}_afterComputeWorldMatrix(){this.doNotSyncBoundingInfo||(this._boundingInfoIsDirty=!0)}isInFrustum(a){return this.getBoundingInfo().isInFrustum(a,this.cullingStrategy)}isCompletelyInFrustum(a){return this.getBoundingInfo().isCompletelyInFrustum(a)}intersectsMesh(a,x=!1,c){const u=this.getBoundingInfo(),g=a.getBoundingInfo();if(u.intersects(g,x))return!0;if(c){for(const y of this.getChildMeshes())if(y.intersectsMesh(a,x,!0))return!0}return!1}intersectsPoint(a){return this.getBoundingInfo().intersectsPoint(a)}get checkCollisions(){return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions}set checkCollisions(a){this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions=a}get collider(){return this._internalAbstractMeshDataInfo._meshCollisionData._collider}moveWithCollisions(a){this.getAbsolutePosition().addToRef(this.ellipsoidOffset,this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);const c=this.getScene().collisionCoordinator;return this._internalAbstractMeshDataInfo._meshCollisionData._collider||(this._internalAbstractMeshDataInfo._meshCollisionData._collider=c.createCollider()),this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius=this.ellipsoid,c.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions,a,this._internalAbstractMeshDataInfo._meshCollisionData._collider,this.collisionRetryCount,this,this._onCollisionPositionChange,this.uniqueId),this}_collideForSubMesh(a,x,c){if(this._generatePointsArray(),!this._positions)return this;if(!a._lastColliderWorldVertices||!a._lastColliderTransformMatrix.equals(x)){a._lastColliderTransformMatrix=x.clone(),a._lastColliderWorldVertices=[],a._trianglePlanes=[];const u=a.verticesStart,g=a.verticesStart+a.verticesCount;for(let y=u;y<g;y++)a._lastColliderWorldVertices.push(Ee.TransformCoordinates(this._positions[y],x))}return c._collide(a._trianglePlanes,a._lastColliderWorldVertices,this.getIndices(),a.indexStart,a.indexStart+a.indexCount,a.verticesStart,!!a.getMaterial(),this,this._shouldConvertRHS(),a.getMaterial()?.fillMode===7),this}_processCollisionsForSubMeshes(a,x){const c=this._scene.getCollidingSubMeshCandidates(this,a),u=c.length;for(let g=0;g<u;g++){const y=c.data[g];u>1&&!y._checkCollision(a)||this._collideForSubMesh(y,x,a)}return this}_shouldConvertRHS(){return!1}_checkCollision(a){if(!this.getBoundingInfo()._checkCollision(a))return this;const x=Yt.Matrix[0],c=Yt.Matrix[1];return vt.ScalingToRef(1/a._radius.x,1/a._radius.y,1/a._radius.z,x),this.worldMatrixFromCache.multiplyToRef(x,c),this._processCollisionsForSubMeshes(a,c),this}_generatePointsArray(){return!1}intersects(a,x,c,u=!1,g,y=!1){const v=new am,w=this.getClassName(),B=w==="InstancedLinesMesh"||w==="LinesMesh"||w==="GreasedLineMesh"?this.intersectionThreshold:0,W=this.getBoundingInfo();if(!this.subMeshes||!y&&(!a.intersectsSphere(W.boundingSphere,B)||!a.intersectsBox(W.boundingBox,B)))return v;if(u)return v.hit=!y,v.pickedMesh=y?null:this,v.distance=y?0:Ee.Distance(a.origin,W.boundingSphere.center),v.subMeshId=0,v;if(!this._generatePointsArray())return v;let ae=null;const ue=this._scene.getIntersectingSubMeshCandidates(this,a),fe=ue.length;let Re=!1;for(let _e=0;_e<fe;_e++){const tt=ue.data[_e].getMaterial();if(tt&&(tt.fillMode==7||tt.fillMode==0||tt.fillMode==1||tt.fillMode==2||tt.fillMode==4)){Re=!0;break}}if(!Re)return v.hit=!0,v.pickedMesh=this,v.distance=Ee.Distance(a.origin,W.boundingSphere.center),v.subMeshId=-1,v;for(let _e=0;_e<fe;_e++){const Be=ue.data[_e];if(fe>1&&!y&&!Be.canIntersects(a))continue;const tt=Be.intersects(a,this._positions,this.getIndices(),x,c);if(tt&&(x||!ae||tt.distance<ae.distance)&&(ae=tt,ae.subMeshId=_e,x))break}if(ae){const _e=g??this.getWorldMatrix(),Be=Yt.Vector3[0],tt=Yt.Vector3[1];Ee.TransformCoordinatesToRef(a.origin,_e,Be),a.direction.scaleToRef(ae.distance,tt);const Et=Ee.TransformNormal(tt,_e).addInPlace(Be);return v.hit=!0,v.distance=Ee.Distance(Be,Et),v.pickedPoint=Et,v.pickedMesh=this,v.bu=ae.bu||0,v.bv=ae.bv||0,v.subMeshFaceId=ae.faceId,v.faceId=ae.faceId+ue.data[ae.subMeshId].indexStart/(this.getClassName().indexOf("LinesMesh")!==-1?2:3),v.subMeshId=ae.subMeshId,v}return v}clone(a,x,c){return null}releaseSubMeshes(){if(this.subMeshes)for(;this.subMeshes.length;)this.subMeshes[0].dispose();else this.subMeshes=[];return this}dispose(a,x=!1){let c;const u=this.getScene();for(this._scene.useMaterialMeshMap&&this._internalAbstractMeshDataInfo._material&&this._internalAbstractMeshDataInfo._material.meshMap&&(this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId]=void 0),u.freeActiveMeshes(),u.freeRenderingGroups(),u.renderingManager.maintainStateBetweenFrames&&u.renderingManager.restoreDispachedFlags(),this.actionManager!==void 0&&this.actionManager!==null&&(this._scene.meshes.some(v=>v!==this&&v.actionManager===this.actionManager)||this.actionManager.dispose(),this.actionManager=null),this._internalAbstractMeshDataInfo._skeleton=null,this._transformMatrixTexture&&(this._transformMatrixTexture.dispose(),this._transformMatrixTexture=null),c=0;c<this._intersectionsInProgress.length;c++){const v=this._intersectionsInProgress[c],w=v._intersectionsInProgress.indexOf(this);v._intersectionsInProgress.splice(w,1)}this._intersectionsInProgress.length=0,u.lights.forEach(v=>{let w=v.includedOnlyMeshes.indexOf(this);w!==-1&&v.includedOnlyMeshes.splice(w,1),w=v.excludedMeshes.indexOf(this),w!==-1&&v.excludedMeshes.splice(w,1);const B=v.getShadowGenerators();if(B){const W=B.values();for(let ae=W.next();ae.done!==!0;ae=W.next()){const fe=ae.value.getShadowMap();fe&&fe.renderList&&(w=fe.renderList.indexOf(this),w!==-1&&fe.renderList.splice(w,1))}}}),(this.getClassName()!=="InstancedMesh"||this.getClassName()!=="InstancedLinesMesh")&&this.releaseSubMeshes();const y=u.getEngine();if(this._occlusionQuery!==null&&(this.isOcclusionQueryInProgress=!1,y.deleteQuery(this._occlusionQuery),this._occlusionQuery=null),y.wipeCaches(),u.removeMesh(this),this._parentContainer){const v=this._parentContainer.meshes.indexOf(this);v>-1&&this._parentContainer.meshes.splice(v,1),this._parentContainer=null}if(x&&this.material&&(this.material.getClassName()==="MultiMaterial"?this.material.dispose(!1,!0,!0):this.material.dispose(!1,!0)),!a)for(c=0;c<u.particleSystems.length;c++)u.particleSystems[c].emitter===this&&(u.particleSystems[c].dispose(),c--);this._internalAbstractMeshDataInfo._facetData.facetDataEnabled&&this.disableFacetData(),this._uniformBuffer.dispose(),this.onAfterWorldMatrixUpdateObservable.clear(),this.onCollideObservable.clear(),this.onCollisionPositionChangeObservable.clear(),this.onRebuildObservable.clear(),super.dispose(a,x)}addChild(a,x=!1){return a.setParent(this,x),this}removeChild(a,x=!1){return a.setParent(null,x),this}_initFacetData(){const a=this._internalAbstractMeshDataInfo._facetData;a.facetNormals||(a.facetNormals=[]),a.facetPositions||(a.facetPositions=[]),a.facetPartitioning||(a.facetPartitioning=new Array),a.facetNb=this.getIndices().length/3|0,a.partitioningSubdivisions=a.partitioningSubdivisions?a.partitioningSubdivisions:10,a.partitioningBBoxRatio=a.partitioningBBoxRatio?a.partitioningBBoxRatio:1.01;for(let x=0;x<a.facetNb;x++)a.facetNormals[x]=Ee.Zero(),a.facetPositions[x]=Ee.Zero();return a.facetDataEnabled=!0,this}updateFacetData(){const a=this._internalAbstractMeshDataInfo._facetData;a.facetDataEnabled||this._initFacetData();const x=this.getVerticesData(Ve.PositionKind),c=this.getIndices(),u=this.getVerticesData(Ve.NormalKind),g=this.getBoundingInfo();if(a.facetDepthSort&&!a.facetDepthSortEnabled){if(a.facetDepthSortEnabled=!0,c instanceof Uint16Array)a.depthSortedIndices=new Uint16Array(c);else if(c instanceof Uint32Array)a.depthSortedIndices=new Uint32Array(c);else{let v=!1;for(let w=0;w<c.length;w++)if(c[w]>65535){v=!0;break}v?a.depthSortedIndices=new Uint32Array(c):a.depthSortedIndices=new Uint16Array(c)}if(a.facetDepthSortFunction=function(v,w){return w.sqDistance-v.sqDistance},!a.facetDepthSortFrom){const v=this.getScene().activeCamera;a.facetDepthSortFrom=v?v.position:Ee.Zero()}a.depthSortedFacets=[];for(let v=0;v<a.facetNb;v++){const w={ind:v*3,sqDistance:0};a.depthSortedFacets.push(w)}a.invertedMatrix=vt.Identity(),a.facetDepthSortOrigin=Ee.Zero()}a.bbSize.x=g.maximum.x-g.minimum.x>Mi?g.maximum.x-g.minimum.x:Mi,a.bbSize.y=g.maximum.y-g.minimum.y>Mi?g.maximum.y-g.minimum.y:Mi,a.bbSize.z=g.maximum.z-g.minimum.z>Mi?g.maximum.z-g.minimum.z:Mi;let y=a.bbSize.x>a.bbSize.y?a.bbSize.x:a.bbSize.y;if(y=y>a.bbSize.z?y:a.bbSize.z,a.subDiv.max=a.partitioningSubdivisions,a.subDiv.X=Math.floor(a.subDiv.max*a.bbSize.x/y),a.subDiv.Y=Math.floor(a.subDiv.max*a.bbSize.y/y),a.subDiv.Z=Math.floor(a.subDiv.max*a.bbSize.z/y),a.subDiv.X=a.subDiv.X<1?1:a.subDiv.X,a.subDiv.Y=a.subDiv.Y<1?1:a.subDiv.Y,a.subDiv.Z=a.subDiv.Z<1?1:a.subDiv.Z,a.facetParameters.facetNormals=this.getFacetLocalNormals(),a.facetParameters.facetPositions=this.getFacetLocalPositions(),a.facetParameters.facetPartitioning=this.getFacetLocalPartitioning(),a.facetParameters.bInfo=g,a.facetParameters.bbSize=a.bbSize,a.facetParameters.subDiv=a.subDiv,a.facetParameters.ratio=this.partitioningBBoxRatio,a.facetParameters.depthSort=a.facetDepthSort,a.facetDepthSort&&a.facetDepthSortEnabled&&(this.computeWorldMatrix(!0),this._worldMatrix.invertToRef(a.invertedMatrix),Ee.TransformCoordinatesToRef(a.facetDepthSortFrom,a.invertedMatrix,a.facetDepthSortOrigin),a.facetParameters.distanceTo=a.facetDepthSortOrigin),a.facetParameters.depthSortedFacets=a.depthSortedFacets,u&&fr.ComputeNormals(x,c,u,a.facetParameters),a.facetDepthSort&&a.facetDepthSortEnabled){a.depthSortedFacets.sort(a.facetDepthSortFunction);const v=a.depthSortedIndices.length/3|0;for(let w=0;w<v;w++){const B=a.depthSortedFacets[w].ind;a.depthSortedIndices[w*3]=c[B],a.depthSortedIndices[w*3+1]=c[B+1],a.depthSortedIndices[w*3+2]=c[B+2]}this.updateIndices(a.depthSortedIndices,void 0,!0)}return this}getFacetLocalNormals(){const a=this._internalAbstractMeshDataInfo._facetData;return a.facetNormals||this.updateFacetData(),a.facetNormals}getFacetLocalPositions(){const a=this._internalAbstractMeshDataInfo._facetData;return a.facetPositions||this.updateFacetData(),a.facetPositions}getFacetLocalPartitioning(){const a=this._internalAbstractMeshDataInfo._facetData;return a.facetPartitioning||this.updateFacetData(),a.facetPartitioning}getFacetPosition(a){const x=Ee.Zero();return this.getFacetPositionToRef(a,x),x}getFacetPositionToRef(a,x){const c=this.getFacetLocalPositions()[a],u=this.getWorldMatrix();return Ee.TransformCoordinatesToRef(c,u,x),this}getFacetNormal(a){const x=Ee.Zero();return this.getFacetNormalToRef(a,x),x}getFacetNormalToRef(a,x){const c=this.getFacetLocalNormals()[a];return Ee.TransformNormalToRef(c,this.getWorldMatrix(),x),this}getFacetsAtLocalCoordinates(a,x,c){const u=this.getBoundingInfo(),g=this._internalAbstractMeshDataInfo._facetData,y=Math.floor((a-u.minimum.x*g.partitioningBBoxRatio)*g.subDiv.X*g.partitioningBBoxRatio/g.bbSize.x),v=Math.floor((x-u.minimum.y*g.partitioningBBoxRatio)*g.subDiv.Y*g.partitioningBBoxRatio/g.bbSize.y),w=Math.floor((c-u.minimum.z*g.partitioningBBoxRatio)*g.subDiv.Z*g.partitioningBBoxRatio/g.bbSize.z);return y<0||y>g.subDiv.max||v<0||v>g.subDiv.max||w<0||w>g.subDiv.max?null:g.facetPartitioning[y+g.subDiv.max*v+g.subDiv.max*g.subDiv.max*w]}getClosestFacetAtCoordinates(a,x,c,u,g=!1,y=!0){const v=this.getWorldMatrix(),w=Yt.Matrix[5];v.invertToRef(w);const B=Yt.Vector3[8];Ee.TransformCoordinatesFromFloatsToRef(a,x,c,w,B);const W=this.getClosestFacetAtLocalCoordinates(B.x,B.y,B.z,u,g,y);return u&&Ee.TransformCoordinatesFromFloatsToRef(u.x,u.y,u.z,v,u),W}getClosestFacetAtLocalCoordinates(a,x,c,u,g=!1,y=!0){let v=null,w=0,B=0,W=0,ae=0,ue=0,fe=0,Re=0,_e=0;const Be=this.getFacetLocalPositions(),tt=this.getFacetLocalNormals(),$e=this.getFacetsAtLocalCoordinates(a,x,c);if(!$e)return null;let Et=Number.MAX_VALUE,ft=Et,dt,ut,Mt;for(let ai=0;ai<$e.length;ai++)dt=$e[ai],ut=tt[dt],Mt=Be[dt],ae=(a-Mt.x)*ut.x+(x-Mt.y)*ut.y+(c-Mt.z)*ut.z,(!g||g&&y&&ae>=0||g&&!y&&ae<=0)&&(ae=ut.x*Mt.x+ut.y*Mt.y+ut.z*Mt.z,ue=-(ut.x*a+ut.y*x+ut.z*c-ae)/(ut.x*ut.x+ut.y*ut.y+ut.z*ut.z),fe=a+ut.x*ue,Re=x+ut.y*ue,_e=c+ut.z*ue,w=fe-a,B=Re-x,W=_e-c,ft=w*w+B*B+W*W,ft<Et&&(Et=ft,v=dt,u&&(u.x=fe,u.y=Re,u.z=_e)));return v}getFacetDataParameters(){return this._internalAbstractMeshDataInfo._facetData.facetParameters}disableFacetData(){const a=this._internalAbstractMeshDataInfo._facetData;return a.facetDataEnabled&&(a.facetDataEnabled=!1,a.facetPositions=[],a.facetNormals=[],a.facetPartitioning=new Array,a.facetParameters=null,a.depthSortedIndices=new Uint32Array(0)),this}updateIndices(a,x,c=!1){return this}createNormals(a){const x=this.getVerticesData(Ve.PositionKind),c=this.getIndices();let u;return this.isVerticesDataPresent(Ve.NormalKind)?u=this.getVerticesData(Ve.NormalKind):u=[],fr.ComputeNormals(x,c,u,{useRightHandedSystem:this.getScene().useRightHandedSystem}),this.setVerticesData(Ve.NormalKind,u,a),this}alignWithNormal(a,x){x||(x=Hh.Y);const c=Yt.Vector3[0],u=Yt.Vector3[1];return Ee.CrossToRef(x,a,u),Ee.CrossToRef(a,u,c),this.rotationQuaternion?Wi.RotationQuaternionFromAxisToRef(c,a,u,this.rotationQuaternion):Ee.RotationFromAxisToRef(c,a,u,this.rotation),this}_checkOcclusionQuery(){return!1}disableEdgesRendering(){throw js("EdgesRenderer")}enableEdgesRendering(a,x,c){throw js("EdgesRenderer")}getConnectedParticleSystems(){return this._scene.particleSystems.filter(a=>a.emitter===this)}}mo.OCCLUSION_TYPE_NONE=0,mo.OCCLUSION_TYPE_OPTIMISTIC=1,mo.OCCLUSION_TYPE_STRICT=2,mo.OCCLUSION_ALGORITHM_TYPE_ACCURATE=0,mo.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE=1,mo.CULLINGSTRATEGY_STANDARD=0,mo.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY=1,mo.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION=2,mo.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY=3,as("BABYLON.AbstractMesh",mo),Es.prototype.updateRawTexture=function(F,a,x,c,u=null,g=0,y=!1){if(!F)return;const v=this._getRGBABufferInternalSizedFormat(g,x,y),w=this._getInternalFormat(x),B=this._getWebGLTextureType(g);this._bindTextureDirectly(this._gl.TEXTURE_2D,F,!0),this._unpackFlipY(c===void 0?!0:!!c),this._doNotHandleContextLost||(F._bufferView=a,F.format=x,F.type=g,F.invertY=c,F._compression=u),F.width%4!==0&&this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,1),u&&a?this._gl.compressedTexImage2D(this._gl.TEXTURE_2D,0,this.getCaps().s3tc[u],F.width,F.height,0,a):this._gl.texImage2D(this._gl.TEXTURE_2D,0,v,F.width,F.height,0,w,B,a),F.generateMipMaps&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null),F.isReady=!0},Es.prototype.createRawTexture=function(F,a,x,c,u,g,y,v=null,w=0,B=0,W=!1){const ae=new a0(this,hn.Raw);ae.baseWidth=a,ae.baseHeight=x,ae.width=a,ae.height=x,ae.format=c,ae.generateMipMaps=u,ae.samplingMode=y,ae.invertY=g,ae._compression=v,ae.type=w,ae._useSRGBBuffer=this._getUseSRGBBuffer(W,!u),this._doNotHandleContextLost||(ae._bufferView=F),this.updateRawTexture(ae,F,c,g,v,w,ae._useSRGBBuffer),this._bindTextureDirectly(this._gl.TEXTURE_2D,ae,!0);const ue=this._getSamplingParameters(y,u);return this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MAG_FILTER,ue.mag),this._gl.texParameteri(this._gl.TEXTURE_2D,this._gl.TEXTURE_MIN_FILTER,ue.min),u&&this._gl.generateMipmap(this._gl.TEXTURE_2D),this._bindTextureDirectly(this._gl.TEXTURE_2D,null),this._internalTexturesCache.push(ae),ae},Es.prototype.createRawCubeTexture=function(F,a,x,c,u,g,y,v=null){const w=this._gl,B=new a0(this,hn.CubeRaw);B.isCube=!0,B.format=x,B.type=c,this._doNotHandleContextLost||(B._bufferViewArray=F);const W=this._getWebGLTextureType(c);let ae=this._getInternalFormat(x);ae===w.RGB&&(ae=w.RGBA),W===w.FLOAT&&!this._caps.textureFloatLinearFiltering?(u=!1,y=1,Qt.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):W===this._gl.HALF_FLOAT_OES&&!this._caps.textureHalfFloatLinearFiltering?(u=!1,y=1,Qt.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")):W===w.FLOAT&&!this._caps.textureFloatRender?(u=!1,Qt.Warn("Render to float textures is not supported. Mipmap generation forced to false.")):W===w.HALF_FLOAT&&!this._caps.colorBufferFloat&&(u=!1,Qt.Warn("Render to half float textures is not supported. Mipmap generation forced to false."));const ue=a,fe=ue;if(B.width=ue,B.height=fe,B.invertY=g,B._compression=v,!this.needPOTTextures||Je(B.width)&&Je(B.height)||(u=!1),F)this.updateRawCubeTexture(B,F,x,c,g,v);else{const Be=this._getRGBABufferInternalSizedFormat(c),tt=0;this._bindTextureDirectly(w.TEXTURE_CUBE_MAP,B,!0);for(let $e=0;$e<6;$e++)v?w.compressedTexImage2D(w.TEXTURE_CUBE_MAP_POSITIVE_X+$e,tt,this.getCaps().s3tc[v],B.width,B.height,0,void 0):w.texImage2D(w.TEXTURE_CUBE_MAP_POSITIVE_X+$e,tt,Be,B.width,B.height,0,ae,W,null);this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null)}this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,B,!0),F&&u&&this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);const _e=this._getSamplingParameters(y,u);return w.texParameteri(w.TEXTURE_CUBE_MAP,w.TEXTURE_MAG_FILTER,_e.mag),w.texParameteri(w.TEXTURE_CUBE_MAP,w.TEXTURE_MIN_FILTER,_e.min),w.texParameteri(w.TEXTURE_CUBE_MAP,w.TEXTURE_WRAP_S,w.CLAMP_TO_EDGE),w.texParameteri(w.TEXTURE_CUBE_MAP,w.TEXTURE_WRAP_T,w.CLAMP_TO_EDGE),this._bindTextureDirectly(w.TEXTURE_CUBE_MAP,null),B.generateMipMaps=u,B.samplingMode=y,B.isReady=!0,B},Es.prototype.updateRawCubeTexture=function(F,a,x,c,u,g=null,y=0){F._bufferViewArray=a,F.format=x,F.type=c,F.invertY=u,F._compression=g;const v=this._gl,w=this._getWebGLTextureType(c);let B=this._getInternalFormat(x);const W=this._getRGBABufferInternalSizedFormat(c);let ae=!1;B===v.RGB&&(B=v.RGBA,ae=!0),this._bindTextureDirectly(v.TEXTURE_CUBE_MAP,F,!0),this._unpackFlipY(u===void 0?!0:!!u),F.width%4!==0&&v.pixelStorei(v.UNPACK_ALIGNMENT,1);for(let fe=0;fe<6;fe++){let Re=a[fe];g?v.compressedTexImage2D(v.TEXTURE_CUBE_MAP_POSITIVE_X+fe,y,this.getCaps().s3tc[g],F.width,F.height,0,Re):(ae&&(Re=gE(Re,F.width,F.height,c)),v.texImage2D(v.TEXTURE_CUBE_MAP_POSITIVE_X+fe,y,W,F.width,F.height,0,B,w,Re))}(!this.needPOTTextures||Je(F.width)&&Je(F.height))&&F.generateMipMaps&&y===0&&this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP),this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP,null),F.isReady=!0},Es.prototype.createRawCubeTextureFromUrl=function(F,a,x,c,u,g,y,v,w=null,B=null,W=3,ae=!1){const ue=this._gl,fe=this.createRawCubeTexture(null,x,c,u,!g,ae,W,null);a?.addPendingData(fe),fe.url=F,fe.isReady=!1,this._internalTexturesCache.push(fe);const Re=(Be,tt)=>{a?.removePendingData(fe),B&&Be&&B(Be.status+" "+Be.statusText,tt)},_e=Be=>{const tt=fe.width,$e=y(Be);if($e){if(v){const Et=this._getWebGLTextureType(u);let ft=this._getInternalFormat(c);const dt=this._getRGBABufferInternalSizedFormat(u);let ut=!1;ft===ue.RGB&&(ft=ue.RGBA,ut=!0),this._bindTextureDirectly(ue.TEXTURE_CUBE_MAP,fe,!0),this._unpackFlipY(!1);const Mt=v($e);for(let ai=0;ai<Mt.length;ai++){const Yi=tt>>ai;for(let Vi=0;Vi<6;Vi++){let Js=Mt[ai][Vi];ut&&(Js=gE(Js,Yi,Yi,u)),ue.texImage2D(Vi,ai,dt,Yi,Yi,0,ft,Et,Js)}}this._bindTextureDirectly(ue.TEXTURE_CUBE_MAP,null)}else this.updateRawCubeTexture(fe,$e,c,u,ae);fe.isReady=!0,a?.removePendingData(fe),fe.onLoadedObservable.notifyObservers(fe),fe.onLoadedObservable.clear(),w&&w()}};return this._loadFile(F,Be=>{_e(Be)},void 0,a?.offlineProvider,!0,Re),fe};function gE(F,a,x,c){let u,g=1;c===1?u=new Float32Array(a*x*4):c===2?(u=new Uint16Array(a*x*4),g=15360):c===7?u=new Uint32Array(a*x*4):u=new Uint8Array(a*x*4);for(let y=0;y<a;y++)for(let v=0;v<x;v++){const w=(v*a+y)*3,B=(v*a+y)*4;u[B+0]=F[w+0],u[B+1]=F[w+1],u[B+2]=F[w+2],u[B+3]=g}return u}function _E(F){return function(a,x,c,u,g,y,v,w,B=null,W=0){const ae=F?this._gl.TEXTURE_3D:this._gl.TEXTURE_2D_ARRAY,ue=F?hn.Raw3D:hn.Raw2DArray,fe=new a0(this,ue);fe.baseWidth=x,fe.baseHeight=c,fe.baseDepth=u,fe.width=x,fe.height=c,fe.depth=u,fe.format=g,fe.type=W,fe.generateMipMaps=y,fe.samplingMode=w,F?fe.is3D=!0:fe.is2DArray=!0,this._doNotHandleContextLost||(fe._bufferView=a),F?this.updateRawTexture3D(fe,a,g,v,B,W):this.updateRawTexture2DArray(fe,a,g,v,B,W),this._bindTextureDirectly(ae,fe,!0);const Re=this._getSamplingParameters(w,y);return this._gl.texParameteri(ae,this._gl.TEXTURE_MAG_FILTER,Re.mag),this._gl.texParameteri(ae,this._gl.TEXTURE_MIN_FILTER,Re.min),y&&this._gl.generateMipmap(ae),this._bindTextureDirectly(ae,null),this._internalTexturesCache.push(fe),fe}}Es.prototype.createRawTexture2DArray=_E(!1),Es.prototype.createRawTexture3D=_E(!0);function yE(F){return function(a,x,c,u,g=null,y=0){const v=F?this._gl.TEXTURE_3D:this._gl.TEXTURE_2D_ARRAY,w=this._getWebGLTextureType(y),B=this._getInternalFormat(c),W=this._getRGBABufferInternalSizedFormat(y,c);this._bindTextureDirectly(v,a,!0),this._unpackFlipY(u===void 0?!0:!!u),this._doNotHandleContextLost||(a._bufferView=x,a.format=c,a.invertY=u,a._compression=g),a.width%4!==0&&this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT,1),g&&x?this._gl.compressedTexImage3D(v,0,this.getCaps().s3tc[g],a.width,a.height,a.depth,0,x):this._gl.texImage3D(v,0,W,a.width,a.height,a.depth,0,B,w,x),a.generateMipMaps&&this._gl.generateMipmap(v),this._bindTextureDirectly(v,null),a.isReady=!0}}Es.prototype.updateRawTexture2DArray=yE(!1),Es.prototype.updateRawTexture3D=yE(!0);class Vx extends fi{constructor(a,x,c,u,g,y=!0,v=!1,w=3,B=0,W,ae){super(null,g,!y,v,void 0,void 0,void 0,void 0,void 0,void 0,void 0,void 0,W),this.format=u,this._engine&&(!this._engine._caps.textureFloatLinearFiltering&&B===1&&(w=1),!this._engine._caps.textureHalfFloatLinearFiltering&&B===2&&(w=1),this._texture=this._engine.createRawTexture(a,x,c,u,y,v,w,null,B,W??0,ae??!1),this.wrapU=fi.CLAMP_ADDRESSMODE,this.wrapV=fi.CLAMP_ADDRESSMODE)}update(a){this._getEngine().updateRawTexture(this._texture,a,this._texture.format,this._texture.invertY,null,this._texture.type,this._texture._useSRGBBuffer)}static CreateLuminanceTexture(a,x,c,u,g=!0,y=!1,v=3){return new Vx(a,x,c,1,u,g,y,v)}static CreateLuminanceAlphaTexture(a,x,c,u,g=!0,y=!1,v=3){return new Vx(a,x,c,2,u,g,y,v)}static CreateAlphaTexture(a,x,c,u,g=!0,y=!1,v=3){return new Vx(a,x,c,0,u,g,y,v)}static CreateRGBTexture(a,x,c,u,g=!0,y=!1,v=3,w=0,B=0,W=!1){return new Vx(a,x,c,4,u,g,y,v,w,B,W)}static CreateRGBATexture(a,x,c,u,g=!0,y=!1,v=3,w=0,B=0,W=!1){return new Vx(a,x,c,5,u,g,y,v,w,B,W)}static CreateRGBAStorageTexture(a,x,c,u,g=!0,y=!1,v=3,w=0,B=!1){return new Vx(a,x,c,5,u,g,y,v,w,1,B)}static CreateRTexture(a,x,c,u,g=!0,y=!1,v=fi.TRILINEAR_SAMPLINGMODE,w=1){return new Vx(a,x,c,6,u,g,y,v,w)}static CreateRStorageTexture(a,x,c,u,g=!0,y=!1,v=fi.TRILINEAR_SAMPLINGMODE,w=1){return new Vx(a,x,c,6,u,g,y,v,w,1)}}class WB extends li{constructor(a,x,c){super({container:a,mode:x,layerCount:2,mirror:c});const u=this.canvas.layers[1];this.renderer=new Bt(u,!0,{alpha:!0,preserveDrawingBuffer:!0},!0);const g=window.devicePixelRatio;this.renderer.setSize(u.clientWidth*g,u.clientHeight*g),this.canvas.on("resize",()=>{this.renderer.setSize(u.clientWidth*g,u.clientHeight*g)}),this.scene=new H0(this.renderer),this.scene.useRightHandedSystem=!0,this.scene.clearColor=new Yr(0,0,0,0),this.camera=new hg("camera",new Ee(0,0,0),this.scene),this.camera.rotationQuaternion=new Wi(1,0,0,0),this.camera.fov=this.cameraAngle,this.camera.minZ=.02,this.camera.maxZ=20}updateScene(){var a;(a=this.scene)==null||a.render()}dispose(){var a;this.renderer.dispose(),this.camera.dispose(),(a=this.scene)==null||a.dispose(),super.dispose()}setupCamera(a,x){super.setupCamera(a,x),this.camera.fov=this.cameraAngle,this.camera.getProjectionMatrix(!0)}}class Xc extends xn{}class bE extends Xc{}class HB extends null{}class T_ extends li{constructor(a,x,c){super({container:a,mode:x,layerCount:1,mirror:c});const u=this.canvas.layers[0];this.renderer=new Bt(u,!0,{alpha:!0,preserveDrawingBuffer:!0},!0);const g=window.devicePixelRatio;this.renderer.setSize(u.clientWidth*g,u.clientHeight*g),this.canvas.on("resize",()=>{this.renderer.setSize(u.clientWidth*g,u.clientHeight*g)}),this.scene=new H0(this.renderer),this.scene.useRightHandedSystem=!0,this.scene.clearColor=new Yr(0,0,0,0),this.camera=new hg("camera",new Ee(0,0,0),this.scene),this.camera.rotationQuaternion=new Wi(1,0,0,0),this.camera.fov=this.cameraAngle,this.camera.minZ=.02,this.camera.maxZ=20,this.layer=new YO("video",null,this.scene,!0)}updateVideo(a){const{shader:x,shaderCtx:c}=this;if(!(!this.current||!x||!c))return x.process([this.current],{flip:[1]}),Ut.prototype.updateVideo.call(this,a)}updateScene(){var a;(a=this.scene)==null||a.render()}dispose(){var a,x,c,u,g;(c=(x=(a=this.layer.texture)==null?void 0:a.getInternalTexture())==null?void 0:x._hardwareTexture)==null||c.reset(),(u=this.layer.texture)==null||u.dispose(),this.layer.dispose(),this.camera.dispose(),(g=this.scene)==null||g.dispose(),this.renderer.dispose(),super.dispose()}setupVideo(a,x){var c,u,g,y;Ut.prototype.setupVideo.call(this,a,x);const{input:v,shader:w,videoSize:B}=this;(g=(u=(c=this.layer.texture)==null?void 0:c.getInternalTexture())==null?void 0:u._hardwareTexture)==null||g.reset(),(y=this.layer.texture)==null||y.dispose(),this.layer.texture=null,v?.resize(B),w?.resize(B);const W=w?.output();W&&(this.layer.texture=new Un(this.scene,this.renderer.wrapWebGLTexture(W)))}setupCamera(a,x){var c;super.setupCamera(a,x),this.camera.fov=this.cameraAngle,(c=this.scene)==null||c.updateTransformMatrix()}}class ID extends T_{}class XB extends null{}class jB extends null{}class YB extends null{}class $B extends Xc{constructor(a,x=!1){super(),this.node=a,this.shapeScale=x}async update(a,x){if(!this.loaded||!this.node)return;const c=a.faces.length>0&&a.faces[0].transform;if(!c)return this.node.setEnabled(!1),super.update(a,x);const u=Ee.FromArray(c.translation),g=new Ee().setAll(c.scale),y=Ee.FromArray(c.shapeScale).scale(c.scale),v=Wi.FromArray(c.rotation);return this.node.setEnabled(!0),this.node.rotationQuaternion=v,this.node.position=u,this.node.scaling=this.shapeScale?y:g,super.update(a,x)}setNode(a){this.node=a}}class JB extends Xc{constructor(a,x=0,c=!1){super(),this.node=a,this.facePoint=x,this.shapeScale=c}async update(a,x){if(!this.loaded||!this.node)return;const{transform:c=void 0,metric:u=void 0}=a.faces.length>0?a.faces[0]:{};if(!c||!u)return this.node.setEnabled(!1),super.update(a,x);const g=Ee.FromArray(u[this.facePoint]),y=new Ee().setAll(c.scale),v=Ee.FromArray(c.shapeScale).scale(c.scale),w=Wi.FromArray(c.rotation);return this.node.setEnabled(!0),this.node.rotationQuaternion=w,this.node.position=g,this.node.scaling=this.shapeScale?v:y,super.update(a,x)}setNode(a){this.node=a}}class tU extends Xc{constructor(a){super(),this.mesh=a,this.pointCont=m.nj.length}async load(a){this.loaded||(await super.load(a),await this.setMesh(this.mesh))}async update(a,x){if(!this.loaded||!this.mesh)return;const c=a.faces.length>0&&a.faces[0].metric;return c?(this.mesh.setEnabled(!0),this.mesh.updateVerticesData(Ve.PositionKind,c.slice(0,this.pointCont).flat()),super.update(a,x)):(this.mesh.setEnabled(!1),super.update(a,x))}async setMesh(a){if(delete this.mesh,this.mesh=a,!(!this.loaded||!a)){var x=new fr;x.positions=m.nj.flat(),x.indices=m.$v.flat(),x.uvs=m.rw.flat(),x.normals=[],fr.ComputeNormals(x.positions,x.indices,x.normals),x.applyToMesh(a,!0),a.renderingGroupId=1}}}var RD=Object.defineProperty,MD=Object.defineProperties,BD=Object.getOwnPropertyDescriptors,EE=Object.getOwnPropertySymbols,UD=Object.prototype.hasOwnProperty,VD=Object.prototype.propertyIsEnumerable,vE=(F,a,x)=>a in F?RD(F,a,{enumerable:!0,configurable:!0,writable:!0,value:x}):F[a]=x,IE=(F,a)=>{for(var x in a||(a={}))UD.call(a,x)&&vE(F,x,a[x]);if(EE)for(var x of EE(a))VD.call(a,x)&&vE(F,x,a[x]);return F},RE=(F,a)=>MD(F,BD(a));const ME=["root","pelvis","spine","spine1","spine2","spine3","neck","neck1","head","headEnd","shoulderL","shoulderR","armL","armR","armMidL","armMidR","forearmL","forearmR","forearmMidL","forearmMidR","handL","handR","uplegL","uplegR","uplegMidL","uplegMidR","legL","legR","footL","footR"],hm=(F,a)=>ur(F,a),WD=F=>hm(F,ME),b_=["root","pelvis","pelvisEnd","spine","spine1","spine2","spine3","neck"],HD=["hipL","hipR","shoulderL","shoulderR","elbowL","elbowR"];class XD extends bE{constructor(a,x={spineCurve:1,pelvisDZ:.01}){super(),this.node=a,this.tune=x,this.nodeOrigin={position:new Ee(0,0,-1),rotation:new Wi},this.cameraRatio=1920/1080,this.cameraAngle=10/180*Math.PI,this.alignScore=.9,this.alignVisibility=.9}async load(a){this.loaded||(await super.load(a),this.setNode(this.node))}unload(){this.loaded&&(delete this.node,delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,super.unload())}setNode(a){var x,c;if(delete this.skeletonNodes,delete this.skeleton,delete this.skeletonSizes,delete this.spineCurve,this.node=a,!this.loaded||!a)return;this.skeleton=((x=a.getChildMeshes(!1).find(Yi=>Yi.skeleton))==null?void 0:x.skeleton)||void 0;const u=(c=this.skeleton)==null?void 0:c.bones;if(!u)return;const g={root:"joint",pelvis:"pelvis",spine:"spine",spine1:"spine1",spine2:"spine2",spine3:"spine3",neck:"neck",neck1:"neck1",head:"head",headEnd:"head_tip",shoulderL:"left_shoulder",shoulderR:"right_shoulder",armL:"left_arm",armR:"right_arm",armMidL:"left_arm_middle",armMidR:"right_arm_middle",forearmL:"left_forearm",forearmR:"right_forearm",forearmMidL:"left_forearm_middie",forearmMidR:"right_forearm_middie",handL:"left_hand",handR:"right_hand",uplegL:"left_thigh",uplegR:"right_thigh",uplegMidL:"left_thigh1",uplegMidR:"right_thigh1",legL:"left_shin",legR:"right_shin",footL:"left_ankle",footR:"right_ankle"},y=WD(Yi=>{var Vi;return(Vi=u.find(Js=>Js.name.toLowerCase().endsWith(g[Yi])))==null?void 0:Vi.getTransformNode()});function v(Yi){return ME.every(Vi=>Yi[Vi])}if(!v(y))return;this.skeletonNodes=y;const w=hm(Yi=>y[Yi].absolutePosition,["shoulderL","shoulderR","neck","neck1","head","armL","armR","armMidL","forearmL","forearmMidL","handL","uplegL","uplegR","uplegMidL","legL","footL"]),B=Ee.Lerp(w.uplegL,w.uplegR,.5),W=Ee.Lerp(w.shoulderL,w.shoulderR,.5),ae=W.subtract(B).length(),ue=w.forearmL.subtract(w.armL).length(),fe=w.handL.subtract(w.forearmL).length(),Re=w.legL.subtract(w.uplegL).length(),_e=w.footL.subtract(w.legL).length();this.skeletonSizes={spineLen:ae,hipsWidth:w.uplegL.subtract(w.uplegR).length(),shoulderWidth:w.armL.subtract(w.armR).length(),shoulderRatio:w.shoulderL.subtract(W).length()/w.armL.subtract(W).length(),neckRatio:w.neck1.subtract(w.neck).length()/w.head.subtract(w.neck).length(),armLen:ue,armRatio:w.armMidL.subtract(w.armL).length()/ue,forearmLen:fe,forearmRatio:w.forearmMidL.subtract(w.forearmL).length()/fe,uplegLen:Re,uplegRatio:w.uplegMidL.subtract(w.uplegL).length()/Re,legLen:_e};const Be=Ee.Cross(w.shoulderL.subtract(B),w.shoulderR.subtract(B)).normalize(),tt=y.pelvis.absolutePosition.subtract(B).length(),$e=RE(IE({},hm(Yi=>y[Yi].absolutePosition,["root","spine","spine1","spine2","spine3","neck","pelvis"])),{pelvisEnd:y.pelvis.absolutePosition.add(new Ee(0,tt,0).applyRotationQuaternion(y.pelvis.absoluteRotationQuaternion))});this.spineCurve=ur(Yi=>{const Vi=$e[Yi].subtract(B),Js=Ee.Dot(Vi,Be);return[Vi.subtract(Be.scale(Js)).length()/ae,Js/ae]},b_),this.nodeOrigin={position:a.absolutePosition.subtract(y.root.absolutePosition).applyRotationQuaternion(y.root.absoluteRotationQuaternion.conjugate()),rotation:a.absoluteRotationQuaternion.multiply(y.root.absoluteRotationQuaternion.conjugate())};let{min:Et,max:ft}=a.getHierarchyBoundingVectors();const dt=Et.add(ft).scale(.5),ut=ft.subtract(Et),Mt=Math.max(ut.x,ut.y,ut.z)*1.1*.5,ai=new Ee(Mt,Mt,Mt);Et=dt.subtract(ai),ft=dt.add(ai),a.getChildMeshes(!1).forEach(Yi=>Yi.buildBoundingInfo(Et,ft))}async update(a,x){var c;if(!this.loaded||!this.node)return;const u=a.poses.length>0&&a.poses[0].points,{node:g,skeletonNodes:y,skeletonSizes:v,spineCurve:w}=this;if(!y||!v||!w||!u)return g.setEnabled(!1),super.update(a,x);const B=Ur.map(_e=>u[_e]),W=B.map(_e=>_e.norm);this.equalize(W);for(let _e=0;_e<4;_e++)this.align(B);const ae=this.estimateBones(u,w,v),ue={position:ae.root.position.add(this.nodeOrigin.position.applyRotationQuaternion(ae.root.rotation)),rotation:ae.root.rotation.multiply(this.nodeOrigin.rotation)};(c=this.skeleton)==null||c.returnToRest(),this.alignBone(ue,g,!1),this.updateSpine(ae,y);const fe=hm(_e=>({transform:ae[_e],bone:y[_e]}),["armL","armMidL","forearmL","forearmMidL","handL","armR","armMidR","forearmR","forearmMidR","handR"]);this.updateArm({arm:fe.armL,armMid:fe.armMidL,forearm:fe.forearmL,forearmMid:fe.forearmMidL,hand:fe.handL},{shoulder:u.shoulderL,elbow:u.elbowL}),this.updateArm({arm:fe.armR,armMid:fe.armMidR,forearm:fe.forearmR,forearmMid:fe.forearmMidR,hand:fe.handR},{shoulder:u.shoulderR,elbow:u.elbowR});const Re=hm(_e=>({transform:ae[_e],bone:y[_e]}),["uplegL","uplegMidL","legL","footL","uplegR","uplegMidR","legR","footR"]);return this.updateLeg({upleg:Re.uplegL,uplegMid:Re.uplegMidL,leg:Re.legL,foot:Re.footL},{hip:u.hipL,knee:u.kneeL}),this.updateLeg({upleg:Re.uplegR,uplegMid:Re.uplegMidR,leg:Re.legR,foot:Re.footR},{hip:u.hipR,knee:u.kneeR}),g.setEnabled(!0),super.update(a,x)}updateSpine(a,x){this.alignBone(a.root,x.root,!1),this.alignBone(a.spine,x.spine,!1),this.alignBone(a.spine1,x.spine1),this.alignBone(a.spine2,x.spine2),this.alignBone(a.spine3,x.spine3),this.alignBone(a.neck,x.neck,!1),this.alignBone(a.neck1,x.neck1,!1),this.alignBone(a.head,x.head,!1),x.head.scaling.setAll(1.1),this.alignBone(a.pelvis,x.pelvis,!1),this.alignBone(a.shoulderL,x.shoulderL,!1),this.alignBone(a.shoulderR,x.shoulderR,!1)}updateArm(a,x){this.alignBone(a.arm.transform,a.arm.bone),this.alignBone(a.armMid.transform,a.armMid.bone),this.alignBone(a.forearm.transform,a.forearm.bone),this.alignBone(a.forearmMid.transform,a.forearmMid.bone),this.connectBone(a.hand.transform.position,a.hand.bone),a.hand.bone.scaling.setAll(.95)}updateLeg(a,x){this.alignBone(a.upleg.transform,a.upleg.bone,!1),this.alignBone(a.uplegMid.transform,a.uplegMid.bone),this.alignBone(a.leg.transform,a.leg.bone),this.connectBone(a.foot.transform.position,a.foot.bone)}estimateBones(a,x,c){var u,g;const y=vr(fe=>new Ee(...a[fe].metric)),v=this.estimateTorso(y);if(this.tune.hipsD){const fe=v.hipsZ.scale(this.tune.hipsD[2]),Re=v.hipsY.scale(this.tune.hipsD[1]).add(v.torsoN.scale((u=this.tune)==null?void 0:u.hipsD[0]));y.hipL.addInPlace(Re).addInPlace(fe),y.hipR.addInPlace(Re).addInPlace(fe.negate()),v.length-=this.tune.hipsD[1]}if(this.tune.shouldersD){const fe=v.shoulderL0.subtract(v.shoulderR0).normalize().scale(this.tune.shouldersD[2]),Re=v.hipsY.scale(this.tune.shouldersD[1]).add(v.torsoN.scale((g=this.tune)==null?void 0:g.shouldersD[0]));y.shoulderL.addInPlace(Re).addInPlace(fe),y.shoulderR.addInPlace(Re).addInPlace(fe.negate()),v.shoulderL0.addInPlace(Re),v.shoulderR0.addInPlace(Re),v.neck.addInPlace(Re),v.length+=this.tune.shouldersD[1]}const w=this.estimateSpine(y,v,x,c),B=this.estimateArm({shoulder0:v.shoulderL0,shoulder:y.shoulderL,elbow:y.elbowL,wrist:y.wristL},v,c),W=this.estimateArm({shoulder0:v.shoulderR0,shoulder:y.shoulderR,elbow:y.elbowR,wrist:y.wristR},v,c),ae=this.estimateLeg({hip:y.hipL,knee:y.kneeL,ankle:y.ankleL},v,c),ue=this.estimateLeg({hip:y.hipR,knee:y.kneeR,ankle:y.ankleR},v,c);return RE(IE({},w),{shoulderL:B.shoulder,armL:B.arm,armMidL:B.armMid,forearmL:B.forearm,forearmMidL:B.forearmMid,handL:B.hand,shoulderR:W.shoulder,armR:W.arm,armMidR:W.armMid,forearmR:W.forearm,forearmMidR:W.forearmMid,handR:W.hand,uplegL:ae.upleg,uplegMidL:ae.uplegMid,legL:ae.leg,footL:ae.foot,uplegR:ue.upleg,uplegMidR:ue.uplegMid,legR:ue.leg,footR:ue.foot})}estimateTorso(a){const x=Ee.Lerp(a.hipL,a.hipR,.5),c=Ee.Lerp(a.shoulderL,a.shoulderR,.5).subtract(x).normalize(),u=a.elbowL.subtract(a.shoulderL).normalize(),g=a.elbowR.subtract(a.shoulderR).normalize(),y=Ee.Dot(u,c),v=Ee.Dot(g,c),w=a.shoulderL.add(a.shoulderL.subtract(a.hipL).normalize().scale(((Math.acos(y)/Math.PI)**2*2-1)*(y>0?.04:.02))),B=a.shoulderR.add(a.shoulderR.subtract(a.hipR).normalize().scale(((Math.acos(v)/Math.PI)**2*2-1)*(v>0?.04:.02))),W=Ee.Lerp(w,B,.5),ae=Ee.Cross(w.subtract(x),B.subtract(x)).normalize(),ue=W.subtract(x),fe=a.hipL.subtract(a.hipR).normalize(),Re=ue.length();return ue.normalize(),{hipsC:x,hipsY:ue,hipsZ:fe,torsoN:ae,length:Re,neck:W,shoulderL0:w,shoulderR0:B}}estimateSpine(a,x,c,u){const{shoulderL0:g,shoulderR0:y,hipsY:v,torsoN:w,length:B}=x,W=ur(ut=>{const Mt=Ee.Lerp(a.hipL,g,c[ut][0]),ai=Ee.Lerp(a.hipR,y,c[ut][0]),Yi=Ee.Lerp(Mt,ai,.5),Vi=ai.subtract(Mt);return{position:Yi,axisZ:Vi}},b_);if(this.tune.spineCurve){const ut=this.tune.spineCurve*B;b_.forEach(Mt=>W[Mt].position.addInPlace(w.scale(c[Mt][1]*ut))),this.tune.pelvisDZ&&W.pelvisEnd.position.addInPlace(w.scale(this.tune.pelvisDZ))}const ae=Ee.Lerp(a.earL,a.earR,.5),ue=ae.subtract(a.nose).normalize(),fe=a.earR.subtract(a.earL).normalize(),Re=ue.cross(fe).normalize().add(ue.scale(.2)).normalize(),_e=ae.add(ue.scale(.02)).add(Re.scale(-.02)),Be=this.estimateRotationYZ(Re,fe),tt=Ee.Lerp(W.neck.axisZ,fe,.15).normalize(),$e=Ee.Lerp(W.neck.position,_e,u.neckRatio),Et=Ee.Lerp(tt,fe,u.neckRatio).normalize(),ft=W.pelvisEnd.position.subtract(W.pelvis.position),dt=this.estimateRotationYX(ft,W.pelvis.axisZ.negate());return{root:this.estimateBone(W.root.position,W.root.position.add(w.negate()),v),spine:this.estimateBone(W.spine.position,W.spine1.position,W.spine.axisZ),spine1:this.estimateBone(W.spine1.position,W.spine2.position,W.spine1.axisZ),spine2:this.estimateBone(W.spine2.position,W.spine3.position,W.spine2.axisZ),spine3:this.estimateBone(W.spine3.position,W.neck.position,W.spine3.axisZ),neck:this.estimateBone(W.neck.position,$e,tt),neck1:this.estimateBone($e,_e,Et),head:{position:_e,rotation:Be},pelvis:{position:W.pelvis.position,rotation:dt}}}estimateArm(a,x,c){const{neck:u,torsoN:g,hipsY:y}=x,v=a.elbow.subtract(a.shoulder).normalize(),w=Ee.Lerp(u,a.shoulder,c.shoulderRatio),B=a.shoulder.subtract(w),W=Math.sqrt(.5*(1+Math.sqrt(1-Math.max(Ee.Dot(v,y),0)**2))),ae=Math.sign(Ee.Dot(g.cross(B),y)),ue=this.estimateRotationYX(B,g).multiply(new Wi(0,-Math.sqrt(.5*(1-W))*ae,0,Math.sqrt(.5*(1+W)))),fe=this.estimateRotationYX(a.shoulder0.subtract(u),g),Re=new Ee(0,0,1).applyRotationQuaternion(fe).applyRotationQuaternion(this.rotationBetween(B,v)),_e=a.wrist.subtract(a.elbow).normalize(),Be=this.rotationBetween(v,_e),tt=Re.applyRotationQuaternion(Be),$e=Ee.Lerp(a.shoulder,a.elbow,c.armRatio),Et=Ee.Lerp(a.elbow,a.wrist,c.forearmRatio);return{shoulder:{position:w,rotation:ue},arm:this.estimateBone(a.shoulder,$e,Re),armMid:this.estimateBone($e,a.elbow,Re),forearm:this.estimateBone(a.elbow,Et,tt),forearmMid:this.estimateBone(Et,a.wrist,tt),hand:{position:a.wrist,rotation:new Wi}}}estimateLeg(a,x,c){const{hipsZ:u,hipsY:g}=x,y=a.knee.subtract(a.hip).normalize(),v=this.rotationBetween(g.negate(),y),w=u.applyRotationQuaternion(v),B=Ee.Lerp(a.hip,a.knee,c.uplegRatio),W=a.ankle.subtract(a.knee).normalize(),ae=this.rotationBetween(y,W),ue=w.applyRotationQuaternion(ae);return{upleg:this.estimateBone(a.hip,B,w),uplegMid:this.estimateBone(B,a.knee,w),leg:this.estimateBone(a.knee,a.ankle,ue),foot:{position:a.ankle,rotation:new Wi}}}estimateBone(a,x,c){return{position:a.clone(),rotation:this.estimateRotationYZ(x.subtract(a),c)}}estimateRotationYZ(a,x){const c=a.normalizeToNew(),u=c.cross(x).normalize(),g=u.cross(c);return Wi.RotationQuaternionFromAxis(u,c,g)}estimateRotationYX(a,x){const c=a.normalizeToNew(),u=x.cross(c).normalize(),g=c.cross(u).normalize();return Wi.RotationQuaternionFromAxis(g,c,u)}rotationBetween(a,x){const c=Ee.Cross(a,x);return new Wi(c.x,c.y,c.z,Math.sqrt(1+Ee.Dot(a,x))).normalize()}alignBone(a,x,c=!0){let u=a.position.clone(),g=a.rotation.clone();x.parent instanceof $s&&(u=Ee.TransformCoordinates(u,x.parent.computeWorldMatrix(!0).clone().invert()),g=x.parent.absoluteRotationQuaternion.conjugate().multiply(g),c&&(x.parent.scaling.setAll(u.length()/x.position.length()),u=Ee.TransformCoordinates(a.position,x.parent.computeWorldMatrix(!0).clone().invert()))),x.position=u,x.rotationQuaternion=g}connectBone(a,x){let c=a.clone();x.parent instanceof $s&&(c=Ee.TransformCoordinates(c,x.parent.computeWorldMatrix(!0).clone().invert()),x.parent.scaling.setAll(c.length()/x.position.length()),c=Ee.TransformCoordinates(a,x.parent.computeWorldMatrix(!0).clone().invert())),x.position=c}positionBone(a,x){let c=a.clone();x.parent instanceof $s&&(c=Ee.TransformCoordinates(c,x.parent.computeWorldMatrix(!0).clone().invert())),x.position=c}rotateBone(a,x){let c=a.clone();x.parent instanceof $s&&(x.parent.computeWorldMatrix(!0),c=x.parent.absoluteRotationQuaternion.conjugate().multiply(c)),x.rotationQuaternion=c}spineLength(a){const x=Y0(u=>new Ee(...a[Io[u]]),HD),{length:c}=this.estimateTorso(x);return c}equalize(a){const x=m.c9.lerp(a[11],a[12],.5),c=m.c9.lerp(a[23],a[24],.5),u=m.c9.sub(x,c),g=m.c9.length(u),y=Math.abs(u[2])/g,v=.7;if(y<v){const w=v*(y/v)**7,B=m.c9.normalizeToLen([u[0]/g,u[1]/g,w*Math.sign(u[2])],g),W=m.c9.sub(B,u);for(let ae=0;ae<23;ae++)a[ae][0]+=W[0],a[ae][1]+=W[1],a[ae][2]+=W[2]}}resize(a){const{skeletonSizes:x}=this;if(!x)return;const c=(Yi,Vi)=>Yi.forEach(Js=>{a[Js][0]+=Vi[0],a[Js][1]+=Vi[1],a[Js][2]+=Vi[2]}),u=m.c9.lerp(a[11],a[12],.5),g=m.c9.lerp(a[23],a[24],.5),y=this.spineLength(a),v=m.c9.sub(u,g),w=m.c9.scale(v,.5*(x.spineLen/y-1)),B=m.c9.sub(a[11],a[12]),W=m.c9.scale(B,.5*(x.shoulderWidth/m.c9.length(B)-1));c([11,13,15,17,19,21],m.c9.add(w,W)),c([12,14,16,18,20,22],m.c9.add(w,m.c9.negate(W)));const ae=m.c9.sub(a[23],a[24]),ue=m.c9.scale(ae,.5*(x.hipsWidth/m.c9.length(ae)-1));c([23,25,27,29,31],m.c9.add(m.c9.negate(w),ue)),c([24,26,28,30,32],m.c9.add(m.c9.negate(w),m.c9.negate(ue)));const fe=m.c9.sub(a[13],a[11]),Re=m.c9.sub(a[15],a[13]),_e=m.c9.scale(fe,x.armLen/m.c9.length(fe)-1);a[13]=m.c9.add(a[13],_e),c([15,17,19,21],m.c9.add(_e,m.c9.scale(Re,x.forearmLen/m.c9.length(Re)-1)));const Be=m.c9.sub(a[14],a[12]),tt=m.c9.sub(a[16],a[14]),$e=m.c9.scale(Be,x.armLen/m.c9.length(Be)-1);a[14]=m.c9.add(a[14],$e),c([16,18,20,22],m.c9.add($e,m.c9.scale(tt,x.forearmLen/m.c9.length(tt)-1)));const Et=m.c9.sub(a[25],a[23]),ft=m.c9.sub(a[27],a[25]),dt=m.c9.scale(Et,x.uplegLen/m.c9.length(Et)-1);a[25]=m.c9.add(a[25],dt),c([27,29,31],m.c9.add(dt,m.c9.scale(ft,x.legLen/m.c9.length(ft)-1)));const ut=m.c9.sub(a[26],a[24]),Mt=m.c9.sub(a[28],a[26]),ai=m.c9.scale(ut,x.uplegLen/m.c9.length(ut)-1);a[26]=m.c9.add(a[26],ai),c([28,30,32],m.c9.add(ai,m.c9.scale(Mt,x.legLen/m.c9.length(Mt)-1)))}align(a,x=!0){const c=a.map(W=>W.norm);this.resize(c);const{alignScore:u,alignVisibility:g}=this,y=[];if([11,12,23,24].forEach(W=>{(a[W].score>u||a[W].visibility>g)&&y.push({world:c[W],pixel:a[W].pixel})}),y.length<2)return;const v=(0,m.cK)(y,{angle:this.cameraAngle,ratio:this.cameraRatio});a.forEach((W,ae)=>{const ue=W.metric;ue[0]=c[ae][0]+v[0],ue[1]=c[ae][1]+v[1],ue[2]=c[ae][2]+v[2]});const w=2*Math.tan(.5*this.cameraAngle),B=this.cameraRatio*w;[11,12,23,24].forEach(W=>{const ae=a[W],ue=[(ae.pixel[0]-.5)*B,(ae.pixel[1]-.5)*w],fe=[ae.metric[0]/ae.metric[2],ae.metric[1]/ae.metric[2]],Re=[.5*(ue[0]+fe[0]),.5*(ue[1]+fe[1])];ae.pixel=[Re[0]/B+.5,Re[1]/w+.5,ae.pixel[2]]}),a.forEach(W=>{if(x&&(W.score>u||W.visibility>g)){const ae=[(W.pixel[0]-.5)*B,(W.pixel[1]-.5)*w],ue=W.metric,fe=Math.sqrt(ue[0]**2+ue[1]**2+ue[2]**2),Re=Math.sqrt(ae[0]**2+ae[1]**2+1),_e=fe/Re;ue[0]=ae[0]*_e,ue[1]=ae[1]*_e,ue[2]=_e}W.metric[1]=-W.metric[1],W.metric[2]=-W.metric[2]}),a.forEach(W=>{const ae=W.metric;W.norm=[ae[0],-ae[1],-ae[2]]})}setupCamera(a,x){this.cameraRatio=a,this.cameraAngle=x}}const BE=["uplegSkirtL","uplegSkirtR","uplegMidSkirtL","uplegMidSkirtR","legSkirtL","legSkirtR"],jD=(F,a)=>ur(F,a),YD=F=>jD(F,BE);class $D extends XD{setNode(a){var x;delete this.skirtSkeletonNodes,super.setNode(a);const c=(x=this.skeleton)==null?void 0:x.bones;if(!c)return;const u={uplegSkirtL:"left_thigh_skirt",uplegSkirtR:"right_thigh_skirt",uplegMidSkirtL:"left_thigh1_skirt",uplegMidSkirtR:"right_thigh1_skirt",legSkirtL:"left_shin_skirt",legSkirtR:"right_shin_skirt"},g=YD(v=>{var w;return(w=c.find(B=>B.name.toLowerCase().endsWith(u[v])))==null?void 0:w.getTransformNode()});function y(v){return BE.every(w=>v[w])}y(g)&&(this.skirtSkeletonNodes=g)}async update(a,x){var c,u;if(!this.loaded||!this.node)return;await super.update(a,x);const{skeletonNodes:g,skirtSkeletonNodes:y}=this;if(!g||!y)return;const{uplegL:v,uplegR:w,legL:B,legR:W}=g,{uplegSkirtL:ae,uplegSkirtR:ue}=y,fe=(c=v.rotationQuaternion)!=null?c:Wi.Identity(),Re=B.position.applyRotationQuaternion(fe.invert()).normalize(),_e=Re.clone();_e.z=Math.min(_e.z,0),_e.normalize();const Be=Ee.Cross(_e,Re),tt=new Wi(Be.x,Be.y,Be.z,Math.sqrt(1+Ee.Dot(_e,Re))).normalize();ae.position=v.position,ae.scaling=v.scaling,ae.rotationQuaternion=fe.multiply(tt);const $e=(u=w.rotationQuaternion)!=null?u:Wi.Identity(),Et=W.position.applyRotationQuaternion($e.invert()).normalize(),ft=Et.clone();ft.z=Math.max(ft.z,0),ft.normalize();const dt=Ee.Cross(ft,Et),ut=new Wi(dt.x,dt.y,dt.z,Math.sqrt(1+Ee.Dot(Et,ft))).normalize();ue.position=w.position,ue.scaling=w.scaling,ue.rotationQuaternion=$e.multiply(ut)}}var JD=Object.defineProperty,tN=Object.defineProperties,aN=Object.getOwnPropertyDescriptors,UE=Object.getOwnPropertySymbols,xN=Object.prototype.hasOwnProperty,lN=Object.prototype.propertyIsEnumerable,VE=(F,a,x)=>a in F?JD(F,a,{enumerable:!0,configurable:!0,writable:!0,value:x}):F[a]=x,hN=(F,a)=>{for(var x in a||(a={}))xN.call(a,x)&&VE(F,x,a[x]);if(UE)for(var x of UE(a))lN.call(a,x)&&VE(F,x,a[x]);return F},uN=(F,a)=>tN(F,aN(a));const WE=["hips","spine","spine1","spine2","neck","head","headEnd","shoulderL","shoulderR","armL","armR","forearmL","forearmR","handL","handR","uplegL","uplegR","legL","legR","footL","footR","toeL","toeR"],Iu=(F,a)=>ur(F,a),dN=F=>Iu(F,WE),fN=["spine","spine1","spine2","neck"],mN=["hipL","hipR","shoulderL","shoulderR","elbowL","elbowR"];class HE extends bE{constructor(a,x={spineCurve:1,neckAdjust:.01,headRatio:.4}){super(),this.node=a,this.tune=x,this.nodeOrigin={position:new Ee(0,0,-1),rotation:new Wi},this.cameraRatio=1920/1080,this.cameraAngle=10/180*Math.PI,this.alignScore=.9,this.alignVisibility=.9}async load(a){this.loaded||(await super.load(a),this.setNode(this.node))}unload(){this.loaded&&(delete this.node,delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,super.unload())}setNode(a){var x,c;if(delete this.skeletonNodes,delete this.skeleton,delete this.skeletonSizes,delete this.spineCurve,this.node=a,!this.loaded||!a)return;this.skeleton=((x=a.getChildMeshes(!1).find(ai=>ai.skeleton))==null?void 0:x.skeleton)||void 0;const u=(c=this.skeleton)==null?void 0:c.bones;if(!u)return;const g={hips:"hips",spine:"spine",spine1:"spine1",spine2:"spine2",neck:"neck",head:"head",headEnd:"headtop_end",shoulderL:"leftshoulder",shoulderR:"rightshoulder",armL:"leftarm",armR:"rightarm",forearmL:"leftforearm",forearmR:"rightforearm",handL:"lefthand",handR:"righthand",uplegL:"leftupleg",uplegR:"rightupleg",legL:"leftleg",legR:"rightleg",footL:"leftfoot",footR:"rightfoot",toeL:"lefttoebase",toeR:"righttoebase"},y=ai=>{var Yi;return((Yi=u.find(Vi=>Vi.name.toLowerCase().endsWith(g[ai])))==null?void 0:Yi.getTransformNode())||void 0},v=dN(ai=>y(ai));function w(ai){return WE.every(Yi=>ai[Yi]!==void 0)}if(!w(v))return;this.skeletonNodes=v;const B=Iu(ai=>v[ai].absolutePosition,["hips","shoulderL","shoulderR","neck","head","headEnd","armL","armR","forearmL","handL","uplegL","uplegR","legL","footL"]),W=B.hips,ae=Ee.Lerp(B.shoulderL,B.shoulderR,.5),ue=ae.subtract(W).length(),fe=B.forearmL.subtract(B.armL).length(),Re=B.handL.subtract(B.forearmL).length(),_e=B.legL.subtract(B.uplegL).length(),Be=B.footL.subtract(B.legL).length();this.skeletonSizes={spineLen:ue,hipsWidth:B.uplegL.subtract(B.uplegR).length(),shoulderWidth:B.armL.subtract(B.armR).length(),shoulderRatio:B.shoulderL.subtract(ae).length()/B.armL.subtract(ae).length(),armLen:fe,forearmLen:Re,uplegLen:_e,legLen:Be,headLen:B.headEnd.subtract(B.head).length()/ue};const tt=Ee.Cross(B.shoulderR.subtract(W),B.shoulderL.subtract(W)).normalize();this.spineCurve=Iu(ai=>{const Yi=v[ai].absolutePosition.subtract(W),Vi=Ee.Dot(Yi,tt);return[Yi.subtract(tt.scale(Vi)).length()/ue,Vi/ue]},fN),this.nodeOrigin={position:a.absolutePosition.subtract(v.hips.absolutePosition).applyRotationQuaternion(v.hips.absoluteRotationQuaternion.conjugate()),rotation:a.absoluteRotationQuaternion.multiply(v.hips.absoluteRotationQuaternion.conjugate())};let{min:$e,max:Et}=a.getHierarchyBoundingVectors();const ft=$e.add(Et).scale(.5),dt=Et.subtract($e),ut=Math.max(dt.x,dt.y,dt.z)*1.1*.5,Mt=new Ee(ut,ut,ut);$e=ft.subtract(Mt),Et=ft.add(Mt),a.getChildMeshes(!1).forEach(ai=>ai.buildBoundingInfo($e,Et))}async update(a,x){var c;if(!this.loaded||!this.node)return;const u=a.poses.length>0&&a.poses[0].points,{node:g,skeletonNodes:y,skeletonSizes:v,spineCurve:w}=this;if(!y||!v||!w||!u)return g.setEnabled(!1),super.update(a,x);const B=Ur.map(_e=>u[_e]),W=B.map(_e=>_e.norm);this.equalize(W);for(let _e=0;_e<4;_e++)this.align(B);const ae=this.estimateBones(u,w,v),ue={position:ae.hips.position.add(this.nodeOrigin.position.applyRotationQuaternion(ae.hips.rotation)),rotation:ae.hips.rotation.multiply(this.nodeOrigin.rotation)};(c=this.skeleton)==null||c.returnToRest(),this.alignBone(ue,g,!1),this.updateSpine(ae,y);const fe=Iu(_e=>({transform:ae[_e],bone:y[_e]}),["armL","forearmL","handL","armR","forearmR","handR"]);this.updateArm({arm:fe.armL,forearm:fe.forearmL,hand:fe.handL},{shoulder:u.shoulderL,elbow:u.elbowL}),this.updateArm({arm:fe.armR,forearm:fe.forearmR,hand:fe.handR},{shoulder:u.shoulderR,elbow:u.elbowR});const Re=Iu(_e=>({transform:ae[_e],bone:y[_e]}),["uplegL","legL","footL","toeL","uplegR","legR","footR","toeR"]);return this.updateLeg({upleg:Re.uplegL,leg:Re.legL,foot:Re.footL,toe:Re.toeL},{hip:u.hipL,knee:u.kneeL,ankle:u.ankleL}),this.updateLeg({upleg:Re.uplegR,leg:Re.legR,foot:Re.footR,toe:Re.toeR},{hip:u.hipR,knee:u.kneeR,ankle:u.ankleR}),g.setEnabled(!0),super.update(a,x)}updateSpine(a,x){this.alignBone(a.hips,x.hips,!1),this.alignBone(a.spine,x.spine),this.alignBone(a.spine1,x.spine1),this.alignBone(a.spine2,x.spine2),this.alignBone(a.neck,x.neck,!1),x.neck.scaling.setAll(1.1),this.alignBone(a.head,x.head,!1),this.alignBone(a.shoulderL,x.shoulderL,!1),this.alignBone(a.shoulderR,x.shoulderR,!1)}updateArm(a,x){const{alignScore:c,alignVisibility:u}=this;this.alignBone(a.arm.transform,a.arm.bone),!(x.elbow.score<c&&x.elbow.visibility<u)&&(this.alignBone(a.forearm.transform,a.forearm.bone),a.hand.bone.scaling.setAll(.95))}updateLeg(a,x){const{alignScore:c,alignVisibility:u}=this;x.hip.score<c&&x.hip.visibility<u||(this.alignBone(a.upleg.transform,a.upleg.bone,!1),!(x.knee.score<c&&x.knee.visibility<u)&&(this.alignBone(a.leg.transform,a.leg.bone),!(x.ankle.score<c&&x.ankle.visibility<u)&&(this.alignBone(a.foot.transform,a.foot.bone),this.alignBone(a.toe.transform,a.toe.bone))))}estimateBones(a,x,c){const u=vr(ae=>new Ee(...a[ae].metric)),g=this.estimateTorso(u),y=this.estimateSpine(u,g,x,c),v=this.estimateArm({neck:g.neck,shoulder:u.shoulderL,elbow:u.elbowL,wrist:u.wristL,index:u.indexL,pinky:u.pinkyL},g,c,!0),w=this.estimateArm({neck:g.neck,shoulder:u.shoulderR,elbow:u.elbowR,wrist:u.wristR,index:u.indexR,pinky:u.pinkyR},g,c,!1),B=this.estimateLeg({hip:u.hipL,knee:u.kneeL,ankle:u.ankleL,heel:u.heelL,footIndex:u.footIndexL},g),W=this.estimateLeg({hip:u.hipR,knee:u.kneeR,ankle:u.ankleR,heel:u.heelR,footIndex:u.footIndexR},g);return uN(hN({},y),{shoulderL:v.shoulder,armL:v.arm,forearmL:v.forearm,handL:v.hand,shoulderR:w.shoulder,armR:w.arm,forearmR:w.forearm,handR:w.hand,uplegL:B.upleg,legL:B.leg,footL:B.foot,toeL:B.toe,uplegR:W.upleg,legR:W.leg,footR:W.foot,toeR:W.toe})}estimateTorso(a){var x,c;const u=Ee.Lerp(a.hipL,a.hipR,.5),g=a.hipL.subtract(a.hipR).normalize(),y=Ee.Lerp(a.shoulderL,a.shoulderR,.5),v=a.shoulderL.subtract(a.shoulderR).normalize(),w=y.subtract(u).normalize(),B=Ee.Cross(a.shoulderR.subtract(u),a.shoulderL.subtract(u)).normalize();if(this.tune.hipsD){const ft=g.scale(this.tune.hipsD[0]),dt=w.scale(this.tune.hipsD[1]).add(B.scale((x=this.tune)==null?void 0:x.hipsD[2]));a.hipL.addInPlace(dt).addInPlace(ft),a.hipR.addInPlace(dt).addInPlace(ft.negate())}if(this.tune.shouldersD){const ft=v.scale(this.tune.shouldersD[0]),dt=w.scale(this.tune.shouldersD[1]).add(B.scale((c=this.tune)==null?void 0:c.shouldersD[2]));a.shoulderL.addInPlace(dt).addInPlace(ft),a.shoulderR.addInPlace(dt).addInPlace(ft.negate())}const W=a.elbowL.subtract(a.shoulderL).normalize(),ae=a.elbowR.subtract(a.shoulderR).normalize(),ue=Ee.Dot(W,w),fe=Ee.Dot(ae,w),Re=a.shoulderL.add(a.shoulderL.subtract(a.hipL).normalize().scale(((Math.acos(ue)/Math.PI)**2*2-1)*(ue>0?.04:.02))),_e=a.shoulderR.add(a.shoulderR.subtract(a.hipR).normalize().scale(((Math.acos(fe)/Math.PI)**2*2-1)*(fe>0?.04:.02))),Be=Ee.Lerp(Re,_e,.5),tt=Ee.Cross(_e.subtract(u),Re.subtract(u)).normalize(),$e=Be.subtract(u),Et=$e.length();return $e.normalize(),{hipsC:u,hipsY:$e,hipsX:g,torsoN:tt,length:Et,neck:Be,shoulderL0:Re,shoulderR0:_e}}estimateSpine(a,x,c,u){const g=Iu($e=>{const Et=Ee.Lerp(a.hipL,x.shoulderL0,c[$e][0]),ft=Ee.Lerp(a.hipR,x.shoulderR0,c[$e][0]),dt=Ee.Lerp(Et,ft,.5),ut=Et.subtract(ft);return{position:dt,axisX:ut}},["spine","spine1","spine2"]);if(this.tune.spineCurve){const $e=this.tune.spineCurve*x.length;["spine","spine1","spine2"].forEach(Et=>g[Et].position.addInPlace(x.torsoN.scale(c[Et][1]*$e)))}const y=Ee.Lerp(a.earL,a.earR,.5),v=y.subtract(a.nose).normalize(),w=a.earL.subtract(a.earR).normalize(),B=w.cross(v).add(v.scale(.05)).normalize(),W=this.tune.headRatio||.4,ae=u.headLen*x.length,ue=y.add(B.cross(w).scale(.01)),fe=ue.add(B.scale(-W*ae)),Re=ue.add(B.scale((1-W)*ae)),_e=Ee.Lerp(fe,Re,2),Be=x.shoulderL0.subtract(x.shoulderR0).normalize(),tt=Ee.Lerp(Be,w,.5);return{hips:this.estimateBone(x.hipsC,g.spine.position,x.hipsX),spine:this.estimateBone(g.spine.position,g.spine1.position,g.spine.axisX),spine1:this.estimateBone(g.spine1.position,g.spine2.position,g.spine1.axisX),spine2:this.estimateBone(g.spine2.position,x.neck,g.spine2.axisX),neck:this.estimateBone(x.neck,fe,tt),head:this.estimateBone(fe,Re,w),headEnd:this.estimateBone(Re,_e,w)}}estimateArm(a,x,c,u){const g=Ee.Lerp(a.neck,a.shoulder,c.shoulderRatio),y=u?x.torsoN.clone():x.torsoN.negate(),v=a.elbow.subtract(a.shoulder).normalize(),w=a.shoulder.subtract(a.neck).normalize(),B=this.rotationBetween(w,v),W=y.applyRotationQuaternion(B),ae=a.wrist.subtract(a.elbow).normalize(),ue=this.rotationBetween(v,ae),fe=W.applyRotationQuaternion(ue),Re=Ee.Lerp(a.index,a.pinky,.5),_e=a.pinky.subtract(a.index);return u||_e.negateInPlace(),{shoulder:this.estimateBone(g,a.shoulder,y),arm:this.estimateBone(a.shoulder,a.elbow,W),forearm:this.estimateBone(a.elbow,a.wrist,fe),hand:this.estimateBone(a.wrist,Re,_e)}}estimateLeg(a,x){const c=a.ankle.subtract(a.knee).normalize(),u=a.footIndex.subtract(a.heel).normalize(),g=c.cross(u).normalize(),y=Ee.Lerp(a.heel,a.footIndex,.8),v=a.knee.subtract(a.hip).normalize(),w=this.rotationBetween(x.hipsY.negate(),v),B=x.hipsX.negate().applyRotationQuaternion(w),W=this.rotationBetween(v,c),ae=B.applyRotationQuaternion(W);return{upleg:this.estimateBone(a.hip,a.knee,B),leg:this.estimateBone(a.knee,a.ankle,ae),foot:this.estimateBone(a.ankle,y,g),toe:this.estimateBone(y,a.footIndex,g)}}estimateBone(a,x,c){const u=x.subtract(a).normalize(),g=c.clone().normalize().cross(u).normalize(),y=u.cross(g);return{position:a.clone(),rotation:Wi.RotationQuaternionFromAxis(y,u,g)}}rotationBetween(a,x){const c=Ee.Cross(a,x);return new Wi(c.x,c.y,c.z,Math.sqrt(1+Ee.Dot(a,x))).normalize()}alignBone(a,x,c=!0){let u=a.rotation.clone(),g=a.position.clone();x.parent instanceof $s&&(g=Ee.TransformCoordinates(g,x.parent.computeWorldMatrix(!0).clone().invert()),u=x.parent.absoluteRotationQuaternion.conjugate().multiply(u),c&&(x.parent.scaling.setAll(g.length()/x.position.length()),g=Ee.TransformCoordinates(a.position,x.parent.computeWorldMatrix(!0).clone().invert()))),x.position=g,x.rotationQuaternion=u}spineLength(a){const x=Y0(u=>new Ee(...a[Io[u]]),mN),{length:c}=this.estimateTorso(x);return c}equalize(a){const x=m.c9.lerp(a[11],a[12],.5),c=m.c9.lerp(a[23],a[24],.5),u=m.c9.sub(x,c),g=m.c9.length(u),y=Math.abs(u[2])/g,v=.7;if(y<v){const w=v*(y/v)**7,B=m.c9.normalizeToLen([u[0]/g,u[1]/g,w*Math.sign(u[2])],g),W=m.c9.sub(B,u);for(let ae=0;ae<23;ae++)a[ae][0]+=W[0],a[ae][1]+=W[1],a[ae][2]+=W[2]}}resize(a){const{skeletonSizes:x}=this;if(!x)return;const c=(Yi,Vi)=>Yi.forEach(Js=>{a[Js][0]+=Vi[0],a[Js][1]+=Vi[1],a[Js][2]+=Vi[2]}),u=m.c9.lerp(a[11],a[12],.5),g=m.c9.lerp(a[23],a[24],.5),y=this.spineLength(a),v=m.c9.sub(u,g),w=m.c9.scale(v,.5*(x.spineLen/y-1)),B=m.c9.sub(a[11],a[12]),W=m.c9.scale(B,.5*(x.shoulderWidth/m.c9.length(B)-1));c([11,13,15,17,19,21],m.c9.add(w,W)),c([12,14,16,18,20,22],m.c9.add(w,m.c9.negate(W)));const ae=m.c9.sub(a[23],a[24]),ue=m.c9.scale(ae,.5*(x.hipsWidth/m.c9.length(ae)-1));c([23,25,27,29,31],m.c9.add(m.c9.negate(w),ue)),c([24,26,28,30,32],m.c9.add(m.c9.negate(w),m.c9.negate(ue)));const fe=m.c9.sub(a[13],a[11]),Re=m.c9.sub(a[15],a[13]),_e=m.c9.scale(fe,x.armLen/m.c9.length(fe)-1);a[13]=m.c9.add(a[13],_e),c([15,17,19,21],m.c9.add(_e,m.c9.scale(Re,x.forearmLen/m.c9.length(Re)-1)));const Be=m.c9.sub(a[14],a[12]),tt=m.c9.sub(a[16],a[14]),$e=m.c9.scale(Be,x.armLen/m.c9.length(Be)-1);a[14]=m.c9.add(a[14],$e),c([16,18,20,22],m.c9.add($e,m.c9.scale(tt,x.forearmLen/m.c9.length(tt)-1)));const Et=m.c9.sub(a[25],a[23]),ft=m.c9.sub(a[27],a[25]),dt=m.c9.scale(Et,x.uplegLen/m.c9.length(Et)-1);a[25]=m.c9.add(a[25],dt),c([27,29,31],m.c9.add(dt,m.c9.scale(ft,x.legLen/m.c9.length(ft)-1)));const ut=m.c9.sub(a[26],a[24]),Mt=m.c9.sub(a[28],a[26]),ai=m.c9.scale(ut,x.uplegLen/m.c9.length(ut)-1);a[26]=m.c9.add(a[26],ai),c([28,30,32],m.c9.add(ai,m.c9.scale(Mt,x.legLen/m.c9.length(Mt)-1)))}align(a,x=!0){const c=a.map(W=>W.norm);this.resize(c);const{alignScore:u,alignVisibility:g}=this,y=[];if([11,12,23,24].forEach(W=>{(a[W].score>u||a[W].visibility>g)&&y.push({world:c[W],pixel:a[W].pixel})}),y.length<2)return;const v=(0,m.cK)(y,{angle:this.cameraAngle,ratio:this.cameraRatio});a.forEach((W,ae)=>{const ue=W.metric;ue[0]=c[ae][0]+v[0],ue[1]=c[ae][1]+v[1],ue[2]=c[ae][2]+v[2]});const w=2*Math.tan(.5*this.cameraAngle),B=this.cameraRatio*w;[11,12,23,24].forEach(W=>{const ae=a[W],ue=[(ae.pixel[0]-.5)*B,(ae.pixel[1]-.5)*w],fe=[ae.metric[0]/ae.metric[2],ae.metric[1]/ae.metric[2]],Re=[.5*(ue[0]+fe[0]),.5*(ue[1]+fe[1])];ae.pixel=[Re[0]/B+.5,Re[1]/w+.5,ae.pixel[2]]}),a.forEach(W=>{if(x&&(W.score>u||W.visibility>g)){const ae=[(W.pixel[0]-.5)*B,(W.pixel[1]-.5)*w],ue=W.metric,fe=Math.sqrt(ue[0]**2+ue[1]**2+ue[2]**2),Re=Math.sqrt(ae[0]**2+ae[1]**2+1),_e=fe/Re;ue[0]=ae[0]*_e,ue[1]=ae[1]*_e,ue[2]=_e}W.metric[1]=-W.metric[1],W.metric[2]=-W.metric[2]}),a.forEach(W=>{const ae=W.metric;W.norm=[ae[0],-ae[1],-ae[2]]})}setupCamera(a,x){this.cameraRatio=a,this.cameraAngle=x}}class aU extends HE{constructor(a,x,c,u,g={spineCurve:1,neckAdjust:.01,headRatio:.4}){super(a,g),this.translation=x,this.rotation=c,this.scale=u}async update(a,x){if(!this.loaded||!this.node)return;await super.update(a,x);const c=a.poses.length>0&&a.poses[0].points,{node:u,translation:g,rotation:y,scale:v}=this;if(!c)return;const w=new Ee(...c.hipL.metric),B=new Ee(...c.hipR.metric),W=Ee.Lerp(w,B,.5);u.position=g?W.add(g):W,y&&(u.rotationQuaternion=y),v&&(u.scaling=new Ee().setAll(v))}updateSpine(a){const{skeletonNodes:x}=this;x&&(this.alignBone(a.hips,x.hips),this.alignBone(a.spine,x.spine),this.alignBone(a.spine1,x.spine1),this.alignBone(a.spine2,x.spine2),this.alignBone(a.neck,x.neck),this.alignBone(a.head,x.head),this.alignBone(a.shoulderL,x.shoulderL),this.alignBone(a.shoulderR,x.shoulderR))}alignBone(a,x){let c=a.rotation.clone();x.parent instanceof $s&&(x.parent.computeWorldMatrix(!0),c=x.parent.absoluteRotationQuaternion.conjugate().multiply(c)),x.rotationQuaternion=c}}const XE=null,gN=(F,a)=>L(F,a),_N=F=>gN(F,XE);class xU extends null{setNode(a){var x;delete this.skirtSkeletonNodes,super.setNode(a);const c=(x=this.skeleton)==null?void 0:x.bones;if(!c)return;const u={uplegSkirtL:"leftuplegskirt",uplegSkirtR:"rightuplegskirt"},g=_N(v=>{var w;return(w=c.find(B=>B.name.toLowerCase().endsWith(u[v])))==null?void 0:w.getTransformNode()});function y(v){return XE.every(w=>v[w])}y(g)&&(this.skirtSkeletonNodes=g)}async update(a,x){var c,u;if(!this.loaded||!this.node)return;await super.update(a,x);const{skeletonNodes:g,skirtSkeletonNodes:y}=this;if(!g||!y)return;const{uplegL:v,uplegR:w,legL:B,legR:W}=g,{uplegSkirtL:ae,uplegSkirtR:ue}=y,fe=(c=v.rotationQuaternion)!=null?c:b.Identity(),Re=B.position.applyRotationQuaternion(fe.invert()).normalize(),_e=Re.clone();_e.x=Math.min(_e.x,0),_e.normalize();const Be=r.Cross(_e,Re),tt=new b(Be.x,Be.y,Be.z,Math.sqrt(1+r.Dot(_e,Re))).normalize();ae.position=v.position,ae.scaling=v.scaling,ae.rotationQuaternion=fe.multiply(tt);const $e=(u=w.rotationQuaternion)!=null?u:b.Identity(),Et=W.position.applyRotationQuaternion($e.invert()).normalize(),ft=Et.clone();ft.x=Math.max(ft.x,0),ft.normalize();const dt=r.Cross(ft,Et),ut=new b(dt.x,dt.y,dt.z,Math.sqrt(1+r.Dot(Et,ft))).normalize();ue.position=w.position,ue.scaling=w.scaling,ue.rotationQuaternion=$e.multiply(ut)}}const yN=`
attribute vec3 position;
#include<bonesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
void main(void) {
    #include<instancesVertex>
    #include<bonesVertex>
    vec4 worldPos = finalWorld * vec4(position, 1.0);
    gl_Position = viewProjection * worldPos;
    #include<clipPlaneVertex>
}`,bN=`
#include<clipPlaneFragmentDeclaration>
void main(void) {
    #include<clipPlaneFragment>
	gl_FragColor = vec4(0, 0, 0, 1);
}`;class EN extends Wl{constructor(a,x){super(a,x,"simpleOccluder",{attributes:["position"],uniforms:["world","viewProjection"]}),this.disableColorWrite=!0,this.needDepthPrePass=!0,this.transparencyMode=ui.MATERIAL_OPAQUE}}Yn.ShadersStore.simpleOccluderVertexShader=yN,Yn.ShadersStore.simpleOccluderFragmentShader=bN;class lU extends HE{constructor(a,x,c={spineCurve:1,neckAdjust:.01,headRatio:.4}){super(a,c),this.outfit=x}setNode(a){super.setNode(a);const{outfit:x,node:c}=this;!x||!c||c.getChildMeshes().forEach(u=>{const g=y=>y?.some(v=>typeof v=="string"?u.name===v:v.test(u.name));if(g(x.occluders)){const y=u.material;u.material=new EN("Occluder",u.getScene()),y?.getBindedMeshes().length===0&&y.dispose();return}if(g(x.hidden)){u.setEnabled(!1);return}})}setOutfit(a,x){this.outfit=x,this.setNode(a)}}const um=.5,vN=32,jE=8,Ru=64,IN=20.1,RN=`
    precision mediump float;
    varying vec2 xy;
    uniform vec2 wh;
    uniform vec4 rect;
    uniform sampler2D image;
    uniform sampler2D mask;
    uniform sampler2D part;
    #define M_SQRT2 1.414213562

    float readMask(vec2 xy0, vec2 dxyI) {
        return texture2D(mask, (xy0 + dxyI / wh - rect.xy) / rect.zw).r;
    }

    vec4 readPart(vec2 xy0, vec2 dxyI) {
        vec2 offset = xy0 + dxyI / wh;
        return texture2D(part, vec2(offset.x, 1.0 - offset.y));
    }

    vec4 readProp(vec2 xy0, vec2 dxyI, vec2 ddxyI) {
        return abs(dxyI.x) + abs(dxyI.y) < `+IN+` &&
            readMask(xy0, ddxyI) < `+um+` ?
            texture2D(image, xy0 + ddxyI / wh) :
            texture2D(image, xy0 + dxyI / wh);
    }

    float traverse(vec2 xy0, vec2 dxyI) {
        bool bg = false;
        float d = 1.0;
        for (int di = 1; di < `+vN+`; di++) {
            d = bg ? d : float(di * `+jE+`);
            bg = bg || readMask(xy0, d * dxyI) < `+um+`;
        }
        bool bg1 = bg;
        for (int di = 1; di < `+jE+`; di++) {
            float d1 = d - 1.0;
            bg1 = bg1 && readMask(xy0, d1 * dxyI) < `+um+`;
            d = bg1 ? d1 : d;
        }
        return bg ? d : -1.0;
    }

    vec2 searchPart(vec2 xy0, vec2 dxyI) {
        vec2 part = vec2(`+(2*Ru+1)+`);
        bool fg = true;
        for (int di = 1; di < `+Ru+`; di++) {
            float df = float(di);
            vec2 partD = readPart(xy0, df * dxyI).rg;
            fg = fg && readMask(xy0, df * dxyI) >= `+um+`;
            part.r = fg && partD.r > 0.5 && df < part.r ? df : part.r;
            part.g = fg && partD.g > 0.5 && df < part.g ? df : part.g;
        }
        return part;
    }

    void main() {
        bool bg = texture2D(mask, (xy - rect.xy) / (rect.zw)).r < `+um+`;
        vec4 color = texture2D(image, xy);
        if (bg) {
            gl_FragColor = color;
            return;
        }
        vec2 part = texture2D(part, vec2(xy.x, 1.0 - xy.y)).rg;
        if (part.g > 0.5 || part.r > 0.5) {
            gl_FragColor = color;
            return;
        }

        vec2 pX0 = searchPart(xy,  vec2( 1.0,  0.0));
        vec2 pX1 = searchPart(xy,  vec2(-1.0,  0.0));
        vec2 pY0 = searchPart(xy,  vec2( 0.0,  1.0));
        vec2 pY1 = searchPart(xy,  vec2( 0.0, -1.0));
        vec2 pD00 = searchPart(xy, vec2( 1.0,  1.0));
        vec2 pD01 = searchPart(xy, vec2( 1.0, -1.0));
        vec2 pD10 = searchPart(xy, vec2(-1.0,  1.0));
        vec2 pD11 = searchPart(xy, vec2(-1.0, -1.0));
        part = min(min(min(pX0,  pX1 ), min(pY0,  pY1 )),
                   min(min(pD00, pD01), min(pD10, pD11)) * M_SQRT2);
        if (part.g < part.r && part.g < float(`+Ru+`) ||
            part.r >= float(`+Ru+`)) {
            gl_FragColor = color;
            return;
        }

        float x0 = traverse(xy, vec2(-1.0, 0.0));
        bg = x0 > 0.0;
        vec4 cx0 = bg ? readProp(xy, vec2(-x0, 0.0),
            vec2(-x0 * 2.0 + 1.0, 0.0)) : color;
        x0 = bg ? 1.0 / x0 : 0.0;

        float x1 = traverse(xy, vec2(1.0, 0.0));
        bg = x1 > 0.0;
        vec4 cx1 = bg ? readProp(xy, vec2(x1, 0.0),
            vec2(x1 * 2.0 - 1.0, 0.0)) : color;
        x1 = bg ? 1.0 / x1 : 0.0;

        float y0 = traverse(xy, vec2(0.0, -1.0));
        bg = y0 > 0.0;
        vec4 cy0 = bg ? readProp(xy, vec2(0.0, -y0),
            vec2(0.0, -2.0 * y0 + 1.0)) : color;
        y0 = bg ? 1.0 / y0 : 0.0;

        float y1 = traverse(xy, vec2(0.0, 1.0));
        bg = y1 > 0.0;
        vec4 cy1 = bg ? readProp(xy, vec2(0.0, y1),
            vec2(0.0, 2.0 * y1 + 1.0)) : color;
        y1 = bg ? 1.0 / y1 : 0.0;

        float s = 1.0 / (x0 + x1 + y0 + y1);
        vec4 subst = cx0 * x0 * s + cx1 * x1 * s + cy0 * y0 * s + cy1 * y1 * s;
        if (part.g >= float(`+Ru+`)) {
            gl_FragColor = subst;
            return;
        }

        bvec2 b[8];
        b[0] = bvec2(pX0.r < pX0.g, pX0.g < pX0.r);
        b[1] = bvec2(pD00.r < pD00.g, pD00.g < pD00.r);
        b[2] = bvec2(pY0.r < pY0.g, pY0.g < pY0.r);
        b[3] = bvec2(pD10.r < pD10.g, pD10.g < pD10.r);
        b[4] = bvec2(pX1.r < pX1.g, pX1.g < pX1.r);
        b[5] = bvec2(pD11.r < pD11.g, pD11.g < pD11.r);
        b[6] = bvec2(pY1.r < pY1.g, pY1.g < pY1.r);
        b[7] = bvec2(pD01.r < pD01.g, pD01.g < pD01.r);
        float rs[8];
        rs[0] = pX0.r;
        rs[1] = pD00.r * M_SQRT2;
        rs[2] = pY0.r;
        rs[3] = pD10.r * M_SQRT2;
        rs[4] = pX1.r;
        rs[5] = pD11.r * M_SQRT2;
        rs[6] = pY1.r;
        rs[7] = pD01.r * M_SQRT2;
        float rMin = float(`+(2*Ru+1)+`);
        bool bMin = false;
        for (int i = 0; i < 8; i++) {
            if (rs[i] < rMin) {
                rMin = rs[i];
                bMin = (b[i + 2 < 8 ? i + 2 : i + 2 - 8].g ||
                        b[i + 3 < 8 ? i + 3 : i + 3 - 8].g ||
                        b[i + 4 < 8 ? i + 4 : i + 4 - 8].g ||
                        b[i + 5 < 8 ? i + 5 : i + 5 - 8].g ||
                        b[i + 6 < 8 ? i + 6 : i + 6 - 8].g) &&
                      !(b[i + 3 < 8 ? i + 3 : i + 3 - 8].r ||
                        b[i + 4 < 8 ? i + 4 : i + 4 - 8].r ||
                        b[i + 5 < 8 ? i + 5 : i + 5 - 8].r);
            }
        }

        // vec4 rs[8];
        // rs[0] = vec4(1, 0, pX0.r, pX0.r);
        // rs[1] = vec4(1, 1, pD00.r, pD00.r * M_SQRT2);
        // rs[2] = vec4(0, 1, pY0.r, pY0.r);
        // rs[3] = vec4(-1, 1, pD10.r, pD10.r * M_SQRT2);
        // rs[4] = vec4(-1, 0, pX1.r, pX1.r);
        // rs[5] = vec4(-1, -1, pD11.r, pD11.r * M_SQRT2);
        // rs[6] = vec4(-1, 0, pY1.r, pY1.r);
        // rs[7] = vec4(-1, 1, pD01.r, pD01.r * M_SQRT2);
        // vec4 rMin = rs[0];
        // for (int i = 1; i < 8; i++) {
        //     if (rs[i].w < rMin.w)
        //         rMin = rs[i];
        // }
        // vec2 d0 = rMin.xy;
        // float norm = abs(d0.x) + abs(d0.y);
        // vec2 d1 = vec2(-d0.x - d0.y, -d0.y + d0.x) / norm;
        // vec2 d2 = vec2(-d0.x + d0.y, -d0.y - d0.x) / norm;
        // float d0Len = length(d0);
        // float d1Len = length(d1);
        // vec2 xyR = xy + d0 * (rMin.z / 2.0 - 1.0) / wh;
        // vec2 c0 = searchPart(xyR, vec2(-d0.x, -d0.y)) * d0Len;
        // vec2 c1 = searchPart(xyR, vec2(-d0.y,  d0.x)) * d0Len;
        // vec2 c2 = searchPart(xyR, vec2( d0.y, -d0.x)) * d0Len;
        // vec2 c3 = searchPart(xyR, vec2( d1.x,  d1.y)) * d1Len;
        // vec2 c4 = searchPart(xyR, vec2( d2.x,  d2.y)) * d1Len;
        // bool bMin = (c0.g < c0.r || c1.g < c1.r || c2.g < c2.r ||
        //              c3.g < c3.r || c4.g < c4.r);

        if (bMin) {
            gl_FragColor = mix(subst, color, pow(part.r / part.g, 0.5));
            return;
        }
        gl_FragColor = subst;
    }
`;class MN extends jr{constructor(a=2){super(["image","mask","part"],{rect:"4f"},RN),this.dilationR=a,this.patchParts=[],this.keepParts=[],this.partsSkeletons=[],this.ordinal=xs.PostRender}setParts(a=[],x=[]){this.partsSkeletons=[],this.patchParts=a,this.keepParts=x,this.partsTarget&&(this.partsTarget.renderList=[...a,...x],this.partsTarget.setMaterialForRendering(a,this.patchMaterial),this.partsTarget.setMaterialForRendering(x,this.keepMaterial),this.partsTarget.renderList.forEach(c=>c.skeleton&&this.partsSkeletons.indexOf(c.skeleton)<0&&this.partsSkeletons.push(c.skeleton)))}async load(a){if(!(a instanceof T_))return;const{scene:x,shaderCtx:c}=a;if(this.loaded||!c||!x)return;const u={width:256,height:256};return this.maskTexture=new mi(c,u,!0),this.dilationR>=1&&(this.dilationShader=new tE(c,u,this.dilationR)),this.partsTarget=new Bo("MasksTarget",this.size,x),this.partsTarget.clearColor=new Yr(0,0,0,1),this.patchMaterial=new Wl("PatchMaskMaterial",x,"bodypatch",{attributes:["position"],uniforms:["world","viewProjection","color"]}),this.patchMaterial.setColor4("color",new Yr(1,0,0,1)),this.patchMaterial.backFaceCulling=!1,this.patchMaterial.needDepthPrePass=!0,this.patchMaterial.transparencyMode=ui.MATERIAL_OPAQUE,this.keepMaterial=new Wl("KeepMaskMaterial",x,"bodypatch",{attributes:["position"],uniforms:["world","viewProjection","color"]}),this.keepMaterial.setColor4("color",new Yr(0,1,0,1)),this.keepMaterial.backFaceCulling=!1,this.keepMaterial.needDepthPrePass=!0,this.keepMaterial.transparencyMode=ui.MATERIAL_OPAQUE,this.setParts(this.patchParts,this.keepParts),super.load(a)}unload(){var a,x,c,u,g;this.loaded&&((a=this.dilationShader)==null||a.dispose(),delete this.dilationShader,(x=this.maskTexture)==null||x.dispose(),delete this.maskTexture,(c=this.partsTarget)==null||c.dispose(),delete this.partsTarget,(u=this.patchMaterial)==null||u.dispose(),delete this.patchMaterial,(g=this.keepMaterial)==null||g.dispose(),delete this.keepMaterial,super.unload())}async process(a,x){const c="poses"in a&&a.poses.length>0&&a.poses[0].mask||"faces"in a&&a.faces.length>0&&a.faces[0].mask,{maskTexture:u,dilationShader:g,shader:y}=this;if(!c||!u||!y)return!1;const v=this.renderParts(),w=Yh(c.box),B=u.update(c.buffer),W=g?.process([B])||B;return y.process([x,W,v||null],{rect:w}),!0}renderParts(){var a,x,c;const{partsTarget:u,partsSkeletons:g,maskTexture:y,dilationShader:v,shader:w}=this;return!u||!y||!w?null:(g.forEach(B=>B.prepare()),(a=u.renderList)==null||a.forEach(B=>B.computeWorldMatrix(!0)),u.render(),((c=(x=u.getInternalTexture())==null?void 0:x._hardwareTexture)==null?void 0:c._webGLTexture)||null)}setupVideo(a){var x;super.setupVideo(a),(x=this.partsTarget)==null||x.resize(a),this.setParts(this.patchParts,this.keepParts)}}const BN=`
attribute vec3 position;
#include<bonesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
void main(void) {
    #include<instancesVertex>
    #include<bonesVertex>
    vec4 worldPos = finalWorld * vec4(position, 1.0);
    gl_Position = viewProjection * worldPos;
    #include<clipPlaneVertex>
}`,UN=`
#include<clipPlaneFragmentDeclaration>
uniform vec4 color;
void main(void) {
    #include<clipPlaneFragment>
	gl_FragColor = color;
}`;Yn.ShadersStore.bodypatchVertexShader=BN,Yn.ShadersStore.bodypatchFragmentShader=UN;class VN extends MN{async load(a){var x;await super.load(a),(x=this.dilationShader)==null||x.resize({width:1024,height:1024})}async process(a,x){const c="poses"in a&&a.poses.length>0&&a.poses[0].maskHD||"faces"in a&&a.faces.length>0&&a.faces[0].maskHD,{dilationShader:u,shader:g}=this;if(!c||!g)return!1;const y=this.renderParts(),v=Yh(c.box),w=c.texture,B=u?.process([w])||w;return g.process([x,B,y||null],{rect:v}),!0}}class hU extends Xc{constructor(a){super(),this.node=a,this.cameraRatio=1920/1080,this.cameraAngle=10/180*Math.PI}async update(a,x){if(!this.loaded||!this.node)return;const{points:c=void 0,handedness:u=0,wrist:g=void 0}=a.hands.length>0?a.hands[0]:{};if(!c||!u||!g)return this.node.setEnabled(!1),super.update(a,x);const y=new Ee(...c[1].metric),v=new Ee(...c[0].metric),w=new Ee(...c[5].metric),B=new Ee(...c[17].metric),W=Ee.Lerp(y.subtract(v).normalize(),w.subtract(B).normalize(),.5).normalize();u>0&&W.negateInPlace();const ae=2*Math.tan(.5*this.cameraAngle),ue=this.cameraRatio*ae,fe=g.lines.map(ja=>{const k0=[(ja.point[0]-.5)*ue,-(ja.point[1]-.5)*ae],B0=[ja.vector[0],-ja.vector[1]];return{point:k0,vector:B0}}),Re=new Ee(...fe[0].vector,0).normalize(),_e=new Ee(...fe[1].vector,0).normalize(),Be=Ee.Cross(Re,_e).length(),tt=(1-Math.abs(W.z))*Be,$e=Ee.Lerp(Re,_e,.5).normalize(),Et=Math.sqrt(1-tt**2);$e.x/=Et,$e.y/=Et,$e.z=tt,$e.normalize();const ft=$e.clone(),dt=W.cross(ft).normalize(),ut=ft.cross(dt),Mt=new Ee(...c[0].metric).z,ai=new Ee(...fe[0].point,1),Yi=new Ee(...fe[1].point,1),Vi=new Ee(...fe[2].point,1);ai.scaleInPlace(Mt),Yi.scaleInPlace(Mt),Vi.scaleInPlace(Mt),Vi.x*=-1,Vi.y*=-1;const Js=.06,Rr=.045,_r=dt.z**2,Vr=dt.x**2+dt.y**2,Ja=Js*Rr/Math.sqrt(Js**2*Vr+Rr**2*_r),ta=ai.subtract(Yi).length()/Ja;return this.node.rotationQuaternion=Wi.RotationQuaternionFromAxis(ut,ft,dt),this.node.position=Vi,this.node.scaling.setAll(ta),this.node.setEnabled(!0),super.update(a,x)}setNode(a){this.node=a}setupCamera(a,x){this.cameraRatio=a,this.cameraAngle=x}}class uU extends Xc{constructor(a,x=0){super(),this.node=a,this.renderOrder=x}async load(a){if(!this.loaded)return this.node instanceof mo&&(this.node.material&&(this.node.material.disableColorWrite=!0,this.node.material.needDepthPrePass=!0),this.node.renderingGroupId=this.renderOrder),this.node.getChildMeshes(!1).forEach(x=>{x.material&&(x.material.disableColorWrite=!0,x.material.needDepthPrePass=!0),x.renderingGroupId=this.renderOrder}),super.load(a)}}const WN=`
attribute vec3 position;
#include<bonesDeclaration>
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
varying vec2 xy;
void main(void) {
    #include<instancesVertex>
    #include<bonesVertex>
    vec4 worldPos = finalWorld * vec4(position, 1.0);
    gl_Position = viewProjection * worldPos;
    xy = 0.5 * (vec2(gl_Position.x, -gl_Position.y) / gl_Position.w + 1.0);
    #include<clipPlaneVertex>
}`,HN=.5,XN=`
#include<clipPlaneFragmentDeclaration>
varying vec2 xy;
uniform vec4 rect;
uniform sampler2D mask;
void main(void) {
    #include<clipPlaneFragment>
    bool bg = texture2D(mask, (xy - rect.xy) / (rect.zw)).r <= `+HN+`;
    if (bg)
        discard;
	gl_FragColor = vec4(0, 0, 0, 1);
}`;class YE extends Wl{constructor(a,x,c){super(a,x,"maskedOccluder",{attributes:["position"],uniforms:["world","viewProjection","rect"],samplers:["mask"]}),this.disableColorWrite=!0,this.needDepthPrePass=!0,this.transparencyMode=ui.MATERIAL_OPAQUE,c&&this.setTexture("mask",c)}dispose(a,x,c){super.dispose(a,!1,c)}}Yn.ShadersStore.maskedOccluderVertexShader=WN,Yn.ShadersStore.maskedOccluderFragmentShader=XN;class dU extends Xc{constructor(){super(...arguments),this.maskRect=new an}async load(a){this.loaded||(await super.load(a),this.scene&&(this.maskTexture=Vx.CreateLuminanceTexture(null,256,256,this.scene,!1,!1,Vx.TRILINEAR_SAMPLINGMODE)))}unload(){var a;this.loaded&&((a=this.maskTexture)==null||a.dispose(),delete this.maskTexture,super.unload())}async update(a,x){if(!this.loaded)return;const{maskTexture:c,maskRect:u}=this,g="poses"in a&&a.poses.length>0&&a.poses[0].mask||"faces"in a&&a.faces.length>0&&a.faces[0].mask;if(!(!c||!g))return c.update(g.buffer),u.set(...Yh(g.box)),super.update(a,x)}createMaterial(){const{scene:a,maskTexture:x}=this;if(!a||!x)return null;const c=new YE("OcclusionMaterial",a,x);return c.onBindObservable.add(()=>{c.setVector4("rect",this.maskRect)}),c}}class jN extends Xc{constructor(){super(...arguments),this.maskRect=new an}async load(a){this.loaded||!(a instanceof T_)||(await super.load(a),this.scene&&(this.maskTexture=new Un(this.scene)))}unload(){var a,x,c,u;this.loaded&&((c=(x=(a=this.maskTexture)==null?void 0:a.getInternalTexture())==null?void 0:x._hardwareTexture)==null||c.reset(),(u=this.maskTexture)==null||u.dispose(),delete this.maskTexture,super.unload())}async update(a,x){var c;if(!this.loaded)return;const u="poses"in a&&a.poses.length>0&&a.poses[0].maskHD||"faces"in a&&a.faces.length>0&&a.faces[0].maskHD;if(!(!u||!this.maskTexture))return this.maskTexture._texture=((c=this.scene)==null?void 0:c.getEngine().wrapWebGLTexture(u.texture))||null,this.maskRect.set(...Yh(u.box)),super.update(a,x)}createMaterial(){const{scene:a}=this;if(!a)return null;const x=new YE("OcclusionMaterial",a);return x.onBindObservable.add(()=>{const{maskTexture:c,maskRect:u}=this;x.setVector4("rect",u),c&&x.setTexture("mask",c)}),x}}class fU extends fD{constructor(a,x=.85,c=.03,u={minCutOff:.05,minCutOffD:.1,beta:.05}){super(void 0,x,c,u),this.scene=a,this.rangeMax=x,this.rangeMin=c,this.filterParams=u,this.intensityMap=new Map,this.adjustIntensities=g=>{var y;this.scene&&this.envIntensity&&(this.scene.environmentIntensity=g*this.envIntensity),(y=this.scene)==null||y.lights.forEach(v=>{const w=this.intensityMap.get(v);w&&(v.intensity=g*w)})},this.resetScene(),this.setCallback(this.adjustIntensities)}setScene(a){var x;this.scene&&this.envIntensity&&(this.scene.environmentIntensity=this.envIntensity),delete this.envIntensity,(x=this.scene)==null||x.lights.forEach(c=>{const u=this.intensityMap.get(c);u&&(c.intensity=u)}),this.intensityMap.clear(),this.envIntensity=a?.environmentIntensity,a?.lights.forEach(c=>this.intensityMap.set(c,c.intensity)),this.scene=a}resetScene(){this.setScene(this.scene)}load(a){return this.resetScene(),super.load(a)}unload(){this.setScene()}}class Wr extends fa{get range(){return this._range}set range(a){this._range=a,this._inverseSquaredRange=1/(this.range*this.range)}get intensityMode(){return this._intensityMode}set intensityMode(a){this._intensityMode=a,this._computePhotometricScale()}get radius(){return this._radius}set radius(a){this._radius=a,this._computePhotometricScale()}get shadowEnabled(){return this._shadowEnabled}set shadowEnabled(a){this._shadowEnabled!==a&&(this._shadowEnabled=a,this._markMeshesAsLightDirty())}get includedOnlyMeshes(){return this._includedOnlyMeshes}set includedOnlyMeshes(a){this._includedOnlyMeshes=a,this._hookArrayForIncludedOnly(a)}get excludedMeshes(){return this._excludedMeshes}set excludedMeshes(a){this._excludedMeshes=a,this._hookArrayForExcluded(a)}get excludeWithLayerMask(){return this._excludeWithLayerMask}set excludeWithLayerMask(a){this._excludeWithLayerMask=a,this._resyncMeshes()}get includeOnlyWithLayerMask(){return this._includeOnlyWithLayerMask}set includeOnlyWithLayerMask(a){this._includeOnlyWithLayerMask=a,this._resyncMeshes()}get lightmapMode(){return this._lightmapMode}set lightmapMode(a){this._lightmapMode!==a&&(this._lightmapMode=a,this._markMeshesAsLightDirty())}getViewMatrix(a){return null}getProjectionMatrix(a,x){return null}constructor(a,x){super(a,x),this.diffuse=new Bs(1,1,1),this.specular=new Bs(1,1,1),this.falloffType=Wr.FALLOFF_DEFAULT,this.intensity=1,this._range=Number.MAX_VALUE,this._inverseSquaredRange=0,this._photometricScale=1,this._intensityMode=Wr.INTENSITYMODE_AUTOMATIC,this._radius=1e-5,this.renderPriority=0,this._shadowEnabled=!0,this._excludeWithLayerMask=0,this._includeOnlyWithLayerMask=0,this._lightmapMode=0,this._shadowGenerators=null,this._excludedMeshesIds=new Array,this._includedOnlyMeshesIds=new Array,this._isLight=!0,this.getScene().addLight(this),this._uniformBuffer=new ys(this.getScene().getEngine(),void 0,void 0,a),this._buildUniformLayout(),this.includedOnlyMeshes=[],this.excludedMeshes=[],this._resyncMeshes()}transferTexturesToEffect(a,x){return this}_bindLight(a,x,c,u,g=!0){const y=a.toString();let v=!1;if(this._uniformBuffer.bindToEffect(c,"Light"+y),this._renderId!==x.getRenderId()||this._lastUseSpecular!==u||!this._uniformBuffer.useUbo){this._renderId=x.getRenderId(),this._lastUseSpecular=u;const w=this.getScaledIntensity();this.transferToEffect(c,y),this.diffuse.scaleToRef(w,Rl.Color3[0]),this._uniformBuffer.updateColor4("vLightDiffuse",Rl.Color3[0],this.range,y),u&&(this.specular.scaleToRef(w,Rl.Color3[1]),this._uniformBuffer.updateColor4("vLightSpecular",Rl.Color3[1],this.radius,y)),v=!0}if(this.transferTexturesToEffect(c,y),x.shadowsEnabled&&this.shadowEnabled&&g){const w=this.getShadowGenerator(x.activeCamera)??this.getShadowGenerator();w&&(w.bindShadowLight(y,c),v=!0)}v?this._uniformBuffer.update():this._uniformBuffer.bindUniformBuffer()}getClassName(){return"Light"}toString(a){let x="Name: "+this.name;if(x+=", type: "+["Point","Directional","Spot","Hemispheric"][this.getTypeID()],this.animations)for(let c=0;c<this.animations.length;c++)x+=", animation[0]: "+this.animations[c].toString(a);return x}_syncParentEnabledState(){super._syncParentEnabledState(),this.isDisposed()||this._resyncMeshes()}setEnabled(a){super.setEnabled(a),this._resyncMeshes()}getShadowGenerator(a=null){return this._shadowGenerators===null?null:this._shadowGenerators.get(a)??null}getShadowGenerators(){return this._shadowGenerators}getAbsolutePosition(){return Ee.Zero()}canAffectMesh(a){return a?!(this.includedOnlyMeshes&&this.includedOnlyMeshes.length>0&&this.includedOnlyMeshes.indexOf(a)===-1||this.excludedMeshes&&this.excludedMeshes.length>0&&this.excludedMeshes.indexOf(a)!==-1||this.includeOnlyWithLayerMask!==0&&!(this.includeOnlyWithLayerMask&a.layerMask)||this.excludeWithLayerMask!==0&&this.excludeWithLayerMask&a.layerMask):!0}dispose(a,x=!1){if(this._shadowGenerators){const c=this._shadowGenerators.values();for(let u=c.next();u.done!==!0;u=c.next())u.value.dispose();this._shadowGenerators=null}if(this.getScene().stopAnimation(this),this._parentContainer){const c=this._parentContainer.lights.indexOf(this);c>-1&&this._parentContainer.lights.splice(c,1),this._parentContainer=null}for(const c of this.getScene().meshes)c._removeLightSource(this,!0);this._uniformBuffer.dispose(),this.getScene().removeLight(this),super.dispose(a,x)}getTypeID(){return 0}getScaledIntensity(){return this._photometricScale*this.intensity}clone(a,x=null){const c=Wr.GetConstructorFromName(this.getTypeID(),a,this.getScene());if(!c)return null;const u=hr.Clone(c,this);return a&&(u.name=a),x&&(u.parent=x),u.setEnabled(this.isEnabled()),this.onClonedObservable.notifyObservers(u),u}serialize(){const a=hr.Serialize(this);return a.uniqueId=this.uniqueId,a.type=this.getTypeID(),this.parent&&this.parent._serializeAsParent(a),this.excludedMeshes.length>0&&(a.excludedMeshesIds=[],this.excludedMeshes.forEach(x=>{a.excludedMeshesIds.push(x.id)})),this.includedOnlyMeshes.length>0&&(a.includedOnlyMeshesIds=[],this.includedOnlyMeshes.forEach(x=>{a.includedOnlyMeshesIds.push(x.id)})),hr.AppendSerializedAnimations(this,a),a.ranges=this.serializeAnimationRanges(),a.isEnabled=this.isEnabled(),a}static GetConstructorFromName(a,x,c){const u=fa.Construct("Light_Type_"+a,x,c);return u||null}static Parse(a,x){const c=Wr.GetConstructorFromName(a.type,a.name,x);if(!c)return null;const u=hr.Parse(c,a,x);if(a.excludedMeshesIds&&(u._excludedMeshesIds=a.excludedMeshesIds),a.includedOnlyMeshesIds&&(u._includedOnlyMeshesIds=a.includedOnlyMeshesIds),a.parentId!==void 0&&(u._waitingParentId=a.parentId),a.parentInstanceIndex!==void 0&&(u._waitingParentInstanceIndex=a.parentInstanceIndex),a.falloffType!==void 0&&(u.falloffType=a.falloffType),a.lightmapMode!==void 0&&(u.lightmapMode=a.lightmapMode),a.animations){for(let g=0;g<a.animations.length;g++){const y=a.animations[g],v=Ua("BABYLON.Animation");v&&u.animations.push(v.Parse(y))}fa.ParseAnimationRanges(u,a,x)}return a.autoAnimate&&x.beginAnimation(u,a.autoAnimateFrom,a.autoAnimateTo,a.autoAnimateLoop,a.autoAnimateSpeed||1),a.isEnabled!==void 0&&u.setEnabled(a.isEnabled),u}_hookArrayForExcluded(a){const x=a.push;a.push=(...u)=>{const g=x.apply(a,u);for(const y of u)y._resyncLightSource(this);return g};const c=a.splice;a.splice=(u,g)=>{const y=c.apply(a,[u,g]);for(const v of y)v._resyncLightSource(this);return y};for(const u of a)u._resyncLightSource(this)}_hookArrayForIncludedOnly(a){const x=a.push;a.push=(...u)=>{const g=x.apply(a,u);return this._resyncMeshes(),g};const c=a.splice;a.splice=(u,g)=>{const y=c.apply(a,[u,g]);return this._resyncMeshes(),y},this._resyncMeshes()}_resyncMeshes(){for(const a of this.getScene().meshes)a._resyncLightSource(this)}_markMeshesAsLightDirty(){for(const a of this.getScene().meshes)a.lightSources.indexOf(this)!==-1&&a._markSubMeshesAsLightDirty()}_computePhotometricScale(){this._photometricScale=this._getPhotometricScale(),this.getScene().resetCachedMaterial()}_getPhotometricScale(){let a=0;const x=this.getTypeID();let c=this.intensityMode;switch(c===Wr.INTENSITYMODE_AUTOMATIC&&(x===Wr.LIGHTTYPEID_DIRECTIONALLIGHT?c=Wr.INTENSITYMODE_ILLUMINANCE:c=Wr.INTENSITYMODE_LUMINOUSINTENSITY),x){case Wr.LIGHTTYPEID_POINTLIGHT:case Wr.LIGHTTYPEID_SPOTLIGHT:switch(c){case Wr.INTENSITYMODE_LUMINOUSPOWER:a=1/(4*Math.PI);break;case Wr.INTENSITYMODE_LUMINOUSINTENSITY:a=1;break;case Wr.INTENSITYMODE_LUMINANCE:a=this.radius*this.radius;break}break;case Wr.LIGHTTYPEID_DIRECTIONALLIGHT:switch(c){case Wr.INTENSITYMODE_ILLUMINANCE:a=1;break;case Wr.INTENSITYMODE_LUMINANCE:{let u=this.radius;u=Math.max(u,.001),a=2*Math.PI*(1-Math.cos(u));break}}break;case Wr.LIGHTTYPEID_HEMISPHERICLIGHT:a=1;break}return a}_reorderLightsInScene(){const a=this.getScene();this._renderPriority!=0&&(a.requireLightSorting=!0),this.getScene().sortLightsByPriority()}}Wr.FALLOFF_DEFAULT=vn.FALLOFF_DEFAULT,Wr.FALLOFF_PHYSICAL=vn.FALLOFF_PHYSICAL,Wr.FALLOFF_GLTF=vn.FALLOFF_GLTF,Wr.FALLOFF_STANDARD=vn.FALLOFF_STANDARD,Wr.LIGHTMAP_DEFAULT=vn.LIGHTMAP_DEFAULT,Wr.LIGHTMAP_SPECULAR=vn.LIGHTMAP_SPECULAR,Wr.LIGHTMAP_SHADOWSONLY=vn.LIGHTMAP_SHADOWSONLY,Wr.INTENSITYMODE_AUTOMATIC=vn.INTENSITYMODE_AUTOMATIC,Wr.INTENSITYMODE_LUMINOUSPOWER=vn.INTENSITYMODE_LUMINOUSPOWER,Wr.INTENSITYMODE_LUMINOUSINTENSITY=vn.INTENSITYMODE_LUMINOUSINTENSITY,Wr.INTENSITYMODE_ILLUMINANCE=vn.INTENSITYMODE_ILLUMINANCE,Wr.INTENSITYMODE_LUMINANCE=vn.INTENSITYMODE_LUMINANCE,Wr.LIGHTTYPEID_POINTLIGHT=vn.LIGHTTYPEID_POINTLIGHT,Wr.LIGHTTYPEID_DIRECTIONALLIGHT=vn.LIGHTTYPEID_DIRECTIONALLIGHT,Wr.LIGHTTYPEID_SPOTLIGHT=vn.LIGHTTYPEID_SPOTLIGHT,Wr.LIGHTTYPEID_HEMISPHERICLIGHT=vn.LIGHTTYPEID_HEMISPHERICLIGHT,Ye([va()],Wr.prototype,"diffuse",void 0),Ye([va()],Wr.prototype,"specular",void 0),Ye([ht()],Wr.prototype,"falloffType",void 0),Ye([ht()],Wr.prototype,"intensity",void 0),Ye([ht()],Wr.prototype,"range",null),Ye([ht()],Wr.prototype,"intensityMode",null),Ye([ht()],Wr.prototype,"radius",null),Ye([ht()],Wr.prototype,"_renderPriority",void 0),Ye([Ji("_reorderLightsInScene")],Wr.prototype,"renderPriority",void 0),Ye([ht("shadowEnabled")],Wr.prototype,"_shadowEnabled",void 0),Ye([ht("excludeWithLayerMask")],Wr.prototype,"_excludeWithLayerMask",void 0),Ye([ht("includeOnlyWithLayerMask")],Wr.prototype,"_includeOnlyWithLayerMask",void 0),Ye([ht("lightmapMode")],Wr.prototype,"_lightmapMode",void 0);class jc extends Wr{constructor(){super(...arguments),this._needProjectionMatrixCompute=!0,this._viewMatrix=vt.Identity(),this._projectionMatrix=vt.Identity()}_setPosition(a){this._position=a}get position(){return this._position}set position(a){this._setPosition(a)}_setDirection(a){this._direction=a}get direction(){return this._direction}set direction(a){this._setDirection(a)}get shadowMinZ(){return this._shadowMinZ}set shadowMinZ(a){this._shadowMinZ=a,this.forceProjectionMatrixCompute()}get shadowMaxZ(){return this._shadowMaxZ}set shadowMaxZ(a){this._shadowMaxZ=a,this.forceProjectionMatrixCompute()}computeTransformedInformation(){return this.parent&&this.parent.getWorldMatrix?(this.transformedPosition||(this.transformedPosition=Ee.Zero()),Ee.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this.transformedPosition),this.direction&&(this.transformedDirection||(this.transformedDirection=Ee.Zero()),Ee.TransformNormalToRef(this.direction,this.parent.getWorldMatrix(),this.transformedDirection)),!0):!1}getDepthScale(){return 50}getShadowDirection(a){return this.transformedDirection?this.transformedDirection:this.direction}getAbsolutePosition(){return this.transformedPosition?this.transformedPosition:this.position}setDirectionToTarget(a){return this.direction=Ee.Normalize(a.subtract(this.position)),this.direction}getRotation(){this.direction.normalize();const a=Ee.Cross(this.direction,Hh.Y),x=Ee.Cross(a,this.direction);return Ee.RotationFromAxis(a,x,this.direction)}needCube(){return!1}needProjectionMatrixCompute(){return this._needProjectionMatrixCompute}forceProjectionMatrixCompute(){this._needProjectionMatrixCompute=!0}_initCache(){super._initCache(),this._cache.position=Ee.Zero()}_isSynchronized(){return!!this._cache.position.equals(this.position)}computeWorldMatrix(a){return!a&&this.isSynchronized()?(this._currentRenderId=this.getScene().getRenderId(),this._worldMatrix):(this._updateCache(),this._cache.position.copyFrom(this.position),this._worldMatrix||(this._worldMatrix=vt.Identity()),vt.TranslationToRef(this.position.x,this.position.y,this.position.z,this._worldMatrix),this.parent&&this.parent.getWorldMatrix&&(this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(),this._worldMatrix),this._markSyncedWithParent()),this._worldMatrixDeterminantIsDirty=!0,this._worldMatrix)}getDepthMinZ(a){return this.shadowMinZ!==void 0?this.shadowMinZ:a.minZ}getDepthMaxZ(a){return this.shadowMaxZ!==void 0?this.shadowMaxZ:a.maxZ}setShadowProjectionMatrix(a,x,c){return this.customProjectionMatrixBuilder?this.customProjectionMatrixBuilder(x,c,a):this._setDefaultShadowProjectionMatrix(a,x,c),this}_syncParentEnabledState(){super._syncParentEnabledState(),(!this.parent||!this.parent.getWorldMatrix)&&(this.transformedPosition=null,this.transformedDirection=null)}getViewMatrix(a){const x=Yt.Vector3[0];let c=this.position;this.computeTransformedInformation()&&(c=this.transformedPosition),Ee.NormalizeToRef(this.getShadowDirection(a),x),Math.abs(Ee.Dot(x,Ee.Up()))===1&&(x.z=1e-13);const u=Yt.Vector3[1];return c.addToRef(x,u),vt.LookAtLHToRef(c,u,Ee.Up(),this._viewMatrix),this._viewMatrix}getProjectionMatrix(a,x){return this.setShadowProjectionMatrix(this._projectionMatrix,a??this._viewMatrix,x??[]),this._projectionMatrix}}Ye([En()],jc.prototype,"position",null),Ye([En()],jc.prototype,"direction",null),Ye([ht()],jc.prototype,"shadowMinZ",null),Ye([ht()],jc.prototype,"shadowMaxZ",null),fa.AddNodeConstructor("Light_Type_0",(F,a)=>()=>new yg(F,Ee.Zero(),a));class yg extends jc{get shadowAngle(){return this._shadowAngle}set shadowAngle(a){this._shadowAngle=a,this.forceProjectionMatrixCompute()}get direction(){return this._direction}set direction(a){const x=this.needCube();if(this._direction=a,this.needCube()!==x&&this._shadowGenerators){const c=this._shadowGenerators.values();for(let u=c.next();u.done!==!0;u=c.next())u.value.recreateShadowMap()}}constructor(a,x,c){super(a,c),this._shadowAngle=Math.PI/2,this.position=x}getClassName(){return"PointLight"}getTypeID(){return Wr.LIGHTTYPEID_POINTLIGHT}needCube(){return!this.direction}getShadowDirection(a){if(this.direction)return super.getShadowDirection(a);switch(a){case 0:return new Ee(1,0,0);case 1:return new Ee(-1,0,0);case 2:return new Ee(0,-1,0);case 3:return new Ee(0,1,0);case 4:return new Ee(0,0,1);case 5:return new Ee(0,0,-1)}return Ee.Zero()}_setDefaultShadowProjectionMatrix(a,x,c){const u=this.getScene().activeCamera;if(!u)return;const g=this.shadowMinZ!==void 0?this.shadowMinZ:u.minZ,y=this.shadowMaxZ!==void 0?this.shadowMaxZ:u.maxZ,v=this.getScene().getEngine().useReverseDepthBuffer;vt.PerspectiveFovLHToRef(this.shadowAngle,1,v?y:g,v?g:y,a,!0,this._scene.getEngine().isNDCHalfZRange,void 0,v)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(a,x){return this.computeTransformedInformation()?this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z,0,x):this._uniformBuffer.updateFloat4("vLightData",this.position.x,this.position.y,this.position.z,0,x),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,0,0,x),this}transferToNodeMaterialEffect(a,x){return this.computeTransformedInformation()?a.setFloat3(x,this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z):a.setFloat3(x,this.position.x,this.position.y,this.position.z),this}prepareLightSpecificDefines(a,x){a["POINTLIGHT"+x]=!0}}Ye([ht()],yg.prototype,"shadowAngle",null),fa.AddNodeConstructor("Light_Type_1",(F,a)=>()=>new Hl(F,Ee.Zero(),a));class Hl extends jc{get shadowFrustumSize(){return this._shadowFrustumSize}set shadowFrustumSize(a){this._shadowFrustumSize=a,this.forceProjectionMatrixCompute()}get shadowOrthoScale(){return this._shadowOrthoScale}set shadowOrthoScale(a){this._shadowOrthoScale=a,this.forceProjectionMatrixCompute()}get orthoLeft(){return this._orthoLeft}set orthoLeft(a){this._orthoLeft=a}get orthoRight(){return this._orthoRight}set orthoRight(a){this._orthoRight=a}get orthoTop(){return this._orthoTop}set orthoTop(a){this._orthoTop=a}get orthoBottom(){return this._orthoBottom}set orthoBottom(a){this._orthoBottom=a}constructor(a,x,c){super(a,c),this._shadowFrustumSize=0,this._shadowOrthoScale=.1,this.autoUpdateExtends=!0,this.autoCalcShadowZBounds=!1,this._orthoLeft=Number.MAX_VALUE,this._orthoRight=Number.MIN_VALUE,this._orthoTop=Number.MIN_VALUE,this._orthoBottom=Number.MAX_VALUE,this.position=x.scale(-1),this.direction=x}getClassName(){return"DirectionalLight"}getTypeID(){return Wr.LIGHTTYPEID_DIRECTIONALLIGHT}_setDefaultShadowProjectionMatrix(a,x,c){this.shadowFrustumSize>0?this._setDefaultFixedFrustumShadowProjectionMatrix(a):this._setDefaultAutoExtendShadowProjectionMatrix(a,x,c)}_setDefaultFixedFrustumShadowProjectionMatrix(a){const x=this.getScene().activeCamera;x&&vt.OrthoLHToRef(this.shadowFrustumSize,this.shadowFrustumSize,this.shadowMinZ!==void 0?this.shadowMinZ:x.minZ,this.shadowMaxZ!==void 0?this.shadowMaxZ:x.maxZ,a,this.getScene().getEngine().isNDCHalfZRange)}_setDefaultAutoExtendShadowProjectionMatrix(a,x,c){const u=this.getScene().activeCamera;if(!u)return;if(this.autoUpdateExtends||this._orthoLeft===Number.MAX_VALUE){const W=Ee.Zero();this._orthoLeft=Number.MAX_VALUE,this._orthoRight=-Number.MAX_VALUE,this._orthoTop=-Number.MAX_VALUE,this._orthoBottom=Number.MAX_VALUE;let ae=Number.MAX_VALUE,ue=-Number.MAX_VALUE;for(let fe=0;fe<c.length;fe++){const Re=c[fe];if(!Re)continue;const Be=Re.getBoundingInfo().boundingBox;for(let tt=0;tt<Be.vectorsWorld.length;tt++)Ee.TransformCoordinatesToRef(Be.vectorsWorld[tt],x,W),W.x<this._orthoLeft&&(this._orthoLeft=W.x),W.y<this._orthoBottom&&(this._orthoBottom=W.y),W.x>this._orthoRight&&(this._orthoRight=W.x),W.y>this._orthoTop&&(this._orthoTop=W.y),this.autoCalcShadowZBounds&&(W.z<ae&&(ae=W.z),W.z>ue&&(ue=W.z))}this.autoCalcShadowZBounds&&(this._shadowMinZ=ae,this._shadowMaxZ=ue)}const g=this._orthoRight-this._orthoLeft,y=this._orthoTop-this._orthoBottom,v=this.shadowMinZ!==void 0?this.shadowMinZ:u.minZ,w=this.shadowMaxZ!==void 0?this.shadowMaxZ:u.maxZ,B=this.getScene().getEngine().useReverseDepthBuffer;vt.OrthoOffCenterLHToRef(this._orthoLeft-g*this.shadowOrthoScale,this._orthoRight+g*this.shadowOrthoScale,this._orthoBottom-y*this.shadowOrthoScale,this._orthoTop+y*this.shadowOrthoScale,B?w:v,B?v:w,a,this.getScene().getEngine().isNDCHalfZRange)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(a,x){return this.computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z,1,x),this):(this._uniformBuffer.updateFloat4("vLightData",this.direction.x,this.direction.y,this.direction.z,1,x),this)}transferToNodeMaterialEffect(a,x){return this.computeTransformedInformation()?(a.setFloat3(x,this.transformedDirection.x,this.transformedDirection.y,this.transformedDirection.z),this):(a.setFloat3(x,this.direction.x,this.direction.y,this.direction.z),this)}getDepthMinZ(a){const x=this._scene.getEngine();return!x.useReverseDepthBuffer&&x.isNDCHalfZRange?0:1}getDepthMaxZ(a){const x=this._scene.getEngine();return x.useReverseDepthBuffer&&x.isNDCHalfZRange?0:1}prepareLightSpecificDefines(a,x){a["DIRLIGHT"+x]=!0}}Ye([ht()],Hl.prototype,"shadowFrustumSize",null),Ye([ht()],Hl.prototype,"shadowOrthoScale",null),Ye([ht()],Hl.prototype,"autoUpdateExtends",void 0),Ye([ht()],Hl.prototype,"autoCalcShadowZBounds",void 0),Ye([ht("orthoLeft")],Hl.prototype,"_orthoLeft",void 0),Ye([ht("orthoRight")],Hl.prototype,"_orthoRight",void 0),Ye([ht("orthoTop")],Hl.prototype,"_orthoTop",void 0),Ye([ht("orthoBottom")],Hl.prototype,"_orthoBottom",void 0);class In{static RegisterShaderCodeProcessing(a,x){if(!x){delete In._CustomShaderCodeProcessing[a??""];return}In._CustomShaderCodeProcessing[a??""]=x}static _GetShaderCodeProcessing(a){return In._CustomShaderCodeProcessing[a]??In._CustomShaderCodeProcessing[""]}get samples(){return this._samples}set samples(a){this._samples=Math.min(a,this._engine.getCaps().maxMSAASamples),this._textures.forEach(x=>{x.setSamples(this._samples)})}getEffectName(){return this._fragmentUrl}set onActivate(a){this._onActivateObserver&&this.onActivateObservable.remove(this._onActivateObserver),a&&(this._onActivateObserver=this.onActivateObservable.add(a))}set onSizeChanged(a){this._onSizeChangedObserver&&this.onSizeChangedObservable.remove(this._onSizeChangedObserver),this._onSizeChangedObserver=this.onSizeChangedObservable.add(a)}set onApply(a){this._onApplyObserver&&this.onApplyObservable.remove(this._onApplyObserver),this._onApplyObserver=this.onApplyObservable.add(a)}set onBeforeRender(a){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(a)}set onAfterRender(a){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(a)}get inputTexture(){return this._textures.data[this._currentRenderTextureInd]}set inputTexture(a){this._forcedOutputTexture=a}restoreDefaultInputTexture(){this._forcedOutputTexture&&(this._forcedOutputTexture=null,this.markTextureDirty())}getCamera(){return this._camera}get texelSize(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.texelSize:(this._forcedOutputTexture&&this._texelSize.copyFromFloats(1/this._forcedOutputTexture.width,1/this._forcedOutputTexture.height),this._texelSize)}constructor(a,x,c,u,g,y,v=1,w,B,W=null,ae=0,ue="postprocess",fe,Re=!1,_e=5,Be=_a.GLSL){this._parentContainer=null,this.width=-1,this.height=-1,this.nodeMaterialSource=null,this._outputTexture=null,this.autoClear=!0,this.forceAutoClearInAlphaMode=!1,this.alphaMode=0,this.animations=[],this.enablePixelPerfectMode=!1,this.forceFullscreenViewport=!0,this.scaleMode=1,this.alwaysForcePOT=!1,this._samples=1,this.adaptScaleToCurrentViewport=!1,this._reusable=!1,this._renderId=0,this.externalTextureSamplerBinding=!1,this._textures=new lt(2),this._textureCache=[],this._currentRenderTextureInd=0,this._scaleRatio=new mr(1,1),this._texelSize=mr.Zero(),this.onActivateObservable=new Jt,this.onSizeChangedObservable=new Jt,this.onApplyObservable=new Jt,this.onBeforeRenderObservable=new Jt,this.onAfterRenderObservable=new Jt,this.name=a;let tt=1,$e=null;if(c&&!Array.isArray(c)){const Et=c;c=Et.uniforms??null,u=Et.samplers??null,tt=Et.size??1,y=Et.camera??null,v=Et.samplingMode??1,w=Et.engine,B=Et.reusable,W=Et.defines??null,ae=Et.textureType??0,ue=Et.vertexUrl??"postprocess",fe=Et.indexParameters,Re=Et.blockCompilation??!1,_e=Et.textureFormat??5,Be=Et.shaderLanguage??_a.GLSL,$e=Et.uniformBuffers??null}else g&&(typeof g=="number"?tt=g:tt={width:g.width,height:g.height});y!=null?(this._camera=y,this._scene=y.getScene(),y.attachPostProcess(this),this._engine=this._scene.getEngine(),this._scene.postProcesses.push(this),this.uniqueId=this._scene.getUniqueId()):w&&(this._engine=w,this._engine.postProcesses.push(this)),this._options=tt,this.renderTargetSamplingMode=v||1,this._reusable=B||!1,this._textureType=ae,this._textureFormat=_e,this._shaderLanguage=Be,this._samplers=u||[],this._samplers.push("textureSampler"),this._fragmentUrl=x,this._vertexUrl=ue,this._parameters=c||[],this._parameters.push("scale"),this._uniformBuffers=$e||[],this._indexParameters=fe,this._drawWrapper=new Yo(this._engine),Re||this.updateEffect(W)}getClassName(){return"PostProcess"}getEngine(){return this._engine}getEffect(){return this._drawWrapper.effect}shareOutputWith(a){return this._disposeTextures(),this._shareOutputWithPostProcess=a,this}useOwnOutput(){this._textures.length==0&&(this._textures=new lt(2)),this._shareOutputWithPostProcess=null}updateEffect(a=null,x=null,c=null,u,g,y,v,w){const B=In._GetShaderCodeProcessing(this.name);if(B?.defineCustomBindings){const W=x?.slice()??[];W.push(...this._parameters);const ae=c?.slice()??[];ae.push(...this._samplers),a=B.defineCustomBindings(this.name,a,W,ae),x=W,c=ae}this._postProcessDefines=a,this._drawWrapper.effect=this._engine.createEffect({vertex:v??this._vertexUrl,fragment:w??this._fragmentUrl},{attributes:["position"],uniformsNames:x||this._parameters,uniformBuffersNames:this._uniformBuffers,samplers:c||this._samplers,defines:a!==null?a:"",fallbacks:null,onCompiled:g??null,onError:y??null,indexParameters:u||this._indexParameters,processCodeAfterIncludes:B?.processCodeAfterIncludes?(W,ae)=>B.processCodeAfterIncludes(this.name,W,ae):null,processFinalCode:B?.processFinalCode?(W,ae)=>B.processFinalCode(this.name,W,ae):null,shaderLanguage:this._shaderLanguage},this._engine)}isReusable(){return this._reusable}markTextureDirty(){this.width=-1}_createRenderTargetTexture(a,x,c=0){for(let g=0;g<this._textureCache.length;g++)if(this._textureCache[g].texture.width===a.width&&this._textureCache[g].texture.height===a.height&&this._textureCache[g].postProcessChannel===c&&this._textureCache[g].texture._generateDepthBuffer===x.generateDepthBuffer&&this._textureCache[g].texture.samples===x.samples)return this._textureCache[g].texture;const u=this._engine.createRenderTargetTexture(a,x);return this._textureCache.push({texture:u,postProcessChannel:c,lastUsedRenderId:-1}),u}_flushTextureCache(){const a=this._renderId;for(let x=this._textureCache.length-1;x>=0;x--)if(a-this._textureCache[x].lastUsedRenderId>100){let c=!1;for(let u=0;u<this._textures.length;u++)if(this._textures.data[u]===this._textureCache[x].texture){c=!0;break}c||(this._textureCache[x].texture.dispose(),this._textureCache.splice(x,1))}}resize(a,x,c=null,u=!1,g=!1){this._textures.length>0&&this._textures.reset(),this.width=a,this.height=x;let y=null;if(c){for(let B=0;B<c._postProcesses.length;B++)if(c._postProcesses[B]!==null){y=c._postProcesses[B];break}}const v={width:this.width,height:this.height},w={generateMipMaps:u,generateDepthBuffer:g||y===this,generateStencilBuffer:(g||y===this)&&this._engine.isStencilEnable,samplingMode:this.renderTargetSamplingMode,type:this._textureType,format:this._textureFormat,samples:this._samples,label:"PostProcessRTT-"+this.name};this._textures.push(this._createRenderTargetTexture(v,w,0)),this._reusable&&this._textures.push(this._createRenderTargetTexture(v,w,1)),this._texelSize.copyFromFloats(1/this.width,1/this.height),this.onSizeChangedObservable.notifyObservers(this)}_getTarget(){let a;if(this._shareOutputWithPostProcess)a=this._shareOutputWithPostProcess.inputTexture;else if(this._forcedOutputTexture)a=this._forcedOutputTexture,this.width=this._forcedOutputTexture.width,this.height=this._forcedOutputTexture.height;else{a=this.inputTexture;let x;for(let c=0;c<this._textureCache.length;c++)if(this._textureCache[c].texture===a){x=this._textureCache[c];break}x&&(x.lastUsedRenderId=this._renderId)}return a}activate(a,x=null,c){a=a||this._camera;const u=a.getScene(),g=u.getEngine(),y=g.getCaps().maxTextureSize,v=(x?x.width:this._engine.getRenderWidth(!0))*this._options|0,w=(x?x.height:this._engine.getRenderHeight(!0))*this._options|0;let B=this._options.width||v,W=this._options.height||w;const ae=this.renderTargetSamplingMode!==7&&this.renderTargetSamplingMode!==1&&this.renderTargetSamplingMode!==2;let ue=null;if(!this._shareOutputWithPostProcess&&!this._forcedOutputTexture){if(this.adaptScaleToCurrentViewport){const fe=g.currentViewport;fe&&(B*=fe.width,W*=fe.height)}(ae||this.alwaysForcePOT)&&(this._options.width||(B=g.needPOTTextures?Bt.GetExponentOfTwo(B,y,this.scaleMode):B),this._options.height||(W=g.needPOTTextures?Bt.GetExponentOfTwo(W,y,this.scaleMode):W)),(this.width!==B||this.height!==W||!(ue=this._getTarget()))&&this.resize(B,W,a,ae,c),this._textures.forEach(fe=>{fe.samples!==this.samples&&this._engine.updateRenderTargetTextureSampleCount(fe,this.samples)}),this._flushTextureCache(),this._renderId++}return ue||(ue=this._getTarget()),this.enablePixelPerfectMode?(this._scaleRatio.copyFromFloats(v/B,w/W),this._engine.bindFramebuffer(ue,0,v,w,this.forceFullscreenViewport)):(this._scaleRatio.copyFromFloats(1,1),this._engine.bindFramebuffer(ue,0,void 0,void 0,this.forceFullscreenViewport)),this._engine._debugInsertMarker?.(`post process ${this.name} input`),this.onActivateObservable.notifyObservers(a),this.autoClear&&(this.alphaMode===0||this.forceAutoClearInAlphaMode)&&this._engine.clear(this.clearColor?this.clearColor:u.clearColor,u._allowPostProcessClearColor,!0,!0),this._reusable&&(this._currentRenderTextureInd=(this._currentRenderTextureInd+1)%2),ue}get isSupported(){return this._drawWrapper.effect.isSupported}get aspectRatio(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.aspectRatio:this._forcedOutputTexture?this._forcedOutputTexture.width/this._forcedOutputTexture.height:this.width/this.height}isReady(){return this._drawWrapper.effect?.isReady()??!1}apply(){if(!this._drawWrapper.effect?.isReady())return null;this._engine.enableEffect(this._drawWrapper),this._engine.setState(!1),this._engine.setDepthBuffer(!1),this._engine.setDepthWrite(!1),this._engine.setAlphaMode(this.alphaMode),this.alphaConstants&&this.getEngine().setAlphaConstants(this.alphaConstants.r,this.alphaConstants.g,this.alphaConstants.b,this.alphaConstants.a);let a;return this._shareOutputWithPostProcess?a=this._shareOutputWithPostProcess.inputTexture:this._forcedOutputTexture?a=this._forcedOutputTexture:a=this.inputTexture,this.externalTextureSamplerBinding||this._drawWrapper.effect._bindTexture("textureSampler",a?.texture),this._drawWrapper.effect.setVector2("scale",this._scaleRatio),this.onApplyObservable.notifyObservers(this._drawWrapper.effect),In._GetShaderCodeProcessing(this.name)?.bindCustomBindings?.(this.name,this._drawWrapper.effect),this._drawWrapper.effect}_disposeTextures(){if(this._shareOutputWithPostProcess||this._forcedOutputTexture){this._disposeTextureCache();return}this._disposeTextureCache(),this._textures.dispose()}_disposeTextureCache(){for(let a=this._textureCache.length-1;a>=0;a--)this._textureCache[a].texture.dispose();this._textureCache.length=0}setPrePassRenderer(a){return this._prePassEffectConfiguration?(this._prePassEffectConfiguration=a.addEffectConfiguration(this._prePassEffectConfiguration),this._prePassEffectConfiguration.enabled=!0,!0):!1}dispose(a){a=a||this._camera,this._disposeTextures();let x;if(this._scene&&(x=this._scene.postProcesses.indexOf(this),x!==-1&&this._scene.postProcesses.splice(x,1)),this._parentContainer){const c=this._parentContainer.postProcesses.indexOf(this);c>-1&&this._parentContainer.postProcesses.splice(c,1),this._parentContainer=null}if(x=this._engine.postProcesses.indexOf(this),x!==-1&&this._engine.postProcesses.splice(x,1),!!a){if(a.detachPostProcess(this),x=a._postProcesses.indexOf(this),x===0&&a._postProcesses.length>0){const c=this._camera._getFirstPostProcess();c&&c.markTextureDirty()}this.onActivateObservable.clear(),this.onAfterRenderObservable.clear(),this.onApplyObservable.clear(),this.onBeforeRenderObservable.clear(),this.onSizeChangedObservable.clear()}}serialize(){const a=hr.Serialize(this),x=this.getCamera()||this._scene&&this._scene.activeCamera;return a.customType="BABYLON."+this.getClassName(),a.cameraId=x?x.id:null,a.reusable=this._reusable,a.textureType=this._textureType,a.fragmentUrl=this._fragmentUrl,a.parameters=this._parameters,a.samplers=this._samplers,a.options=this._options,a.defines=this._postProcessDefines,a.textureFormat=this._textureFormat,a.vertexUrl=this._vertexUrl,a.indexParameters=this._indexParameters,a}clone(){const a=this.serialize();a._engine=this._engine,a.cameraId=null;const x=In.Parse(a,this._scene,"");return x?(x.onActivateObservable=this.onActivateObservable.clone(),x.onSizeChangedObservable=this.onSizeChangedObservable.clone(),x.onApplyObservable=this.onApplyObservable.clone(),x.onBeforeRenderObservable=this.onBeforeRenderObservable.clone(),x.onAfterRenderObservable=this.onAfterRenderObservable.clone(),x._prePassEffectConfiguration=this._prePassEffectConfiguration,x):null}static Parse(a,x,c){const u=Ua(a.customType);if(!u||!u._Parse)return null;const g=x?x.getCameraById(a.cameraId):null;return u._Parse(a,g,x,c)}static _Parse(a,x,c,u){return hr.Parse(()=>new In(a.name,a.fragmentUrl,a.parameters,a.samplers,a.options,x,a.renderTargetSamplingMode,a._engine,a.reusable,a.defines,a.textureType,a.vertexUrl,a.indexParameters,!1,a.textureFormat),a,c,u)}}In._CustomShaderCodeProcessing={},Ye([ht()],In.prototype,"uniqueId",void 0),Ye([ht()],In.prototype,"name",void 0),Ye([ht()],In.prototype,"width",void 0),Ye([ht()],In.prototype,"height",void 0),Ye([ht()],In.prototype,"renderTargetSamplingMode",void 0),Ye([$y()],In.prototype,"clearColor",void 0),Ye([ht()],In.prototype,"autoClear",void 0),Ye([ht()],In.prototype,"forceAutoClearInAlphaMode",void 0),Ye([ht()],In.prototype,"alphaMode",void 0),Ye([ht()],In.prototype,"alphaConstants",void 0),Ye([ht()],In.prototype,"enablePixelPerfectMode",void 0),Ye([ht()],In.prototype,"forceFullscreenViewport",void 0),Ye([ht()],In.prototype,"scaleMode",void 0),Ye([ht()],In.prototype,"alwaysForcePOT",void 0),Ye([ht("samples")],In.prototype,"_samples",void 0),Ye([ht()],In.prototype,"adaptScaleToCurrentViewport",void 0),as("BABYLON.PostProcess",In);const $E="kernelBlurVaryingDeclaration",JE="varying vec2 sampleCoord{X};";hi.IncludesShadersStore[$E]=JE;const mU={name:$E,shader:JE},tA="packingFunctions",aA=`vec4 pack(float depth)
{const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}`;hi.IncludesShadersStore[tA]=aA;const gU={name:tA,shader:aA},xA="kernelBlurFragment",lA=`#ifdef DOF
factor=sampleCoC(sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;
#endif
`;hi.IncludesShadersStore[xA]=lA;const _U={name:xA,shader:lA},hA="kernelBlurFragment2",uA=`#ifdef DOF
factor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});computedWeight=KERNEL_DEP_WEIGHT{X}*factor;sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;hi.IncludesShadersStore[hA]=uA;const yU={name:hA,shader:uA},dA="kernelBlurPixelShader",fA=`uniform sampler2D textureSampler;uniform vec2 delta;varying vec2 sampleCenter;
#ifdef DOF
uniform sampler2D circleOfConfusionSampler;float sampleCoC(in vec2 offset) {float coc=texture2D(circleOfConfusionSampler,offset).r;return coc; }
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{float computedWeight=0.0;
#ifdef PACKEDFLOAT
float blend=0.;
#else
vec4 blend=vec4(0.);
#endif
#ifdef DOF
float sumOfWeights=CENTER_WEIGHT; 
float factor=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;
#else
blend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
gl_FragColor=pack(blend);
#else
gl_FragColor=blend;
#endif
#ifdef DOF
gl_FragColor/=sumOfWeights;
#endif
}`;hi.ShadersStore[dA]=fA;const bU={name:dA,shader:fA},mA="kernelBlurVertex",gA="sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";hi.IncludesShadersStore[mA]=gA;const EU={name:mA,shader:gA},_A="kernelBlurVertexShader",yA=`attribute vec2 position;uniform vec2 delta;varying vec2 sampleCenter;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
sampleCenter=(position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;hi.ShadersStore[_A]=yA;const vU={name:_A,shader:yA};class Yc extends In{set kernel(a){this._idealKernel!==a&&(a=Math.max(a,1),this._idealKernel=a,this._kernel=this._nearestBestKernel(a),this._blockCompilation||this._updateParameters())}get kernel(){return this._idealKernel}set packedFloat(a){this._packedFloat!==a&&(this._packedFloat=a,this._blockCompilation||this._updateParameters())}get packedFloat(){return this._packedFloat}getClassName(){return"BlurPostProcess"}constructor(a,x,c,u,g,y=fi.BILINEAR_SAMPLINGMODE,v,w,B=0,W="",ae=!1,ue=5){super(a,"kernelBlur",["delta","direction"],["circleOfConfusionSampler"],u,g,y,v,w,null,B,"kernelBlur",{varyingCount:0,depCount:0},!0,ue),this._blockCompilation=ae,this._packedFloat=!1,this._staticDefines="",this._staticDefines=W,this.direction=x,this.onApplyObservable.add(fe=>{this._outputTexture?fe.setFloat2("delta",1/this._outputTexture.width*this.direction.x,1/this._outputTexture.height*this.direction.y):fe.setFloat2("delta",1/this.width*this.direction.x,1/this.height*this.direction.y)}),this.kernel=c}updateEffect(a=null,x=null,c=null,u,g,y){this._updateParameters(g,y)}_updateParameters(a,x){const c=this._kernel,u=(c-1)/2;let g=[],y=[],v=0;for(let Be=0;Be<c;Be++){const tt=Be/(c-1),$e=this._gaussianWeight(tt*2-1);g[Be]=Be-u,y[Be]=$e,v+=$e}for(let Be=0;Be<y.length;Be++)y[Be]/=v;const w=[],B=[],W=[];for(let Be=0;Be<=u;Be+=2){const tt=Math.min(Be+1,Math.floor(u));if(Be===tt)W.push({o:g[Be],w:y[Be]});else{const Et=tt===u,ft=y[Be]+y[tt]*(Et?.5:1),dt=g[Be]+1/(1+y[Be]/y[tt]);dt===0?(W.push({o:g[Be],w:y[Be]}),W.push({o:g[Be+1],w:y[Be+1]})):(W.push({o:dt,w:ft}),W.push({o:-dt,w:ft}))}}for(let Be=0;Be<W.length;Be++)B[Be]=W[Be].o,w[Be]=W[Be].w;g=B,y=w;const ae=this.getEngine().getCaps().maxVaryingVectors,ue=Math.max(ae,0)-1;let fe=Math.min(g.length,ue),Re="";Re+=this._staticDefines,this._staticDefines.indexOf("DOF")!=-1&&(Re+=`#define CENTER_WEIGHT ${this._glslFloat(y[fe-1])}
`,fe--);for(let Be=0;Be<fe;Be++)Re+=`#define KERNEL_OFFSET${Be} ${this._glslFloat(g[Be])}
`,Re+=`#define KERNEL_WEIGHT${Be} ${this._glslFloat(y[Be])}
`;let _e=0;for(let Be=ue;Be<g.length;Be++)Re+=`#define KERNEL_DEP_OFFSET${_e} ${this._glslFloat(g[Be])}
`,Re+=`#define KERNEL_DEP_WEIGHT${_e} ${this._glslFloat(y[Be])}
`,_e++;this.packedFloat&&(Re+="#define PACKEDFLOAT 1"),this._blockCompilation=!1,super.updateEffect(Re,null,null,{varyingCount:fe,depCount:_e},a,x)}_nearestBestKernel(a){const x=Math.round(a);for(const c of[x,x-1,x+1,x-2,x+2])if(c%2!==0&&Math.floor(c/2)%2===0&&c>0)return Math.max(c,3);return Math.max(x,3)}_gaussianWeight(a){const x=.3333333333333333,c=Math.sqrt(2*Math.PI)*x,u=-(a*a/(2*x*x));return 1/c*Math.exp(u)}_glslFloat(a,x=8){return a.toFixed(x).replace(/0+$/,"")}static _Parse(a,x,c,u){return hr.Parse(()=>new Yc(a.name,a.direction,a.kernel,a.options,x,a.renderTargetSamplingMode,c.getEngine(),a.reusable,a.textureType,void 0,!1),a,c,u)}}Ye([ht("kernel")],Yc.prototype,"_kernel",void 0),Ye([ht("packedFloat")],Yc.prototype,"_packedFloat",void 0),Ye([Vh()],Yc.prototype,"direction",void 0),as("BABYLON.BlurPostProcess",Yc);const bA="bayerDitherFunctions",EA=`float bayerDither2(vec2 _P) {return mod(2.0*_P.y+_P.x+1.0,4.0);}
float bayerDither4(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5*mod(_P,4.0)); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);}
float bayerDither8(vec2 _P) {vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5 *mod(_P,4.0)); 
vec2 P4=floor(0.25*mod(_P,8.0)); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);}
`;hi.IncludesShadersStore[bA]=EA;const IU={name:bA,shader:EA},vA="shadowMapFragmentExtraDeclaration",IA=`#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform float softTransparentShadowSM;
#endif
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
uniform vec3 lightDataSM;varying vec3 vPositionWSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;hi.IncludesShadersStore[vA]=IA;const RU={name:vA,shader:IA},RA="shadowMapFragment",MA=`float depthSM=vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
depthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_FragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
gl_FragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
gl_FragColor=vec4(depthSM,1.0,1.0,1.0);
#else
gl_FragColor=pack(depthSM);
#endif
return;`;hi.IncludesShadersStore[RA]=MA;const MU={name:RA,shader:MA},BA="shadowMapPixelShader",UA=`#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEXTURE
float alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;
#ifdef ALPHATESTVALUE
if (alphaFromAlphaTexture<ALPHATESTVALUE)
discard;
#endif
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEXTURE
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;
#else
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;
#endif
#endif
#include<shadowMapFragment>
}`;hi.ShadersStore[BA]=UA;const BU={name:BA,shader:UA},VA="bakedVertexAnimationDeclaration",WA=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}
#endif
`;hi.IncludesShadersStore[VA]=WA;const UU={name:VA,shader:WA},HA="morphTargetsVertexGlobalDeclaration",XA=`#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}
#endif
#endif
`;hi.IncludesShadersStore[HA]=XA;const VU={name:HA,shader:XA},jA="morphTargetsVertexDeclaration",YA=`#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#elif {X}==0
uniform int morphTargetCount;
#endif
#endif
`;hi.IncludesShadersStore[jA]=YA;const WU={name:jA,shader:YA},$A="sceneVertexDeclaration",JA=`uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform mat4 view;uniform mat4 projection;uniform vec4 vEyePosition;
`;hi.IncludesShadersStore[$A]=JA;const HU={name:$A,shader:JA},tv="meshVertexDeclaration",av=`uniform mat4 world;uniform float visibility;
`;hi.IncludesShadersStore[tv]=av;const XU={name:tv,shader:av},xv="shadowMapVertexDeclaration",lv=`#include<sceneVertexDeclaration>
#include<meshVertexDeclaration>
`;hi.IncludesShadersStore[xv]=lv;const jU={name:xv,shader:lv},hv="sceneUboDeclaration",uv=`layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;mat4 projection;vec4 vEyePosition;};
`;hi.IncludesShadersStore[hv]=uv;const YU={name:hv,shader:uv},dv="meshUboDeclaration",fv=`#ifdef WEBGL2
uniform mat4 world;uniform float visibility;
#else
layout(std140,column_major) uniform;uniform Mesh
{mat4 world;float visibility;};
#endif
#define WORLD_UBO
`;hi.IncludesShadersStore[dv]=fv;const $U={name:dv,shader:fv},mv="shadowMapUboDeclaration",gv=`layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;hi.IncludesShadersStore[mv]=gv;const JU={name:mv,shader:gv},_v="shadowMapVertexExtraDeclaration",yv=`#if SM_NORMALBIAS==1
uniform vec3 lightDataSM;
#endif
uniform vec3 biasAndScaleSM;uniform vec2 depthValuesSM;varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
varying vec3 vPositionWSM;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;hi.IncludesShadersStore[_v]=yv;const tV={name:_v,shader:yv},bv="morphTargetsVertexGlobal",Ev=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;hi.IncludesShadersStore[bv]=Ev;const aV={name:bv,shader:Ev},vv="morphTargetsVertex",Iv=`#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
#if {X}==0
for (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];
#endif
}
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;hi.IncludesShadersStore[vv]=Iv;const xV={name:vv,shader:Iv},Rv="bakedVertexAnimation",Mv=`#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`;hi.IncludesShadersStore[Rv]=Mv;const lV={name:Rv,shader:Mv},Bv="shadowMapVertexNormalBias",Uv=`#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
vec3 worldLightDirSM=normalize(-lightDataSM.xyz);
#else
vec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;vec3 worldLightDirSM=normalize(directionToLightSM);
#endif
float ndlSM=dot(vNormalW,worldLightDirSM);float sinNLSM=sqrt(1.0-ndlSM*ndlSM);float normalBiasSM=biasAndScaleSM.y*sinNLSM;worldPos.xyz-=vNormalW*normalBiasSM;
#endif
`;hi.IncludesShadersStore[Bv]=Uv;const hV={name:Bv,shader:Uv},Vv="shadowMapVertexMetric",Wv=`#if SM_USEDISTANCE==1
vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#else
gl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
zSM=gl_Position.z;gl_Position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
vDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
`;hi.IncludesShadersStore[Vv]=Wv;const uV={name:Vv,shader:Wv},Hv="shadowMapVertexShader",Xv=`attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#endif
#include<helperFunctions>
#include<__decl__shadowMapVertex>
#ifdef ALPHATEXTURE
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normWorldSM=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vec3 vNormalW=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
gl_Position=viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
}`;hi.ShadersStore[Hv]=Xv;const dV={name:Hv,shader:Xv},jv="depthBoxBlurPixelShader",Yv=`varying vec2 vUV;uniform sampler2D textureSampler;uniform vec2 screenSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{vec4 colorDepth=vec4(0.0);for (int x=-OFFSET; x<=OFFSET; x++)
for (int y=-OFFSET; y<=OFFSET; y++)
colorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);gl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));}`;hi.ShadersStore[jv]=Yv;const fV={name:jv,shader:Yv},$v="shadowMapFragmentSoftTransparentShadow",Jv=`#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;
#endif
`;hi.IncludesShadersStore[$v]=Jv;const mV={name:$v,shader:Jv};class Hs{get bias(){return this._bias}set bias(a){this._bias=a}get normalBias(){return this._normalBias}set normalBias(a){this._normalBias=a}get blurBoxOffset(){return this._blurBoxOffset}set blurBoxOffset(a){this._blurBoxOffset!==a&&(this._blurBoxOffset=a,this._disposeBlurPostProcesses())}get blurScale(){return this._blurScale}set blurScale(a){this._blurScale!==a&&(this._blurScale=a,this._disposeBlurPostProcesses())}get blurKernel(){return this._blurKernel}set blurKernel(a){this._blurKernel!==a&&(this._blurKernel=a,this._disposeBlurPostProcesses())}get useKernelBlur(){return this._useKernelBlur}set useKernelBlur(a){this._useKernelBlur!==a&&(this._useKernelBlur=a,this._disposeBlurPostProcesses())}get depthScale(){return this._depthScale!==void 0?this._depthScale:this._light.getDepthScale()}set depthScale(a){this._depthScale=a}_validateFilter(a){return a}get filter(){return this._filter}set filter(a){if(a=this._validateFilter(a),this._light.needCube()){if(a===Hs.FILTER_BLUREXPONENTIALSHADOWMAP){this.useExponentialShadowMap=!0;return}else if(a===Hs.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP){this.useCloseExponentialShadowMap=!0;return}else if(a===Hs.FILTER_PCF||a===Hs.FILTER_PCSS){this.usePoissonSampling=!0;return}}if((a===Hs.FILTER_PCF||a===Hs.FILTER_PCSS)&&!this._scene.getEngine()._features.supportShadowSamplers){this.usePoissonSampling=!0;return}this._filter!==a&&(this._filter=a,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get usePoissonSampling(){return this.filter===Hs.FILTER_POISSONSAMPLING}set usePoissonSampling(a){const x=this._validateFilter(Hs.FILTER_POISSONSAMPLING);!a&&this.filter!==Hs.FILTER_POISSONSAMPLING||(this.filter=a?x:Hs.FILTER_NONE)}get useExponentialShadowMap(){return this.filter===Hs.FILTER_EXPONENTIALSHADOWMAP}set useExponentialShadowMap(a){const x=this._validateFilter(Hs.FILTER_EXPONENTIALSHADOWMAP);!a&&this.filter!==Hs.FILTER_EXPONENTIALSHADOWMAP||(this.filter=a?x:Hs.FILTER_NONE)}get useBlurExponentialShadowMap(){return this.filter===Hs.FILTER_BLUREXPONENTIALSHADOWMAP}set useBlurExponentialShadowMap(a){const x=this._validateFilter(Hs.FILTER_BLUREXPONENTIALSHADOWMAP);!a&&this.filter!==Hs.FILTER_BLUREXPONENTIALSHADOWMAP||(this.filter=a?x:Hs.FILTER_NONE)}get useCloseExponentialShadowMap(){return this.filter===Hs.FILTER_CLOSEEXPONENTIALSHADOWMAP}set useCloseExponentialShadowMap(a){const x=this._validateFilter(Hs.FILTER_CLOSEEXPONENTIALSHADOWMAP);!a&&this.filter!==Hs.FILTER_CLOSEEXPONENTIALSHADOWMAP||(this.filter=a?x:Hs.FILTER_NONE)}get useBlurCloseExponentialShadowMap(){return this.filter===Hs.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP}set useBlurCloseExponentialShadowMap(a){const x=this._validateFilter(Hs.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);!a&&this.filter!==Hs.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP||(this.filter=a?x:Hs.FILTER_NONE)}get usePercentageCloserFiltering(){return this.filter===Hs.FILTER_PCF}set usePercentageCloserFiltering(a){const x=this._validateFilter(Hs.FILTER_PCF);!a&&this.filter!==Hs.FILTER_PCF||(this.filter=a?x:Hs.FILTER_NONE)}get filteringQuality(){return this._filteringQuality}set filteringQuality(a){this._filteringQuality!==a&&(this._filteringQuality=a,this._disposeBlurPostProcesses(),this._applyFilterValues(),this._light._markMeshesAsLightDirty())}get useContactHardeningShadow(){return this.filter===Hs.FILTER_PCSS}set useContactHardeningShadow(a){const x=this._validateFilter(Hs.FILTER_PCSS);!a&&this.filter!==Hs.FILTER_PCSS||(this.filter=a?x:Hs.FILTER_NONE)}get contactHardeningLightSizeUVRatio(){return this._contactHardeningLightSizeUVRatio}set contactHardeningLightSizeUVRatio(a){this._contactHardeningLightSizeUVRatio=a}get darkness(){return this._darkness}set darkness(a){this.setDarkness(a)}getDarkness(){return this._darkness}setDarkness(a){return a>=1?this._darkness=1:a<=0?this._darkness=0:this._darkness=a,this}get transparencyShadow(){return this._transparencyShadow}set transparencyShadow(a){this.setTransparencyShadow(a)}setTransparencyShadow(a){return this._transparencyShadow=a,this}getShadowMap(){return this._shadowMap}getShadowMapForRendering(){return this._shadowMap2?this._shadowMap2:this._shadowMap}getClassName(){return Hs.CLASSNAME}addShadowCaster(a,x=!0){if(!this._shadowMap)return this;if(this._shadowMap.renderList||(this._shadowMap.renderList=[]),this._shadowMap.renderList.indexOf(a)===-1&&this._shadowMap.renderList.push(a),x)for(const c of a.getChildMeshes())this._shadowMap.renderList.indexOf(c)===-1&&this._shadowMap.renderList.push(c);return this}removeShadowCaster(a,x=!0){if(!this._shadowMap||!this._shadowMap.renderList)return this;const c=this._shadowMap.renderList.indexOf(a);if(c!==-1&&this._shadowMap.renderList.splice(c,1),x)for(const u of a.getChildren())this.removeShadowCaster(u);return this}getLight(){return this._light}_getCamera(){return this._camera??this._scene.activeCamera}get mapSize(){return this._mapSize}set mapSize(a){this._mapSize=a,this._light._markMeshesAsLightDirty(),this.recreateShadowMap()}constructor(a,x,c,u,g){this.onBeforeShadowMapRenderObservable=new Jt,this.onAfterShadowMapRenderObservable=new Jt,this.onBeforeShadowMapRenderMeshObservable=new Jt,this.onAfterShadowMapRenderMeshObservable=new Jt,this._bias=5e-5,this._normalBias=0,this._blurBoxOffset=1,this._blurScale=2,this._blurKernel=1,this._useKernelBlur=!1,this._filter=Hs.FILTER_NONE,this._filteringQuality=Hs.QUALITY_HIGH,this._contactHardeningLightSizeUVRatio=.1,this._darkness=0,this._transparencyShadow=!1,this.enableSoftTransparentShadow=!1,this.useOpacityTextureForTransparentShadow=!1,this.frustumEdgeFalloff=0,this.forceBackFacesOnly=!1,this._lightDirection=Ee.Zero(),this._viewMatrix=vt.Zero(),this._projectionMatrix=vt.Zero(),this._transformMatrix=vt.Zero(),this._cachedPosition=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cachedDirection=new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._currentFaceIndex=0,this._currentFaceIndexCache=0,this._defaultTextureMatrix=vt.Identity(),this._mapSize=a,this._light=x,this._scene=x.getScene(),this._camera=u??null,this._useRedTextureType=!!g;let y=x._shadowGenerators;y||(y=x._shadowGenerators=new Map),y.set(this._camera,this),this.id=x.id,this._useUBO=this._scene.getEngine().supportsUniformBuffers,this._useUBO&&(this._sceneUBOs=[],this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`))),Hs._SceneComponentInitialization(this._scene);const v=this._scene.getEngine().getCaps();c?v.textureFloatRender&&v.textureFloatLinearFiltering?this._textureType=1:v.textureHalfFloatRender&&v.textureHalfFloatLinearFiltering?this._textureType=2:this._textureType=0:v.textureHalfFloatRender&&v.textureHalfFloatLinearFiltering?this._textureType=2:v.textureFloatRender&&v.textureFloatLinearFiltering?this._textureType=1:this._textureType=0,this._initializeGenerator(),this._applyFilterValues()}_initializeGenerator(){this._light._markMeshesAsLightDirty(),this._initializeShadowMap()}_createTargetRenderTexture(){const a=this._scene.getEngine();a._features.supportDepthStencilTexture?(this._shadowMap=new Bo(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube(),void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(a.useReverseDepthBuffer?516:513,!0)):this._shadowMap=new Bo(this._light.name+"_shadowMap",this._mapSize,this._scene,!1,!0,this._textureType,this._light.needCube()),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(this._createTargetRenderTexture(),this._shadowMap===null)return;this._shadowMap.wrapU=fi.CLAMP_ADDRESSMODE,this._shadowMap.wrapV=fi.CLAMP_ADDRESSMODE,this._shadowMap.anisotropicFilteringLevel=1,this._shadowMap.updateSamplingMode(fi.BILINEAR_SAMPLINGMODE),this._shadowMap.renderParticles=!1,this._shadowMap.ignoreCameraViewport=!0,this._storedUniqueId&&(this._shadowMap.uniqueId=this._storedUniqueId),this._shadowMap.customRenderFunction=(u,g,y,v)=>this._renderForShadowMap(u,g,y,v),this._shadowMap.customIsReadyFunction=()=>!0;const a=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.add(()=>{this._currentSceneUBO=this._scene.getSceneUniformBuffer(),a._debugPushGroup?.(`shadow map generation for pass id ${a.currentRenderPassId}`,1)}),this._shadowMap.onBeforeRenderObservable.add(u=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[0]),this._currentFaceIndex=u,this._filter===Hs.FILTER_PCF&&a.setColorWrite(!1),this.getTransformMatrix(),this._scene.setTransformMatrix(this._viewMatrix,this._projectionMatrix),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onAfterUnbindObservable.add(()=>{if(this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._currentSceneUBO),this._scene.updateTransformMatrix(),this._filter===Hs.FILTER_PCF&&a.setColorWrite(!0),!this.useBlurExponentialShadowMap&&!this.useBlurCloseExponentialShadowMap){a._debugPopGroup?.(1);return}const u=this.getShadowMapForRendering();u&&(this._scene.postProcessManager.directRender(this._blurPostProcesses,u.renderTarget,!0),a.unBindFramebuffer(u.renderTarget,!0),a._debugPopGroup?.(1))});const x=new Yr(0,0,0,0),c=new Yr(1,1,1,1);this._shadowMap.onClearObservable.add(u=>{this._filter===Hs.FILTER_PCF?u.clear(c,!1,!0,!1):this.useExponentialShadowMap||this.useBlurExponentialShadowMap?u.clear(x,!0,!0,!1):u.clear(c,!0,!0,!1)}),this._shadowMap.onResizeObservable.add(u=>{this._storedUniqueId=this._shadowMap.uniqueId,this._mapSize=u.getRenderSize(),this._light._markMeshesAsLightDirty(),this.recreateShadowMap()});for(let u=io.MIN_RENDERINGGROUPS;u<io.MAX_RENDERINGGROUPS;u++)this._shadowMap.setRenderingAutoClearDepthStencil(u,!1)}_initializeBlurRTTAndPostProcesses(){const a=this._scene.getEngine(),x=this._mapSize/this.blurScale;(!this.useKernelBlur||this.blurScale!==1)&&(this._shadowMap2=new Bo(this._light.name+"_shadowMap2",x,this._scene,!1,!0,this._textureType,void 0,void 0,!1),this._shadowMap2.wrapU=fi.CLAMP_ADDRESSMODE,this._shadowMap2.wrapV=fi.CLAMP_ADDRESSMODE,this._shadowMap2.updateSamplingMode(fi.BILINEAR_SAMPLINGMODE)),this.useKernelBlur?(this._kernelBlurXPostprocess=new Yc(this._light.name+"KernelBlurX",new mr(1,0),this.blurKernel,1,null,fi.BILINEAR_SAMPLINGMODE,a,!1,this._textureType),this._kernelBlurXPostprocess.width=x,this._kernelBlurXPostprocess.height=x,this._kernelBlurXPostprocess.externalTextureSamplerBinding=!0,this._kernelBlurXPostprocess.onApplyObservable.add(c=>{c.setTexture("textureSampler",this._shadowMap)}),this._kernelBlurYPostprocess=new Yc(this._light.name+"KernelBlurY",new mr(0,1),this.blurKernel,1,null,fi.BILINEAR_SAMPLINGMODE,a,!1,this._textureType),this._kernelBlurXPostprocess.autoClear=!1,this._kernelBlurYPostprocess.autoClear=!1,this._textureType===0&&(this._kernelBlurXPostprocess.packedFloat=!0,this._kernelBlurYPostprocess.packedFloat=!0),this._blurPostProcesses=[this._kernelBlurXPostprocess,this._kernelBlurYPostprocess]):(this._boxBlurPostprocess=new In(this._light.name+"DepthBoxBlur","depthBoxBlur",["screenSize","boxOffset"],[],1,null,fi.BILINEAR_SAMPLINGMODE,a,!1,"#define OFFSET "+this._blurBoxOffset,this._textureType),this._boxBlurPostprocess.externalTextureSamplerBinding=!0,this._boxBlurPostprocess.onApplyObservable.add(c=>{c.setFloat2("screenSize",x,x),c.setTexture("textureSampler",this._shadowMap)}),this._boxBlurPostprocess.autoClear=!1,this._blurPostProcesses=[this._boxBlurPostprocess])}_renderForShadowMap(a,x,c,u){let g;if(u.length)for(g=0;g<u.length;g++)this._renderSubMeshForShadowMap(u.data[g]);for(g=0;g<a.length;g++)this._renderSubMeshForShadowMap(a.data[g]);for(g=0;g<x.length;g++)this._renderSubMeshForShadowMap(x.data[g]);if(this._transparencyShadow)for(g=0;g<c.length;g++)this._renderSubMeshForShadowMap(c.data[g],!0);else for(g=0;g<c.length;g++)c.data[g].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}_bindCustomEffectForRenderSubMeshForShadowMap(a,x,c){x.setMatrix("viewProjection",this.getTransformMatrix())}_renderSubMeshForShadowMap(a,x=!1){const c=a.getRenderingMesh(),u=a.getEffectiveMesh(),g=this._scene,y=g.getEngine(),v=a.getMaterial();if(u._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!v||a.verticesCount===0||a._renderId===g.getRenderId())return;const w=u._getWorldMatrixDeterminant()<0;let B=c.overrideMaterialSideOrientation??v.sideOrientation;w&&(B=B===0?1:0);const W=B===0;y.setState(v.backFaceCulling,void 0,void 0,W,v.cullBackFaces);const ae=c._getInstancesRenderList(a._id,!!a.getReplacementMesh());if(ae.mustReturn)return;const ue=y.getCaps().instancedArrays&&(ae.visibleInstances[a._id]!==null&&ae.visibleInstances[a._id]!==void 0||c.hasThinInstances);if(!(this.customAllowRendering&&!this.customAllowRendering(a)))if(this.isReady(a,ue,x)){a._renderId=g.getRenderId();const fe=v.shadowDepthWrapper,Re=fe?.getEffect(a,this,y.currentRenderPassId)??a._getDrawWrapper(),_e=Yo.GetEffect(Re);y.enableEffect(Re),ue||c._bind(a,_e,v.fillMode),this.getTransformMatrix(),_e.setFloat3("biasAndScaleSM",this.bias,this.normalBias,this.depthScale),this.getLight().getTypeID()===Wr.LIGHTTYPEID_DIRECTIONALLIGHT?_e.setVector3("lightDataSM",this._cachedDirection):_e.setVector3("lightDataSM",this._cachedPosition);const Be=this._getCamera();if(Be&&_e.setFloat2("depthValuesSM",this.getLight().getDepthMinZ(Be),this.getLight().getDepthMinZ(Be)+this.getLight().getDepthMaxZ(Be)),x&&this.enableSoftTransparentShadow&&_e.setFloat("softTransparentShadowSM",u.visibility*v.alpha),fe)a._setMainDrawWrapperOverride(Re),fe.standalone?fe.baseMaterial.bindForSubMesh(u.getWorldMatrix(),c,a):v.bindForSubMesh(u.getWorldMatrix(),c,a),a._setMainDrawWrapperOverride(null);else{if(this._opacityTexture&&(_e.setTexture("diffuseSampler",this._opacityTexture),_e.setMatrix("diffuseMatrix",this._opacityTexture.getTextureMatrix()||this._defaultTextureMatrix)),c.useBones&&c.computeBonesUsingShaders&&c.skeleton){const $e=c.skeleton;if($e.isUsingTextureForMatrices){const Et=$e.getTransformMatrixTexture(c);if(!Et)return;_e.setTexture("boneSampler",Et),_e.setFloat("boneTextureWidth",4*($e.bones.length+1))}else _e.setMatrices("mBones",$e.getTransformMatrices(c))}gg(c,_e),c.morphTargetManager&&c.morphTargetManager.isUsingTextureForTargets&&c.morphTargetManager._bind(_e),fg(_e,v,g)}!this._useUBO&&!fe&&this._bindCustomEffectForRenderSubMeshForShadowMap(a,_e,u),c_(_e,this._scene.getSceneUniformBuffer()),this._scene.getSceneUniformBuffer().bindUniformBuffer();const tt=u.getWorldMatrix();ue&&(u.getMeshUniformBuffer().bindToEffect(_e,"Mesh"),u.transferToEffect(tt)),this.forceBackFacesOnly&&y.setState(!0,0,!1,!0,v.cullBackFaces),this.onBeforeShadowMapRenderMeshObservable.notifyObservers(c),this.onBeforeShadowMapRenderObservable.notifyObservers(_e),c._processRendering(u,a,_e,v.fillMode,ae,ue,($e,Et)=>{u!==c&&!$e?(c.getMeshUniformBuffer().bindToEffect(_e,"Mesh"),c.transferToEffect(Et)):(u.getMeshUniformBuffer().bindToEffect(_e,"Mesh"),u.transferToEffect($e?Et:tt))}),this.forceBackFacesOnly&&y.setState(!0,0,!1,!1,v.cullBackFaces),this.onAfterShadowMapRenderObservable.notifyObservers(_e),this.onAfterShadowMapRenderMeshObservable.notifyObservers(c)}else this._shadowMap&&this._shadowMap.resetRefreshCounter()}_applyFilterValues(){this._shadowMap&&(this.filter===Hs.FILTER_NONE||this.filter===Hs.FILTER_PCSS?this._shadowMap.updateSamplingMode(fi.NEAREST_SAMPLINGMODE):this._shadowMap.updateSamplingMode(fi.BILINEAR_SAMPLINGMODE))}forceCompilation(a,x){const c={useInstances:!1,...x},u=this.getShadowMap();if(!u){a&&a(this);return}const g=u.renderList;if(!g){a&&a(this);return}const y=[];for(const B of g)y.push(...B.subMeshes);if(y.length===0){a&&a(this);return}let v=0;const w=()=>{if(!(!this._scene||!this._scene.getEngine())){for(;this.isReady(y[v],c.useInstances,y[v].getMaterial()?.needAlphaBlendingForMesh(y[v].getMesh())??!1);)if(v++,v>=y.length){a&&a(this);return}setTimeout(w,16)}};w()}forceCompilationAsync(a){return new Promise(x=>{this.forceCompilation(()=>{x()},a)})}_isReadyCustomDefines(a,x,c){}_prepareShadowDefines(a,x,c,u){c.push("#define SM_LIGHTTYPE_"+this._light.getClassName().toUpperCase()),c.push("#define SM_FLOAT "+(this._textureType!==0?"1":"0")),c.push("#define SM_ESM "+(this.useExponentialShadowMap||this.useBlurExponentialShadowMap?"1":"0")),c.push("#define SM_DEPTHTEXTURE "+(this.usePercentageCloserFiltering||this.useContactHardeningShadow?"1":"0"));const g=a.getMesh();return c.push("#define SM_NORMALBIAS "+(this.normalBias&&g.isVerticesDataPresent(Ve.NormalKind)?"1":"0")),c.push("#define SM_DIRECTIONINLIGHTDATA "+(this.getLight().getTypeID()===Wr.LIGHTTYPEID_DIRECTIONALLIGHT?"1":"0")),c.push("#define SM_USEDISTANCE "+(this._light.needCube()?"1":"0")),c.push("#define SM_SOFTTRANSPARENTSHADOW "+(this.enableSoftTransparentShadow&&u?"1":"0")),this._isReadyCustomDefines(c,a,x),c}isReady(a,x,c){const u=a.getMaterial(),g=u?.shadowDepthWrapper;if(this._opacityTexture=null,!u)return!1;const y=[];if(this._prepareShadowDefines(a,x,y,c),g){if(!g.isReadyForSubMesh(a,y,this,x,this._scene.getEngine().currentRenderPassId))return!1}else{const v=a._getDrawWrapper(void 0,!0);let w=v.effect,B=v.defines;const W=[Ve.PositionKind],ae=a.getMesh();this.normalBias&&ae.isVerticesDataPresent(Ve.NormalKind)&&(W.push(Ve.NormalKind),y.push("#define NORMAL"),ae.nonUniformScaling&&y.push("#define NONUNIFORMSCALING"));const ue=u.needAlphaTesting();if((ue||u.needAlphaBlending())&&(this.useOpacityTextureForTransparentShadow?this._opacityTexture=u.opacityTexture:this._opacityTexture=u.getAlphaTestTexture(),this._opacityTexture)){if(!this._opacityTexture.isReady())return!1;const tt=u.alphaCutOff??Hs.DEFAULT_ALPHA_CUTOFF;y.push("#define ALPHATEXTURE"),ue&&y.push(`#define ALPHATESTVALUE ${tt}${tt%1===0?".":""}`),ae.isVerticesDataPresent(Ve.UVKind)&&(W.push(Ve.UVKind),y.push("#define UV1")),ae.isVerticesDataPresent(Ve.UV2Kind)&&this._opacityTexture.coordinatesIndex===1&&(W.push(Ve.UV2Kind),y.push("#define UV2"))}const fe=new m_;if(ae.useBones&&ae.computeBonesUsingShaders&&ae.skeleton){W.push(Ve.MatricesIndicesKind),W.push(Ve.MatricesWeightsKind),ae.numBoneInfluencers>4&&(W.push(Ve.MatricesIndicesExtraKind),W.push(Ve.MatricesWeightsExtraKind));const tt=ae.skeleton;y.push("#define NUM_BONE_INFLUENCERS "+ae.numBoneInfluencers),ae.numBoneInfluencers>0&&fe.addCPUSkinningFallback(0,ae),tt.isUsingTextureForMatrices?y.push("#define BONETEXTURE"):y.push("#define BonesPerMesh "+(tt.bones.length+1))}else y.push("#define NUM_BONE_INFLUENCERS 0");const Re=ae.morphTargetManager;let _e=0;if(Re&&(_e=Re.numMaxInfluencers||Re.numInfluencers,_e>0&&(y.push("#define MORPHTARGETS"),y.push("#define NUM_MORPH_INFLUENCERS "+_e),Re.isUsingTextureForTargets&&y.push("#define MORPHTARGETS_TEXTURE"),YT(W,ae,_e))),l_(u,this._scene,y),x&&(y.push("#define INSTANCES"),mg(W),a.getRenderingMesh().hasThinInstances&&y.push("#define THIN_INSTANCES")),this.customShaderOptions&&this.customShaderOptions.defines)for(const tt of this.customShaderOptions.defines)y.indexOf(tt)===-1&&y.push(tt);const Be=y.join(`
`);if(B!==Be){B=Be;let tt="shadowMap";const $e=["world","mBones","viewProjection","diffuseMatrix","lightDataSM","depthValuesSM","biasAndScaleSM","morphTargetInfluences","morphTargetCount","boneTextureWidth","softTransparentShadowSM","morphTargetTextureInfo","morphTargetTextureIndices"],Et=["diffuseSampler","boneSampler","morphTargets"],ft=["Scene","Mesh"];if(dg($e),this.customShaderOptions){if(tt=this.customShaderOptions.shaderName,this.customShaderOptions.attributes)for(const ut of this.customShaderOptions.attributes)W.indexOf(ut)===-1&&W.push(ut);if(this.customShaderOptions.uniforms)for(const ut of this.customShaderOptions.uniforms)$e.indexOf(ut)===-1&&$e.push(ut);if(this.customShaderOptions.samplers)for(const ut of this.customShaderOptions.samplers)Et.indexOf(ut)===-1&&Et.push(ut)}const dt=this._scene.getEngine();w=dt.createEffect(tt,{attributes:W,uniformsNames:$e,uniformBuffersNames:ft,samplers:Et,defines:Be,fallbacks:fe,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:_e}},dt),v.setEffect(w,B)}if(!w.isReady())return!1}return(this.useBlurExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(!this._blurPostProcesses||!this._blurPostProcesses.length)&&this._initializeBlurRTTAndPostProcesses(),!(this._kernelBlurXPostprocess&&!this._kernelBlurXPostprocess.isReady()||this._kernelBlurYPostprocess&&!this._kernelBlurYPostprocess.isReady()||this._boxBlurPostprocess&&!this._boxBlurPostprocess.isReady())}prepareDefines(a,x){const c=this._scene,u=this._light;!c.shadowsEnabled||!u.shadowEnabled||(a["SHADOW"+x]=!0,this.useContactHardeningShadow?(a["SHADOWPCSS"+x]=!0,this._filteringQuality===Hs.QUALITY_LOW?a["SHADOWLOWQUALITY"+x]=!0:this._filteringQuality===Hs.QUALITY_MEDIUM&&(a["SHADOWMEDIUMQUALITY"+x]=!0)):this.usePercentageCloserFiltering?(a["SHADOWPCF"+x]=!0,this._filteringQuality===Hs.QUALITY_LOW?a["SHADOWLOWQUALITY"+x]=!0:this._filteringQuality===Hs.QUALITY_MEDIUM&&(a["SHADOWMEDIUMQUALITY"+x]=!0)):this.usePoissonSampling?a["SHADOWPOISSON"+x]=!0:this.useExponentialShadowMap||this.useBlurExponentialShadowMap?a["SHADOWESM"+x]=!0:(this.useCloseExponentialShadowMap||this.useBlurCloseExponentialShadowMap)&&(a["SHADOWCLOSEESM"+x]=!0),u.needCube()&&(a["SHADOWCUBE"+x]=!0))}bindShadowLight(a,x){const c=this._light;if(!this._scene.shadowsEnabled||!c.shadowEnabled)return;const g=this._getCamera();if(!g)return;const y=this.getShadowMap();y&&(c.needCube()||x.setMatrix("lightMatrix"+a,this.getTransformMatrix()),this._filter===Hs.FILTER_PCF?(x.setDepthStencilTexture("shadowSampler"+a,this.getShadowMapForRendering()),c._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),y.getSize().width,1/y.getSize().width,this.frustumEdgeFalloff,a)):this._filter===Hs.FILTER_PCSS?(x.setDepthStencilTexture("shadowSampler"+a,this.getShadowMapForRendering()),x.setTexture("depthSampler"+a,this.getShadowMapForRendering()),c._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/y.getSize().width,this._contactHardeningLightSizeUVRatio*y.getSize().width,this.frustumEdgeFalloff,a)):(x.setTexture("shadowSampler"+a,this.getShadowMapForRendering()),c._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),this.blurScale/y.getSize().width,this.depthScale,this.frustumEdgeFalloff,a)),c._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(g),this.getLight().getDepthMinZ(g)+this.getLight().getDepthMaxZ(g),a))}get viewMatrix(){return this._viewMatrix}get projectionMatrix(){return this._projectionMatrix}getTransformMatrix(){const a=this._scene;if(this._currentRenderId===a.getRenderId()&&this._currentFaceIndexCache===this._currentFaceIndex)return this._transformMatrix;this._currentRenderId=a.getRenderId(),this._currentFaceIndexCache=this._currentFaceIndex;let x=this._light.position;if(this._light.computeTransformedInformation()&&(x=this._light.transformedPosition),Ee.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex),this._lightDirection),Math.abs(Ee.Dot(this._lightDirection,Ee.Up()))===1&&(this._lightDirection.z=1e-13),this._light.needProjectionMatrixCompute()||!this._cachedPosition||!this._cachedDirection||!x.equals(this._cachedPosition)||!this._lightDirection.equals(this._cachedDirection)){this._cachedPosition.copyFrom(x),this._cachedDirection.copyFrom(this._lightDirection),vt.LookAtLHToRef(x,x.add(this._lightDirection),Ee.Up(),this._viewMatrix);const c=this.getShadowMap();if(c){const u=c.renderList;u&&this._light.setShadowProjectionMatrix(this._projectionMatrix,this._viewMatrix,u)}this._viewMatrix.multiplyToRef(this._projectionMatrix,this._transformMatrix)}return this._transformMatrix}recreateShadowMap(){const a=this._shadowMap;if(!a)return;const x=a.renderList;if(this._disposeRTTandPostProcesses(),this._initializeGenerator(),this.filter=this._filter,this._applyFilterValues(),x){this._shadowMap.renderList||(this._shadowMap.renderList=[]);for(const c of x)this._shadowMap.renderList.push(c)}else this._shadowMap.renderList=null}_disposeBlurPostProcesses(){this._shadowMap2&&(this._shadowMap2.dispose(),this._shadowMap2=null),this._boxBlurPostprocess&&(this._boxBlurPostprocess.dispose(),this._boxBlurPostprocess=null),this._kernelBlurXPostprocess&&(this._kernelBlurXPostprocess.dispose(),this._kernelBlurXPostprocess=null),this._kernelBlurYPostprocess&&(this._kernelBlurYPostprocess.dispose(),this._kernelBlurYPostprocess=null),this._blurPostProcesses=[]}_disposeRTTandPostProcesses(){this._shadowMap&&(this._shadowMap.dispose(),this._shadowMap=null),this._disposeBlurPostProcesses()}_disposeSceneUBOs(){if(this._sceneUBOs){for(const a of this._sceneUBOs)a.dispose();this._sceneUBOs=[]}}dispose(){if(this._disposeRTTandPostProcesses(),this._disposeSceneUBOs(),this._light){if(this._light._shadowGenerators){const a=this._light._shadowGenerators.entries();for(let x=a.next();x.done!==!0;x=a.next()){const[c,u]=x.value;u===this&&this._light._shadowGenerators.delete(c)}this._light._shadowGenerators.size===0&&(this._light._shadowGenerators=null)}this._light._markMeshesAsLightDirty()}this.onBeforeShadowMapRenderMeshObservable.clear(),this.onBeforeShadowMapRenderObservable.clear(),this.onAfterShadowMapRenderMeshObservable.clear(),this.onAfterShadowMapRenderObservable.clear()}serialize(){const a={},x=this.getShadowMap();if(!x)return a;if(a.className=this.getClassName(),a.lightId=this._light.id,a.cameraId=this._camera?.id,a.id=this.id,a.mapSize=x.getRenderSize(),a.forceBackFacesOnly=this.forceBackFacesOnly,a.darkness=this.getDarkness(),a.transparencyShadow=this._transparencyShadow,a.frustumEdgeFalloff=this.frustumEdgeFalloff,a.bias=this.bias,a.normalBias=this.normalBias,a.usePercentageCloserFiltering=this.usePercentageCloserFiltering,a.useContactHardeningShadow=this.useContactHardeningShadow,a.contactHardeningLightSizeUVRatio=this.contactHardeningLightSizeUVRatio,a.filteringQuality=this.filteringQuality,a.useExponentialShadowMap=this.useExponentialShadowMap,a.useBlurExponentialShadowMap=this.useBlurExponentialShadowMap,a.useCloseExponentialShadowMap=this.useBlurExponentialShadowMap,a.useBlurCloseExponentialShadowMap=this.useBlurExponentialShadowMap,a.usePoissonSampling=this.usePoissonSampling,a.depthScale=this.depthScale,a.blurBoxOffset=this.blurBoxOffset,a.blurKernel=this.blurKernel,a.blurScale=this.blurScale,a.useKernelBlur=this.useKernelBlur,a.renderList=[],x.renderList)for(let c=0;c<x.renderList.length;c++){const u=x.renderList[c];a.renderList.push(u.id)}return a}static Parse(a,x,c){const u=x.getLightById(a.lightId),g=a.cameraId!==void 0?x.getCameraById(a.cameraId):null,y=c?c(a.mapSize,u,g):new Hs(a.mapSize,u,void 0,g),v=y.getShadowMap();for(let w=0;w<a.renderList.length;w++)x.getMeshesById(a.renderList[w]).forEach(function(W){v&&(v.renderList||(v.renderList=[]),v.renderList.push(W))});return a.id!==void 0&&(y.id=a.id),y.forceBackFacesOnly=!!a.forceBackFacesOnly,a.darkness!==void 0&&y.setDarkness(a.darkness),a.transparencyShadow&&y.setTransparencyShadow(!0),a.frustumEdgeFalloff!==void 0&&(y.frustumEdgeFalloff=a.frustumEdgeFalloff),a.bias!==void 0&&(y.bias=a.bias),a.normalBias!==void 0&&(y.normalBias=a.normalBias),a.usePercentageCloserFiltering?y.usePercentageCloserFiltering=!0:a.useContactHardeningShadow?y.useContactHardeningShadow=!0:a.usePoissonSampling?y.usePoissonSampling=!0:a.useExponentialShadowMap?y.useExponentialShadowMap=!0:a.useBlurExponentialShadowMap?y.useBlurExponentialShadowMap=!0:a.useCloseExponentialShadowMap?y.useCloseExponentialShadowMap=!0:a.useBlurCloseExponentialShadowMap?y.useBlurCloseExponentialShadowMap=!0:a.useVarianceShadowMap?y.useExponentialShadowMap=!0:a.useBlurVarianceShadowMap&&(y.useBlurExponentialShadowMap=!0),a.contactHardeningLightSizeUVRatio!==void 0&&(y.contactHardeningLightSizeUVRatio=a.contactHardeningLightSizeUVRatio),a.filteringQuality!==void 0&&(y.filteringQuality=a.filteringQuality),a.depthScale&&(y.depthScale=a.depthScale),a.blurScale&&(y.blurScale=a.blurScale),a.blurBoxOffset&&(y.blurBoxOffset=a.blurBoxOffset),a.useKernelBlur&&(y.useKernelBlur=a.useKernelBlur),a.blurKernel&&(y.blurKernel=a.blurKernel),y}}Hs.CLASSNAME="ShadowGenerator",Hs.FILTER_NONE=0,Hs.FILTER_EXPONENTIALSHADOWMAP=1,Hs.FILTER_POISSONSAMPLING=2,Hs.FILTER_BLUREXPONENTIALSHADOWMAP=3,Hs.FILTER_CLOSEEXPONENTIALSHADOWMAP=4,Hs.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP=5,Hs.FILTER_PCF=6,Hs.FILTER_PCSS=7,Hs.QUALITY_HIGH=0,Hs.QUALITY_MEDIUM=1,Hs.QUALITY_LOW=2,Hs.DEFAULT_ALPHA_CUTOFF=.5,Hs._SceneComponentInitialization=F=>{throw js("ShadowGeneratorSceneComponent")};class f0{static get ForceFullSceneLoadingForIncremental(){return f0._ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(a){f0._ForceFullSceneLoadingForIncremental=a}static get ShowLoadingScreen(){return f0._ShowLoadingScreen}static set ShowLoadingScreen(a){f0._ShowLoadingScreen=a}static get loggingLevel(){return f0._LoggingLevel}static set loggingLevel(a){f0._LoggingLevel=a}static get CleanBoneMatrixWeights(){return f0._CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(a){f0._CleanBoneMatrixWeights=a}}f0._ForceFullSceneLoadingForIncremental=!1,f0._ShowLoadingScreen=!0,f0._CleanBoneMatrixWeights=!1,f0._LoggingLevel=0;var $c;(function(F){F[F.Clean=0]="Clean",F[F.Stop=1]="Stop",F[F.Sync=2]="Sync",F[F.NoSync=3]="NoSync"})($c||($c={}));class ln{static get ForceFullSceneLoadingForIncremental(){return f0.ForceFullSceneLoadingForIncremental}static set ForceFullSceneLoadingForIncremental(a){f0.ForceFullSceneLoadingForIncremental=a}static get ShowLoadingScreen(){return f0.ShowLoadingScreen}static set ShowLoadingScreen(a){f0.ShowLoadingScreen=a}static get loggingLevel(){return f0.loggingLevel}static set loggingLevel(a){f0.loggingLevel=a}static get CleanBoneMatrixWeights(){return f0.CleanBoneMatrixWeights}static set CleanBoneMatrixWeights(a){f0.CleanBoneMatrixWeights=a}static GetDefaultPlugin(){return ln._RegisteredPlugins[".babylon"]}static _GetPluginForExtension(a){const x=ln._RegisteredPlugins[a];return x||(Qt.Warn("Unable to find a plugin to load "+a+" files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes"),ln.GetDefaultPlugin())}static _GetPluginForDirectLoad(a){for(const x in ln._RegisteredPlugins){const c=ln._RegisteredPlugins[x].plugin;if(c.canDirectLoad&&c.canDirectLoad(a))return ln._RegisteredPlugins[x]}return ln.GetDefaultPlugin()}static _GetPluginForFilename(a){const x=a.indexOf("?");x!==-1&&(a=a.substring(0,x));const c=a.lastIndexOf("."),u=a.substring(c,a.length).toLowerCase();return ln._GetPluginForExtension(u)}static _GetDirectLoad(a){return a.substr(0,5)==="data:"?a.substr(5):null}static _FormatErrorMessage(a,x,c){let g="Unable to load from "+(a.rawData?"binary data":a.url);return x?g+=`: ${x}`:c&&(g+=`: ${c}`),g}static _LoadData(a,x,c,u,g,y,v,w){const B=ln._GetDirectLoad(a.url);if(a.rawData&&!v)throw"When using ArrayBufferView to load data the file extension must be provided.";const W=v?ln._GetPluginForExtension(v):B?ln._GetPluginForDirectLoad(a.url):ln._GetPluginForFilename(a.url);if(a.rawData&&!W.isBinary)throw"Loading from ArrayBufferView can not be used with plugins that don't support binary loading.";let ae;if(W.plugin.createPlugin!==void 0?ae=W.plugin.createPlugin():ae=W.plugin,!ae)throw"The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";if(ln.OnPluginActivatedObservable.notifyObservers(ae),B&&(ae.canDirectLoad&&ae.canDirectLoad(a.url)||!bl(a.url))){if(ae.directLoad){const ft=ae.directLoad(x,B);ft.then?ft.then(dt=>{c(ae,dt)}).catch(dt=>{g("Error in directLoad of _loadData: "+dt,dt)}):c(ae,ft)}else c(ae,B);return ae}const ue=W.isBinary,fe=(ft,dt)=>{if(x.isDisposed){g("Scene has been disposed");return}c(ae,ft,dt)};let Re=null,_e=!1;const Be=ae.onDisposeObservable;Be&&Be.add(()=>{_e=!0,Re&&(Re.abort(),Re=null),y()});const tt=()=>{if(_e)return;const ft=(dt,ut)=>{g(dt?.statusText,ut)};if(!ae.loadFile&&a.rawData)throw"Plugin does not support loading ArrayBufferView.";Re=ae.loadFile?ae.loadFile(x,a.rawData||a.file||a.url,a.rootUrl,fe,u,ue,ft,w):x._loadFile(a.file||a.url,fe,u,!0,ue,ft)},$e=x.getEngine();let Et=$e.enableOfflineSupport;if(Et){let ft=!1;for(const dt of x.disableOfflineSupportExceptionRules)if(dt.test(a.url)){ft=!0;break}Et=!ft}return Et&&Bt.OfflineProviderFactory?x.offlineProvider=Bt.OfflineProviderFactory(a.url,tt,$e.disableManifestCheck):tt(),ae}static _GetFileInfo(a,x){let c,u,g=null,y=null;if(!x)c=a,u=_t.GetFilename(a),a=_t.GetFolderPath(a);else if(x.name){const v=x;c=`file:${v.name}`,u=v.name,g=v}else if(ArrayBuffer.isView(x))c="",u=v0(),y=x;else if(typeof x=="string"&&x.startsWith("data:"))c=x,u="";else{const v=x;if(v.substr(0,1)==="/")return _t.Error("Wrong sceneFilename parameter"),null;c=a+v,u=v}return{url:c,rootUrl:a,name:u,file:g,rawData:y}}static GetPluginForExtension(a){return ln._GetPluginForExtension(a).plugin}static IsPluginForExtensionAvailable(a){return!!ln._RegisteredPlugins[a]}static RegisterPlugin(a){if(typeof a.extensions=="string"){const x=a.extensions;ln._RegisteredPlugins[x.toLowerCase()]={plugin:a,isBinary:!1}}else{const x=a.extensions;Object.keys(x).forEach(c=>{ln._RegisteredPlugins[c.toLowerCase()]={plugin:a,isBinary:x[c].isBinary}})}}static ImportMesh(a,x,c="",u=tr.LastCreatedScene,g=null,y=null,v=null,w=null,B=""){if(!u)return Qt.Error("No scene available to import mesh to"),null;const W=ln._GetFileInfo(x,c);if(!W)return null;const ae={};u.addPendingData(ae);const ue=()=>{u.removePendingData(ae)},fe=(Be,tt)=>{const $e=ln._FormatErrorMessage(W,Be,tt);v?v(u,$e,new Xo($e,Ho.SceneLoaderError,tt)):Qt.Error($e),ue()},Re=y?Be=>{try{y(Be)}catch(tt){fe("Error in onProgress callback: "+tt,tt)}}:void 0,_e=(Be,tt,$e,Et,ft,dt,ut,Mt)=>{if(u.importedMeshesFiles.push(W.url),g)try{g(Be,tt,$e,Et,ft,dt,ut,Mt)}catch(ai){fe("Error in onSuccess callback: "+ai,ai)}u.removePendingData(ae)};return ln._LoadData(W,u,(Be,tt,$e)=>{if(Be.rewriteRootURL&&(W.rootUrl=Be.rewriteRootURL(W.rootUrl,$e)),Be.importMesh){const Et=Be,ft=[],dt=[],ut=[];if(!Et.importMesh(a,u,tt,W.rootUrl,ft,dt,ut,fe))return;u.loadingPluginName=Be.name,_e(ft,dt,ut,[],[],[],[],[])}else Be.importMeshAsync(a,u,tt,W.rootUrl,Re,W.name).then(ft=>{u.loadingPluginName=Be.name,_e(ft.meshes,ft.particleSystems,ft.skeletons,ft.animationGroups,ft.transformNodes,ft.geometries,ft.lights,ft.spriteManagers)}).catch(ft=>{fe(ft.message,ft)})},Re,fe,ue,w,B)}static ImportMeshAsync(a,x,c="",u=tr.LastCreatedScene,g=null,y=null,v=""){return new Promise((w,B)=>{ln.ImportMesh(a,x,c,u,(W,ae,ue,fe,Re,_e,Be,tt)=>{w({meshes:W,particleSystems:ae,skeletons:ue,animationGroups:fe,transformNodes:Re,geometries:_e,lights:Be,spriteManagers:tt})},g,(W,ae,ue)=>{B(ue||new Error(ae))},y,v)})}static Load(a,x="",c=tr.LastCreatedEngine,u=null,g=null,y=null,v=null,w=""){return c?ln.Append(a,x,new H0(c),u,g,y,v,w):(_t.Error("No engine available"),null)}static LoadAsync(a,x="",c=tr.LastCreatedEngine,u=null,g=null,y=""){return new Promise((v,w)=>{ln.Load(a,x,c,B=>{v(B)},u,(B,W,ae)=>{w(ae||new Error(W))},g,y)})}static Append(a,x="",c=tr.LastCreatedScene,u=null,g=null,y=null,v=null,w=""){if(!c)return Qt.Error("No scene available to append to"),null;const B=ln._GetFileInfo(a,x);if(!B)return null;const W={};c.addPendingData(W);const ae=()=>{c.removePendingData(W)};ln.ShowLoadingScreen&&!this._ShowingLoadingScreen&&(this._ShowingLoadingScreen=!0,c.getEngine().displayLoadingUI(),c.executeWhenReady(()=>{c.getEngine().hideLoadingUI(),this._ShowingLoadingScreen=!1}));const ue=(_e,Be)=>{const tt=ln._FormatErrorMessage(B,_e,Be);y?y(c,tt,new Xo(tt,Ho.SceneLoaderError,Be)):Qt.Error(tt),ae()},fe=g?_e=>{try{g(_e)}catch(Be){ue("Error in onProgress callback",Be)}}:void 0,Re=()=>{if(u)try{u(c)}catch(_e){ue("Error in onSuccess callback",_e)}c.removePendingData(W)};return ln._LoadData(B,c,(_e,Be)=>{if(_e.load){if(!_e.load(c,Be,B.rootUrl,ue))return;c.loadingPluginName=_e.name,Re()}else _e.loadAsync(c,Be,B.rootUrl,fe,B.name).then(()=>{c.loadingPluginName=_e.name,Re()}).catch($e=>{ue($e.message,$e)})},fe,ue,ae,v,w)}static AppendAsync(a,x="",c=tr.LastCreatedScene,u=null,g=null,y=""){return new Promise((v,w)=>{ln.Append(a,x,c,B=>{v(B)},u,(B,W,ae)=>{w(ae||new Error(W))},g,y)})}static LoadAssetContainer(a,x="",c=tr.LastCreatedScene,u=null,g=null,y=null,v=null,w=""){if(!c)return Qt.Error("No scene available to load asset container to"),null;const B=ln._GetFileInfo(a,x);if(!B)return null;const W={};c.addPendingData(W);const ae=()=>{c.removePendingData(W)},ue=(_e,Be)=>{const tt=ln._FormatErrorMessage(B,_e,Be);y?y(c,tt,new Xo(tt,Ho.SceneLoaderError,Be)):Qt.Error(tt),ae()},fe=g?_e=>{try{g(_e)}catch(Be){ue("Error in onProgress callback",Be)}}:void 0,Re=_e=>{if(u)try{u(_e)}catch(Be){ue("Error in onSuccess callback",Be)}c.removePendingData(W)};return ln._LoadData(B,c,(_e,Be)=>{if(_e.loadAssetContainer){const $e=_e.loadAssetContainer(c,Be,B.rootUrl,ue);if(!$e)return;$e.populateRootNodes(),c.loadingPluginName=_e.name,Re($e)}else _e.loadAssetContainerAsync?_e.loadAssetContainerAsync(c,Be,B.rootUrl,fe,B.name).then($e=>{$e.populateRootNodes(),c.loadingPluginName=_e.name,Re($e)}).catch($e=>{ue($e.message,$e)}):ue("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.")},fe,ue,ae,v,w)}static LoadAssetContainerAsync(a,x="",c=tr.LastCreatedScene,u=null,g=null){return new Promise((y,v)=>{ln.LoadAssetContainer(a,x,c,w=>{y(w)},u,(w,B,W)=>{v(W||new Error(B))},g)})}static ImportAnimations(a,x="",c=tr.LastCreatedScene,u=!0,g=$c.Clean,y=null,v=null,w=null,B=null,W=null){if(!c){Qt.Error("No scene available to load animations to");return}if(u){for(const Re of c.animatables)Re.reset();c.stopAllAnimations(),c.animationGroups.slice().forEach(Re=>{Re.dispose()}),c.getNodes().forEach(Re=>{Re.animations&&(Re.animations=[])})}else switch(g){case $c.Clean:c.animationGroups.slice().forEach(fe=>{fe.dispose()});break;case $c.Stop:c.animationGroups.forEach(fe=>{fe.stop()});break;case $c.Sync:c.animationGroups.forEach(fe=>{fe.reset(),fe.restart()});break;case $c.NoSync:break;default:Qt.Error("Unknown animation group loading mode value '"+g+"'");return}const ae=c.animatables.length,ue=fe=>{fe.mergeAnimationsTo(c,c.animatables.slice(ae),y),fe.dispose(),c.onAnimationFileImportedObservable.notifyObservers(c),v&&v(c)};this.LoadAssetContainer(a,x,c,ue,w,B,W)}static ImportAnimationsAsync(a,x="",c=tr.LastCreatedScene,u=!0,g=$c.Clean,y=null,v=null,w=null,B=null,W=null){return new Promise((ae,ue)=>{ln.ImportAnimations(a,x,c,u,g,y,fe=>{ae(fe)},w,(fe,Re,_e)=>{ue(_e||new Error(Re))},W)})}}ln.NO_LOGGING=0,ln.MINIMAL_LOGGING=1,ln.SUMMARY_LOGGING=2,ln.DETAILED_LOGGING=3,ln.OnPluginActivatedObservable=new Jt,ln._RegisteredPlugins={},ln._ShowingLoadingScreen=!1;const t1="depthPixelShader",a1=`#ifdef ALPHATEST
varying vec2 vUV;uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
varying float vDepthMetric;
#ifdef PACKED
#include<packingFunctions>
#endif
#ifdef STORE_CAMERASPACE_Z
varying vec4 vViewPos;
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#ifdef STORE_CAMERASPACE_Z
#ifdef PACKED
gl_FragColor=pack(vViewPos.z);
#else
gl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);
#endif
#else
#ifdef NONLINEARDEPTH
#ifdef PACKED
gl_FragColor=pack(gl_FragCoord.z);
#else
gl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
gl_FragColor=pack(vDepthMetric);
#else
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
#endif
#endif
}`;hi.ShadersStore[t1]=a1;const gV={name:t1,shader:a1},x1="pointCloudVertexDeclaration",l1=`#ifdef POINTSIZE
uniform float pointSize;
#endif
`;hi.IncludesShadersStore[x1]=l1;const _V={name:x1,shader:l1},h1="pointCloudVertex",u1=`#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`;hi.IncludesShadersStore[h1]=u1;const yV={name:h1,shader:u1},d1="depthVertexShader",f1=`attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#ifdef STORE_CAMERASPACE_Z
uniform mat4 view;varying vec4 vViewPos;
#endif
#include<pointCloudVertexDeclaration>
varying float vDepthMetric;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#include<clipPlaneVertex>
gl_Position=viewProjection*worldPos;
#ifdef STORE_CAMERASPACE_Z
vViewPos=view*worldPos;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#include<pointCloudVertex>
}
`;hi.ShadersStore[d1]=f1;const bV={name:d1,shader:f1};class bg{setMaterialForRendering(a,x){this._depthMap.setMaterialForRendering(a,x)}constructor(a,x=1,c=null,u=!1,g=fi.TRILINEAR_SAMPLINGMODE,y=!1,v){this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this.useOnlyInActiveCamera=!1,this.reverseCulling=!1,this._scene=a,this._storeNonLinearDepth=u,this._storeCameraSpaceZ=y,this.isPacked=x===0,this.isPacked?this.clearColor=new Yr(1,1,1,1):this.clearColor=new Yr(y?1e8:1,0,0,1),bg._SceneComponentInitialization(this._scene);const w=a.getEngine();this._camera=c,g!==fi.NEAREST_SAMPLINGMODE&&(x===1&&!w._caps.textureFloatLinearFiltering&&(g=fi.NEAREST_SAMPLINGMODE),x===2&&!w._caps.textureHalfFloatLinearFiltering&&(g=fi.NEAREST_SAMPLINGMODE));const B=this.isPacked||!w._features.supportExtendedTextureFormats?5:6;this._depthMap=new Bo(v??"DepthRenderer",{width:w.getRenderWidth(),height:w.getRenderHeight()},this._scene,!1,!0,x,!1,g,void 0,void 0,void 0,B),this._depthMap.wrapU=fi.CLAMP_ADDRESSMODE,this._depthMap.wrapV=fi.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.noPrePassRenderer=!0,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add(ae=>{ae.clear(this.clearColor,!0,!0,!0)}),this._depthMap.onBeforeBindObservable.add(()=>{w._debugPushGroup?.("depth renderer",1)}),this._depthMap.onAfterUnbindObservable.add(()=>{w._debugPopGroup?.(1)}),this._depthMap.customIsReadyFunction=(ae,ue,fe)=>{if((fe||ue===0)&&ae.subMeshes)for(let Re=0;Re<ae.subMeshes.length;++Re){const _e=ae.subMeshes[Re],Be=_e.getRenderingMesh(),tt=Be._getInstancesRenderList(_e._id,!!_e.getReplacementMesh()),$e=w.getCaps().instancedArrays&&(tt.visibleInstances[_e._id]!==null&&tt.visibleInstances[_e._id]!==void 0||Be.hasThinInstances);if(!this.isReady(_e,$e))return!1}return!0};const W=ae=>{const ue=ae.getRenderingMesh(),fe=ae.getEffectiveMesh(),Re=this._scene,_e=Re.getEngine(),Be=ae.getMaterial();if(fe._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!Be||fe.infiniteDistance||Be.disableDepthWrite||ae.verticesCount===0||ae._renderId===Re.getRenderId())return;const tt=fe._getWorldMatrixDeterminant()<0;let $e=ue.overrideMaterialSideOrientation??Be.sideOrientation;tt&&($e=$e===0?1:0);const Et=$e===0;_e.setState(Be.backFaceCulling,0,!1,Et,this.reverseCulling?!Be.cullBackFaces:Be.cullBackFaces);const ft=ue._getInstancesRenderList(ae._id,!!ae.getReplacementMesh());if(ft.mustReturn)return;const dt=_e.getCaps().instancedArrays&&(ft.visibleInstances[ae._id]!==null&&ft.visibleInstances[ae._id]!==void 0||ue.hasThinInstances),ut=this._camera||Re.activeCamera;if(this.isReady(ae,dt)&&ut){ae._renderId=Re.getRenderId();const Mt=fe._internalAbstractMeshDataInfo._materialForRenderPass?.[_e.currentRenderPassId];let ai=ae._getDrawWrapper();!ai&&Mt&&(ai=Mt._getDrawWrapper());const Yi=ut.mode===gr.ORTHOGRAPHIC_CAMERA;if(!ai)return;const Vi=ai.effect;_e.enableEffect(ai),dt||ue._bind(ae,Vi,Be.fillMode),Mt?Mt.bindForSubMesh(fe.getWorldMatrix(),fe,ae):(Vi.setMatrix("viewProjection",Re.getTransformMatrix()),Vi.setMatrix("world",fe.getWorldMatrix()),this._storeCameraSpaceZ&&Vi.setMatrix("view",Re.getViewMatrix()));let Js,Rr;if(Yi?(Js=!_e.useReverseDepthBuffer&&_e.isNDCHalfZRange?0:1,Rr=_e.useReverseDepthBuffer&&_e.isNDCHalfZRange?0:1):(Js=_e.useReverseDepthBuffer&&_e.isNDCHalfZRange?ut.minZ:_e.isNDCHalfZRange?0:ut.minZ,Rr=_e.useReverseDepthBuffer&&_e.isNDCHalfZRange?0:ut.maxZ),Vi.setFloat2("depthValues",Js,Js+Rr),!Mt){if(Be.needAlphaTesting()){const _r=Be.getAlphaTestTexture();_r&&(Vi.setTexture("diffuseSampler",_r),Vi.setMatrix("diffuseMatrix",_r.getTextureMatrix()))}if(ue.useBones&&ue.computeBonesUsingShaders&&ue.skeleton){const _r=ue.skeleton;if(_r.isUsingTextureForMatrices){const Vr=_r.getTransformMatrixTexture(ue);if(!Vr)return;Vi.setTexture("boneSampler",Vr),Vi.setFloat("boneTextureWidth",4*(_r.bones.length+1))}else Vi.setMatrices("mBones",_r.getTransformMatrices(ue))}fg(Vi,Be,Re),gg(ue,Vi),ue.morphTargetManager&&ue.morphTargetManager.isUsingTextureForTargets&&ue.morphTargetManager._bind(Vi),Be.pointsCloud&&Vi.setFloat("pointSize",Be.pointSize)}ue._processRendering(fe,ae,Vi,Be.fillMode,ft,dt,(_r,Vr)=>Vi.setMatrix("world",Vr))}};this._depthMap.customRenderFunction=(ae,ue,fe,Re)=>{let _e;if(Re.length)for(_e=0;_e<Re.length;_e++)W(Re.data[_e]);for(_e=0;_e<ae.length;_e++)W(ae.data[_e]);for(_e=0;_e<ue.length;_e++)W(ue.data[_e]);if(this.forceDepthWriteTransparentMeshes)for(_e=0;_e<fe.length;_e++)W(fe.data[_e]);else for(_e=0;_e<fe.length;_e++)fe.data[_e].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1}}isReady(a,x){const c=this._scene.getEngine(),u=a.getMesh(),g=u.getScene(),y=u._internalAbstractMeshDataInfo._materialForRenderPass?.[c.currentRenderPassId];if(y)return y.isReadyForSubMesh(u,a,x);const v=a.getMaterial();if(!v||v.disableDepthWrite)return!1;const w=[],B=[Ve.PositionKind];v&&v.needAlphaTesting()&&v.getAlphaTestTexture()&&(w.push("#define ALPHATEST"),u.isVerticesDataPresent(Ve.UVKind)&&(B.push(Ve.UVKind),w.push("#define UV1")),u.isVerticesDataPresent(Ve.UV2Kind)&&(B.push(Ve.UV2Kind),w.push("#define UV2"))),u.useBones&&u.computeBonesUsingShaders?(B.push(Ve.MatricesIndicesKind),B.push(Ve.MatricesWeightsKind),u.numBoneInfluencers>4&&(B.push(Ve.MatricesIndicesExtraKind),B.push(Ve.MatricesWeightsExtraKind)),w.push("#define NUM_BONE_INFLUENCERS "+u.numBoneInfluencers),w.push("#define BonesPerMesh "+(u.skeleton?u.skeleton.bones.length+1:0)),a.getRenderingMesh().skeleton?.isUsingTextureForMatrices&&w.push("#define BONETEXTURE")):w.push("#define NUM_BONE_INFLUENCERS 0");const W=u.morphTargetManager;let ae=0;W&&(ae=W.numMaxInfluencers||W.numInfluencers,ae>0&&(w.push("#define MORPHTARGETS"),w.push("#define NUM_MORPH_INFLUENCERS "+ae),W.isUsingTextureForTargets&&w.push("#define MORPHTARGETS_TEXTURE"),YT(B,u,ae))),v.pointsCloud&&w.push("#define POINTSIZE"),x&&(w.push("#define INSTANCES"),mg(B),a.getRenderingMesh().hasThinInstances&&w.push("#define THIN_INSTANCES")),this._storeNonLinearDepth&&w.push("#define NONLINEARDEPTH"),this._storeCameraSpaceZ&&w.push("#define STORE_CAMERASPACE_Z"),this.isPacked&&w.push("#define PACKED"),l_(v,g,w);const ue=a._getDrawWrapper(void 0,!0),fe=ue.defines,Re=w.join(`
`);if(fe!==Re){const _e=["world","mBones","boneTextureWidth","pointSize","viewProjection","view","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices"];dg(_e),ue.setEffect(c.createEffect("depth",B,_e,["diffuseSampler","morphTargets","boneSampler"],Re,void 0,void 0,void 0,{maxSimultaneousMorphTargets:ae}),Re)}return ue.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const a=[];for(const x in this._scene._depthRenderer)this._scene._depthRenderer[x]===this&&a.push(x);if(a.length>0){this._depthMap.dispose();for(const x of a)delete this._scene._depthRenderer[x]}}}bg._SceneComponentInitialization=F=>{throw js("DepthRendererSceneComponent")};const m1="minmaxReduxPixelShader",g1=`varying vec2 vUV;uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform sampler2D sourceTexture;uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(sourceTexture,coord,0).r;float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;float minz=min(min(min(f1,f2),f3),f4);
#ifdef DEPTH_REDUX
float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#else
float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(MAIN)
uniform vec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;void main(void)
{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(f1.x,f2.x);float maxz=max(f1.y,f2.y);glFragColor=vec4(minz,maxz,0.,0.);}
#elif defined(LAST)
void main(void)
{glFragColor=vec4(0.);if (true) { 
discard;}}
#endif
`;hi.ShadersStore[m1]=g1;const EV={name:m1,shader:g1};class YN{constructor(a){this.onAfterReductionPerformed=new Jt,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=a,this._postProcessManager=new Ym(a.getScene()),this._onContextRestoredObserver=a.getEngine().onContextRestoredObservable.add(()=>{this._postProcessManager._rebuild()})}get sourceTexture(){return this._sourceTexture}setSourceTexture(a,x,c=2,u=!0){if(a===this._sourceTexture)return;this.dispose(!1),this._sourceTexture=a,this._reductionSteps=[],this._forceFullscreenViewport=u;const g=this._camera.getScene(),y=new In("Initial reduction phase","minmaxRedux",["texSize"],["sourceTexture"],1,null,1,g.getEngine(),!1,"#define INITIAL"+(x?`
#define DEPTH_REDUX`:""),c,void 0,void 0,void 0,7);y.autoClear=!1,y.forceFullscreenViewport=u;let v=this._sourceTexture.getRenderWidth(),w=this._sourceTexture.getRenderHeight();y.onApply=((W,ae)=>ue=>{ue.setTexture("sourceTexture",this._sourceTexture),ue.setFloat2("texSize",W,ae)})(v,w),this._reductionSteps.push(y);let B=1;for(;v>1||w>1;){v=Math.max(Math.round(v/2),1),w=Math.max(Math.round(w/2),1);const W=new In("Reduction phase "+B,"minmaxRedux",["texSize"],null,{width:v,height:w},null,1,g.getEngine(),!1,"#define "+(v==1&&w==1?"LAST":v==1||w==1?"ONEBEFORELAST":"MAIN"),c,void 0,void 0,void 0,7);if(W.autoClear=!1,W.forceFullscreenViewport=u,W.onApply=((ae,ue)=>fe=>{ae==1||ue==1?fe.setInt2("texSize",ae,ue):fe.setFloat2("texSize",ae,ue)})(v,w),this._reductionSteps.push(W),B++,v==1&&w==1){const ae=(ue,fe,Re)=>{const _e=new Float32Array(4*ue*fe),Be={min:0,max:0};return()=>{g.getEngine()._readTexturePixels(Re.inputTexture.texture,ue,fe,-1,0,_e,!1),Be.min=_e[0],Be.max=_e[1],this.onAfterReductionPerformed.notifyObservers(Be)}};W.onAfterRenderObservable.add(ae(v,w,W))}}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(a){this._sourceTexture&&(this._sourceTexture.refreshRate=a)}get activated(){return this._activated}activate(){this._onAfterUnbindObserver||!this._sourceTexture||(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add(()=>{const a=this._camera.getScene().getEngine();a._debugPushGroup?.("min max reduction",1),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport),a.unBindFramebuffer(this._reductionSteps[0].inputTexture,!1),a._debugPopGroup?.(1)}),this._activated=!0)}deactivate(){!this._onAfterUnbindObserver||!this._sourceTexture||(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(a=!0){if(a&&(this.onAfterReductionPerformed.clear(),this._onContextRestoredObserver&&(this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)),this.deactivate(),this._reductionSteps){for(let x=0;x<this._reductionSteps.length;++x)this._reductionSteps[x].dispose();this._reductionSteps=null}this._postProcessManager&&a&&this._postProcessManager.dispose(),this._sourceTexture=null}}class $N extends YN{get depthRenderer(){return this._depthRenderer}constructor(a){super(a)}setDepthRenderer(a=null,x=2,c=!0){const u=this._camera.getScene();this._depthRenderer&&(delete u._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),a===null&&(u._depthRenderer||(u._depthRenderer={}),a=this._depthRenderer=new bg(u,x,this._camera,!1,1),a.enabled=!1,this._depthRendererId="minmax"+this._camera.id,u._depthRenderer[this._depthRendererId]=a),super.setSourceTexture(a.getDepthMap(),!0,x,c)}setSourceTexture(a,x,c=2,u=!0){super.setSourceTexture(a,x,c,u)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(a=!0){if(super.dispose(a),this._depthRenderer&&a){const x=this._depthRenderer.getDepthMap().getScene();x&&delete x._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null}}}const _1=Ee.Up(),JN=Ee.Zero(),m0=new Ee,Mu=new Ee,Eg=new vt;class j0 extends Hs{_validateFilter(a){return a===Hs.FILTER_NONE||a===Hs.FILTER_PCF||a===Hs.FILTER_PCSS?a:(Qt.Error('Unsupported filter "'+a+'"!'),Hs.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(a){a=Math.min(Math.max(a,j0.MIN_CASCADES_COUNT),j0.MAX_CASCADES_COUNT),a!==this._numCascades&&(this._numCascades=a,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(a){this._freezeShadowCastersBoundingInfoObservable&&a&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),!this._freezeShadowCastersBoundingInfoObservable&&!a&&(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add(()=>this._computeShadowCastersBoundingInfo())),this._freezeShadowCastersBoundingInfo=a,a&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._shadowMap&&this._shadowMap.renderList){const a=this._shadowMap.renderList;for(let c=0;c<a.length;c++){const u=a[c];if(!u)continue;const g=u.getBoundingInfo(),y=g.boundingBox;this._scbiMin.minimizeInPlace(y.minimumWorld),this._scbiMax.maximizeInPlace(y.maximumWorld)}const x=this._scene.meshes;for(let c=0;c<x.length;c++){const u=x[c];if(!u||!u.isVisible||!u.isEnabled||!u.receiveShadows)continue;const g=u.getBoundingInfo(),y=g.boundingBox;this._scbiMin.minimizeInPlace(y.minimumWorld),this._scbiMax.maximizeInPlace(y.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(a){this._shadowCastersBoundingInfo=a}setMinMaxDistance(a,x){this._minDistance===a&&this._maxDistance===x||(a>x&&(a=0,x=1),a<0&&(a=0),x>1&&(x=1),this._minDistance=a,this._maxDistance=x,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return j0.CLASSNAME}getCascadeMinExtents(a){return a>=0&&a<this._numCascades?this._cascadeMinExtents[a]:null}getCascadeMaxExtents(a){return a>=0&&a<this._numCascades?this._cascadeMaxExtents[a]:null}get shadowMaxZ(){return this._getCamera()?this._shadowMaxZ:0}set shadowMaxZ(a){const x=this._getCamera();if(!x){this._shadowMaxZ=a;return}this._shadowMaxZ===a||a<x.minZ||a>x.maxZ&&x.maxZ!==0||(this._shadowMaxZ=a,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0)}get debug(){return this._debug}set debug(a){this._debug=a,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(a){this._depthClamp=a}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(a){this._cascadeBlendPercentage=a,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(a){const x=Math.min(Math.max(a,0),1);this._lambda!=x&&(this._lambda=x,this._breaksAreDirty=!0)}getCascadeViewMatrix(a){return a>=0&&a<this._numCascades?this._viewMatrices[a]:null}getCascadeProjectionMatrix(a){return a>=0&&a<this._numCascades?this._projectionMatrices[a]:null}getCascadeTransformMatrix(a){return a>=0&&a<this._numCascades?this._transformMatrices[a]:null}setDepthRenderer(a){this._depthRenderer=a,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(a){const x=this._getCamera();if(x){if(this._autoCalcDepthBounds=a,!a){this._depthReducer&&this._depthReducer.deactivate(),this.setMinMaxDistance(0,1);return}this._depthReducer||(this._depthReducer=new $N(x),this._depthReducer.onAfterReductionPerformed.add(c=>{let u=c.min,g=c.max;u>=g&&(u=0,g=1),(u!=this._minDistance||g!=this._maxDistance)&&this.setMinMaxDistance(u,g)}),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate??-1}set autoCalcDepthBoundsRefreshRate(a){this._depthReducer?.depthRenderer&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=a)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const a=this._getCamera();if(!a)return;const x=a.minZ,c=a.maxZ||this._shadowMaxZ,u=c-x,g=this._minDistance,y=this._shadowMaxZ<c&&this._shadowMaxZ>=x?Math.min((this._shadowMaxZ-x)/(c-x),this._maxDistance):this._maxDistance,v=x+g*u,w=x+y*u,B=w-v,W=w/v;for(let ae=0;ae<this._cascades.length;++ae){const ue=(ae+1)/this._numCascades,fe=v*W**ue,Re=v+B*ue,_e=this._lambda*(fe-Re)+Re;this._cascades[ae].prevBreakDistance=ae===0?g:this._cascades[ae-1].breakDistance,this._cascades[ae].breakDistance=(_e-x)/u,this._viewSpaceFrustumsZ[ae]=_e,this._frustumLengths[ae]=(this._cascades[ae].breakDistance-this._cascades[ae].prevBreakDistance)*u}this._breaksAreDirty=!1}_computeMatrices(){const a=this._scene;if(!this._getCamera())return;Ee.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),Math.abs(Ee.Dot(this._lightDirection,Ee.Up()))===1&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const c=a.getEngine().useReverseDepthBuffer;for(let u=0;u<this._numCascades;++u){this._computeFrustumInWorldSpace(u),this._computeCascadeFrustum(u),this._cascadeMaxExtents[u].subtractToRef(this._cascadeMinExtents[u],m0),this._frustumCenter[u].addToRef(this._lightDirection.scale(this._cascadeMinExtents[u].z),this._shadowCameraPos[u]),vt.LookAtLHToRef(this._shadowCameraPos[u],this._frustumCenter[u],_1,this._viewMatrices[u]);let g=0,y=m0.z;const v=this._shadowCastersBoundingInfo;v.update(this._viewMatrices[u]),y=Math.min(y,v.boundingBox.maximumWorld.z),!this._depthClamp||this.filter===Hs.FILTER_PCSS?g=Math.min(g,v.boundingBox.minimumWorld.z):g=Math.max(g,v.boundingBox.minimumWorld.z),vt.OrthoOffCenterLHToRef(this._cascadeMinExtents[u].x,this._cascadeMaxExtents[u].x,this._cascadeMinExtents[u].y,this._cascadeMaxExtents[u].y,c?y:g,c?g:y,this._projectionMatrices[u],a.getEngine().isNDCHalfZRange),this._cascadeMinExtents[u].z=g,this._cascadeMaxExtents[u].z=y,this._viewMatrices[u].multiplyToRef(this._projectionMatrices[u],this._transformMatrices[u]),Ee.TransformCoordinatesToRef(JN,this._transformMatrices[u],m0),m0.scaleInPlace(this._mapSize/2),Mu.copyFromFloats(Math.round(m0.x),Math.round(m0.y),Math.round(m0.z)),Mu.subtractInPlace(m0).scaleInPlace(2/this._mapSize),vt.TranslationToRef(Mu.x,Mu.y,0,Eg),this._projectionMatrices[u].multiplyToRef(Eg,this._projectionMatrices[u]),this._viewMatrices[u].multiplyToRef(this._projectionMatrices[u],this._transformMatrices[u]),this._transformMatrices[u].copyToArray(this._transformMatricesAsArray,u*16)}}_computeFrustumInWorldSpace(a){const x=this._getCamera();if(!x)return;const c=this._cascades[a].prevBreakDistance,u=this._cascades[a].breakDistance,g=this._scene.getEngine().isNDCHalfZRange;x.getViewMatrix();const y=x.maxZ===0,v=x.maxZ;y&&(x.maxZ=this._shadowMaxZ,x.getProjectionMatrix(!0));const w=vt.Invert(x.getTransformationMatrix());y&&(x.maxZ=v,x.getProjectionMatrix(!0));const B=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let W=0;W<j0._FrustumCornersNDCSpace.length;++W)m0.copyFrom(j0._FrustumCornersNDCSpace[(W+B)%j0._FrustumCornersNDCSpace.length]),g&&m0.z===-1&&(m0.z=0),Ee.TransformCoordinatesToRef(m0,w,this._frustumCornersWorldSpace[a][W]);for(let W=0;W<j0._FrustumCornersNDCSpace.length/2;++W)m0.copyFrom(this._frustumCornersWorldSpace[a][W+4]).subtractInPlace(this._frustumCornersWorldSpace[a][W]),Mu.copyFrom(m0).scaleInPlace(c),m0.scaleInPlace(u),m0.addInPlace(this._frustumCornersWorldSpace[a][W]),this._frustumCornersWorldSpace[a][W+4].copyFrom(m0),this._frustumCornersWorldSpace[a][W].addInPlace(Mu)}_computeCascadeFrustum(a){if(this._cascadeMinExtents[a].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[a].copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._frustumCenter[a].copyFromFloats(0,0,0),!!this._getCamera()){for(let c=0;c<this._frustumCornersWorldSpace[a].length;++c)this._frustumCenter[a].addInPlace(this._frustumCornersWorldSpace[a][c]);if(this._frustumCenter[a].scaleInPlace(1/this._frustumCornersWorldSpace[a].length),this.stabilizeCascades){let c=0;for(let u=0;u<this._frustumCornersWorldSpace[a].length;++u){const g=this._frustumCornersWorldSpace[a][u].subtractToRef(this._frustumCenter[a],m0).length();c=Math.max(c,g)}c=Math.ceil(c*16)/16,this._cascadeMaxExtents[a].copyFromFloats(c,c,c),this._cascadeMinExtents[a].copyFromFloats(-c,-c,-c)}else{const c=this._frustumCenter[a];this._frustumCenter[a].addToRef(this._lightDirection,m0),vt.LookAtLHToRef(c,m0,_1,Eg);for(let u=0;u<this._frustumCornersWorldSpace[a].length;++u)Ee.TransformCoordinatesToRef(this._frustumCornersWorldSpace[a][u],Eg,m0),this._cascadeMinExtents[a].minimizeInPlace(m0),this._cascadeMaxExtents[a].maximizeInPlace(m0)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let a=0;a<this._numCascades;++a)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${a})`))}static get IsSupported(){const a=tr.LastCreatedEngine;return a?a._features.supportCSM:!1}constructor(a,x,c,u,g=!0){if(!j0.IsSupported){Qt.Error("CascadedShadowMap is not supported by the current engine.");return}super(a,x,c,u,g),this.usePercentageCloserFiltering=!0}_initializeGenerator(){this.penumbraDarkness=this.penumbraDarkness??1,this._numCascades=this._numCascades??j0.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=this.stabilizeCascades??!1,this._freezeShadowCastersBoundingInfoObservable=this._freezeShadowCastersBoundingInfoObservable??null,this.freezeShadowCastersBoundingInfo=this.freezeShadowCastersBoundingInfo??!1,this._scbiMin=this._scbiMin??new Ee(0,0,0),this._scbiMax=this._scbiMax??new Ee(0,0,0),this._shadowCastersBoundingInfo=this._shadowCastersBoundingInfo??new tx(new Ee(0,0,0),new Ee(0,0,0)),this._breaksAreDirty=this._breaksAreDirty??!0,this._minDistance=this._minDistance??0,this._maxDistance=this._maxDistance??1,this._currentLayer=this._currentLayer??0,this._shadowMaxZ=this._shadowMaxZ??this._getCamera()?.maxZ??1e4,this._debug=this._debug??!1,this._depthClamp=this._depthClamp??!0,this._cascadeBlendPercentage=this._cascadeBlendPercentage??.1,this._lambda=this._lambda??.5,this._autoCalcDepthBounds=this._autoCalcDepthBounds??!1,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){const a=this._scene.getEngine(),x={width:this._mapSize,height:this._mapSize,layers:this.numCascades};this._shadowMap=new Bo(this._light.name+"_CSMShadowMap",x,this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0,this._useRedTextureType?6:5),this._shadowMap.createDepthStencilTexture(a.useReverseDepthBuffer?516:513,!0),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(super._initializeShadowMap(),this._shadowMap===null)return;this._transformMatricesAsArray=new Float32Array(this._numCascades*16),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(this._numCascades*2),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let x=0;x<this._numCascades;++x){this._cascades[x]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[x]=vt.Zero(),this._projectionMatrices[x]=vt.Zero(),this._transformMatrices[x]=vt.Zero(),this._cascadeMinExtents[x]=new Ee,this._cascadeMaxExtents[x]=new Ee,this._frustumCenter[x]=new Ee,this._shadowCameraPos[x]=new Ee,this._frustumCornersWorldSpace[x]=new Array(j0._FrustumCornersNDCSpace.length);for(let c=0;c<j0._FrustumCornersNDCSpace.length;++c)this._frustumCornersWorldSpace[x][c]=new Ee}const a=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add(x=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[x]),this._currentLayer=x,this._filter===Hs.FILTER_PCF&&a.setColorWrite(!1),this._scene.setTransformMatrix(this.getCascadeViewMatrix(x),this.getCascadeProjectionMatrix(x)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())}),this._shadowMap.onBeforeBindObservable.add(()=>{this._currentSceneUBO=this._scene.getSceneUniformBuffer(),a._debugPushGroup?.(`cascaded shadow map generation for pass id ${a.currentRenderPassId}`,1),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()}),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(a,x){x.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(a){a.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==Hs.FILTER_PCSS?"1":"0"))}prepareDefines(a,x){super.prepareDefines(a,x);const c=this._scene,u=this._light;if(!c.shadowsEnabled||!u.shadowEnabled)return;a["SHADOWCSM"+x]=!0,a["SHADOWCSMDEBUG"+x]=this.debug,a["SHADOWCSMNUM_CASCADES"+x]=this.numCascades,a["SHADOWCSM_RIGHTHANDED"+x]=c.useRightHandedSystem;const g=this._getCamera();g&&this._shadowMaxZ<=(g.maxZ||this._shadowMaxZ)&&(a["SHADOWCSMUSESHADOWMAXZ"+x]=!0),this.cascadeBlendPercentage===0&&(a["SHADOWCSMNOBLEND"+x]=!0)}bindShadowLight(a,x){const c=this._light;if(!this._scene.shadowsEnabled||!c.shadowEnabled)return;const g=this._getCamera();if(!g)return;const y=this.getShadowMap();if(!y)return;const v=y.getSize().width;if(x.setMatrices("lightMatrix"+a,this._transformMatricesAsArray),x.setArray("viewFrustumZ"+a,this._viewSpaceFrustumsZ),x.setFloat("cascadeBlendFactor"+a,this.cascadeBlendPercentage===0?1e4:1/this.cascadeBlendPercentage),x.setArray("frustumLengths"+a,this._frustumLengths),this._filter===Hs.FILTER_PCF)x.setDepthStencilTexture("shadowSampler"+a,y),c._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),v,1/v,this.frustumEdgeFalloff,a);else if(this._filter===Hs.FILTER_PCSS){for(let w=0;w<this._numCascades;++w)this._lightSizeUVCorrection[w*2+0]=w===0?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[w].x-this._cascadeMinExtents[w].x),this._lightSizeUVCorrection[w*2+1]=w===0?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[w].y-this._cascadeMinExtents[w].y),this._depthCorrection[w]=w===0?1:(this._cascadeMaxExtents[w].z-this._cascadeMinExtents[w].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);x.setDepthStencilTexture("shadowSampler"+a,y),x.setTexture("depthSampler"+a,y),x.setArray2("lightSizeUVCorrection"+a,this._lightSizeUVCorrection),x.setArray("depthCorrection"+a,this._depthCorrection),x.setFloat("penumbraDarkness"+a,this.penumbraDarkness),c._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/v,this._contactHardeningLightSizeUVRatio*v,this.frustumEdgeFalloff,a)}else x.setTexture("shadowSampler"+a,y),c._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),v,1/v,this.frustumEdgeFalloff,a);c._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(g),this.getLight().getDepthMinZ(g)+this.getLight().getDepthMaxZ(g),a)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const a=super.serialize(),x=this.getShadowMap();if(!x)return a;if(a.numCascades=this._numCascades,a.debug=this._debug,a.stabilizeCascades=this.stabilizeCascades,a.lambda=this._lambda,a.cascadeBlendPercentage=this.cascadeBlendPercentage,a.depthClamp=this._depthClamp,a.autoCalcDepthBounds=this.autoCalcDepthBounds,a.shadowMaxZ=this._shadowMaxZ,a.penumbraDarkness=this.penumbraDarkness,a.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,a.minDistance=this.minDistance,a.maxDistance=this.maxDistance,a.renderList=[],x.renderList)for(let c=0;c<x.renderList.length;c++){const u=x.renderList[c];a.renderList.push(u.id)}return a}static Parse(a,x){const c=Hs.Parse(a,x,(u,g,y)=>new j0(u,g,void 0,y));return a.numCascades!==void 0&&(c.numCascades=a.numCascades),a.debug!==void 0&&(c.debug=a.debug),a.stabilizeCascades!==void 0&&(c.stabilizeCascades=a.stabilizeCascades),a.lambda!==void 0&&(c.lambda=a.lambda),a.cascadeBlendPercentage!==void 0&&(c.cascadeBlendPercentage=a.cascadeBlendPercentage),a.depthClamp!==void 0&&(c.depthClamp=a.depthClamp),a.autoCalcDepthBounds!==void 0&&(c.autoCalcDepthBounds=a.autoCalcDepthBounds),a.shadowMaxZ!==void 0&&(c.shadowMaxZ=a.shadowMaxZ),a.penumbraDarkness!==void 0&&(c.penumbraDarkness=a.penumbraDarkness),a.freezeShadowCastersBoundingInfo!==void 0&&(c.freezeShadowCastersBoundingInfo=a.freezeShadowCastersBoundingInfo),a.minDistance!==void 0&&a.maxDistance!==void 0&&c.setMinMaxDistance(a.minDistance,a.maxDistance),c}}j0._FrustumCornersNDCSpace=[new Ee(-1,1,-1),new Ee(1,1,-1),new Ee(1,-1,-1),new Ee(-1,-1,-1),new Ee(-1,1,1),new Ee(1,1,1),new Ee(1,-1,1),new Ee(-1,-1,1)],j0.CLASSNAME="CascadedShadowGenerator",j0.DEFAULT_CASCADES_COUNT=4,j0.MIN_CASCADES_COUNT=2,j0.MAX_CASCADES_COUNT=4,j0._SceneComponentInitialization=F=>{throw js("ShadowGeneratorSceneComponent")},Wc.AddParser(Xs.NAME_SHADOWGENERATOR,(F,a)=>{if(F.shadowGenerators!==void 0&&F.shadowGenerators!==null)for(let x=0,c=F.shadowGenerators.length;x<c;x++){const u=F.shadowGenerators[x];u.className===j0.CLASSNAME?j0.Parse(u,a):Hs.Parse(u,a)}});class tL{constructor(a){this.name=Xs.NAME_SHADOWGENERATOR,this.scene=a}register(){this.scene._gatherRenderTargetsStage.registerStep(Xs.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR,this,this._gatherRenderTargets)}rebuild(){}serialize(a){a.shadowGenerators=[];const x=this.scene.lights;for(const c of x){const u=c.getShadowGenerators();if(u){const g=u.values();for(let y=g.next();y.done!==!0;y=g.next()){const v=y.value;a.shadowGenerators.push(v.serialize())}}}}addFromContainer(a){}removeFromContainer(a,x){}dispose(){}_gatherRenderTargets(a){const x=this.scene;if(this.scene.shadowsEnabled)for(let c=0;c<x.lights.length;c++){const u=x.lights[c],g=u.getShadowGenerators();if(u.isEnabled()&&u.shadowEnabled&&g){const y=g.values();for(let v=y.next();v.done!==!0;v=y.next()){const B=v.value.getShadowMap();x.textures.indexOf(B)!==-1&&a.push(B)}}}}}Hs._SceneComponentInitialization=F=>{let a=F._getComponent(Xs.NAME_SHADOWGENERATOR);a||(a=new tL(F),F._addComponent(a))};class dm{get resolve(){return this._resolve}get reject(){return this._reject}constructor(){this.promise=new Promise((a,x)=>{this._resolve=a,this._reject=x})}}var vg;(function(F){F[F.NONE=0]="NONE",F[F.STEP=1]="STEP"})(vg||(vg={}));class Bu{constructor(a,x,c){this.name=a,this.from=x,this.to=c}clone(){return new Bu(this.name,this.from,this.to)}}const aL=Object.freeze(new Wi(0,0,0,0)),xL=Object.freeze(Ee.Zero()),lL=Object.freeze(mr.Zero()),hL=Object.freeze(Ux.Zero()),uL=Object.freeze(Bs.Black()),dL=Object.freeze(new Yr(0,0,0,0)),Xl={key:0,repeatCount:0,loopMode:2};class xi{static _PrepareAnimation(a,x,c,u,g,y,v,w){let B;if(!isNaN(parseFloat(g))&&isFinite(g)?B=xi.ANIMATIONTYPE_FLOAT:g instanceof Wi?B=xi.ANIMATIONTYPE_QUATERNION:g instanceof Ee?B=xi.ANIMATIONTYPE_VECTOR3:g instanceof mr?B=xi.ANIMATIONTYPE_VECTOR2:g instanceof Bs?B=xi.ANIMATIONTYPE_COLOR3:g instanceof Yr?B=xi.ANIMATIONTYPE_COLOR4:g instanceof Ux&&(B=xi.ANIMATIONTYPE_SIZE),B==null)return null;const W=new xi(a,x,c,B,v),ae=[{frame:0,value:g},{frame:u,value:y}];return W.setKeys(ae),w!==void 0&&W.setEasingFunction(w),W}static CreateAnimation(a,x,c,u){const g=new xi(a+"Animation",a,c,x,xi.ANIMATIONLOOPMODE_CONSTANT);return g.setEasingFunction(u),g}static CreateAndStartAnimation(a,x,c,u,g,y,v,w,B,W,ae){const ue=xi._PrepareAnimation(a,c,u,g,y,v,w,B);return!ue||(x.getScene&&(ae=x.getScene()),!ae)?null:ae.beginDirectAnimation(x,[ue],0,g,ue.loopMode===1,1,W)}static CreateAndStartHierarchyAnimation(a,x,c,u,g,y,v,w,B,W,ae){const ue=xi._PrepareAnimation(a,u,g,y,v,w,B,W);return ue?x.getScene().beginDirectHierarchyAnimation(x,c,[ue],0,y,ue.loopMode===1,1,ae):null}static CreateMergeAndStartAnimation(a,x,c,u,g,y,v,w,B,W){const ae=xi._PrepareAnimation(a,c,u,g,y,v,w,B);return ae?(x.animations.push(ae),x.getScene().beginAnimation(x,0,g,ae.loopMode===1,1,W)):null}static MakeAnimationAdditive(a,x,c,u=!1,g){let y;typeof x=="object"?y=x:y={referenceFrame:x??0,range:c,cloneOriginalAnimation:u,clonedAnimationName:g};let v=a;if(y.cloneOriginalAnimation&&(v=a.clone(),v.name=y.clonedAnimationName||v.name),!v._keys.length)return v;const w=y.referenceFrame&&y.referenceFrame>=0?y.referenceFrame:0;let B=0;const W=v._keys[0];let ae=v._keys.length-1;const ue=v._keys[ae],fe={referenceValue:W.value,referencePosition:Yt.Vector3[0],referenceQuaternion:Yt.Quaternion[0],referenceScaling:Yt.Vector3[1],keyPosition:Yt.Vector3[2],keyQuaternion:Yt.Quaternion[1],keyScaling:Yt.Vector3[3]};let Re=W.frame,_e=ue.frame;if(y.range){const $e=v.getRange(y.range);$e&&(Re=$e.from,_e=$e.to)}else Re=y.fromFrame??Re,_e=y.toFrame??_e;if(Re!==W.frame&&(B=v.createKeyForFrame(Re)),_e!==ue.frame&&(ae=v.createKeyForFrame(_e)),v._keys.length===1){const $e=v._getKeyValue(v._keys[0]);fe.referenceValue=$e.clone?$e.clone():$e}else if(w<=W.frame){const $e=v._getKeyValue(W.value);fe.referenceValue=$e.clone?$e.clone():$e}else if(w>=ue.frame){const $e=v._getKeyValue(ue.value);fe.referenceValue=$e.clone?$e.clone():$e}else{Xl.key=0;const $e=v._interpolate(w,Xl);fe.referenceValue=$e.clone?$e.clone():$e}v.dataType===xi.ANIMATIONTYPE_QUATERNION?fe.referenceValue.normalize().conjugateInPlace():v.dataType===xi.ANIMATIONTYPE_MATRIX&&(fe.referenceValue.decompose(fe.referenceScaling,fe.referenceQuaternion,fe.referencePosition),fe.referenceQuaternion.normalize().conjugateInPlace());let Be=Number.MAX_VALUE;const tt=y.clipKeys?[]:null;for(let $e=B;$e<=ae;$e++){let Et=v._keys[$e];if(tt&&(Et={frame:Et.frame,value:Et.value.clone?Et.value.clone():Et.value,inTangent:Et.inTangent,outTangent:Et.outTangent,interpolation:Et.interpolation,lockedTangent:Et.lockedTangent},Be===Number.MAX_VALUE&&(Be=Et.frame),Et.frame-=Be,tt.push(Et)),!($e&&v.dataType!==xi.ANIMATIONTYPE_FLOAT&&Et.value===W.value))switch(v.dataType){case xi.ANIMATIONTYPE_MATRIX:Et.value.decompose(fe.keyScaling,fe.keyQuaternion,fe.keyPosition),fe.keyPosition.subtractInPlace(fe.referencePosition),fe.keyScaling.divideInPlace(fe.referenceScaling),fe.referenceQuaternion.multiplyToRef(fe.keyQuaternion,fe.keyQuaternion),vt.ComposeToRef(fe.keyScaling,fe.keyQuaternion,fe.keyPosition,Et.value);break;case xi.ANIMATIONTYPE_QUATERNION:fe.referenceValue.multiplyToRef(Et.value,Et.value);break;case xi.ANIMATIONTYPE_VECTOR2:case xi.ANIMATIONTYPE_VECTOR3:case xi.ANIMATIONTYPE_COLOR3:case xi.ANIMATIONTYPE_COLOR4:Et.value.subtractToRef(fe.referenceValue,Et.value);break;case xi.ANIMATIONTYPE_SIZE:Et.value.width-=fe.referenceValue.width,Et.value.height-=fe.referenceValue.height;break;default:Et.value-=fe.referenceValue}}return tt&&v.setKeys(tt,!0),v}static TransitionTo(a,x,c,u,g,y,v,w=null){if(v<=0)return c[a]=x,w&&w(),null;const B=g*(v/1e3);y.setKeys([{frame:0,value:c[a].clone?c[a].clone():c[a]},{frame:B,value:x}]),c.animations||(c.animations=[]),c.animations.push(y);const W=u.beginAnimation(c,0,B,!1);return W.onAnimationEnd=w,W}get runtimeAnimations(){return this._runtimeAnimations}get hasRunningRuntimeAnimations(){for(const a of this._runtimeAnimations)if(!a.isStopped())return!0;return!1}constructor(a,x,c,u,g,y){this.name=a,this.targetProperty=x,this.framePerSecond=c,this.dataType=u,this.loopMode=g,this.enableBlending=y,this._easingFunction=null,this._runtimeAnimations=new Array,this._events=new Array,this.blendingSpeed=.01,this._ranges={},this.targetPropertyPath=x.split("."),this.dataType=u,this.loopMode=g===void 0?xi.ANIMATIONLOOPMODE_CYCLE:g,this.uniqueId=xi._UniqueIdGenerator++}toString(a){let x="Name: "+this.name+", property: "+this.targetProperty;if(x+=", datatype: "+["Float","Vector3","Quaternion","Matrix","Color3","Vector2"][this.dataType],x+=", nKeys: "+(this._keys?this._keys.length:"none"),x+=", nRanges: "+(this._ranges?Object.keys(this._ranges).length:"none"),a){x+=", Ranges: {";let c=!0;for(const u in this._ranges)c&&(x+=", ",c=!1),x+=u;x+="}"}return x}addEvent(a){this._events.push(a),this._events.sort((x,c)=>x.frame-c.frame)}removeEvents(a){for(let x=0;x<this._events.length;x++)this._events[x].frame===a&&(this._events.splice(x,1),x--)}getEvents(){return this._events}createRange(a,x,c){this._ranges[a]||(this._ranges[a]=new Bu(a,x,c))}deleteRange(a,x=!0){const c=this._ranges[a];if(c){if(x){const u=c.from,g=c.to;for(let y=this._keys.length-1;y>=0;y--)this._keys[y].frame>=u&&this._keys[y].frame<=g&&this._keys.splice(y,1)}this._ranges[a]=null}}getRange(a){return this._ranges[a]}getKeys(){return this._keys}getHighestFrame(){let a=0;for(let x=0,c=this._keys.length;x<c;x++)a<this._keys[x].frame&&(a=this._keys[x].frame);return a}getEasingFunction(){return this._easingFunction}setEasingFunction(a){this._easingFunction=a}floatInterpolateFunction(a,x,c){return _n.Lerp(a,x,c)}floatInterpolateFunctionWithTangents(a,x,c,u,g){return _n.Hermite(a,x,c,u,g)}quaternionInterpolateFunction(a,x,c){return Wi.Slerp(a,x,c)}quaternionInterpolateFunctionWithTangents(a,x,c,u,g){return Wi.Hermite(a,x,c,u,g).normalize()}vector3InterpolateFunction(a,x,c){return Ee.Lerp(a,x,c)}vector3InterpolateFunctionWithTangents(a,x,c,u,g){return Ee.Hermite(a,x,c,u,g)}vector2InterpolateFunction(a,x,c){return mr.Lerp(a,x,c)}vector2InterpolateFunctionWithTangents(a,x,c,u,g){return mr.Hermite(a,x,c,u,g)}sizeInterpolateFunction(a,x,c){return Ux.Lerp(a,x,c)}color3InterpolateFunction(a,x,c){return Bs.Lerp(a,x,c)}color3InterpolateFunctionWithTangents(a,x,c,u,g){return Bs.Hermite(a,x,c,u,g)}color4InterpolateFunction(a,x,c){return Yr.Lerp(a,x,c)}color4InterpolateFunctionWithTangents(a,x,c,u,g){return Yr.Hermite(a,x,c,u,g)}_getKeyValue(a){return typeof a=="function"?a():a}evaluate(a){return Xl.key=0,this._interpolate(a,Xl)}_interpolate(a,x,c=!1){if(x.loopMode===xi.ANIMATIONLOOPMODE_CONSTANT&&x.repeatCount>0)return x.highLimitValue.clone?x.highLimitValue.clone():x.highLimitValue;const u=this._keys,g=u.length;let y=x.key;for(;y>=0&&a<u[y].frame;)--y;for(;y+1<=g-1&&a>=u[y+1].frame;)++y;if(x.key=y,y<0)return c?void 0:this._getKeyValue(u[0].value);if(y+1>g-1)return c?void 0:this._getKeyValue(u[g-1].value);const v=u[y],w=u[y+1];if(c&&(a===v.frame||a===w.frame))return;const B=this._getKeyValue(v.value),W=this._getKeyValue(w.value);if(v.interpolation===vg.STEP)return w.frame>a?B:W;const ae=v.outTangent!==void 0&&w.inTangent!==void 0,ue=w.frame-v.frame;let fe=(a-v.frame)/ue;const Re=v.easingFunction||this.getEasingFunction();switch(Re!==null&&(fe=Re.ease(fe)),this.dataType){case xi.ANIMATIONTYPE_FLOAT:{const _e=ae?this.floatInterpolateFunctionWithTangents(B,v.outTangent*ue,W,w.inTangent*ue,fe):this.floatInterpolateFunction(B,W,fe);switch(x.loopMode){case xi.ANIMATIONLOOPMODE_CYCLE:case xi.ANIMATIONLOOPMODE_CONSTANT:case xi.ANIMATIONLOOPMODE_YOYO:return _e;case xi.ANIMATIONLOOPMODE_RELATIVE:case xi.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return(x.offsetValue??0)*x.repeatCount+_e}break}case xi.ANIMATIONTYPE_QUATERNION:{const _e=ae?this.quaternionInterpolateFunctionWithTangents(B,v.outTangent.scale(ue),W,w.inTangent.scale(ue),fe):this.quaternionInterpolateFunction(B,W,fe);switch(x.loopMode){case xi.ANIMATIONLOOPMODE_CYCLE:case xi.ANIMATIONLOOPMODE_CONSTANT:case xi.ANIMATIONLOOPMODE_YOYO:return _e;case xi.ANIMATIONLOOPMODE_RELATIVE:case xi.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return _e.addInPlace((x.offsetValue||aL).scale(x.repeatCount))}return _e}case xi.ANIMATIONTYPE_VECTOR3:{const _e=ae?this.vector3InterpolateFunctionWithTangents(B,v.outTangent.scale(ue),W,w.inTangent.scale(ue),fe):this.vector3InterpolateFunction(B,W,fe);switch(x.loopMode){case xi.ANIMATIONLOOPMODE_CYCLE:case xi.ANIMATIONLOOPMODE_CONSTANT:case xi.ANIMATIONLOOPMODE_YOYO:return _e;case xi.ANIMATIONLOOPMODE_RELATIVE:case xi.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return _e.add((x.offsetValue||xL).scale(x.repeatCount))}break}case xi.ANIMATIONTYPE_VECTOR2:{const _e=ae?this.vector2InterpolateFunctionWithTangents(B,v.outTangent.scale(ue),W,w.inTangent.scale(ue),fe):this.vector2InterpolateFunction(B,W,fe);switch(x.loopMode){case xi.ANIMATIONLOOPMODE_CYCLE:case xi.ANIMATIONLOOPMODE_CONSTANT:case xi.ANIMATIONLOOPMODE_YOYO:return _e;case xi.ANIMATIONLOOPMODE_RELATIVE:case xi.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return _e.add((x.offsetValue||lL).scale(x.repeatCount))}break}case xi.ANIMATIONTYPE_SIZE:{switch(x.loopMode){case xi.ANIMATIONLOOPMODE_CYCLE:case xi.ANIMATIONLOOPMODE_CONSTANT:case xi.ANIMATIONLOOPMODE_YOYO:return this.sizeInterpolateFunction(B,W,fe);case xi.ANIMATIONLOOPMODE_RELATIVE:case xi.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return this.sizeInterpolateFunction(B,W,fe).add((x.offsetValue||hL).scale(x.repeatCount))}break}case xi.ANIMATIONTYPE_COLOR3:{const _e=ae?this.color3InterpolateFunctionWithTangents(B,v.outTangent.scale(ue),W,w.inTangent.scale(ue),fe):this.color3InterpolateFunction(B,W,fe);switch(x.loopMode){case xi.ANIMATIONLOOPMODE_CYCLE:case xi.ANIMATIONLOOPMODE_CONSTANT:case xi.ANIMATIONLOOPMODE_YOYO:return _e;case xi.ANIMATIONLOOPMODE_RELATIVE:case xi.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return _e.add((x.offsetValue||uL).scale(x.repeatCount))}break}case xi.ANIMATIONTYPE_COLOR4:{const _e=ae?this.color4InterpolateFunctionWithTangents(B,v.outTangent.scale(ue),W,w.inTangent.scale(ue),fe):this.color4InterpolateFunction(B,W,fe);switch(x.loopMode){case xi.ANIMATIONLOOPMODE_CYCLE:case xi.ANIMATIONLOOPMODE_CONSTANT:case xi.ANIMATIONLOOPMODE_YOYO:return _e;case xi.ANIMATIONLOOPMODE_RELATIVE:case xi.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return _e.add((x.offsetValue||dL).scale(x.repeatCount))}break}case xi.ANIMATIONTYPE_MATRIX:{switch(x.loopMode){case xi.ANIMATIONLOOPMODE_CYCLE:case xi.ANIMATIONLOOPMODE_CONSTANT:case xi.ANIMATIONLOOPMODE_YOYO:return xi.AllowMatricesInterpolation?this.matrixInterpolateFunction(B,W,fe,x.workValue):B;case xi.ANIMATIONLOOPMODE_RELATIVE:case xi.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT:return B}break}}return 0}matrixInterpolateFunction(a,x,c,u){return xi.AllowMatrixDecomposeForInterpolation?u?(vt.DecomposeLerpToRef(a,x,c,u),u):vt.DecomposeLerp(a,x,c):u?(vt.LerpToRef(a,x,c,u),u):vt.Lerp(a,x,c)}clone(){const a=new xi(this.name,this.targetPropertyPath.join("."),this.framePerSecond,this.dataType,this.loopMode);if(a.enableBlending=this.enableBlending,a.blendingSpeed=this.blendingSpeed,this._keys&&a.setKeys(this._keys),this._ranges){a._ranges={};for(const x in this._ranges){const c=this._ranges[x];c&&(a._ranges[x]=c.clone())}}return a}setKeys(a,x=!1){this._keys=x?a:a.slice(0)}createKeyForFrame(a){Xl.key=0;const x=this._interpolate(a,Xl,!0);if(!x)return this._keys[Xl.key].frame===a?Xl.key:Xl.key+1;const c={frame:a,value:x.clone?x.clone():x};return this._keys.splice(Xl.key+1,0,c),Xl.key+1}serialize(){const a={};a.name=this.name,a.property=this.targetProperty,a.framePerSecond=this.framePerSecond,a.dataType=this.dataType,a.loopBehavior=this.loopMode,a.enableBlending=this.enableBlending,a.blendingSpeed=this.blendingSpeed;const x=this.dataType;a.keys=[];const c=this.getKeys();for(let u=0;u<c.length;u++){const g=c[u],y={};switch(y.frame=g.frame,x){case xi.ANIMATIONTYPE_FLOAT:y.values=[g.value],g.inTangent!==void 0&&y.values.push(g.inTangent),g.outTangent!==void 0&&(g.inTangent===void 0&&y.values.push(void 0),y.values.push(g.outTangent)),g.interpolation!==void 0&&(g.inTangent===void 0&&y.values.push(void 0),g.outTangent===void 0&&y.values.push(void 0),y.values.push(g.interpolation));break;case xi.ANIMATIONTYPE_QUATERNION:case xi.ANIMATIONTYPE_MATRIX:case xi.ANIMATIONTYPE_VECTOR3:case xi.ANIMATIONTYPE_COLOR3:case xi.ANIMATIONTYPE_COLOR4:y.values=g.value.asArray(),g.inTangent!=null&&y.values.push(g.inTangent.asArray()),g.outTangent!=null&&(g.inTangent===void 0&&y.values.push(void 0),y.values.push(g.outTangent.asArray())),g.interpolation!==void 0&&(g.inTangent===void 0&&y.values.push(void 0),g.outTangent===void 0&&y.values.push(void 0),y.values.push(g.interpolation));break}a.keys.push(y)}a.ranges=[];for(const u in this._ranges){const g=this._ranges[u];if(!g)continue;const y={};y.name=u,y.from=g.from,y.to=g.to,a.ranges.push(y)}return a}static _UniversalLerp(a,x,c){const u=a.constructor;return u.Lerp?u.Lerp(a,x,c):u.Slerp?u.Slerp(a,x,c):a.toFixed?a*(1-c)+c*x:x}static Parse(a){const x=new xi(a.name,a.property,a.framePerSecond,a.dataType,a.loopBehavior),c=a.dataType,u=[];let g,y;for(a.enableBlending&&(x.enableBlending=a.enableBlending),a.blendingSpeed&&(x.blendingSpeed=a.blendingSpeed),y=0;y<a.keys.length;y++){const v=a.keys[y];let w,B,W;switch(c){case xi.ANIMATIONTYPE_FLOAT:g=v.values[0],v.values.length>=2&&(w=v.values[1]),v.values.length>=3&&(B=v.values[2]),v.values.length>=4&&(W=v.values[3]);break;case xi.ANIMATIONTYPE_QUATERNION:if(g=Wi.FromArray(v.values),v.values.length>=8){const ue=Wi.FromArray(v.values.slice(4,8));ue.equals(Wi.Zero())||(w=ue)}if(v.values.length>=12){const ue=Wi.FromArray(v.values.slice(8,12));ue.equals(Wi.Zero())||(B=ue)}v.values.length>=13&&(W=v.values[12]);break;case xi.ANIMATIONTYPE_MATRIX:g=vt.FromArray(v.values),v.values.length>=17&&(W=v.values[16]);break;case xi.ANIMATIONTYPE_COLOR3:g=Bs.FromArray(v.values),v.values[3]&&(w=Bs.FromArray(v.values[3])),v.values[4]&&(B=Bs.FromArray(v.values[4])),v.values[5]&&(W=v.values[5]);break;case xi.ANIMATIONTYPE_COLOR4:g=Yr.FromArray(v.values),v.values[4]&&(w=Yr.FromArray(v.values[4])),v.values[5]&&(B=Yr.FromArray(v.values[5])),v.values[6]&&(W=Yr.FromArray(v.values[6]));break;case xi.ANIMATIONTYPE_VECTOR3:default:g=Ee.FromArray(v.values),v.values[3]&&(w=Ee.FromArray(v.values[3])),v.values[4]&&(B=Ee.FromArray(v.values[4])),v.values[5]&&(W=v.values[5]);break}const ae={};ae.frame=v.frame,ae.value=g,w!=null&&(ae.inTangent=w),B!=null&&(ae.outTangent=B),W!=null&&(ae.interpolation=W),u.push(ae)}if(x.setKeys(u),a.ranges)for(y=0;y<a.ranges.length;y++)g=a.ranges[y],x.createRange(g.name,g.from,g.to);return x}static AppendSerializedAnimations(a,x){hr.AppendSerializedAnimations(a,x)}static ParseFromFileAsync(a,x){return new Promise((c,u)=>{const g=new da;g.addEventListener("readystatechange",()=>{if(g.readyState==4)if(g.status==200){let y=JSON.parse(g.responseText);if(y.animations&&(y=y.animations),y.length){const v=[];for(const w of y)v.push(this.Parse(w));c(v)}else{const v=this.Parse(y);a&&(v.name=a),c(v)}}else u("Unable to load the animation")}),g.open("GET",x),g.send()})}static ParseFromSnippetAsync(a){return new Promise((x,c)=>{const u=new da;u.addEventListener("readystatechange",()=>{if(u.readyState==4)if(u.status==200){const g=JSON.parse(JSON.parse(u.responseText).jsonPayload);if(g.animations){const y=JSON.parse(g.animations),v=[];for(const w of y.animations){const B=this.Parse(w);B.snippetId=a,v.push(B)}x(v)}else{const y=JSON.parse(g.animation),v=this.Parse(y);v.snippetId=a,x(v)}}else c("Unable to load the snippet "+a)}),u.open("GET",this.SnippetUrl+"/"+a.replace(/#/g,"/")),u.send()})}}xi._UniqueIdGenerator=0,xi.AllowMatricesInterpolation=!1,xi.AllowMatrixDecomposeForInterpolation=!0,xi.SnippetUrl="https://snippet.babylonjs.com",xi.ANIMATIONTYPE_FLOAT=0,xi.ANIMATIONTYPE_VECTOR3=1,xi.ANIMATIONTYPE_QUATERNION=2,xi.ANIMATIONTYPE_MATRIX=3,xi.ANIMATIONTYPE_COLOR3=4,xi.ANIMATIONTYPE_COLOR4=7,xi.ANIMATIONTYPE_VECTOR2=5,xi.ANIMATIONTYPE_SIZE=6,xi.ANIMATIONLOOPMODE_RELATIVE=0,xi.ANIMATIONLOOPMODE_CYCLE=1,xi.ANIMATIONLOOPMODE_CONSTANT=2,xi.ANIMATIONLOOPMODE_YOYO=4,xi.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT=5,xi.CreateFromSnippetAsync=xi.ParseFromSnippetAsync,as("BABYLON.Animation",xi),fa._AnimationRangeFactory=(F,a,x)=>new Bu(F,a,x);class fL{getClassName(){return"TargetedAnimation"}serialize(){const a={};return a.animation=this.animation.serialize(),a.targetId=this.target.id,a}}class xc{get mask(){return this._mask}set mask(a){this._mask!==a&&(this._mask=a,this.syncWithMask(!0))}syncWithMask(a=!1){if(!this.mask&&!a){this._numActiveAnimatables=this._targetedAnimations.length;return}this._numActiveAnimatables=0;for(let x=0;x<this._animatables.length;++x){const c=this._animatables[x];!this.mask||this.mask.disabled||this.mask.retainsTarget(c.target.name)?(this._numActiveAnimatables++,c.paused&&c.restart()):c.paused||c.pause()}}removeUnmaskedAnimations(){if(!(!this.mask||this.mask.disabled)){for(let a=0;a<this._animatables.length;++a){const x=this._animatables[a];this.mask.retainsTarget(x.target.name)||(x.stop(),this._animatables.splice(a,1),--a)}for(let a=0;a<this._targetedAnimations.length;a++){const x=this._targetedAnimations[a];this.mask.retainsTarget(x.target.name)||(this._targetedAnimations.splice(a,1),--a)}}}get from(){return this._from}set from(a){if(this._from!==a){this._from=a;for(let x=0;x<this._animatables.length;x++){const c=this._animatables[x];c.fromFrame=this._from}}}get to(){return this._to}set to(a){if(this._to!==a){this._to=a;for(let x=0;x<this._animatables.length;x++){const c=this._animatables[x];c.toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(a){if(this._speedRatio!==a){this._speedRatio=a;for(let x=0;x<this._animatables.length;x++){const c=this._animatables[x];c.speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(a){if(this._loopAnimation!==a){this._loopAnimation=a;for(let x=0;x<this._animatables.length;x++){const c=this._animatables[x];c.loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(a){if(this._isAdditive!==a){this._isAdditive=a;for(let x=0;x<this._animatables.length;x++){const c=this._animatables[x];c.isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(a){this._weight!==a&&(this._weight=a,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(a){if(this._playOrder!==a&&(this._playOrder=a,this._animatables.length>0)){for(let x=0;x<this._animatables.length;x++)this._animatables[x].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(a){if(this._enableBlending!==a&&(this._enableBlending=a,a!==null))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.enableBlending=a}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(a){if(this._blendingSpeed!==a&&(this._blendingSpeed=a,a!==null))for(let x=0;x<this._targetedAnimations.length;++x)this._targetedAnimations[x].animation.blendingSpeed=a}getLength(a,x){a=a??this._from,x=x??this._to;const c=this.targetedAnimations[0].animation.framePerSecond*this._speedRatio;return(x-a)/c}static MergeAnimationGroups(a,x=!0,c=!1,u){if(a.length===0)return null;u=u??a[0].weight;let g=Number.MAX_VALUE,y=-Number.MAX_VALUE;if(c)for(const w of a)w.from<g&&(g=w.from),w.to>y&&(y=w.to);const v=new xc(a[0].name+"_merged",a[0]._scene,u);for(const w of a){c&&w.normalize(g,y);for(const B of w.targetedAnimations)v.addTargetedAnimation(B.animation,B.target);x&&w.dispose()}return v}constructor(a,x=null,c=-1,u=0){this.name=a,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._parentContainer=null,this.onAnimationEndObservable=new Jt,this.onAnimationLoopObservable=new Jt,this.onAnimationGroupLoopObservable=new Jt,this.onAnimationGroupEndObservable=new Jt,this.onAnimationGroupPauseObservable=new Jt,this.onAnimationGroupPlayObservable=new Jt,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=x||tr.LastCreatedScene,this._weight=c,this._playOrder=u,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(a,x){const c=new fL;c.animation=a,c.target=x;const u=a.getKeys();return this._from>u[0].frame&&(this._from=u[0].frame),this._to<u[u.length-1].frame&&(this._to=u[u.length-1].frame),this._enableBlending!==null&&(a.enableBlending=this._enableBlending),this._blendingSpeed!==null&&(a.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(c),c}removeTargetedAnimation(a){for(let x=this._targetedAnimations.length-1;x>-1;x--)this._targetedAnimations[x].animation===a&&this._targetedAnimations.splice(x,1)}normalize(a=null,x=null){a==null&&(a=this._from),x==null&&(x=this._to);for(let c=0;c<this._targetedAnimations.length;c++){const g=this._targetedAnimations[c].animation.getKeys(),y=g[0],v=g[g.length-1];if(y.frame>a){const w={frame:a,value:y.value,inTangent:y.inTangent,outTangent:y.outTangent,interpolation:y.interpolation};g.splice(0,0,w)}if(v.frame<x){const w={frame:x,value:v.value,inTangent:v.inTangent,outTangent:v.outTangent,interpolation:v.interpolation};g.push(w)}}return this._from=a,this._to=x,this}_processLoop(a,x,c){a.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(x),!this._animationLoopFlags[c]&&(this._animationLoopFlags[c]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(a=!1,x=1,c,u,g){if(this._isStarted||this._targetedAnimations.length===0)return this;this._loopAnimation=a,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let y=0;y<this._targetedAnimations.length;y++){const v=this._targetedAnimations[y],w=this._scene.beginDirectAnimation(v.target,[v.animation],c!==void 0?c:this._from,u!==void 0?u:this._to,a,x,void 0,void 0,g!==void 0?g:this._isAdditive);w.weight=this._weight,w.playOrder=this._playOrder,w.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(v),this._checkAnimationGroupEnded(w)},this._processLoop(w,v,y),this._animatables.push(w)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=x,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let a=0;a<this._animatables.length;a++)this._animatables[a].pause();return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(a){return this.isStarted&&this._animatables.length===this._targetedAnimations.length?(a!==void 0&&(this.loopAnimation=a),this.restart()):(this.stop(),this.start(a,this._speedRatio)),this._isPaused=!1,this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(),this;for(let a=0;a<this._animatables.length;a++)this._animatables[a].reset();return this}restart(){if(!this._isStarted)return this;for(let a=0;a<this._animatables.length;a++)this._animatables[a].restart();return this.syncWithMask(),this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){if(!this._isStarted)return this;const a=this._animatables.slice();for(let c=0;c<a.length;c++)a[c].stop(void 0,void 0,!0);let x=0;for(let c=0;c<this._scene._activeAnimatables.length;c++){const u=this._scene._activeAnimatables[c];u._runtimeAnimations.length>0&&(this._scene._activeAnimatables[x++]=u)}return this._scene._activeAnimatables.length=x,this._isStarted=!1,this}setWeightForAllAnimatables(a){for(let x=0;x<this._animatables.length;x++){const c=this._animatables[x];c.weight=a}return this}syncAllAnimationsWith(a){for(let x=0;x<this._animatables.length;x++)this._animatables[x].syncWith(a);return this}goToFrame(a){if(!this._isStarted)return this;for(let x=0;x<this._animatables.length;x++)this._animatables[x].goToFrame(a);return this}dispose(){this._targetedAnimations.length=0,this._animatables.length=0;const a=this._scene.animationGroups.indexOf(this);if(a>-1&&this._scene.animationGroups.splice(a,1),this._parentContainer){const x=this._parentContainer.animationGroups.indexOf(this);x>-1&&this._parentContainer.animationGroups.splice(x,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(a){const x=this._animatables.indexOf(a);x>-1&&this._animatables.splice(x,1),this._animatables.length===0&&(this._isStarted=!1,this.onAnimationGroupEndObservable.notifyObservers(this))}clone(a,x,c=!1){const u=new xc(a||this.name,this._scene,this._weight,this._playOrder);u._from=this.from,u._to=this.to,u._speedRatio=this.speedRatio,u._loopAnimation=this.loopAnimation,u._isAdditive=this.isAdditive,u._enableBlending=this.enableBlending,u._blendingSpeed=this.blendingSpeed,u.metadata=this.metadata,u.mask=this.mask;for(const g of this._targetedAnimations)u.addTargetedAnimation(c?g.animation.clone():g.animation,x?x(g.target):g.target);return u}serialize(){const a={};a.name=this.name,a.from=this.from,a.to=this.to,a.speedRatio=this.speedRatio,a.loopAnimation=this.loopAnimation,a.isAdditive=this.isAdditive,a.weight=this.weight,a.playOrder=this.playOrder,a.enableBlending=this.enableBlending,a.blendingSpeed=this.blendingSpeed,a.targetedAnimations=[];for(let x=0;x<this.targetedAnimations.length;x++){const c=this.targetedAnimations[x];a.targetedAnimations[x]=c.serialize()}return Vt&&Vt.HasTags(this)&&(a.tags=Vt.GetTags(this)),this.metadata&&(a.metadata=this.metadata),a}static Parse(a,x){const c=new xc(a.name,x,a.weight,a.playOrder);for(let u=0;u<a.targetedAnimations.length;u++){const g=a.targetedAnimations[u],y=xi.Parse(g.animation),v=g.targetId;if(g.animation.property==="influence"){const w=x.getMorphTargetById(v);w&&c.addTargetedAnimation(y,w)}else{const w=x.getNodeById(v);w!=null&&c.addTargetedAnimation(y,w)}}return Vt&&Vt.AddTagsTo(c,a.tags),a.from!==null&&a.to!==null&&c.normalize(a.from,a.to),a.speedRatio!==void 0&&(c._speedRatio=a.speedRatio),a.loopAnimation!==void 0&&(c._loopAnimation=a.loopAnimation),a.isAdditive!==void 0&&(c._isAdditive=a.isAdditive),a.weight!==void 0&&(c._weight=a.weight),a.playOrder!==void 0&&(c._playOrder=a.playOrder),a.enableBlending!==void 0&&(c._enableBlending=a.enableBlending),a.blendingSpeed!==void 0&&(c._blendingSpeed=a.blendingSpeed),a.metadata!==void 0&&(c.metadata=a.metadata),c}static MakeAnimationAdditive(a,x,c,u=!1,g){let y;typeof x=="object"?y=x:y={referenceFrame:x,range:c,cloneOriginalAnimationGroup:u,clonedAnimationName:g};let v=a;y.cloneOriginalAnimationGroup&&(v=a.clone(y.clonedAnimationGroupName||v.name));const w=v.targetedAnimations;for(let B=0;B<w.length;B++){const W=w[B];W.animation=xi.MakeAnimationAdditive(W.animation,y)}if(v.isAdditive=!0,y.clipKeys){let B=Number.MAX_VALUE,W=-Number.MAX_VALUE;const ae=v.targetedAnimations;for(let ue=0;ue<ae.length;ue++){const _e=ae[ue].animation.getKeys();B>_e[0].frame&&(B=_e[0].frame),W<_e[_e.length-1].frame&&(W=_e[_e.length-1].frame)}v._from=B,v._to=W}return v}static ClipKeys(a,x,c,u,g){const y=a.clone(u||a.name);return xc.ClipKeysInPlace(y,x,c,g)}static ClipKeysInPlace(a,x,c,u){return xc.ClipInPlace(a,x,c,u,!1)}static ClipFrames(a,x,c,u,g){const y=a.clone(u||a.name);return xc.ClipFramesInPlace(y,x,c,g)}static ClipFramesInPlace(a,x,c,u){return xc.ClipInPlace(a,x,c,u,!0)}static ClipInPlace(a,x,c,u,g=!1){let y=Number.MAX_VALUE,v=-Number.MAX_VALUE;const w=a.targetedAnimations;for(let B=0;B<w.length;B++){const W=w[B],ae=u?W.animation:W.animation.clone();g&&(ae.createKeyForFrame(x),ae.createKeyForFrame(c));const ue=ae.getKeys(),fe=[];let Re=Number.MAX_VALUE;for(let _e=0;_e<ue.length;_e++){const Be=ue[_e];if(!g&&_e>=x&&_e<=c||g&&Be.frame>=x&&Be.frame<=c){const tt={frame:Be.frame,value:Be.value.clone?Be.value.clone():Be.value,inTangent:Be.inTangent,outTangent:Be.outTangent,interpolation:Be.interpolation,lockedTangent:Be.lockedTangent};Re===Number.MAX_VALUE&&(Re=tt.frame),tt.frame-=Re,fe.push(tt)}}if(fe.length===0){w.splice(B,1),B--;continue}y>fe[0].frame&&(y=fe[0].frame),v<fe[fe.length-1].frame&&(v=fe[fe.length-1].frame),ae.setKeys(fe,!0),W.animation=ae}return a._from=y,a._to=v,a}getClassName(){return"AnimationGroup"}toString(a){let x="Name: "+this.name;return x+=", type: "+this.getClassName(),a&&(x+=", from: "+this._from,x+=", to: "+this._to,x+=", isStarted: "+this._isStarted,x+=", speedRatio: "+this._speedRatio,x+=", targetedAnimations length: "+this._targetedAnimations.length,x+=", animatables length: "+this._animatables),x}}class Hn extends fa{get _matrix(){return this._compose(),this._localMatrix}set _matrix(a){a.updateFlag===this._localMatrix.updateFlag&&!this._needToCompose||(this._needToCompose=!1,this._localMatrix.copyFrom(a),this._markAsDirtyAndDecompose())}constructor(a,x,c=null,u=null,g=null,y=null,v=null){super(a,x.getScene()),this.name=a,this.children=[],this.animations=[],this._index=null,this._scalingDeterminant=1,this._needToDecompose=!0,this._needToCompose=!1,this._linkedTransformNode=null,this._waitingTransformNodeId=null,this._skeleton=x,this._localMatrix=u?.clone()??vt.Identity(),this._restMatrix=g??this._localMatrix.clone(),this._bindMatrix=y??this._localMatrix.clone(),this._index=v,this._absoluteMatrix=new vt,this._absoluteBindMatrix=new vt,this._absoluteInverseBindMatrix=new vt,this._finalMatrix=new vt,x.bones.push(this),this.setParent(c,!1),this._updateAbsoluteBindMatrices()}getClassName(){return"Bone"}getSkeleton(){return this._skeleton}get parent(){return this._parentNode}getParent(){return this.parent}getChildren(){return this.children}getIndex(){return this._index===null?this.getSkeleton().bones.indexOf(this):this._index}set parent(a){this.setParent(a)}setParent(a,x=!0){if(this.parent!==a){if(this.parent){const c=this.parent.children.indexOf(this);c!==-1&&this.parent.children.splice(c,1)}this._parentNode=a,this.parent&&this.parent.children.push(this),x&&this._updateAbsoluteBindMatrices(),this.markAsDirty()}}getLocalMatrix(){return this._compose(),this._localMatrix}getBindMatrix(){return this._bindMatrix}getBaseMatrix(){return this.getBindMatrix()}getRestMatrix(){return this._restMatrix}getRestPose(){return this.getRestMatrix()}setRestMatrix(a){this._restMatrix.copyFrom(a)}setRestPose(a){this.setRestMatrix(a)}getBindPose(){return this.getBindMatrix()}setBindMatrix(a){this.updateMatrix(a)}setBindPose(a){this.setBindMatrix(a)}getFinalMatrix(){return this._finalMatrix}getWorldMatrix(){return this.getFinalMatrix()}returnToRest(){if(this._linkedTransformNode){const a=Yt.Vector3[0],x=Yt.Quaternion[0],c=Yt.Vector3[1];this.getRestMatrix().decompose(a,x,c),this._linkedTransformNode.position.copyFrom(c),this._linkedTransformNode.rotationQuaternion=this._linkedTransformNode.rotationQuaternion??Wi.Identity(),this._linkedTransformNode.rotationQuaternion.copyFrom(x),this._linkedTransformNode.scaling.copyFrom(a)}else this._matrix=this._restMatrix}getAbsoluteInverseBindMatrix(){return this._absoluteInverseBindMatrix}getInvertedAbsoluteTransform(){return this.getAbsoluteInverseBindMatrix()}getAbsoluteMatrix(){return this._absoluteMatrix}getAbsoluteTransform(){return this._absoluteMatrix}linkTransformNode(a){this._linkedTransformNode&&this._skeleton._numBonesWithLinkedTransformNode--,this._linkedTransformNode=a,this._linkedTransformNode&&this._skeleton._numBonesWithLinkedTransformNode++}getTransformNode(){return this._linkedTransformNode}get position(){return this._decompose(),this._localPosition}set position(a){this._decompose(),this._localPosition.copyFrom(a),this._markAsDirtyAndCompose()}get rotation(){return this.getRotation()}set rotation(a){this.setRotation(a)}get rotationQuaternion(){return this._decompose(),this._localRotation}set rotationQuaternion(a){this.setRotationQuaternion(a)}get scaling(){return this.getScale()}set scaling(a){this.setScale(a)}get animationPropertiesOverride(){return this._skeleton.animationPropertiesOverride}_decompose(){this._needToDecompose&&(this._needToDecompose=!1,this._localScaling||(this._localScaling=Ee.Zero(),this._localRotation=Wi.Zero(),this._localPosition=Ee.Zero()),this._localMatrix.decompose(this._localScaling,this._localRotation,this._localPosition))}_compose(){if(this._needToCompose){if(!this._localScaling){this._needToCompose=!1;return}this._needToCompose=!1,vt.ComposeToRef(this._localScaling,this._localRotation,this._localPosition,this._localMatrix)}}updateMatrix(a,x=!0,c=!0){this._bindMatrix.copyFrom(a),x&&this._updateAbsoluteBindMatrices(),c?this._matrix=a:this.markAsDirty()}_updateAbsoluteBindMatrices(a,x=!0){if(a||(a=this._bindMatrix),this.parent?a.multiplyToRef(this.parent._absoluteBindMatrix,this._absoluteBindMatrix):this._absoluteBindMatrix.copyFrom(a),this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix),x)for(let c=0;c<this.children.length;c++)this.children[c]._updateAbsoluteBindMatrices();this._scalingDeterminant=this._absoluteBindMatrix.determinant()<0?-1:1}markAsDirty(){return this._currentRenderId++,this._childUpdateId++,this._skeleton._markAsDirty(),this}_markAsDirtyAndCompose(){this.markAsDirty(),this._needToCompose=!0}_markAsDirtyAndDecompose(){this.markAsDirty(),this._needToDecompose=!0}_updatePosition(a,x=mn.LOCAL,c,u=!0){const g=this.getLocalMatrix();if(x==mn.LOCAL)u?(g.addAtIndex(12,a.x),g.addAtIndex(13,a.y),g.addAtIndex(14,a.z)):g.setTranslationFromFloats(a.x,a.y,a.z);else{let y=null;c&&(y=c.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const v=Hn._TmpMats[0],w=Hn._TmpVecs[0];this.parent?c&&y?(v.copyFrom(this.parent.getAbsoluteMatrix()),v.multiplyToRef(y,v)):v.copyFrom(this.parent.getAbsoluteMatrix()):vt.IdentityToRef(v),u&&v.setTranslationFromFloats(0,0,0),v.invert(),Ee.TransformCoordinatesToRef(a,v,w),u?(g.addAtIndex(12,w.x),g.addAtIndex(13,w.y),g.addAtIndex(14,w.z)):g.setTranslationFromFloats(w.x,w.y,w.z)}this._markAsDirtyAndDecompose()}translate(a,x=mn.LOCAL,c){this._updatePosition(a,x,c,!0)}setPosition(a,x=mn.LOCAL,c){this._updatePosition(a,x,c,!1)}setAbsolutePosition(a,x){this.setPosition(a,mn.WORLD,x)}scale(a,x,c,u=!1){const g=this.getLocalMatrix(),y=Hn._TmpMats[0];vt.ScalingToRef(a,x,c,y),y.multiplyToRef(g,g),y.invert();for(const v of this.children){const w=v.getLocalMatrix();w.multiplyToRef(y,w),w.multiplyAtIndex(12,a),w.multiplyAtIndex(13,x),w.multiplyAtIndex(14,c),v._markAsDirtyAndDecompose()}if(this._markAsDirtyAndDecompose(),u)for(const v of this.children)v.scale(a,x,c,u)}setScale(a){this._decompose(),this._localScaling.copyFrom(a),this._markAsDirtyAndCompose()}getScale(){return this._decompose(),this._localScaling}getScaleToRef(a){this._decompose(),a.copyFrom(this._localScaling)}setYawPitchRoll(a,x,c,u=mn.LOCAL,g){if(u===mn.LOCAL){const w=Hn._TmpQuat;Wi.RotationYawPitchRollToRef(a,x,c,w),this.setRotationQuaternion(w,u,g);return}const y=Hn._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(y,g))return;const v=Hn._TmpMats[1];vt.RotationYawPitchRollToRef(a,x,c,v),y.multiplyToRef(v,v),this._rotateWithMatrix(v,u,g)}rotate(a,x,c=mn.LOCAL,u){const g=Hn._TmpMats[0];g.setTranslationFromFloats(0,0,0),vt.RotationAxisToRef(a,x,g),this._rotateWithMatrix(g,c,u)}setAxisAngle(a,x,c=mn.LOCAL,u){if(c===mn.LOCAL){const v=Hn._TmpQuat;Wi.RotationAxisToRef(a,x,v),this.setRotationQuaternion(v,c,u);return}const g=Hn._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(g,u))return;const y=Hn._TmpMats[1];vt.RotationAxisToRef(a,x,y),g.multiplyToRef(y,y),this._rotateWithMatrix(y,c,u)}setRotation(a,x=mn.LOCAL,c){this.setYawPitchRoll(a.y,a.x,a.z,x,c)}setRotationQuaternion(a,x=mn.LOCAL,c){if(x===mn.LOCAL){this._decompose(),this._localRotation.copyFrom(a),this._markAsDirtyAndCompose();return}const u=Hn._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(u,c))return;const g=Hn._TmpMats[1];vt.FromQuaternionToRef(a,g),u.multiplyToRef(g,g),this._rotateWithMatrix(g,x,c)}setRotationMatrix(a,x=mn.LOCAL,c){if(x===mn.LOCAL){const y=Hn._TmpQuat;Wi.FromRotationMatrixToRef(a,y),this.setRotationQuaternion(y,x,c);return}const u=Hn._TmpMats[0];if(!this._getAbsoluteInverseMatrixUnscaledToRef(u,c))return;const g=Hn._TmpMats[1];g.copyFrom(a),u.multiplyToRef(a,g),this._rotateWithMatrix(g,x,c)}_rotateWithMatrix(a,x=mn.LOCAL,c){const u=this.getLocalMatrix(),g=u.m[12],y=u.m[13],v=u.m[14],w=this.getParent(),B=Hn._TmpMats[3],W=Hn._TmpMats[4];w&&x==mn.WORLD?(c?(B.copyFrom(c.getWorldMatrix()),w.getAbsoluteMatrix().multiplyToRef(B,B)):B.copyFrom(w.getAbsoluteMatrix()),W.copyFrom(B),W.invert(),u.multiplyToRef(B,u),u.multiplyToRef(a,u),u.multiplyToRef(W,u)):x==mn.WORLD&&c?(B.copyFrom(c.getWorldMatrix()),W.copyFrom(B),W.invert(),u.multiplyToRef(B,u),u.multiplyToRef(a,u),u.multiplyToRef(W,u)):u.multiplyToRef(a,u),u.setTranslationFromFloats(g,y,v),this.computeAbsoluteMatrices(),this._markAsDirtyAndDecompose()}_getAbsoluteInverseMatrixUnscaledToRef(a,x){const c=Hn._TmpMats[2];return a.copyFrom(this.getAbsoluteMatrix()),x?(a.multiplyToRef(x.getWorldMatrix(),a),vt.ScalingToRef(x.scaling.x,x.scaling.y,x.scaling.z,c)):vt.IdentityToRef(c),a.invert(),isNaN(a.m[0])?!1:(c.multiplyAtIndex(0,this._scalingDeterminant),a.multiplyToRef(c,a),!0)}getPosition(a=mn.LOCAL,x=null){const c=Ee.Zero();return this.getPositionToRef(a,x,c),c}getPositionToRef(a=mn.LOCAL,x,c){if(a==mn.LOCAL){const u=this.getLocalMatrix();c.x=u.m[12],c.y=u.m[13],c.z=u.m[14]}else{let u=null;x&&(u=x.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();let g=Hn._TmpMats[0];x&&u?(g.copyFrom(this.getAbsoluteMatrix()),g.multiplyToRef(u,g)):g=this.getAbsoluteMatrix(),c.x=g.m[12],c.y=g.m[13],c.z=g.m[14]}}getAbsolutePosition(a=null){const x=Ee.Zero();return this.getPositionToRef(mn.WORLD,a,x),x}getAbsolutePositionToRef(a,x){this.getPositionToRef(mn.WORLD,a,x)}computeAbsoluteMatrices(){if(this._compose(),this.parent)this._localMatrix.multiplyToRef(this.parent._absoluteMatrix,this._absoluteMatrix);else{this._absoluteMatrix.copyFrom(this._localMatrix);const c=this._skeleton.getPoseMatrix();c&&this._absoluteMatrix.multiplyToRef(c,this._absoluteMatrix)}const a=this.children,x=a.length;for(let c=0;c<x;c++)a[c].computeAbsoluteMatrices()}computeAbsoluteTransforms(){this.computeAbsoluteMatrices()}getDirection(a,x=null){const c=Ee.Zero();return this.getDirectionToRef(a,x,c),c}getDirectionToRef(a,x=null,c){let u=null;x&&(u=x.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const g=Hn._TmpMats[0];g.copyFrom(this.getAbsoluteMatrix()),x&&u&&g.multiplyToRef(u,g),Ee.TransformNormalToRef(a,g,c),c.normalize()}getRotation(a=mn.LOCAL,x=null){const c=Ee.Zero();return this.getRotationToRef(a,x,c),c}getRotationToRef(a=mn.LOCAL,x=null,c){const u=Hn._TmpQuat;this.getRotationQuaternionToRef(a,x,u),u.toEulerAnglesToRef(c)}getRotationQuaternion(a=mn.LOCAL,x=null){const c=Wi.Identity();return this.getRotationQuaternionToRef(a,x,c),c}getRotationQuaternionToRef(a=mn.LOCAL,x=null,c){if(a==mn.LOCAL)this._decompose(),c.copyFrom(this._localRotation);else{const u=Hn._TmpMats[0],g=this.getAbsoluteMatrix();x?g.multiplyToRef(x.getWorldMatrix(),u):u.copyFrom(g),u.multiplyAtIndex(0,this._scalingDeterminant),u.multiplyAtIndex(1,this._scalingDeterminant),u.multiplyAtIndex(2,this._scalingDeterminant),u.decompose(void 0,c,void 0)}}getRotationMatrix(a=mn.LOCAL,x){const c=vt.Identity();return this.getRotationMatrixToRef(a,x,c),c}getRotationMatrixToRef(a=mn.LOCAL,x,c){if(a==mn.LOCAL)this.getLocalMatrix().getRotationMatrixToRef(c);else{const u=Hn._TmpMats[0],g=this.getAbsoluteMatrix();x?g.multiplyToRef(x.getWorldMatrix(),u):u.copyFrom(g),u.multiplyAtIndex(0,this._scalingDeterminant),u.multiplyAtIndex(1,this._scalingDeterminant),u.multiplyAtIndex(2,this._scalingDeterminant),u.getRotationMatrixToRef(c)}}getAbsolutePositionFromLocal(a,x=null){const c=Ee.Zero();return this.getAbsolutePositionFromLocalToRef(a,x,c),c}getAbsolutePositionFromLocalToRef(a,x=null,c){let u=null;x&&(u=x.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const g=Hn._TmpMats[0];g.copyFrom(this.getAbsoluteMatrix()),x&&u&&g.multiplyToRef(u,g),Ee.TransformCoordinatesToRef(a,g,c)}getLocalPositionFromAbsolute(a,x=null){const c=Ee.Zero();return this.getLocalPositionFromAbsoluteToRef(a,x,c),c}getLocalPositionFromAbsoluteToRef(a,x=null,c){let u=null;x&&(u=x.getWorldMatrix()),this._skeleton.computeAbsoluteMatrices();const g=Hn._TmpMats[0];g.copyFrom(this.getAbsoluteMatrix()),x&&u&&g.multiplyToRef(u,g),g.invert(),Ee.TransformCoordinatesToRef(a,g,c)}setCurrentPoseAsRest(){this.setRestMatrix(this.getLocalMatrix())}}Hn._TmpVecs=Ws.BuildArray(2,Ee.Zero),Hn._TmpQuat=Wi.Identity(),Hn._TmpMats=Ws.BuildArray(5,vt.Identity);class Ig{get useTextureToStoreBoneMatrices(){return this._useTextureToStoreBoneMatrices}set useTextureToStoreBoneMatrices(a){this._useTextureToStoreBoneMatrices=a,this._markAsDirty()}get animationPropertiesOverride(){return this._animationPropertiesOverride?this._animationPropertiesOverride:this._scene.animationPropertiesOverride}set animationPropertiesOverride(a){this._animationPropertiesOverride=a}get isUsingTextureForMatrices(){return this.useTextureToStoreBoneMatrices&&this._canUseTextureForBones}get uniqueId(){return this._uniqueId}constructor(a,x,c){this.name=a,this.id=x,this.bones=[],this.needInitialSkinMatrix=!1,this._isDirty=!0,this._meshesWithPoseMatrix=new Array,this._identity=vt.Identity(),this._currentRenderId=-1,this._ranges={},this._absoluteTransformIsDirty=!0,this._canUseTextureForBones=!1,this._uniqueId=0,this._numBonesWithLinkedTransformNode=0,this._hasWaitingData=null,this._parentContainer=null,this.doNotSerialize=!1,this._useTextureToStoreBoneMatrices=!0,this._animationPropertiesOverride=null,this.onBeforeComputeObservable=new Jt,this.bones=[],this._scene=c||tr.LastCreatedScene,this._uniqueId=this._scene.getUniqueId(),this._scene.addSkeleton(this),this._isDirty=!0;const u=this._scene.getEngine().getCaps();this._canUseTextureForBones=u.textureFloat&&u.maxVertexTextureImageUnits>0}getClassName(){return"Skeleton"}getChildren(){return this.bones.filter(a=>!a.getParent())}getTransformMatrices(a){if(this.needInitialSkinMatrix){if(!a)throw new Error("getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided");return a._bonesTransformMatrices||this.prepare(!0),a._bonesTransformMatrices}return(!this._transformMatrices||this._isDirty)&&this.prepare(!this._transformMatrices),this._transformMatrices}getTransformMatrixTexture(a){return this.needInitialSkinMatrix&&a._transformMatrixTexture?a._transformMatrixTexture:this._transformMatrixTexture}getScene(){return this._scene}toString(a){let x=`Name: ${this.name}, nBones: ${this.bones.length}`;if(x+=`, nAnimationRanges: ${this._ranges?Object.keys(this._ranges).length:"none"}`,a){x+=", Ranges: {";let c=!0;for(const u in this._ranges)c&&(x+=", ",c=!1),x+=u;x+="}"}return x}getBoneIndexByName(a){for(let x=0,c=this.bones.length;x<c;x++)if(this.bones[x].name===a)return x;return-1}createAnimationRange(a,x,c){if(!this._ranges[a]){this._ranges[a]=new Bu(a,x,c);for(let u=0,g=this.bones.length;u<g;u++)this.bones[u].animations[0]&&this.bones[u].animations[0].createRange(a,x,c)}}deleteAnimationRange(a,x=!0){for(let c=0,u=this.bones.length;c<u;c++)this.bones[c].animations[0]&&this.bones[c].animations[0].deleteRange(a,x);this._ranges[a]=null}getAnimationRange(a){return this._ranges[a]||null}getAnimationRanges(){const a=[];let x;for(x in this._ranges)a.push(this._ranges[x]);return a}copyAnimationRange(a,x,c=!1){if(this._ranges[x]||!a.getAnimationRange(x))return!1;let u=!0;const g=this._getHighestAnimationFrame()+1,y={},v=a.bones;let w,B;for(B=0,w=v.length;B<w;B++)y[v[B].name]=v[B];this.bones.length!==v.length&&(Qt.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${v.length}`),u=!1);const W=c&&this.dimensionsAtRest&&a.dimensionsAtRest?this.dimensionsAtRest.divide(a.dimensionsAtRest):null;for(B=0,w=this.bones.length;B<w;B++){const ue=this.bones[B].name,fe=y[ue];fe?u=u&&this.bones[B].copyAnimationRange(fe,x,g,c,W):(Qt.Warn("copyAnimationRange: not same rig, missing source bone "+ue),u=!1)}const ae=a.getAnimationRange(x);return ae&&(this._ranges[x]=new Bu(x,ae.from+g,ae.to+g)),u}returnToRest(){for(const a of this.bones)a._index!==-1&&a.returnToRest()}_getHighestAnimationFrame(){let a=0;for(let x=0,c=this.bones.length;x<c;x++)if(this.bones[x].animations[0]){const u=this.bones[x].animations[0].getHighestFrame();a<u&&(a=u)}return a}beginAnimation(a,x,c,u){const g=this.getAnimationRange(a);return g?this._scene.beginAnimation(this,g.from,g.to,x,c,u):null}static MakeAnimationAdditive(a,x=0,c){const u=a.getAnimationRange(c);if(!u)return null;const g=a._scene.getAllAnimatablesByTarget(a);let y=null;for(let w=0;w<g.length;w++){const B=g[w];if(B.fromFrame===u?.from&&B.toFrame===u?.to){y=B;break}}const v=a.getAnimatables();for(let w=0;w<v.length;w++){const W=v[w].animations;if(W)for(let ae=0;ae<W.length;ae++)xi.MakeAnimationAdditive(W[ae],x,c)}return y&&(y.isAdditive=!0),a}_markAsDirty(){this._isDirty=!0,this._absoluteTransformIsDirty=!0}_registerMeshWithPoseMatrix(a){this._meshesWithPoseMatrix.push(a)}_unregisterMeshWithPoseMatrix(a){const x=this._meshesWithPoseMatrix.indexOf(a);x>-1&&this._meshesWithPoseMatrix.splice(x,1)}_computeTransformMatrices(a,x){this.onBeforeComputeObservable.notifyObservers(this);for(let c=0;c<this.bones.length;c++){const u=this.bones[c];u._childUpdateId++;const g=u.getParent();if(g?u.getLocalMatrix().multiplyToRef(g.getFinalMatrix(),u.getFinalMatrix()):x?u.getLocalMatrix().multiplyToRef(x,u.getFinalMatrix()):u.getFinalMatrix().copyFrom(u.getLocalMatrix()),u._index!==-1){const y=u._index===null?c:u._index;u.getAbsoluteInverseBindMatrix().multiplyToArray(u.getFinalMatrix(),a,y*16)}}this._identity.copyToArray(a,this.bones.length*16)}prepare(a=!1){if(!a){const x=this.getScene().getRenderId();if(this._currentRenderId===x)return;this._currentRenderId=x}if(this._numBonesWithLinkedTransformNode>0){for(const x of this.bones)if(x._linkedTransformNode){const c=x._linkedTransformNode;x.position=c.position,c.rotationQuaternion?x.rotationQuaternion=c.rotationQuaternion:x.rotation=c.rotation,x.scaling=c.scaling}}if(this.needInitialSkinMatrix)for(const x of this._meshesWithPoseMatrix){const c=x.getPoseMatrix();let u=this._isDirty;if((!x._bonesTransformMatrices||x._bonesTransformMatrices.length!==16*(this.bones.length+1))&&(x._bonesTransformMatrices=new Float32Array(16*(this.bones.length+1)),u=!0),!!u){if(this._synchronizedWithMesh!==x){this._synchronizedWithMesh=x;for(const g of this.bones)g.getParent()||(g.getBindMatrix().multiplyToRef(c,Yt.Matrix[1]),g._updateAbsoluteBindMatrices(Yt.Matrix[1]));if(this.isUsingTextureForMatrices){const g=(this.bones.length+1)*4;(!x._transformMatrixTexture||x._transformMatrixTexture.getSize().width!==g)&&(x._transformMatrixTexture&&x._transformMatrixTexture.dispose(),x._transformMatrixTexture=Vx.CreateRGBATexture(x._bonesTransformMatrices,(this.bones.length+1)*4,1,this._scene,!1,!1,1,1))}}this._computeTransformMatrices(x._bonesTransformMatrices,c),this.isUsingTextureForMatrices&&x._transformMatrixTexture&&x._transformMatrixTexture.update(x._bonesTransformMatrices)}}else{if(!this._isDirty)return;(!this._transformMatrices||this._transformMatrices.length!==16*(this.bones.length+1))&&(this._transformMatrices=new Float32Array(16*(this.bones.length+1)),this.isUsingTextureForMatrices&&(this._transformMatrixTexture&&this._transformMatrixTexture.dispose(),this._transformMatrixTexture=Vx.CreateRGBATexture(this._transformMatrices,(this.bones.length+1)*4,1,this._scene,!1,!1,1,1))),this._computeTransformMatrices(this._transformMatrices,null),this.isUsingTextureForMatrices&&this._transformMatrixTexture&&this._transformMatrixTexture.update(this._transformMatrices)}this._isDirty=!1}getAnimatables(){if(!this._animatables||this._animatables.length!==this.bones.length){this._animatables=[];for(let a=0;a<this.bones.length;a++)this._animatables.push(this.bones[a])}return this._animatables}clone(a,x){const c=new Ig(a,x||a,this._scene);c.needInitialSkinMatrix=this.needInitialSkinMatrix;for(let u=0;u<this.bones.length;u++){const g=this.bones[u];let y=null;const v=g.getParent();if(v){const B=this.bones.indexOf(v);y=c.bones[B]}const w=new Hn(g.name,c,y,g.getBindMatrix().clone(),g.getRestMatrix().clone());w._index=g._index,g._linkedTransformNode&&w.linkTransformNode(g._linkedTransformNode),$x.DeepCopy(g.animations,w.animations)}if(this._ranges){c._ranges={};for(const u in this._ranges){const g=this._ranges[u];g&&(c._ranges[u]=g.clone())}}return this._isDirty=!0,c.prepare(!0),c}enableBlending(a=.01){this.bones.forEach(x=>{x.animations.forEach(c=>{c.enableBlending=!0,c.blendingSpeed=a})})}dispose(){if(this._meshesWithPoseMatrix.length=0,this.getScene().stopAnimation(this),this.getScene().removeSkeleton(this),this._parentContainer){const a=this._parentContainer.skeletons.indexOf(this);a>-1&&this._parentContainer.skeletons.splice(a,1),this._parentContainer=null}this._transformMatrixTexture&&(this._transformMatrixTexture.dispose(),this._transformMatrixTexture=null)}serialize(){const a={};a.name=this.name,a.id=this.id,this.dimensionsAtRest&&(a.dimensionsAtRest=this.dimensionsAtRest.asArray()),a.bones=[],a.needInitialSkinMatrix=this.needInitialSkinMatrix;for(let x=0;x<this.bones.length;x++){const c=this.bones[x],u=c.getParent(),g={parentBoneIndex:u?this.bones.indexOf(u):-1,index:c.getIndex(),name:c.name,id:c.id,matrix:c.getBindMatrix().asArray(),rest:c.getRestMatrix().asArray(),linkedTransformNodeId:c.getTransformNode()?.id};a.bones.push(g),c.length&&(g.length=c.length),c.metadata&&(g.metadata=c.metadata),c.animations&&c.animations.length>0&&(g.animation=c.animations[0].serialize()),a.ranges=[];for(const y in this._ranges){const v=this._ranges[y];if(!v)continue;const w={};w.name=y,w.from=v.from,w.to=v.to,a.ranges.push(w)}}return a}static Parse(a,x){const c=new Ig(a.name,a.id,x);a.dimensionsAtRest&&(c.dimensionsAtRest=Ee.FromArray(a.dimensionsAtRest)),c.needInitialSkinMatrix=a.needInitialSkinMatrix;let u;for(u=0;u<a.bones.length;u++){const g=a.bones[u],y=a.bones[u].index;let v=null;g.parentBoneIndex>-1&&(v=c.bones[g.parentBoneIndex]);const w=g.rest?vt.FromArray(g.rest):null,B=new Hn(g.name,c,v,vt.FromArray(g.matrix),w,null,y);g.id!==void 0&&g.id!==null&&(B.id=g.id),g.length&&(B.length=g.length),g.metadata&&(B.metadata=g.metadata),g.animation&&B.animations.push(xi.Parse(g.animation)),g.linkedTransformNodeId!==void 0&&g.linkedTransformNodeId!==null&&(c._hasWaitingData=!0,B._waitingTransformNodeId=g.linkedTransformNodeId)}if(a.ranges)for(u=0;u<a.ranges.length;u++){const g=a.ranges[u];c.createAnimationRange(g.name,g.from,g.to)}return c}computeAbsoluteMatrices(a=!1){(this._absoluteTransformIsDirty||a)&&(this.bones[0].computeAbsoluteMatrices(),this._absoluteTransformIsDirty=!1)}computeAbsoluteTransforms(a=!1){this.computeAbsoluteMatrices(a)}getPoseMatrix(){let a=null;return this._meshesWithPoseMatrix.length>0&&(a=this._meshesWithPoseMatrix[0].getPoseMatrix()),a}sortBones(){const a=[],x=new Array(this.bones.length);for(let c=0;c<this.bones.length;c++)this._sortBones(c,a,x);this.bones=a}_sortBones(a,x,c){if(c[a])return;c[a]=!0;const u=this.bones[a];if(!u)return;u._index===void 0&&(u._index=a);const g=u.getParent();g&&this._sortBones(this.bones.indexOf(g),x,c),x.push(u)}setCurrentPoseAsRest(){this.bones.forEach(a=>{a.setCurrentPoseAsRest()})}}const y1="rgbdDecodePixelShader",b1=`varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;hi.ShadersStore[y1]=b1;const vV={name:y1,shader:b1},E1="passCubePixelShader",v1=`varying vec2 vUV;uniform samplerCube textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec2 uv=vUV*2.0-1.0;
#ifdef POSITIVEX
gl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));
#endif
#ifdef NEGATIVEX
gl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));
#endif
#ifdef POSITIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));
#endif
#ifdef NEGATIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));
#endif
#ifdef POSITIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,1.001));
#endif
#ifdef NEGATIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));
#endif
}`;hi.ShadersStore[E1]=v1;const IV={name:E1,shader:v1};class fm extends In{getClassName(){return"PassPostProcess"}constructor(a,x,c=null,u,g,y,v=0,w=!1){super(a,"pass",null,null,x,c,u,g,y,void 0,v,void 0,null,w)}static _Parse(a,x,c,u){return hr.Parse(()=>new fm(a.name,a.options,x,a.renderTargetSamplingMode,a._engine,a.reusable),a,c,u)}}as("BABYLON.PassPostProcess",fm);class R1 extends In{get face(){return this._face}set face(a){if(!(a<0||a>5))switch(this._face=a,this._face){case 0:this.updateEffect("#define POSITIVEX");break;case 1:this.updateEffect("#define NEGATIVEX");break;case 2:this.updateEffect("#define POSITIVEY");break;case 3:this.updateEffect("#define NEGATIVEY");break;case 4:this.updateEffect("#define POSITIVEZ");break;case 5:this.updateEffect("#define NEGATIVEZ");break}}getClassName(){return"PassCubePostProcess"}constructor(a,x,c=null,u,g,y,v=0,w=!1){super(a,"passCube",null,null,x,c,u,g,y,"#define POSITIVEX",v,void 0,null,w),this._face=0}static _Parse(a,x,c,u){return hr.Parse(()=>new R1(a.name,a.options,x,a.renderTargetSamplingMode,a._engine,a.reusable),a,c,u)}}Bt._RescalePostProcessFactory=F=>new fm("rescale",1,null,2,F,!1,0);function mL(F,a,x,c=!0){const u=F.getScene(),g=u.getEngine(),y=new Bo("resized"+F.name,{width:a,height:x},u,!F.noMipmap,!0,F._texture.type,!1,F.samplingMode,!1);y.wrapU=F.wrapU,y.wrapV=F.wrapV,y.uOffset=F.uOffset,y.vOffset=F.vOffset,y.uScale=F.uScale,y.vScale=F.vScale,y.uAng=F.uAng,y.vAng=F.vAng,y.wAng=F.wAng,y.coordinatesIndex=F.coordinatesIndex,y.level=F.level,y.anisotropicFilteringLevel=F.anisotropicFilteringLevel,y._texture.isReady=!1,F.wrapU=fi.CLAMP_ADDRESSMODE,F.wrapV=fi.CLAMP_ADDRESSMODE;const v=new fm("pass",1,null,c?fi.BILINEAR_SAMPLINGMODE:fi.NEAREST_SAMPLINGMODE,g,!1,0);return v.externalTextureSamplerBinding=!0,v.getEffect().executeWhenCompiled(()=>{v.onApply=function(B){B.setTexture("textureSampler",F)};const w=y.renderTarget;w&&(u.postProcessManager.directRender([v],w),g.unBindFramebuffer(w),y.disposeFramebufferObjects(),v.dispose(),y.getInternalTexture().isReady=!0)}),y}function M1(F,a,x,c,u,g,y,v){const w=a.getEngine();return a.isReady=!1,u=u??a.samplingMode,c=c??a.type,g=g??a.format,y=y??a.width,v=v??a.height,c===-1&&(c=0),new Promise(B=>{const W=new In("postprocess",F,null,null,1,null,u,w,!1,void 0,c,void 0,null,!1,g);W.externalTextureSamplerBinding=!0;const ae=w.createRenderTargetTexture({width:y,height:v},{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:u,type:c,format:g});W.getEffect().executeWhenCompiled(()=>{W.onApply=ue=>{ue._bindTexture("textureSampler",a),ue.setFloat2("scale",1,1)},x.postProcessManager.directRender([W],ae,!0),w.restoreDefaultFramebuffer(),w._releaseTexture(a),W&&W.dispose(),ae._swapAndDie(a),a.type=c,a.format=5,a.isReady=!0,B(a)})})}let Rg,k1;function gL(F){Rg||(Rg=new Float32Array(1),k1=new Int32Array(Rg.buffer)),Rg[0]=F;const a=k1[0];let x=a>>16&32768,c=a>>12&2047;const u=a>>23&255;return u<103?x:u>142?(x|=31744,x|=(u==255?0:1)&&a&8388607,x):u<113?(c|=2048,x|=(c>>114-u)+(c>>113-u&1),x):(x|=u-112<<10|c>>1,x+=c&1,x)}function _L(F){const a=(F&32768)>>15,x=(F&31744)>>10,c=F&1023;return x===0?(a?-1:1)*Math.pow(2,-14)*(c/Math.pow(2,10)):x==31?c?NaN:(a?-1:1)*(1/0):(a?-1:1)*Math.pow(2,x-15)*(1+c/Math.pow(2,10))}const yL=async(F,a,x,c,u)=>{const g=F.getScene(),y=g.getEngine();let v;if(!F.isCube)v=new In("lod","lod",["lod","gamma"],null,1,null,fi.NEAREST_NEAREST_MIPNEAREST,y);else{const W=["#define POSITIVEX","#define NEGATIVEX","#define POSITIVEY","#define NEGATIVEY","#define POSITIVEZ","#define NEGATIVEZ"];v=new In("lodCube","lodCube",["lod","gamma"],null,1,null,fi.NEAREST_NEAREST_MIPNEAREST,y,!1,W[c])}await new Promise(W=>{v.getEffect().executeWhenCompiled(()=>{W(0)})});const w=new Bo("temp",{width:a,height:x},g,!1);v.onApply=function(W){W.setTexture("textureSampler",F),W.setFloat("lod",u),W.setBool("gamma",F.gammaSpace)};const B=F.getInternalTexture();try{if(w.renderTarget&&B){const W=B.samplingMode;u!==0?F.updateSamplingMode(fi.NEAREST_NEAREST_MIPNEAREST):F.updateSamplingMode(fi.NEAREST_NEAREST),g.postProcessManager.directRender([v],w.renderTarget,!0),F.updateSamplingMode(W);const ae=await y.readPixels(0,0,a,x),ue=new Uint8Array(ae.buffer,0,ae.byteLength);return y.unBindFramebuffer(w.renderTarget),ue}else throw Error("Render to texture failed.")}finally{w.dispose(),v.dispose()}};async function bL(F,a,x,c=0,u=0){return!F.isReady()&&F._texture&&await new Promise((g,y)=>{if(F._texture===null){y(0);return}F._texture.onLoadedObservable.addOnce(()=>{g(0)})}),await yL(F,a,x,c,u)}const RV={CreateResizedCopy:mL,ApplyPostProcess:M1,ToHalfFloat:gL,FromHalfFloat:_L,GetTextureDataAsync:bL};class E_{static ExpandRGBDTexture(a){const x=a._texture;if(!x||!a.isRGBD)return;const c=x.getEngine(),u=c.getCaps(),g=x.isReady;let y=!1;u.textureHalfFloatRender&&u.textureHalfFloatLinearFiltering?(y=!0,x.type=2):u.textureFloatRender&&u.textureFloatLinearFiltering&&(y=!0,x.type=1),y&&(x.isReady=!1,x._isRGBD=!1,x.invertY=!1);const v=()=>{const w=new In("rgbdDecode","rgbdDecode",null,null,1,null,3,c,!1,void 0,x.type,void 0,null,!1);w.externalTextureSamplerBinding=!0;const B=c.createRenderTargetTexture(x.width,{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:x.samplingMode,type:x.type,format:5});w.getEffect().executeWhenCompiled(()=>{w.onApply=W=>{W._bindTexture("textureSampler",x),W.setFloat2("scale",1,1)},a.getScene().postProcessManager.directRender([w],B,!0),c.restoreDefaultFramebuffer(),c._releaseTexture(x),w&&w.dispose(),B._swapAndDie(x),x.isReady=!0})};y&&(g?v():a.onLoadObservable.addOnce(v))}static EncodeTextureToRGBD(a,x,c=0){return M1("rgbdEncode",a,x,c,1,5)}}const EL="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";let vL=0;const A_=F=>{if(!F.environmentBRDFTexture){const a=F.useDelayedTextureLoading;F.useDelayedTextureLoading=!1;const x=F._blockEntityCollection;F._blockEntityCollection=!1;const c=fi.CreateFromBase64String(EL,"EnvironmentBRDFTexture"+vL++,F,!0,!1,fi.BILINEAR_SAMPLINGMODE);F._blockEntityCollection=x;const u=F.getEngine().getLoadedTexturesCache(),g=u.indexOf(c.getInternalTexture());g!==-1&&u.splice(g,1),c.isRGBD=!0,c.wrapU=fi.CLAMP_ADDRESSMODE,c.wrapV=fi.CLAMP_ADDRESSMODE,F.environmentBRDFTexture=c,F.useDelayedTextureLoading=a,E_.ExpandRGBDTexture(c);const y=F.getEngine().onContextRestoredObservable.add(()=>{c.isRGBD=!0;const v=F.onBeforeRenderObservable.add(()=>{c.isReady()&&(F.onBeforeRenderObservable.remove(v),E_.ExpandRGBDTexture(c))})});F.onDisposeObservable.add(()=>{F.getEngine().onContextRestoredObservable.remove(y)})}return F.environmentBRDFTexture},MV={GetEnvironmentBRDFTexture:A_};class Jc{constructor(a){if(this._keys=[],this._isDirty=!0,this._areLightsDirty=!0,this._areLightsDisposed=!1,this._areAttributesDirty=!0,this._areTexturesDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._arePrePassDirty=!0,this._areImageProcessingDirty=!0,this._normals=!1,this._uvs=!1,this._needNormals=!1,this._needUVs=!1,this._externalProperties=a,a)for(const x in a)Object.prototype.hasOwnProperty.call(a,x)&&this._setDefaultValue(x)}get isDirty(){return this._isDirty}markAsProcessed(){this._isDirty=!1,this._areAttributesDirty=!1,this._areTexturesDirty=!1,this._areFresnelDirty=!1,this._areLightsDirty=!1,this._areLightsDisposed=!1,this._areMiscDirty=!1,this._arePrePassDirty=!1,this._areImageProcessingDirty=!1}markAsUnprocessed(){this._isDirty=!0}markAllAsDirty(){this._areTexturesDirty=!0,this._areAttributesDirty=!0,this._areLightsDirty=!0,this._areFresnelDirty=!0,this._areMiscDirty=!0,this._arePrePassDirty=!1,this._areImageProcessingDirty=!0,this._isDirty=!0}markAsImageProcessingDirty(){this._areImageProcessingDirty=!0,this._isDirty=!0}markAsLightDirty(a=!1){this._areLightsDirty=!0,this._areLightsDisposed=this._areLightsDisposed||a,this._isDirty=!0}markAsAttributesDirty(){this._areAttributesDirty=!0,this._isDirty=!0}markAsTexturesDirty(){this._areTexturesDirty=!0,this._isDirty=!0}markAsFresnelDirty(){this._areFresnelDirty=!0,this._isDirty=!0}markAsMiscDirty(){this._areMiscDirty=!0,this._isDirty=!0}markAsPrePassDirty(){this._arePrePassDirty=!0,this._isDirty=!0}rebuild(){this._keys.length=0;for(const a of Object.keys(this))a[0]!=="_"&&this._keys.push(a);if(this._externalProperties)for(const a in this._externalProperties)this._keys.indexOf(a)===-1&&this._keys.push(a)}isEqual(a){if(this._keys.length!==a._keys.length)return!1;for(let x=0;x<this._keys.length;x++){const c=this._keys[x];if(this[c]!==a[c])return!1}return!0}cloneTo(a){this._keys.length!==a._keys.length&&(a._keys=this._keys.slice(0));for(let x=0;x<this._keys.length;x++){const c=this._keys[x];a[c]=this[c]}}reset(){this._keys.forEach(a=>this._setDefaultValue(a))}_setDefaultValue(a){const x=this._externalProperties?.[a]?.type??typeof this[a],c=this._externalProperties?.[a]?.default;switch(x){case"number":this[a]=c??0;break;case"string":this[a]=c??"";break;default:this[a]=c??!1;break}}toString(){let a="";for(let x=0;x<this._keys.length;x++){const c=this._keys[x],u=this[c];switch(typeof u){case"number":case"string":a+="#define "+c+" "+u+`
`;break;default:u&&(a+="#define "+c+`
`);break}}return a}}const IL=new RegExp("^([gimus]+)!");class th{constructor(a){this._plugins=[],this._activePlugins=[],this._activePluginsForExtraEvents=[],this._material=a,this._scene=a.getScene(),this._engine=this._scene.getEngine()}_addPlugin(a){for(let u=0;u<this._plugins.length;++u)if(this._plugins[u].name===a.name)return!1;if(this._material._uniformBufferLayoutBuilt)throw`The plugin "${a.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;const x=a.getClassName();th._MaterialPluginClassToMainDefine[x]||(th._MaterialPluginClassToMainDefine[x]="MATERIALPLUGIN_"+ ++th._MaterialPluginCounter),this._material._callbackPluginEventGeneric=(u,g)=>this._handlePluginEvent(u,g),this._plugins.push(a),this._plugins.sort((u,g)=>u.priority-g.priority),this._codeInjectionPoints={};const c={};c[th._MaterialPluginClassToMainDefine[x]]={type:"boolean",default:!0};for(const u of this._plugins)u.collectDefines(c),this._collectPointNames("vertex",u.getCustomCode("vertex")),this._collectPointNames("fragment",u.getCustomCode("fragment"));return this._defineNamesFromPlugins=c,!0}_activatePlugin(a){this._activePlugins.indexOf(a)===-1&&(this._activePlugins.push(a),this._activePlugins.sort((x,c)=>x.priority-c.priority),this._material._callbackPluginEventIsReadyForSubMesh=this._handlePluginEventIsReadyForSubMesh.bind(this),this._material._callbackPluginEventPrepareDefinesBeforeAttributes=this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this),this._material._callbackPluginEventPrepareDefines=this._handlePluginEventPrepareDefines.bind(this),this._material._callbackPluginEventBindForSubMesh=this._handlePluginEventBindForSubMesh.bind(this),a.registerForExtraEvents&&(this._activePluginsForExtraEvents.push(a),this._activePluginsForExtraEvents.sort((x,c)=>x.priority-c.priority),this._material._callbackPluginEventHasRenderTargetTextures=this._handlePluginEventHasRenderTargetTextures.bind(this),this._material._callbackPluginEventFillRenderTargetTextures=this._handlePluginEventFillRenderTargetTextures.bind(this),this._material._callbackPluginEventHardBindForSubMesh=this._handlePluginEventHardBindForSubMesh.bind(this)))}getPlugin(a){for(let x=0;x<this._plugins.length;++x)if(this._plugins[x].name===a)return this._plugins[x];return null}_handlePluginEventIsReadyForSubMesh(a){let x=!0;for(const c of this._activePlugins)x=x&&c.isReadyForSubMesh(a.defines,this._scene,this._engine,a.subMesh);a.isReadyForSubMesh=x}_handlePluginEventPrepareDefinesBeforeAttributes(a){for(const x of this._activePlugins)x.prepareDefinesBeforeAttributes(a.defines,this._scene,a.mesh)}_handlePluginEventPrepareDefines(a){for(const x of this._activePlugins)x.prepareDefines(a.defines,this._scene,a.mesh)}_handlePluginEventHardBindForSubMesh(a){for(const x of this._activePluginsForExtraEvents)x.hardBindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,a.subMesh)}_handlePluginEventBindForSubMesh(a){for(const x of this._activePlugins)x.bindForSubMesh(this._material._uniformBuffer,this._scene,this._engine,a.subMesh)}_handlePluginEventHasRenderTargetTextures(a){let x=!1;for(const c of this._activePluginsForExtraEvents)if(x=c.hasRenderTargetTextures(),x)break;a.hasRenderTargetTextures=x}_handlePluginEventFillRenderTargetTextures(a){for(const x of this._activePluginsForExtraEvents)x.fillRenderTargetTextures(a.renderTargets)}_handlePluginEvent(a,x){switch(a){case bo.GetActiveTextures:{const c=x;for(const u of this._activePlugins)u.getActiveTextures(c.activeTextures);break}case bo.GetAnimatables:{const c=x;for(const u of this._activePlugins)u.getAnimatables(c.animatables);break}case bo.HasTexture:{const c=x;let u=!1;for(const g of this._activePlugins)if(u=g.hasTexture(c.texture),u)break;c.hasTexture=u;break}case bo.Disposed:{const c=x;for(const u of this._plugins)u.dispose(c.forceDisposeTextures);break}case bo.GetDefineNames:{const c=x;c.defineNames=this._defineNamesFromPlugins;break}case bo.PrepareEffect:{const c=x;for(const u of this._activePlugins)c.fallbackRank=u.addFallbacks(c.defines,c.fallbacks,c.fallbackRank),u.getAttributes(c.attributes,this._scene,c.mesh);this._uniformList.length>0&&c.uniforms.push(...this._uniformList),this._samplerList.length>0&&c.samplers.push(...this._samplerList),this._uboList.length>0&&c.uniformBuffersNames.push(...this._uboList),c.customCode=this._injectCustomCode(c,c.customCode);break}case bo.PrepareUniformBuffer:{const c=x;this._uboDeclaration="",this._vertexDeclaration="",this._fragmentDeclaration="",this._uniformList=[],this._samplerList=[],this._uboList=[];for(const u of this._plugins){const g=u.getUniforms();if(g){if(g.ubo)for(const y of g.ubo){if(y.size&&y.type){const v=y.arraySize??0;c.ubo.addUniform(y.name,y.size,v),this._uboDeclaration+=`${y.type} ${y.name}${v>0?`[${v}]`:""};
`}this._uniformList.push(y.name)}g.vertex&&(this._vertexDeclaration+=g.vertex+`
`),g.fragment&&(this._fragmentDeclaration+=g.fragment+`
`)}u.getSamplers(this._samplerList),u.getUniformBuffersNames(this._uboList)}break}}}_collectPointNames(a,x){if(x)for(const c in x)this._codeInjectionPoints[a]||(this._codeInjectionPoints[a]={}),this._codeInjectionPoints[a][c]=!0}_injectCustomCode(a,x){return(c,u)=>{x&&(u=x(c,u)),this._uboDeclaration&&(u=u.replace("#define ADDITIONAL_UBO_DECLARATION",this._uboDeclaration)),this._vertexDeclaration&&(u=u.replace("#define ADDITIONAL_VERTEX_DECLARATION",this._vertexDeclaration)),this._fragmentDeclaration&&(u=u.replace("#define ADDITIONAL_FRAGMENT_DECLARATION",this._fragmentDeclaration));const g=this._codeInjectionPoints?.[c];if(!g)return u;let y=null;for(let v in g){let w="";for(const B of this._activePlugins){let W=B.getCustomCode(c)?.[v];if(W){if(B.resolveIncludes){if(y===null){const ae=_a.GLSL;y={defines:[],indexParameters:a.indexParameters,isFragment:!1,shouldUseHighPrecisionShader:this._engine._shouldUseHighPrecisionShader,processor:void 0,supportsUniformBuffers:this._engine.supportsUniformBuffers,shadersRepository:hi.GetShadersRepository(ae),includesShadersStore:hi.GetIncludesShadersStore(ae),version:void 0,platformName:this._engine.shaderPlatformName,processingContext:void 0,isNDCHalfZRange:this._engine.isNDCHalfZRange,useReverseDepthBuffer:this._engine.useReverseDepthBuffer,processCodeAfterIncludes:void 0}}y.isFragment=c==="fragment",ho._ProcessIncludes(W,y,ae=>W=ae)}w+=W+`
`}}if(w.length>0)if(v.charAt(0)==="!"){v=v.substring(1);let B="g";if(v.charAt(0)==="!")B="",v=v.substring(1);else{const fe=IL.exec(v);fe&&fe.length>=2&&(B=fe[1],v=v.substring(B.length+1))}B.indexOf("g")<0&&(B+="g");const W=u,ae=new RegExp(v,B);let ue=ae.exec(W);for(;ue!==null;){let fe=w;for(let Re=0;Re<ue.length;++Re)fe=fe.replace("$"+Re,ue[Re]);u=u.replace(ue[0],fe),ue=ae.exec(W)}}else{const B="#define "+v;u=u.replace(B,`
`+w+`
`+B)}}return u}}}th._MaterialPluginClassToMainDefine={},th._MaterialPluginCounter=0,tr.OnEnginesDisposedObservable.add(()=>{B1()});const ah=[];let v_=!1,S_=null;function BV(F,a){v_||(S_=Material.OnEventObservable.add(c=>{for(const[,u]of ah)u(c)},MaterialPluginEvent.Created),v_=!0);const x=ah.filter(([c,u])=>c===F);x.length>0?x[0][1]=a:ah.push([F,a])}function UV(F){for(let a=0;a<ah.length;++a)if(ah[a][0]===F)return ah.splice(a,1),ah.length===0&&B1(),!0;return!1}function B1(){ah.length=0,v_=!1,ui.OnEventObservable.remove(S_),S_=null}class jl{_enable(a){a&&this._pluginManager._activatePlugin(this)}constructor(a,x,c,u,g=!0,y=!1,v=!1){this.priority=500,this.resolveIncludes=!1,this.registerForExtraEvents=!1,this._material=a,this.name=x,this.priority=c,this.resolveIncludes=v,a.pluginManager||(a.pluginManager=new th(a),a.onDisposeObservable.add(()=>{a.pluginManager=void 0})),this._pluginDefineNames=u,this._pluginManager=a.pluginManager,g&&this._pluginManager._addPlugin(this),y&&this._enable(!0),this.markAllDefinesAsDirty=a._dirtyCallbacks[63]}getClassName(){return"MaterialPluginBase"}isReadyForSubMesh(a,x,c,u){return!0}hardBindForSubMesh(a,x,c,u){}bindForSubMesh(a,x,c,u){}dispose(a){}getCustomCode(a){return null}collectDefines(a){if(this._pluginDefineNames)for(const x of Object.keys(this._pluginDefineNames)){if(x[0]==="_")continue;const c=typeof this._pluginDefineNames[x];a[x]={type:c==="number"?"number":c==="string"?"string":c==="boolean"?"boolean":"object",default:this._pluginDefineNames[x]}}}prepareDefinesBeforeAttributes(a,x,c){}prepareDefines(a,x,c){}hasTexture(a){return!1}hasRenderTargetTextures(){return!1}fillRenderTargetTextures(a){}getActiveTextures(a){}getAnimatables(a){}addFallbacks(a,x,c){return c}getSamplers(a){}getAttributes(a,x,c){}getUniformBuffersNames(a){}getUniforms(){return{}}copyTo(a){hr.Clone(()=>a,this)}serialize(){return hr.Serialize(this)}parse(a,x,c){hr.Parse(()=>this,a,x,c)}}Ye([ht()],jl.prototype,"name",void 0),Ye([ht()],jl.prototype,"priority",void 0),Ye([ht()],jl.prototype,"resolveIncludes",void 0),Ye([ht()],jl.prototype,"registerForExtraEvents",void 0);class RL extends Jc{constructor(){super(...arguments),this.BRDF_V_HEIGHT_CORRELATED=!1,this.MS_BRDF_ENERGY_CONSERVATION=!1,this.SPHERICAL_HARMONICS=!1,this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION=!1}}class Eo extends jl{_markAllSubMeshesAsMiscDirty(){this._internalMarkAllSubMeshesAsMiscDirty()}constructor(a,x=!0){super(a,"PBRBRDF",90,new RL,x),this._useEnergyConservation=Eo.DEFAULT_USE_ENERGY_CONSERVATION,this.useEnergyConservation=Eo.DEFAULT_USE_ENERGY_CONSERVATION,this._useSmithVisibilityHeightCorrelated=Eo.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED,this.useSmithVisibilityHeightCorrelated=Eo.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED,this._useSphericalHarmonics=Eo.DEFAULT_USE_SPHERICAL_HARMONICS,this.useSphericalHarmonics=Eo.DEFAULT_USE_SPHERICAL_HARMONICS,this._useSpecularGlossinessInputEnergyConservation=Eo.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION,this.useSpecularGlossinessInputEnergyConservation=Eo.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION,this._internalMarkAllSubMeshesAsMiscDirty=a._dirtyCallbacks[16],this._enable(!0)}prepareDefines(a){a.BRDF_V_HEIGHT_CORRELATED=this._useSmithVisibilityHeightCorrelated,a.MS_BRDF_ENERGY_CONSERVATION=this._useEnergyConservation&&this._useSmithVisibilityHeightCorrelated,a.SPHERICAL_HARMONICS=this._useSphericalHarmonics,a.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION=this._useSpecularGlossinessInputEnergyConservation}getClassName(){return"PBRBRDFConfiguration"}}Eo.DEFAULT_USE_ENERGY_CONSERVATION=!0,Eo.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED=!0,Eo.DEFAULT_USE_SPHERICAL_HARMONICS=!0,Eo.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION=!0,Ye([ht(),Ji("_markAllSubMeshesAsMiscDirty")],Eo.prototype,"useEnergyConservation",void 0),Ye([ht(),Ji("_markAllSubMeshesAsMiscDirty")],Eo.prototype,"useSmithVisibilityHeightCorrelated",void 0),Ye([ht(),Ji("_markAllSubMeshesAsMiscDirty")],Eo.prototype,"useSphericalHarmonics",void 0),Ye([ht(),Ji("_markAllSubMeshesAsMiscDirty")],Eo.prototype,"useSpecularGlossinessInputEnergyConservation",void 0);class C_{constructor(){this.previousWorldMatrices={},this.previousBones={}}static AddUniforms(a){a.push("previousWorld","previousViewProjection","mPreviousBones")}static AddSamplers(a){}bindForSubMesh(a,x,c,u,g){if(x.prePassRenderer&&x.prePassRenderer.enabled&&x.prePassRenderer.currentRTisSceneRT&&x.prePassRenderer.getIndex(2)!==-1){this.previousWorldMatrices[c.uniqueId]||(this.previousWorldMatrices[c.uniqueId]=u.clone()),this.previousViewProjection||(this.previousViewProjection=x.getTransformMatrix().clone(),this.currentViewProjection=x.getTransformMatrix().clone());const y=x.getEngine();this.currentViewProjection.updateFlag!==x.getTransformMatrix().updateFlag?(this._lastUpdateFrameId=y.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection),this.currentViewProjection.copyFrom(x.getTransformMatrix())):this._lastUpdateFrameId!==y.frameId&&(this._lastUpdateFrameId=y.frameId,this.previousViewProjection.copyFrom(this.currentViewProjection)),a.setMatrix("previousWorld",this.previousWorldMatrices[c.uniqueId]),a.setMatrix("previousViewProjection",this.previousViewProjection),this.previousWorldMatrices[c.uniqueId]=u.clone()}}}class $i{static get DiffuseTextureEnabled(){return this._DiffuseTextureEnabled}static set DiffuseTextureEnabled(a){this._DiffuseTextureEnabled!==a&&(this._DiffuseTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get DetailTextureEnabled(){return this._DetailTextureEnabled}static set DetailTextureEnabled(a){this._DetailTextureEnabled!==a&&(this._DetailTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get DecalMapEnabled(){return this._DecalMapEnabled}static set DecalMapEnabled(a){this._DecalMapEnabled!==a&&(this._DecalMapEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get AmbientTextureEnabled(){return this._AmbientTextureEnabled}static set AmbientTextureEnabled(a){this._AmbientTextureEnabled!==a&&(this._AmbientTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get OpacityTextureEnabled(){return this._OpacityTextureEnabled}static set OpacityTextureEnabled(a){this._OpacityTextureEnabled!==a&&(this._OpacityTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get ReflectionTextureEnabled(){return this._ReflectionTextureEnabled}static set ReflectionTextureEnabled(a){this._ReflectionTextureEnabled!==a&&(this._ReflectionTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get EmissiveTextureEnabled(){return this._EmissiveTextureEnabled}static set EmissiveTextureEnabled(a){this._EmissiveTextureEnabled!==a&&(this._EmissiveTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get SpecularTextureEnabled(){return this._SpecularTextureEnabled}static set SpecularTextureEnabled(a){this._SpecularTextureEnabled!==a&&(this._SpecularTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get BumpTextureEnabled(){return this._BumpTextureEnabled}static set BumpTextureEnabled(a){this._BumpTextureEnabled!==a&&(this._BumpTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get LightmapTextureEnabled(){return this._LightmapTextureEnabled}static set LightmapTextureEnabled(a){this._LightmapTextureEnabled!==a&&(this._LightmapTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get RefractionTextureEnabled(){return this._RefractionTextureEnabled}static set RefractionTextureEnabled(a){this._RefractionTextureEnabled!==a&&(this._RefractionTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get ColorGradingTextureEnabled(){return this._ColorGradingTextureEnabled}static set ColorGradingTextureEnabled(a){this._ColorGradingTextureEnabled!==a&&(this._ColorGradingTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get FresnelEnabled(){return this._FresnelEnabled}static set FresnelEnabled(a){this._FresnelEnabled!==a&&(this._FresnelEnabled=a,Bt.MarkAllMaterialsAsDirty(4))}static get ClearCoatTextureEnabled(){return this._ClearCoatTextureEnabled}static set ClearCoatTextureEnabled(a){this._ClearCoatTextureEnabled!==a&&(this._ClearCoatTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get ClearCoatBumpTextureEnabled(){return this._ClearCoatBumpTextureEnabled}static set ClearCoatBumpTextureEnabled(a){this._ClearCoatBumpTextureEnabled!==a&&(this._ClearCoatBumpTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get ClearCoatTintTextureEnabled(){return this._ClearCoatTintTextureEnabled}static set ClearCoatTintTextureEnabled(a){this._ClearCoatTintTextureEnabled!==a&&(this._ClearCoatTintTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get SheenTextureEnabled(){return this._SheenTextureEnabled}static set SheenTextureEnabled(a){this._SheenTextureEnabled!==a&&(this._SheenTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get AnisotropicTextureEnabled(){return this._AnisotropicTextureEnabled}static set AnisotropicTextureEnabled(a){this._AnisotropicTextureEnabled!==a&&(this._AnisotropicTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get ThicknessTextureEnabled(){return this._ThicknessTextureEnabled}static set ThicknessTextureEnabled(a){this._ThicknessTextureEnabled!==a&&(this._ThicknessTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get RefractionIntensityTextureEnabled(){return this._ThicknessTextureEnabled}static set RefractionIntensityTextureEnabled(a){this._RefractionIntensityTextureEnabled!==a&&(this._RefractionIntensityTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get TranslucencyIntensityTextureEnabled(){return this._ThicknessTextureEnabled}static set TranslucencyIntensityTextureEnabled(a){this._TranslucencyIntensityTextureEnabled!==a&&(this._TranslucencyIntensityTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}static get IridescenceTextureEnabled(){return this._IridescenceTextureEnabled}static set IridescenceTextureEnabled(a){this._IridescenceTextureEnabled!==a&&(this._IridescenceTextureEnabled=a,Bt.MarkAllMaterialsAsDirty(1))}}$i._DiffuseTextureEnabled=!0,$i._DetailTextureEnabled=!0,$i._DecalMapEnabled=!0,$i._AmbientTextureEnabled=!0,$i._OpacityTextureEnabled=!0,$i._ReflectionTextureEnabled=!0,$i._EmissiveTextureEnabled=!0,$i._SpecularTextureEnabled=!0,$i._BumpTextureEnabled=!0,$i._LightmapTextureEnabled=!0,$i._RefractionTextureEnabled=!0,$i._ColorGradingTextureEnabled=!0,$i._FresnelEnabled=!0,$i._ClearCoatTextureEnabled=!0,$i._ClearCoatBumpTextureEnabled=!0,$i._ClearCoatTintTextureEnabled=!0,$i._SheenTextureEnabled=!0,$i._AnisotropicTextureEnabled=!0,$i._ThicknessTextureEnabled=!0,$i._RefractionIntensityTextureEnabled=!0,$i._TranslucencyIntensityTextureEnabled=!0,$i._IridescenceTextureEnabled=!0;var Uu;(function(F){F[F.CW=0]="CW",F[F.CCW=1]="CCW"})(Uu||(Uu={}));class VV{static Interpolate(a,x,c,u,g){const y=1-3*u+3*x,v=3*u-6*x,w=3*x;let B=a;for(let W=0;W<5;W++){const ae=B*B,ue=ae*B,fe=y*ue+v*ae+w*B,Re=1/(3*y*ae+2*v*B+w);B-=(fe-a)*Re,B=Math.min(1,Math.max(0,B))}return 3*Math.pow(1-B,2)*B*c+3*(1-B)*Math.pow(B,2)*g+Math.pow(B,3)}}class _2{constructor(a){this._radians=a,this._radians<0&&(this._radians+=2*Math.PI)}degrees(){return this._radians*180/Math.PI}radians(){return this._radians}static BetweenTwoPoints(a,x){const c=x.subtract(a),u=Math.atan2(c.y,c.x);return new _2(u)}static BetweenTwoVectors(a,x){let c=a.lengthSquared()*x.lengthSquared();if(c===0)return new _2(Math.PI/2);c=Math.sqrt(c);let u=a.dot(x)/c;u=Scalar.Clamp(u,-1,1);const g=Math.acos(u);return new _2(g)}static FromRadians(a){return new _2(a)}static FromDegrees(a){return new _2(a*Math.PI/180)}}class ML{constructor(a,x,c){this.startPoint=a,this.midPoint=x,this.endPoint=c;const u=Math.pow(x.x,2)+Math.pow(x.y,2),g=(Math.pow(a.x,2)+Math.pow(a.y,2)-u)/2,y=(u-Math.pow(c.x,2)-Math.pow(c.y,2))/2,v=(a.x-x.x)*(x.y-c.y)-(x.x-c.x)*(a.y-x.y);this.centerPoint=new Vector2((g*(x.y-c.y)-y*(a.y-x.y))/v,((a.x-x.x)*y-(x.x-c.x)*g)/v),this.radius=this.centerPoint.subtract(this.startPoint).length(),this.startAngle=_2.BetweenTwoPoints(this.centerPoint,this.startPoint);const w=this.startAngle.degrees();let B=_2.BetweenTwoPoints(this.centerPoint,this.midPoint).degrees(),W=_2.BetweenTwoPoints(this.centerPoint,this.endPoint).degrees();B-w>180&&(B-=360),B-w<-180&&(B+=360),W-B>180&&(W-=360),W-B<-180&&(W+=360),this.orientation=B-w<0?Uu.CW:Uu.CCW,this.angle=_2.FromDegrees(this.orientation===Uu.CW?w-W:W-w)}}class U1{constructor(a,x){this._points=new Array,this._length=0,this.closed=!1,this._points.push(new Vector2(a,x))}addLineTo(a,x){if(this.closed)return this;const c=new Vector2(a,x),u=this._points[this._points.length-1];return this._points.push(c),this._length+=c.subtract(u).length(),this}addArcTo(a,x,c,u,g=36){if(this.closed)return this;const y=this._points[this._points.length-1],v=new Vector2(a,x),w=new Vector2(c,u),B=new ML(y,v,w);let W=B.angle.radians()/g;B.orientation===Uu.CW&&(W*=-1);let ae=B.startAngle.radians()+W;for(let ue=0;ue<g;ue++){const fe=Math.cos(ae)*B.radius+B.centerPoint.x,Re=Math.sin(ae)*B.radius+B.centerPoint.y;this.addLineTo(fe,Re),ae+=W}return this}addQuadraticCurveTo(a,x,c,u,g=36){if(this.closed)return this;const y=(w,B,W,ae)=>(1-w)*(1-w)*B+2*w*(1-w)*W+w*w*ae,v=this._points[this._points.length-1];for(let w=0;w<=g;w++){const B=w/g,W=y(B,v.x,a,c),ae=y(B,v.y,x,u);this.addLineTo(W,ae)}return this}addBezierCurveTo(a,x,c,u,g,y,v=36){if(this.closed)return this;const w=(W,ae,ue,fe,Re)=>(1-W)*(1-W)*(1-W)*ae+3*W*(1-W)*(1-W)*ue+3*W*W*(1-W)*fe+W*W*W*Re,B=this._points[this._points.length-1];for(let W=0;W<=v;W++){const ae=W/v,ue=w(ae,B.x,a,c,g),fe=w(ae,B.y,x,u,y);this.addLineTo(ue,fe)}return this}isPointInside(a){let x=!1;const c=this._points.length;for(let u=c-1,g=0;g<c;u=g++){let y=this._points[u],v=this._points[g],w=v.x-y.x,B=v.y-y.y;if(Math.abs(B)>Number.EPSILON){if(B<0&&(y=this._points[g],w=-w,v=this._points[u],B=-B),a.y<y.y||a.y>v.y)continue;if(a.y===y.y&&a.x===y.x)return!0;{const W=B*(a.x-y.x)-w*(a.y-y.y);if(W===0)return!0;if(W<0)continue;x=!x}}else{if(a.y!==y.y)continue;if(v.x<=a.x&&a.x<=y.x||y.x<=a.x&&a.x<=v.x)return!0}}return x}close(){return this.closed=!0,this}length(){let a=this._length;if(this.closed){const x=this._points[this._points.length-1],c=this._points[0];a+=c.subtract(x).length()}return a}area(){const a=this._points.length;let x=0;for(let c=a-1,u=0;u<a;c=u++)x+=this._points[c].x*this._points[u].y-this._points[u].x*this._points[c].y;return x*.5}getPoints(){return this._points}getPointAtLengthPosition(a){if(a<0||a>1)return Vector2.Zero();const x=a*this.length();let c=0;for(let u=0;u<this._points.length;u++){const g=(u+1)%this._points.length,y=this._points[u],w=this._points[g].subtract(y),B=w.length()+c;if(x>=c&&x<=B){const W=w.normalize(),ae=x-c;return new Vector2(y.x+W.x*ae,y.y+W.y*ae)}c=B}return Vector2.Zero()}static StartingAt(a,x){return new U1(a,x)}}class V1{constructor(a,x=null,c,u=!1){this.path=a,this._curve=new Array,this._distances=new Array,this._tangents=new Array,this._normals=new Array,this._binormals=new Array,this._pointAtData={id:0,point:Vector3.Zero(),previousPointArrayIndex:0,position:0,subPosition:0,interpolateReady:!1,interpolationMatrix:Matrix.Identity()};for(let g=0;g<a.length;g++)this._curve[g]=a[g].clone();this._raw=c||!1,this._alignTangentsWithPath=u,this._compute(x,u)}getCurve(){return this._curve}getPoints(){return this._curve}length(){return this._distances[this._distances.length-1]}getTangents(){return this._tangents}getNormals(){return this._normals}getBinormals(){return this._binormals}getDistances(){return this._distances}getPointAt(a){return this._updatePointAtData(a).point}getTangentAt(a,x=!1){return this._updatePointAtData(a,x),x?Vector3.TransformCoordinates(Vector3.Forward(),this._pointAtData.interpolationMatrix):this._tangents[this._pointAtData.previousPointArrayIndex]}getNormalAt(a,x=!1){return this._updatePointAtData(a,x),x?Vector3.TransformCoordinates(Vector3.Right(),this._pointAtData.interpolationMatrix):this._normals[this._pointAtData.previousPointArrayIndex]}getBinormalAt(a,x=!1){return this._updatePointAtData(a,x),x?Vector3.TransformCoordinates(Vector3.UpReadOnly,this._pointAtData.interpolationMatrix):this._binormals[this._pointAtData.previousPointArrayIndex]}getDistanceAt(a){return this.length()*a}getPreviousPointIndexAt(a){return this._updatePointAtData(a),this._pointAtData.previousPointArrayIndex}getSubPositionAt(a){return this._updatePointAtData(a),this._pointAtData.subPosition}getClosestPositionTo(a){let x=Number.MAX_VALUE,c=0;for(let u=0;u<this._curve.length-1;u++){const g=this._curve[u+0],y=this._curve[u+1].subtract(g).normalize(),v=this._distances[u+1]-this._distances[u+0],w=Math.min(Math.max(Vector3.Dot(y,a.subtract(g).normalize()),0)*Vector3.Distance(g,a)/v,1),B=Vector3.Distance(g.add(y.scale(w*v)),a);B<x&&(x=B,c=(this._distances[u+0]+v*w)/this.length())}return c}slice(a=0,x=1){if(a<0&&(a=1-a*-1%1),x<0&&(x=1-x*-1%1),a>x){const B=a;a=x,x=B}const c=this.getCurve(),u=this.getPointAt(a);let g=this.getPreviousPointIndexAt(a);const y=this.getPointAt(x),v=this.getPreviousPointIndexAt(x)+1,w=[];return a!==0&&(g++,w.push(u)),w.push(...c.slice(g,v)),(x!==1||a===1)&&w.push(y),new V1(w,this.getNormalAt(a),this._raw,this._alignTangentsWithPath)}update(a,x=null,c=!1){for(let u=0;u<a.length;u++)this._curve[u].x=a[u].x,this._curve[u].y=a[u].y,this._curve[u].z=a[u].z;return this._compute(x,c),this}_compute(a,x=!1){const c=this._curve.length;if(c<2)return;this._tangents[0]=this._getFirstNonNullVector(0),this._raw||this._tangents[0].normalize(),this._tangents[c-1]=this._curve[c-1].subtract(this._curve[c-2]),this._raw||this._tangents[c-1].normalize();const u=this._tangents[0],g=this._normalVector(u,a);this._normals[0]=g,this._raw||this._normals[0].normalize(),this._binormals[0]=Vector3.Cross(u,this._normals[0]),this._raw||this._binormals[0].normalize(),this._distances[0]=0;let y,v,w,B,W;for(let ae=1;ae<c;ae++)y=this._getLastNonNullVector(ae),ae<c-1&&(v=this._getFirstNonNullVector(ae),this._tangents[ae]=x?v:y.add(v),this._tangents[ae].normalize()),this._distances[ae]=this._distances[ae-1]+this._curve[ae].subtract(this._curve[ae-1]).length(),w=this._tangents[ae],W=this._binormals[ae-1],this._normals[ae]=Vector3.Cross(W,w),this._raw||(this._normals[ae].length()===0?(B=this._normals[ae-1],this._normals[ae]=B.clone()):this._normals[ae].normalize()),this._binormals[ae]=Vector3.Cross(w,this._normals[ae]),this._raw||this._binormals[ae].normalize();this._pointAtData.id=NaN}_getFirstNonNullVector(a){let x=1,c=this._curve[a+x].subtract(this._curve[a]);for(;c.length()===0&&a+x+1<this._curve.length;)x++,c=this._curve[a+x].subtract(this._curve[a]);return c}_getLastNonNullVector(a){let x=1,c=this._curve[a].subtract(this._curve[a-x]);for(;c.length()===0&&a>x+1;)x++,c=this._curve[a].subtract(this._curve[a-x]);return c}_normalVector(a,x){let c,u=a.length();if(u===0&&(u=1),x==null){let g;Scalar.WithinEpsilon(Math.abs(a.y)/u,1,Epsilon)?Scalar.WithinEpsilon(Math.abs(a.x)/u,1,Epsilon)?Scalar.WithinEpsilon(Math.abs(a.z)/u,1,Epsilon)?g=Vector3.Zero():g=new Vector3(0,0,1):g=new Vector3(1,0,0):g=new Vector3(0,-1,0),c=Vector3.Cross(a,g)}else c=Vector3.Cross(a,x),Vector3.CrossToRef(c,a,c);return c.normalize(),c}_updatePointAtData(a,x=!1){if(this._pointAtData.id===a)return this._pointAtData.interpolateReady||this._updateInterpolationMatrix(),this._pointAtData;this._pointAtData.id=a;const c=this.getPoints();if(a<=0)return this._setPointAtData(0,0,c[0],0,x);if(a>=1)return this._setPointAtData(1,1,c[c.length-1],c.length-1,x);let u=c[0],g,y=0;const v=a*this.length();for(let w=1;w<c.length;w++){g=c[w];const B=Vector3.Distance(u,g);if(y+=B,y===v)return this._setPointAtData(a,1,g,w,x);if(y>v){const ae=(y-v)/B,ue=u.subtract(g),fe=g.add(ue.scaleInPlace(ae));return this._setPointAtData(a,1-ae,fe,w-1,x)}u=g}return this._pointAtData}_setPointAtData(a,x,c,u,g){return this._pointAtData.point=c,this._pointAtData.position=a,this._pointAtData.subPosition=x,this._pointAtData.previousPointArrayIndex=u,this._pointAtData.interpolateReady=g,g&&this._updateInterpolationMatrix(),this._pointAtData}_updateInterpolationMatrix(){this._pointAtData.interpolationMatrix=Matrix.Identity();const a=this._pointAtData.previousPointArrayIndex;if(a!==this._tangents.length-1){const x=a+1,c=this._tangents[a].clone(),u=this._normals[a].clone(),g=this._binormals[a].clone(),y=this._tangents[x].clone(),v=this._normals[x].clone(),w=this._binormals[x].clone(),B=Quaternion.RotationQuaternionFromAxis(u,g,c),W=Quaternion.RotationQuaternionFromAxis(v,w,y);Quaternion.Slerp(B,W,this._pointAtData.subPosition).toRotationMatrix(this._pointAtData.interpolationMatrix)}}}class xh{static CreateQuadraticBezier(a,x,c,u){u=u>2?u:3;const g=[],y=(v,w,B,W)=>(1-v)*(1-v)*w+2*v*(1-v)*B+v*v*W;for(let v=0;v<=u;v++)g.push(new Vector3(y(v/u,a.x,x.x,c.x),y(v/u,a.y,x.y,c.y),y(v/u,a.z,x.z,c.z)));return new xh(g)}static CreateCubicBezier(a,x,c,u,g){g=g>3?g:4;const y=[],v=(w,B,W,ae,ue)=>(1-w)*(1-w)*(1-w)*B+3*w*(1-w)*(1-w)*W+3*w*w*(1-w)*ae+w*w*w*ue;for(let w=0;w<=g;w++)y.push(new Vector3(v(w/g,a.x,x.x,c.x,u.x),v(w/g,a.y,x.y,c.y,u.y),v(w/g,a.z,x.z,c.z,u.z)));return new xh(y)}static CreateHermiteSpline(a,x,c,u,g){const y=[],v=1/g;for(let w=0;w<=g;w++)y.push(Vector3.Hermite(a,x,c,u,w*v));return new xh(y)}static CreateCatmullRomSpline(a,x,c){const u=[],g=1/x;let y=0;if(c){const v=a.length;for(let w=0;w<v;w++){y=0;for(let B=0;B<x;B++)u.push(Vector3.CatmullRom(a[w%v],a[(w+1)%v],a[(w+2)%v],a[(w+3)%v],y)),y+=g}u.push(u[0])}else{const v=[];v.push(a[0].clone()),Array.prototype.push.apply(v,a),v.push(a[a.length-1].clone());let w=0;for(;w<v.length-3;w++){y=0;for(let B=0;B<x;B++)u.push(Vector3.CatmullRom(v[w],v[w+1],v[w+2],v[w+3],y)),y+=g}w--,u.push(Vector3.CatmullRom(v[w],v[w+1],v[w+2],v[w+3],y))}return new xh(u)}static ArcThru3Points(a,x,c,u=32,g=!1,y=!1){const v=[],w=x.subtract(a),B=c.subtract(x),W=a.subtract(c),ae=Vector3.Cross(w,B),ue=ae.length();if(ue<Math.pow(10,-8))return new xh(v);const fe=w.lengthSquared(),Re=B.lengthSquared(),_e=W.lengthSquared(),Be=ae.lengthSquared(),tt=w.length(),$e=B.length(),Et=W.length(),ft=.5*tt*$e*Et/ue,dt=Vector3.Dot(w,W),ut=Vector3.Dot(w,B),Mt=Vector3.Dot(B,W),ai=-.5*Re*dt/Be,Yi=-.5*_e*ut/Be,Vi=-.5*fe*Mt/Be,Js=a.scale(ai).add(x.scale(Yi)).add(c.scale(Vi)),_r=a.subtract(Js).normalize(),Vr=Vector3.Cross(ae,_r).normalize();if(y){const Ja=2*Math.PI/u;for(let ta=0;ta<=2*Math.PI;ta+=Ja)v.push(Js.add(_r.scale(ft*Math.cos(ta)).add(Vr.scale(ft*Math.sin(ta)))));v.push(a)}else{const Ja=1/u;let ta=0,ja=Vector3.Zero();do ja=Js.add(_r.scale(ft*Math.cos(ta)).add(Vr.scale(ft*Math.sin(ta)))),v.push(ja),ta+=Ja;while(!ja.equalsWithEpsilon(c,ft*Ja*1.1));v.push(c),g&&v.push(a)}return new xh(v)}constructor(a){this._length=0,this._points=a,this._length=this._computeLength(a)}getPoints(){return this._points}length(){return this._length}continue(a){const x=this._points[this._points.length-1],c=this._points.slice(),u=a.getPoints();for(let y=1;y<u.length;y++)c.push(u[y].subtract(u[0]).add(x));return new xh(c)}_computeLength(a){let x=0;for(let c=1;c<a.length;c++)x+=a[c].subtract(a[c-1]).length();return x}}class W1{constructor(a=Vector3.Zero(),x=Vector3.Up()){this.position=a,this.normal=x}clone(){return new W1(this.position.clone(),this.normal.clone())}}class H1{constructor(a=Vector3.Zero(),x=Vector3.Up(),c=Vector2.Zero()){this.position=a,this.normal=x,this.uv=c}clone(){return new H1(this.position.clone(),this.normal.clone(),this.uv.clone())}}const y2=[Math.sqrt(1/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(3/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(15/(4*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(5/(16*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(15/(16*Math.PI))],BL=[()=>1,F=>F.y,F=>F.z,F=>F.x,F=>F.x*F.y,F=>F.y*F.z,F=>3*F.z*F.z-1,F=>F.x*F.z,F=>F.x*F.x-F.y*F.y],lc=(F,a)=>y2[F]*BL[F](a),hc=[Math.PI,2*Math.PI/3,2*Math.PI/3,2*Math.PI/3,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4];class Vu{constructor(){this.preScaled=!1,this.l00=Ee.Zero(),this.l1_1=Ee.Zero(),this.l10=Ee.Zero(),this.l11=Ee.Zero(),this.l2_2=Ee.Zero(),this.l2_1=Ee.Zero(),this.l20=Ee.Zero(),this.l21=Ee.Zero(),this.l22=Ee.Zero()}addLight(a,x,c){Yt.Vector3[0].set(x.r,x.g,x.b);const u=Yt.Vector3[0],g=Yt.Vector3[1];u.scaleToRef(c,g),g.scaleToRef(lc(0,a),Yt.Vector3[2]),this.l00.addInPlace(Yt.Vector3[2]),g.scaleToRef(lc(1,a),Yt.Vector3[2]),this.l1_1.addInPlace(Yt.Vector3[2]),g.scaleToRef(lc(2,a),Yt.Vector3[2]),this.l10.addInPlace(Yt.Vector3[2]),g.scaleToRef(lc(3,a),Yt.Vector3[2]),this.l11.addInPlace(Yt.Vector3[2]),g.scaleToRef(lc(4,a),Yt.Vector3[2]),this.l2_2.addInPlace(Yt.Vector3[2]),g.scaleToRef(lc(5,a),Yt.Vector3[2]),this.l2_1.addInPlace(Yt.Vector3[2]),g.scaleToRef(lc(6,a),Yt.Vector3[2]),this.l20.addInPlace(Yt.Vector3[2]),g.scaleToRef(lc(7,a),Yt.Vector3[2]),this.l21.addInPlace(Yt.Vector3[2]),g.scaleToRef(lc(8,a),Yt.Vector3[2]),this.l22.addInPlace(Yt.Vector3[2])}scaleInPlace(a){this.l00.scaleInPlace(a),this.l1_1.scaleInPlace(a),this.l10.scaleInPlace(a),this.l11.scaleInPlace(a),this.l2_2.scaleInPlace(a),this.l2_1.scaleInPlace(a),this.l20.scaleInPlace(a),this.l21.scaleInPlace(a),this.l22.scaleInPlace(a)}convertIncidentRadianceToIrradiance(){this.l00.scaleInPlace(hc[0]),this.l1_1.scaleInPlace(hc[1]),this.l10.scaleInPlace(hc[2]),this.l11.scaleInPlace(hc[3]),this.l2_2.scaleInPlace(hc[4]),this.l2_1.scaleInPlace(hc[5]),this.l20.scaleInPlace(hc[6]),this.l21.scaleInPlace(hc[7]),this.l22.scaleInPlace(hc[8])}convertIrradianceToLambertianRadiance(){this.scaleInPlace(1/Math.PI)}preScaleForRendering(){this.preScaled=!0,this.l00.scaleInPlace(y2[0]),this.l1_1.scaleInPlace(y2[1]),this.l10.scaleInPlace(y2[2]),this.l11.scaleInPlace(y2[3]),this.l2_2.scaleInPlace(y2[4]),this.l2_1.scaleInPlace(y2[5]),this.l20.scaleInPlace(y2[6]),this.l21.scaleInPlace(y2[7]),this.l22.scaleInPlace(y2[8])}updateFromArray(a){return Ee.FromArrayToRef(a[0],0,this.l00),Ee.FromArrayToRef(a[1],0,this.l1_1),Ee.FromArrayToRef(a[2],0,this.l10),Ee.FromArrayToRef(a[3],0,this.l11),Ee.FromArrayToRef(a[4],0,this.l2_2),Ee.FromArrayToRef(a[5],0,this.l2_1),Ee.FromArrayToRef(a[6],0,this.l20),Ee.FromArrayToRef(a[7],0,this.l21),Ee.FromArrayToRef(a[8],0,this.l22),this}updateFromFloatsArray(a){return Ee.FromFloatsToRef(a[0],a[1],a[2],this.l00),Ee.FromFloatsToRef(a[3],a[4],a[5],this.l1_1),Ee.FromFloatsToRef(a[6],a[7],a[8],this.l10),Ee.FromFloatsToRef(a[9],a[10],a[11],this.l11),Ee.FromFloatsToRef(a[12],a[13],a[14],this.l2_2),Ee.FromFloatsToRef(a[15],a[16],a[17],this.l2_1),Ee.FromFloatsToRef(a[18],a[19],a[20],this.l20),Ee.FromFloatsToRef(a[21],a[22],a[23],this.l21),Ee.FromFloatsToRef(a[24],a[25],a[26],this.l22),this}static FromArray(a){return new Vu().updateFromArray(a)}static FromPolynomial(a){const x=new Vu;return x.l00=a.xx.scale(.376127).add(a.yy.scale(.376127)).add(a.zz.scale(.376126)),x.l1_1=a.y.scale(.977204),x.l10=a.z.scale(.977204),x.l11=a.x.scale(.977204),x.l2_2=a.xy.scale(1.16538),x.l2_1=a.yz.scale(1.16538),x.l20=a.zz.scale(1.34567).subtract(a.xx.scale(.672834)).subtract(a.yy.scale(.672834)),x.l21=a.zx.scale(1.16538),x.l22=a.xx.scale(1.16538).subtract(a.yy.scale(1.16538)),x.l1_1.scaleInPlace(-1),x.l11.scaleInPlace(-1),x.l2_1.scaleInPlace(-1),x.l21.scaleInPlace(-1),x.scaleInPlace(Math.PI),x}}class Wu{constructor(){this.x=Ee.Zero(),this.y=Ee.Zero(),this.z=Ee.Zero(),this.xx=Ee.Zero(),this.yy=Ee.Zero(),this.zz=Ee.Zero(),this.xy=Ee.Zero(),this.yz=Ee.Zero(),this.zx=Ee.Zero()}get preScaledHarmonics(){return this._harmonics||(this._harmonics=Vu.FromPolynomial(this)),this._harmonics.preScaled||this._harmonics.preScaleForRendering(),this._harmonics}addAmbient(a){Yt.Vector3[0].copyFromFloats(a.r,a.g,a.b);const x=Yt.Vector3[0];this.xx.addInPlace(x),this.yy.addInPlace(x),this.zz.addInPlace(x)}scaleInPlace(a){this.x.scaleInPlace(a),this.y.scaleInPlace(a),this.z.scaleInPlace(a),this.xx.scaleInPlace(a),this.yy.scaleInPlace(a),this.zz.scaleInPlace(a),this.yz.scaleInPlace(a),this.zx.scaleInPlace(a),this.xy.scaleInPlace(a)}updateFromHarmonics(a){return this._harmonics=a,this.x.copyFrom(a.l11),this.x.scaleInPlace(1.02333).scaleInPlace(-1),this.y.copyFrom(a.l1_1),this.y.scaleInPlace(1.02333).scaleInPlace(-1),this.z.copyFrom(a.l10),this.z.scaleInPlace(1.02333),this.xx.copyFrom(a.l00),Yt.Vector3[0].copyFrom(a.l20).scaleInPlace(.247708),Yt.Vector3[1].copyFrom(a.l22).scaleInPlace(.429043),this.xx.scaleInPlace(.886277).subtractInPlace(Yt.Vector3[0]).addInPlace(Yt.Vector3[1]),this.yy.copyFrom(a.l00),this.yy.scaleInPlace(.886277).subtractInPlace(Yt.Vector3[0]).subtractInPlace(Yt.Vector3[1]),this.zz.copyFrom(a.l00),Yt.Vector3[0].copyFrom(a.l20).scaleInPlace(.495417),this.zz.scaleInPlace(.886277).addInPlace(Yt.Vector3[0]),this.yz.copyFrom(a.l2_1),this.yz.scaleInPlace(.858086).scaleInPlace(-1),this.zx.copyFrom(a.l21),this.zx.scaleInPlace(.858086).scaleInPlace(-1),this.xy.copyFrom(a.l2_2),this.xy.scaleInPlace(.858086),this.scaleInPlace(1/Math.PI),this}static FromHarmonics(a){return new Wu().updateFromHarmonics(a)}static FromArray(a){const x=new Wu;return Ee.FromArrayToRef(a[0],0,x.x),Ee.FromArrayToRef(a[1],0,x.y),Ee.FromArrayToRef(a[2],0,x.z),Ee.FromArrayToRef(a[3],0,x.xx),Ee.FromArrayToRef(a[4],0,x.yy),Ee.FromArrayToRef(a[5],0,x.zz),Ee.FromArrayToRef(a[6],0,x.yz),Ee.FromArrayToRef(a[7],0,x.zx),Ee.FromArrayToRef(a[8],0,x.xy),x}}class Hu{constructor(a,x,c,u){this.name=a,this.worldAxisForNormal=x,this.worldAxisForFileX=c,this.worldAxisForFileY=u}}class Mg{static ConvertCubeMapTextureToSphericalPolynomial(a){if(!a.isCube)return null;a.getScene()?.getEngine().flushFramebuffer();const x=a.getSize().width,c=a.readPixels(0,void 0,void 0,!1),u=a.readPixels(1,void 0,void 0,!1);let g,y;a.isRenderTarget?(g=a.readPixels(3,void 0,void 0,!1),y=a.readPixels(2,void 0,void 0,!1)):(g=a.readPixels(2,void 0,void 0,!1),y=a.readPixels(3,void 0,void 0,!1));const v=a.readPixels(4,void 0,void 0,!1),w=a.readPixels(5,void 0,void 0,!1),B=a.gammaSpace,W=5;let ae=0;return(a.textureType==1||a.textureType==2)&&(ae=1),new Promise(ue=>{Promise.all([u,c,g,y,v,w]).then(([fe,Re,_e,Be,tt,$e])=>{const Et={size:x,right:Re,left:fe,up:_e,down:Be,front:tt,back:$e,format:W,type:ae,gammaSpace:B};ue(this.ConvertCubeMapToSphericalPolynomial(Et))})})}static _AreaElement(a,x){return Math.atan2(a*x,Math.sqrt(a*a+x*x+1))}static ConvertCubeMapToSphericalPolynomial(a){const x=new Vu;let c=0;const u=2/a.size,g=u,y=.5*u,v=y-1;for(let ue=0;ue<6;ue++){const fe=this._FileFaces[ue],Re=a[fe.name];let _e=v;const Be=a.format===5?4:3;for(let tt=0;tt<a.size;tt++){let $e=v;for(let Et=0;Et<a.size;Et++){const ft=fe.worldAxisForFileX.scale($e).add(fe.worldAxisForFileY.scale(_e)).add(fe.worldAxisForNormal);ft.normalize();const dt=this._AreaElement($e-y,_e-y)-this._AreaElement($e-y,_e+y)-this._AreaElement($e+y,_e-y)+this._AreaElement($e+y,_e+y);let ut=Re[tt*a.size*Be+Et*Be+0],Mt=Re[tt*a.size*Be+Et*Be+1],ai=Re[tt*a.size*Be+Et*Be+2];isNaN(ut)&&(ut=0),isNaN(Mt)&&(Mt=0),isNaN(ai)&&(ai=0),a.type===0&&(ut/=255,Mt/=255,ai/=255),a.gammaSpace&&(ut=Math.pow(_n.Clamp(ut),Xi),Mt=Math.pow(_n.Clamp(Mt),Xi),ai=Math.pow(_n.Clamp(ai),Xi));const Yi=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const Js=Math.max(ut,Mt,ai);if(Js>Yi){const Rr=Yi/Js;ut*=Rr,Mt*=Rr,ai*=Rr}}else ut=_n.Clamp(ut,0,Yi),Mt=_n.Clamp(Mt,0,Yi),ai=_n.Clamp(ai,0,Yi);const Vi=new Bs(ut,Mt,ai);x.addLight(ft,Vi,dt),c+=dt,$e+=u}_e+=g}}const ae=4*Math.PI*6/6/c;return x.scaleInPlace(ae),x.convertIncidentRadianceToIrradiance(),x.convertIrradianceToLambertianRadiance(),Wu.FromHarmonics(x)}}Mg._FileFaces=[new Hu("right",new Ee(1,0,0),new Ee(0,0,-1),new Ee(0,-1,0)),new Hu("left",new Ee(-1,0,0),new Ee(0,0,1),new Ee(0,-1,0)),new Hu("up",new Ee(0,1,0),new Ee(1,0,0),new Ee(0,0,1)),new Hu("down",new Ee(0,-1,0),new Ee(1,0,0),new Ee(0,0,-1)),new Hu("front",new Ee(0,0,1),new Ee(1,0,0),new Ee(0,-1,0)),new Hu("back",new Ee(0,0,-1),new Ee(-1,0,0),new Ee(0,-1,0))],Mg.MAX_HDRI_VALUE=4096,Mg.PRESERVE_CLAMPED_COLORS=!1,Un.prototype.forceSphericalPolynomialsRecompute=function(){this._texture&&(this._texture._sphericalPolynomial=null,this._texture._sphericalPolynomialPromise=null,this._texture._sphericalPolynomialComputed=!1)},Object.defineProperty(Un.prototype,"sphericalPolynomial",{get:function(){if(this._texture){if(this._texture._sphericalPolynomial||this._texture._sphericalPolynomialComputed)return this._texture._sphericalPolynomial;if(this._texture.isReady)return this._texture._sphericalPolynomialPromise||(this._texture._sphericalPolynomialPromise=Mg.ConvertCubeMapTextureToSphericalPolynomial(this),this._texture._sphericalPolynomialPromise===null?this._texture._sphericalPolynomialComputed=!0:this._texture._sphericalPolynomialPromise.then(F=>{this._texture._sphericalPolynomial=F,this._texture._sphericalPolynomialComputed=!0})),null}return null},set:function(F){this._texture&&(this._texture._sphericalPolynomial=F)},enumerable:!0,configurable:!0});const X1="prePassDeclaration",j1=`#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;hi.IncludesShadersStore[X1]=j1;const WV={name:X1,shader:j1},Y1="oitDeclaration",$1=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;
#endif
`;hi.IncludesShadersStore[Y1]=$1;const HV={name:Y1,shader:$1},J1="decalFragmentDeclaration",tS=`#ifdef DECAL
uniform vec4 vDecalInfos;
#endif
`;hi.IncludesShadersStore[J1]=tS;const XV={name:J1,shader:tS},aS="pbrFragmentDeclaration",xS=`uniform vec4 vEyePosition;uniform vec3 vReflectionColor;uniform vec4 vAlbedoColor;uniform vec4 vLightingIntensity;uniform vec4 vReflectivityColor;uniform vec4 vMetallicReflectanceFactors;uniform vec3 vEmissiveColor;uniform float visibility;uniform vec3 vAmbientColor;
#ifdef ALBEDO
uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform vec4 vAmbientInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef OPACITY
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef REFLECTIVITY
uniform vec3 vReflectivityInfos;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#ifdef REALTIME_FILTERING
uniform vec2 vReflectionFilteringInfo;
#endif
uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#ifdef CLEARCOAT
uniform vec2 vClearCoatParams;uniform vec4 vClearCoatRefractionParams;
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform vec2 vClearCoatTangentSpaceParams;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT
uniform vec4 vClearCoatTintParams;uniform float clearCoatColorAtDistance;
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#endif
#ifdef IRIDESCENCE
uniform vec4 vIridescenceParams;
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
uniform vec3 vAnisotropy;
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
uniform vec4 vSheenColor;
#ifdef SHEEN_ROUGHNESS
uniform float vSheenRoughness;
#endif
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionMicrosurfaceInfos;uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#ifdef REALTIME_FILTERING
uniform vec2 vRefractionFilteringInfo;
#endif
#ifdef SS_DISPERSION
uniform float dispersion;
#endif
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
uniform vec2 vThicknessParam;uniform vec3 vDiffusionDistance;uniform vec4 vTintColor;uniform vec3 vSubSurfaceIntensity;
#endif
#ifdef PREPASS
#ifdef SS_SCATTERING
uniform float scatteringDiffusionProfile;
#endif
#endif
#if DEBUGMODE>0
uniform vec2 vDebugMode;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;hi.IncludesShadersStore[aS]=xS;const jV={name:aS,shader:xS},lS="pbrUboDeclaration",hS=`layout(std140,column_major) uniform;uniform Material {vec2 vAlbedoInfos;vec4 vAmbientInfos;vec2 vOpacityInfos;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec3 vReflectivityInfos;vec2 vMicroSurfaceSamplerInfos;vec2 vReflectionInfos;vec2 vReflectionFilteringInfo;vec3 vReflectionPosition;vec3 vReflectionSize;vec3 vBumpInfos;mat4 albedoMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 reflectivityMatrix;mat4 microSurfaceSamplerMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;mat4 reflectionMatrix;vec3 vReflectionColor;vec4 vAlbedoColor;vec4 vLightingIntensity;vec3 vReflectionMicrosurfaceInfos;float pointSize;vec4 vReflectivityColor;vec3 vEmissiveColor;vec3 vAmbientColor;vec2 vDebugMode;vec4 vMetallicReflectanceFactors;vec2 vMetallicReflectanceInfos;mat4 metallicReflectanceMatrix;vec2 vReflectanceInfos;mat4 reflectanceMatrix;vec3 vSphericalL00;vec3 vSphericalL1_1;vec3 vSphericalL10;vec3 vSphericalL11;vec3 vSphericalL2_2;vec3 vSphericalL2_1;vec3 vSphericalL20;vec3 vSphericalL21;vec3 vSphericalL22;vec3 vSphericalX;vec3 vSphericalY;vec3 vSphericalZ;vec3 vSphericalXX_ZZ;vec3 vSphericalYY_ZZ;vec3 vSphericalZZ;vec3 vSphericalXY;vec3 vSphericalYZ;vec3 vSphericalZX;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;hi.IncludesShadersStore[lS]=hS;const YV={name:lS,shader:hS},uS="mainUVVaryingDeclaration",dS=`#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;hi.IncludesShadersStore[uS]=dS;const $V={name:uS,shader:dS},fS="pbrFragmentExtraDeclaration",mS=`varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
`;hi.IncludesShadersStore[fS]=mS;const JV={name:fS,shader:mS},gS="lightFragmentDeclaration",_S=`#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#endif
`;hi.IncludesShadersStore[gS]=_S;const tG={name:gS,shader:_S},yS="lightUboDeclaration",bS=`#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;hi.IncludesShadersStore[yS]=bS;const aG={name:yS,shader:bS},ES="samplerFragmentDeclaration",vS=`#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;hi.IncludesShadersStore[ES]=vS;const xG={name:ES,shader:vS},IS="samplerFragmentAlternateDeclaration",RS=`#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
#endif
`;hi.IncludesShadersStore[IS]=RS;const lG={name:IS,shader:RS},MS="pbrFragmentSamplersDeclaration",BS=`#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)
#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef CLEARCOAT
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D clearCoatRoughnessSampler;
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D sheenRoughnessSampler;
#endif
#endif
#ifdef ANISOTROPIC
#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)
#endif
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
#define sampleReflection(s,c) textureCube(s,c)
uniform samplerCube reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform samplerCube irradianceSampler;
#endif
#else
#define sampleReflection(s,c) texture2D(s,c)
uniform sampler2D reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D reflectionSamplerLow;uniform sampler2D reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform sampler2D irradianceSampler;
#endif
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#endif
#ifdef ENVIRONMENTBRDF
uniform sampler2D environmentBrdfSampler;
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#ifdef SS_REFRACTIONMAP_3D
#define sampleRefraction(s,c) textureCube(s,c)
uniform samplerCube refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube refractionSamplerLow;uniform samplerCube refractionSamplerHigh;
#endif
#else
#define sampleRefraction(s,c) texture2D(s,c)
uniform sampler2D refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D refractionSamplerLow;uniform sampler2D refractionSamplerHigh;
#endif
#endif
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)
#endif
`;hi.IncludesShadersStore[MS]=BS;const hG={name:MS,shader:BS},US="imageProcessingDeclaration",VS=`#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;hi.IncludesShadersStore[US]=VS;const uG={name:US,shader:VS},WS="logDepthDeclaration",HS=`#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;varying float vFragmentDepth;
#endif
`;hi.IncludesShadersStore[WS]=HS;const dG={name:WS,shader:HS},XS="fogFragmentDeclaration",jS=`#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()
{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)
{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}
else if (FOGMODE_EXP==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}
else if (FOGMODE_EXP2==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}
return clamp(fogCoeff,0.0,1.0);}
#endif
`;hi.IncludesShadersStore[XS]=jS;const fG={name:XS,shader:jS},YS="subSurfaceScatteringFunctions",$S=`bool testLightingForSSS(float diffusionProfile)
{return diffusionProfile<1.;}`;hi.IncludesShadersStore[YS]=$S;const mG={name:YS,shader:$S},JS="importanceSampling",tC=`vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { 
float phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}`;hi.IncludesShadersStore[JS]=tC;const gG={name:JS,shader:tC},aC="pbrHelperFunctions",xC=`#define MINIMUMVARIANCE 0.0005
float convertRoughnessToAverageSlope(float roughness)
{return square(roughness)+MINIMUMVARIANCE;}
float fresnelGrazingReflectance(float reflectance0) {float reflectance90=saturate(reflectance0*25.0);return reflectance90;}
vec2 getAARoughnessFactors(vec3 normalVector) {
#ifdef SPECULARAA
vec3 nDfdx=dFdx(normalVector.xyz);vec3 nDfdy=dFdy(normalVector.xyz);float slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));float geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);float geometricAlphaGFactor=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2(geometricRoughnessFactor,geometricAlphaGFactor);
#else
return vec2(0.);
#endif
}
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_LEGACY
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;vec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);vec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);vec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}
#else
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG,MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 bentNormal=cross(B,V);bentNormal=normalize(cross(bentNormal,B));float a=square(square(1.0-anisotropy*(1.0-roughness)));bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}
#endif
#endif
#if defined(CLEARCOAT) || defined(SS_REFRACTION)
vec3 cocaLambert(vec3 alpha,float distance) {return exp(-alpha*distance);}
vec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {return cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}
vec3 computeColorAtDistanceInMedia(vec3 color,float distance) {return -log(color)/distance;}
vec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 clearCoatAbsorption=mix(vec3(1.0),
cocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),
clearCoatIntensity);return clearCoatAbsorption;}
#endif
#ifdef MICROSURFACEAUTOMATIC
float computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)
{const float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;float reflectivityLuminance=getLuminance(reflectivityColor);float reflectivityLuma=sqrt(reflectivityLuminance);microSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return microSurface;}
#endif
`;hi.IncludesShadersStore[aC]=xC;const _G={name:aC,shader:xC},lC="imageProcessingFunctions",hC=`#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);vec3 RRTAndODTFit(vec3 v)
{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
vec3 ACESFitted(vec3 color)
{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;}`;hi.IncludesShadersStore[lC]=hC;const yG={name:lC,shader:hC},uC="shadowsFragmentFunctions",dC=`#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
#define inline
float computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);}
#define inline
float computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}
#define inline
float computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
/* disable_uniformity_analysis */
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.),
vec3(0.)
);const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}
else
{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
if (numBlocker<1.0) {return 1.0;}
else
{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
#endif
`;hi.IncludesShadersStore[uC]=dC;const bG={name:uC,shader:dC},fC="harmonicsFunctions",mC=`#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
vec3 computeEnvironmentIrradiance(vec3 normal) {return vSphericalL00
+ vSphericalL1_1*(normal.y)
+ vSphericalL10*(normal.z)
+ vSphericalL11*(normal.x)
+ vSphericalL2_2*(normal.y*normal.x)
+ vSphericalL2_1*(normal.y*normal.z)
+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)
+ vSphericalL21*(normal.z*normal.x)
+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}
#else
vec3 computeEnvironmentIrradiance(vec3 normal) {float Nx=normal.x;float Ny=normal.y;float Nz=normal.z;vec3 C1=vSphericalZZ.rgb;vec3 Cx=vSphericalX.rgb;vec3 Cy=vSphericalY.rgb;vec3 Cz=vSphericalZ.rgb;vec3 Cxx_zz=vSphericalXX_ZZ.rgb;vec3 Cyy_zz=vSphericalYY_ZZ.rgb;vec3 Cxy=vSphericalXY.rgb;vec3 Cyz=vSphericalYZ.rgb;vec3 Czx=vSphericalZX.rgb;vec3 a1=Cyy_zz*Ny+Cy;vec3 a2=Cyz*Nz+a1;vec3 b1=Czx*Nz+Cx;vec3 b2=Cxy*Ny+b1;vec3 b3=Cxx_zz*Nx+b2;vec3 t1=Cz *Nz+C1;vec3 t2=a2 *Ny+t1;vec3 t3=b3 *Nx+t2;return t3;}
#endif
#endif
`;hi.IncludesShadersStore[fC]=mC;const EG={name:fC,shader:mC},gC="pbrDirectLightingSetupFunctions",_C=`struct preLightingInfo
{vec3 lightOffset;float lightDistanceSquared;float lightDistance;float attenuation;vec3 L;vec3 H;float NdotV;float NdotLUnclamped;float NdotL;float VdotH;float roughness;
#ifdef IRIDESCENCE
float iridescenceIntensity;
#endif
};preLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightOffset=lightData.xyz-vPositionW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;
#ifdef SPECULARTERM
result.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));
#endif
return result;}`;hi.IncludesShadersStore[gC]=_C;const vG={name:gC,shader:_C},yC="pbrDirectLightingFalloffFunctions",bC=`float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)
{return max(0.,1.0-length(lightOffset)/range);}
float computeDistanceLightFalloff_Physical(float lightDistanceSquared)
{return 1.0/maxEps(lightDistanceSquared);}
float computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)
{float lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);float factor=lightDistanceSquared*inverseSquaredRange;float attenuation=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}
float computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDistanceLightFalloff_Physical(lightDistanceSquared);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);
#else
return computeDistanceLightFalloff_Standard(lightOffset,range);
#endif
}
float computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)
{float falloff=0.0;float cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)
{falloff=max(0.,pow(cosAngle,exponent));}
return falloff;}
float computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)
{const float kMinusLog2ConeAngleIntensityRatio=6.64385618977; 
float concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);vec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);float falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}
float computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)
{float cd=dot(-lightDirection,directionToLightCenterW);float falloff=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}
float computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);
#else
return computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);
#endif
}`;hi.IncludesShadersStore[yC]=bC;const RG={name:yC,shader:bC},EC="pbrBRDFFunctions",vC=`#define FRESNEL_MAXIMUM_ON_ROUGH 0.25
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}
#endif
#ifdef ENVIRONMENTBRDF
vec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);
#ifdef ENVIRONMENTBRDF_RGBD
brdfLookup.rgb=fromRGBD(brdfLookup.rgba);
#endif
return brdfLookup.rgb;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;
#endif
return reflectance;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;
#endif
return reflectance;}
#endif
/* NOT USED
#if defined(SHEEN) && defined(SHEEN_SOFTER)
float getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)
{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}
#endif
*/
#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)
vec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)
{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
/**
* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.
* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table
*/
vec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}
#endif
vec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
float fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
#ifdef CLEARCOAT
vec3 getR0RemappedForClearCoat(vec3 f0) {
#ifdef CLEARCOAT_DEFAULTIOR
#ifdef MOBILE
return saturate(f0*(f0*0.526868+0.529324)-0.0482256);
#else
return saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);
#endif
#else
vec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);
#endif
}
#endif
#ifdef IRIDESCENCE
const mat3 XYZ_TO_REC709=mat3(
3.2404542,-0.9692660, 0.0556434,
-1.5371385, 1.8760108,-0.2040259,
-0.4985314, 0.0415560, 1.0572252
);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}
vec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}
float getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}
vec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}
vec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}
float cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); 
vec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)
{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}
return max(I,vec3(0.0));}
#endif
float normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)
{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}
#ifdef SHEEN
float normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)
{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}
#endif
#ifdef ANISOTROPIC
float normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}
#endif
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {
#ifdef MOBILE
float GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);
#else
float a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);
#endif
}
#else
float smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)
{
#ifdef MOBILE
return 1.0/(dot+alphaG+(1.0-alphaG)*dot ));
#else
float alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));
#endif
}
float smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)
{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}
#endif
#ifdef ANISOTROPIC
float smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}
#endif
#ifdef CLEARCOAT
float visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }
#endif
#ifdef SHEEN
float visibility_Ashikhmin(float NdotL,float NdotV)
{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}
/* NOT USED
#ifdef SHEEN_SOFTER
float l(float x,float alphaG)
{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}
float lambdaSheen(float cosTheta,float alphaG)
{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}
float visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)
{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}
#endif
*/
#endif
float diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}
#ifdef SS_TRANSLUCENCY
vec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}
float computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}
#endif
`;hi.IncludesShadersStore[EC]=vC;const MG={name:EC,shader:vC},RC="hdrFilteringFunctions",MC=`#ifdef NUM_SAMPLES
#if NUM_SAMPLES>0
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
float radicalInverse_VdC(uint bits) 
{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }
vec2 hammersley(uint i,uint N)
{return vec2(float(i)/float(N),radicalInverse_VdC(i));}
#else
float vanDerCorpus(int n,int base)
{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)
{if(n>0)
{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}
return result;}
vec2 hammersley(int i,int N)
{return vec2(float(i)/float(N),vanDerCorpus(i,2));}
#endif
float log4(float x) {return log2(x)/2.;}
const float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;
#define inline
vec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c;}}
result=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}
#define inline
vec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 c=textureCube(inputTexture,n).rgb; 
if (alphaG==0.) {
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
return c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c*NoL;}}
result=result/weight;return result;}}
#endif
#endif
`;hi.IncludesShadersStore[RC]=MC;const BG={name:RC,shader:MC},BC="pbrDirectLightingFunctions",UC=`#define CLEARCOATREFLECTANCE90 1.0
struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef CLEARCOAT
vec4 clearCoat;
#endif
#ifdef SHEEN
vec3 sheen;
#endif
};float adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {
#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)
float lightRoughness=lightRadius/lightDistance;float totalRoughness=saturate(lightRoughness+roughness);return totalRoughness;
#else
return roughness;
#endif
}
vec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {return mix(groundColor,lightColor,info.NdotL);}
vec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {float diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return toLinearSpace(textureColor);}
#ifdef SS_TRANSLUCENCY
vec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {float NdotL=absEps(info.NdotLUnclamped);float wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);float trAdapt=step(0.,info.NdotLUnclamped);vec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);float diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}
#endif
#ifdef SPECULARTERM
vec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);
#else
float smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);
#endif
vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef ANISOTROPIC
vec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float TdotH=dot(T,info.H);float BdotH=dot(B,info.H);float TdotV=dot(T,V);float BdotV=dot(B,V);float TdotL=dot(T,info.L);float BdotL=dot(B,info.L);float alphaG=convertRoughnessToAverageSlope(info.roughness);vec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,square(geometricRoughnessFactor));vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);float smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef CLEARCOAT
vec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {float NccdotL=saturateEps(dot(Ncc,info.L));float NccdotH=saturateEps(dot(Ncc,info.H));float clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);float fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);float kelemenVisibility=visibility_Kelemen(info.VdotH);float clearCoatTerm=fresnel*distribution*kelemenVisibility;return vec4(
clearCoatTerm*info.attenuation*NccdotL*lightColor,
1.0-fresnel
);}
vec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);float NdotLRefract=saturateEps(dot(Ncc,LRefract));vec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}
#endif
#ifdef SHEEN
vec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);float fresnel=1.;float distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER
float visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);
#else */
float visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */
float sheenTerm=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}
#endif
`;hi.IncludesShadersStore[BC]=UC;const UG={name:BC,shader:UC},VC="pbrIBLFunctions",WC=`#if defined(REFLECTION) || defined(SS_REFRACTION)
float getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {float microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;float lod=log2(microsurfaceAverageSlopeTexels);return lod;}
float getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {float lod=log2(cubeMapDimensionPixels)*roughness;return lod;}
#endif
#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)
float environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {float temp=NdotVUnclamped+ambientOcclusion;return saturate(square(temp)-1.0+ambientOcclusion);}
#endif
#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)
float environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {vec3 reflection=reflect(view,normal);float temp=saturate(1.0+1.1*dot(reflection,geometricNormal));return square(temp);}
#endif
#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)
#define UNPACK_LOD(x) (1.0-x)*255.0
float getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {float microsurfaceAverageSlope=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}
#endif
`;hi.IncludesShadersStore[VC]=WC;const VG={name:VC,shader:WC},HC="bumpFragmentMainFunctions",XC=`#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#if defined(WEBGL2) || defined(WEBGPU)
mat4 toNormalMatrix(mat4 wMatrix)
{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}
#else
mat4 toNormalMatrix(mat4 m)
{float
a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],
a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],
a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],
a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],
b00=a00*a11-a01*a10,
b01=a00*a12-a02*a10,
b02=a00*a13-a03*a10,
b03=a01*a12-a02*a11,
b04=a01*a13-a03*a11,
b05=a02*a13-a03*a12,
b06=a20*a31-a21*a30,
b07=a20*a32-a22*a30,
b08=a20*a33-a23*a30,
b09=a21*a32-a22*a31,
b10=a21*a33-a23*a31,
b11=a22*a33-a23*a32,
det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(
a11*b11-a12*b10+a13*b09,
a02*b10-a01*b11-a03*b09,
a31*b05-a32*b04+a33*b03,
a22*b04-a21*b05-a23*b03,
a12*b08-a10*b11-a13*b07,
a00*b11-a02*b08+a03*b07,
a32*b02-a30*b05-a33*b01,
a20*b05-a22*b02+a23*b01,
a10*b10-a11*b08+a13*b06,
a01*b08-a00*b10-a03*b06,
a30*b04-a31*b02+a33*b00,
a21*b02-a20*b04-a23*b00,
a11*b07-a10*b09-a12*b06,
a00*b09-a01*b07+a02*b06,
a31*b01-a30*b03-a32*b00,
a20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}
#endif
`;hi.IncludesShadersStore[HC]=XC;const WG={name:HC,shader:XC},jC="bumpFragmentFunctions",YC=`#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)
{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;
#ifdef PARALLAX_RHS
vCurrOffset-=stepSize*vMaxOffset;
#else
vCurrOffset+=stepSize*vMaxOffset;
#endif
lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;
#ifdef PARALLAX_RHS
return texCoordOffset;
#else
return -texCoordOffset;
#endif
}
#endif
`;hi.IncludesShadersStore[jC]=YC;const HG={name:jC,shader:YC},$C="reflectionFunction",JC=`vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*(view*worldPos));}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*vec4(positionW,1.));}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;hi.IncludesShadersStore[$C]=JC;const XG={name:$C,shader:JC},tI="decalFragment",aI=`#ifdef DECAL
#ifdef GAMMADECAL
decalColor.rgb=toLinearSpace(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalColor.a*=decalColor.a;
#endif
surfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);
#endif
`;hi.IncludesShadersStore[tI]=aI;const jG={name:tI,shader:aI},xI="pbrBlockAlbedoOpacity",lI=`struct albedoOpacityOutParams
{vec3 surfaceAlbedo;float alpha;};
#define pbr_inline
void albedoOpacityBlock(
in vec4 vAlbedoColor,
#ifdef ALBEDO
in vec4 albedoTexture,
in vec2 albedoInfos,
#endif
#ifdef OPACITY
in vec4 opacityMap,
in vec2 vOpacityInfos,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
#ifdef DECAL
in vec4 decalColor,
in vec4 vDecalInfos,
#endif
out albedoOpacityOutParams outParams
)
{vec3 surfaceAlbedo=vAlbedoColor.rgb;float alpha=vAlbedoColor.a;
#ifdef ALBEDO
#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)
alpha*=albedoTexture.a;
#endif
#ifdef GAMMAALBEDO
surfaceAlbedo*=toLinearSpace(albedoTexture.rgb);
#else
surfaceAlbedo*=albedoTexture.rgb;
#endif
surfaceAlbedo*=albedoInfos.y;
#endif
#ifndef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
surfaceAlbedo*=vColor.rgb;
#endif
#ifdef DETAIL
float detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; 
#endif
#ifdef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALBEDO
#ifdef OPACITY
#ifdef OPACITYRGB
alpha=getLuminance(opacityMap.rgb);
#else
alpha*=opacityMap.a;
#endif
alpha*=vOpacityInfos.y;
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)
#ifdef ALPHATEST 
#if DEBUGMODE != 88
if (alpha<ALPHATESTVALUE)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
#endif
outParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;}
`;hi.IncludesShadersStore[xI]=lI;const YG={name:xI,shader:lI},hI="pbrBlockReflectivity",uI=`struct reflectivityOutParams
{float microSurface;float roughness;vec3 surfaceReflectivityColor;
#ifdef METALLICWORKFLOW
vec3 surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
vec3 ambientOcclusionColor;
#endif
#if DEBUGMODE>0
#ifdef METALLICWORKFLOW
vec2 metallicRoughness;
#ifdef REFLECTIVITY
vec4 surfaceMetallicColorMap;
#endif
#ifndef FROSTBITE_REFLECTANCE
vec3 metallicF0;
#endif
#else
#ifdef REFLECTIVITY
vec4 surfaceReflectivityColorMap;
#endif
#endif
#endif
};
#define pbr_inline
void reflectivityBlock(
in vec4 vReflectivityColor,
#ifdef METALLICWORKFLOW
in vec3 surfaceAlbedo,
in vec4 metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
in vec3 reflectivityInfos,
in vec4 surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
in vec3 ambientOcclusionColorIn,
#endif
#ifdef MICROSURFACEMAP
in vec4 microSurfaceTexel,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
out reflectivityOutParams outParams
)
{float microSurface=vReflectivityColor.a;vec3 surfaceReflectivityColor=vReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec2 metallicRoughness=surfaceReflectivityColor.rg;
#ifdef REFLECTIVITY
#if DEBUGMODE>0
outParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef AOSTOREINMETALMAPRED
vec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);
#endif
#ifdef METALLNESSSTOREINMETALMAPBLUE
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;
#else
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;
#endif
#ifdef ROUGHNESSSTOREINMETALMAPALPHA
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;
#else
#ifdef ROUGHNESSSTOREINMETALMAPGREEN
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;
#endif
#endif
#endif
#ifdef DETAIL
float detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);float loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);float hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));
#endif
#ifdef MICROSURFACEMAP
metallicRoughness.g*=microSurfaceTexel.r;
#endif
#if DEBUGMODE>0
outParams.metallicRoughness=metallicRoughness;
#endif
#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS
microSurface=1.0-metallicRoughness.g;vec3 baseColor=surfaceAlbedo;
#ifdef FROSTBITE_REFLECTANCE
outParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);
#else
vec3 metallicF0=metallicReflectanceFactors.rgb;
#if DEBUGMODE>0
outParams.metallicF0=metallicF0;
#endif
outParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);
#endif
#else
#ifdef REFLECTIVITY
surfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;
#if DEBUGMODE>0
outParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef MICROSURFACEFROMREFLECTIVITYMAP
microSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;
#else
#ifdef MICROSURFACEAUTOMATIC
microSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);
#endif
#ifdef MICROSURFACEMAP
microSurface*=microSurfaceTexel.r;
#endif
#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE
#endif
#endif
#endif
microSurface=saturate(microSurface);float roughness=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;}
`;hi.IncludesShadersStore[hI]=uI;const $G={name:hI,shader:uI},dI="pbrBlockAmbientOcclusion",fI=`struct ambientOcclusionOutParams
{vec3 ambientOcclusionColor;
#if DEBUGMODE>0 && defined(AMBIENT)
vec3 ambientOcclusionColorMap;
#endif
};
#define pbr_inline
void ambientOcclusionBlock(
#ifdef AMBIENT
in vec3 ambientOcclusionColorMap_,
in vec4 vAmbientInfos,
#endif
out ambientOcclusionOutParams outParams
)
{vec3 ambientOcclusionColor=vec3(1.,1.,1.);
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;
#ifdef AMBIENTINGRAYSCALE
ambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);
#endif
ambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);
#if DEBUGMODE>0
outParams.ambientOcclusionColorMap=ambientOcclusionColorMap;
#endif
#endif
outParams.ambientOcclusionColor=ambientOcclusionColor;}
`;hi.IncludesShadersStore[dI]=fI;const JG={name:dI,shader:fI},mI="pbrBlockAlphaFresnel",gI=`#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
struct alphaFresnelOutParams
{float alpha;};
#define pbr_inline
void alphaFresnelBlock(
in vec3 normalW,
in vec3 viewDirectionW,
in float alpha,
in float microSurface,
out alphaFresnelOutParams outParams
)
{float opacityPerceptual=alpha;
#ifdef LINEARALPHAFRESNEL
float opacity0=opacityPerceptual;
#else
float opacity0=opacityPerceptual*opacityPerceptual;
#endif
float opacity90=fresnelGrazingReflectance(opacity0);vec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;
#ifdef ALPHATEST
if (outParams.alpha<ALPHATESTVALUE)
discard;
#ifndef ALPHABLEND
outParams.alpha=1.0;
#endif
#endif
}
#endif
#endif
`;hi.IncludesShadersStore[mI]=gI;const t5={name:mI,shader:gI},_I="pbrBlockAnisotropic",yI=`#ifdef ANISOTROPIC
struct anisotropicOutParams
{float anisotropy;vec3 anisotropicTangent;vec3 anisotropicBitangent;vec3 anisotropicNormal;
#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)
vec3 anisotropyMapData;
#endif
};
#define pbr_inline
void anisotropicBlock(
in vec3 vAnisotropy,
in float roughness,
#ifdef ANISOTROPIC_TEXTURE
in vec3 anisotropyMapData,
#endif
in mat3 TBN,
in vec3 normalW,
in vec3 viewDirectionW,
out anisotropicOutParams outParams
)
{float anisotropy=vAnisotropy.b;vec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);
#ifdef ANISOTROPIC_TEXTURE
anisotropy*=anisotropyMapData.b;
#if DEBUGMODE>0
outParams.anisotropyMapData=anisotropyMapData;
#endif
anisotropyMapData.rg=anisotropyMapData.rg*2.0-1.0;
#ifdef ANISOTROPIC_LEGACY
anisotropyDirection.rg*=anisotropyMapData.rg;
#else
anisotropyDirection.xy=mat2(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(anisotropyMapData.rg);
#endif
#endif
mat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));vec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);vec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);}
#endif
`;hi.IncludesShadersStore[_I]=yI;const a5={name:_I,shader:yI},bI="pbrBlockReflection",EI=`#ifdef REFLECTION
struct reflectionOutParams
{vec4 environmentRadiance;vec3 environmentIrradiance;
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords;
#else
vec2 reflectionCoords;
#endif
#ifdef SS_TRANSLUCENCY
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
vec3 irradianceVector;
#endif
#endif
#endif
};
#define pbr_inline
void createReflectionCoords(
in vec3 vPositionW,
in vec3 normalW,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REFLECTIONMAP_3D
out vec3 reflectionCoords
#else
out vec2 reflectionCoords
#endif
)
{
#ifdef ANISOTROPIC
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);
#else
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
reflectionCoords=reflectionVector;
#else
reflectionCoords=reflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
reflectionCoords/=reflectionVector.z;
#endif
reflectionCoords.y=1.0-reflectionCoords.y;
#endif
}
#define pbr_inline
#define inline
void sampleReflectionTexture(
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
const vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
const vec2 reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out vec4 environmentRadiance
)
{
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);
#elif defined(LINEARSPECULARREFLECTION)
float reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);
#else
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);
#endif
#ifdef LODBASEDMICROSFURACE
reflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;
#ifdef LODINREFLECTIONALPHA
float automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);float requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);
#else
float requestedReflectionLOD=reflectionLOD;
#endif
#ifdef REALTIME_FILTERING
environmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);
#else
environmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);
#endif
#else
float lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(
sampleReflection(reflectionSamplerHigh,reflectionCoords),
environmentMid,
lodReflectionNormalizedDoubled
);} else {environmentRadiance=mix(
environmentMid,
sampleReflection(reflectionSamplerLow,reflectionCoords),
lodReflectionNormalizedDoubled-1.0
);}
#endif
#ifdef RGBDREFLECTION
environmentRadiance.rgb=fromRGBD(environmentRadiance);
#endif
#ifdef GAMMAREFLECTION
environmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);
#endif
environmentRadiance.rgb*=vReflectionInfos.x;environmentRadiance.rgb*=vReflectionColor.rgb;}
#define pbr_inline
#define inline
void reflectionBlock(
in vec3 vPositionW,
in vec3 normalW,
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
in vec3 vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in mat4 reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out reflectionOutParams outParams
)
{vec4 environmentRadiance=vec4(0.,0.,0.,0.);
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords=vec3(0.);
#else
vec2 reflectionCoords=vec2(0.);
#endif
createReflectionCoords(
vPositionW,
normalW,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
reflectionCoords
);sampleReflectionTexture(
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
#ifdef REFLECTIONMAP_3D
reflectionSampler,
reflectionCoords,
#else
reflectionSampler,
reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentRadiance
);vec3 environmentIrradiance=vec3(0.,0.,0.);
#ifdef USESPHERICALFROMREFLECTIONMAP
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
environmentIrradiance=vEnvironmentIrradiance;
#else
#ifdef ANISOTROPIC
vec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;
#else
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#if defined(REALTIME_FILTERING)
environmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);
#else
environmentIrradiance=computeEnvironmentIrradiance(irradianceVector);
#endif
#ifdef SS_TRANSLUCENCY
outParams.irradianceVector=irradianceVector;
#endif
#endif
#elif defined(USEIRRADIANCEMAP)
vec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;
#ifdef RGBDREFLECTION
environmentIrradiance.rgb=fromRGBD(environmentIrradiance4);
#endif
#ifdef GAMMAREFLECTION
environmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);
#endif
#endif
environmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;}
#endif
`;hi.IncludesShadersStore[bI]=EI;const x5={name:bI,shader:EI},vI="pbrBlockSheen",II=`#ifdef SHEEN
struct sheenOutParams
{float sheenIntensity;vec3 sheenColor;float sheenRoughness;
#ifdef SHEEN_LINKWITHALBEDO
vec3 surfaceAlbedo;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
float sheenAlbedoScaling;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 finalSheenRadianceScaled;
#endif
#if DEBUGMODE>0
#ifdef SHEEN_TEXTURE
vec4 sheenMapData;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 sheenEnvironmentReflectance;
#endif
#endif
};
#define pbr_inline
#define inline
void sheenBlock(
in vec4 vSheenColor,
#ifdef SHEEN_ROUGHNESS
in float vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 sheenMapRoughnessData,
#endif
#endif
in float roughness,
#ifdef SHEEN_TEXTURE
in vec4 sheenMapData,
in float sheenMapLevel,
#endif
in float reflectance,
#ifdef SHEEN_LINKWITHALBEDO
in vec3 baseColor,
in vec3 surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
in float NdotV,
in vec3 environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
in vec2 AARoughnessFactors,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
in vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
in vec2 reflectionCoords,
#endif
in float NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
in float seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
in float eho,
#endif
#endif
out sheenOutParams outParams
)
{float sheenIntensity=vSheenColor.a;
#ifdef SHEEN_TEXTURE
#if DEBUGMODE>0
outParams.sheenMapData=sheenMapData;
#endif
#endif
#ifdef SHEEN_LINKWITHALBEDO
float sheenFactor=pow5(1.0-sheenIntensity);vec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);float sheenRoughness=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#else
vec3 sheenColor=vSheenColor.rgb;
#ifdef SHEEN_TEXTURE
#ifdef SHEEN_GAMMATEXTURE
sheenColor.rgb*=toLinearSpace(sheenMapData.rgb);
#else
sheenColor.rgb*=sheenMapData.rgb;
#endif
sheenColor.rgb*=sheenMapLevel;
#endif
#ifdef SHEEN_ROUGHNESS
float sheenRoughness=vSheenRoughness;
#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE
#if defined(SHEEN_TEXTURE)
sheenRoughness*=sheenMapData.a;
#endif
#elif defined(SHEEN_TEXTURE_ROUGHNESS)
#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL
sheenRoughness*=sheenMapData.a;
#else
sheenRoughness*=sheenMapRoughnessData.a;
#endif
#endif
#else
float sheenRoughness=roughness;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#endif
#if !defined(SHEEN_ALBEDOSCALING)
sheenIntensity*=(1.-reflectance);
#endif
sheenColor*=sheenIntensity;
#endif
#ifdef ENVIRONMENTBRDF
/*#ifdef SHEEN_SOFTER
vec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));
#else*/
#ifdef SHEEN_ROUGHNESS
vec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);
#else
vec3 environmentSheenBrdf=environmentBrdf;
#endif
/*#endif*/
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
float sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);
#ifdef SPECULARAA
sheenAlphaG+=AARoughnessFactors.y;
#endif
vec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);sampleReflectionTexture(
sheenAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
sheenRoughness,
#endif
reflectionSampler,
reflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentSheenRadiance
);vec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
sheenEnvironmentReflectance*=seo;
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
sheenEnvironmentReflectance*=eho;
#endif
#if DEBUGMODE>0
outParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;
#endif
outParams.finalSheenRadianceScaled=
environmentSheenRadiance.rgb *
sheenEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
outParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;
#endif
outParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;}
#endif
`;hi.IncludesShadersStore[vI]=II;const l5={name:vI,shader:II},RI="pbrBlockClearcoat",MI=`struct clearcoatOutParams
{vec3 specularEnvironmentR0;float conservationFactor;vec3 clearCoatNormalW;vec2 clearCoatAARoughnessFactors;float clearCoatIntensity;float clearCoatRoughness;
#ifdef REFLECTION
vec3 finalClearCoatRadianceScaled;
#endif
#ifdef CLEARCOAT_TINT
vec3 absorption;float clearCoatNdotVRefract;vec3 clearCoatColor;float clearCoatThickness;
#endif
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
vec3 energyConservationFactorClearCoat;
#endif
#if DEBUGMODE>0
#ifdef CLEARCOAT_BUMP
mat3 TBNClearCoat;
#endif
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData;
#endif
#ifdef REFLECTION
vec4 environmentClearCoatRadiance;vec3 clearCoatEnvironmentReflectance;
#endif
float clearCoatNdotV;
#endif
};
#ifdef CLEARCOAT
#define pbr_inline
#define inline
void clearcoatBlock(
in vec3 vPositionW,
in vec3 geometricNormalW,
in vec3 viewDirectionW,
in vec2 vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 clearCoatMapRoughnessData,
#endif
in vec3 specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
in vec4 vClearCoatTintParams,
in float clearCoatColorAtDistance,
in vec4 vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
in vec4 clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
in vec2 vClearCoatBumpInfos,
in vec4 clearCoatBumpMapData,
in vec2 vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
in mat3 vTBN,
#else
in vec2 vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
in mat4 normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
in vec3 faceNormal,
#endif
#ifdef REFLECTION
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
in float ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
in float frontFacingMultiplier,
#endif
out clearcoatOutParams outParams
)
{float clearCoatIntensity=vClearCoatParams.x;float clearCoatRoughness=vClearCoatParams.y;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE
clearCoatRoughness*=clearCoatMapData.y;
#endif
#if DEBUGMODE>0
outParams.clearCoatMapData=clearCoatMapData;
#endif
#endif
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL
clearCoatRoughness*=clearCoatMapData.y;
#else
clearCoatRoughness*=clearCoatMapRoughnessData.y;
#endif
#endif
outParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;
#ifdef CLEARCOAT_TINT
vec3 clearCoatColor=vClearCoatTintParams.rgb;float clearCoatThickness=vClearCoatTintParams.a;
#ifdef CLEARCOAT_TINT_TEXTURE
#ifdef CLEARCOAT_TINT_GAMMATEXTURE
clearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);
#else
clearCoatColor*=clearCoatTintMapData.rgb;
#endif
clearCoatThickness*=clearCoatTintMapData.a;
#if DEBUGMODE>0
outParams.clearCoatTintMapData=clearCoatTintMapData;
#endif
#endif
outParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;
#endif
#ifdef CLEARCOAT_REMAP_F0
vec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);
#else
vec3 specularEnvironmentR0Updated=specularEnvironmentR0;
#endif
outParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);vec3 clearCoatNormalW=geometricNormalW;
#ifdef CLEARCOAT_BUMP
#ifdef NORMALXYSCALE
float clearCoatNormalScale=1.0;
#else
float clearCoatNormalScale=vClearCoatBumpInfos.y;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBNClearCoat=vTBN;
#else
vec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;mat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);
#endif
#if DEBUGMODE>0
outParams.TBNClearCoat=TBNClearCoat;
#endif
#ifdef OBJECTSPACE_NORMALMAP
clearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);
#else
clearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
clearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
clearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;
#endif
outParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);float clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);float clearCoatNdotV=absEps(clearCoatNdotVUnclamped);
#if DEBUGMODE>0
outParams.clearCoatNdotV=clearCoatNdotV;
#endif
#ifdef CLEARCOAT_TINT
vec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));
#endif
#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))
vec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);
#endif
#if defined(REFLECTION)
float clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);
#ifdef SPECULARAA
clearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;
#endif
vec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);vec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
clearCoatReflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
vec3 clearCoatReflectionCoords=clearCoatReflectionVector;
#else
vec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
clearCoatReflectionCoords/=clearCoatReflectionVector.z;
#endif
clearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;
#endif
sampleReflectionTexture(
clearCoatAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
clearCoatNdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
clearCoatRoughness,
#endif
reflectionSampler,
clearCoatReflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentClearCoatRadiance
);
#if DEBUGMODE>0
outParams.environmentClearCoatRadiance=environmentClearCoatRadiance;
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;
#endif
#endif
#endif
#else
vec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));
#endif
clearCoatEnvironmentReflectance*=clearCoatIntensity;
#if DEBUGMODE>0
outParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;
#endif
outParams.finalClearCoatRadianceScaled=
environmentClearCoatRadiance.rgb *
clearCoatEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(CLEARCOAT_TINT)
outParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);
#endif
float fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
outParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);
#endif
}
#endif
`;hi.IncludesShadersStore[RI]=MI;const h5={name:RI,shader:MI},BI="pbrBlockIridescence",UI=`struct iridescenceOutParams
{float iridescenceIntensity;float iridescenceIOR;float iridescenceThickness;vec3 specularEnvironmentR0;};
#ifdef IRIDESCENCE
#define pbr_inline
#define inline
void iridescenceBlock(
in vec4 vIridescenceParams,
in float viewAngle,
in vec3 specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
in vec2 iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
in vec2 iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
in float NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#endif
out iridescenceOutParams outParams
)
{float iridescenceIntensity=vIridescenceParams.x;float iridescenceIOR=vIridescenceParams.y;float iridescenceThicknessMin=vIridescenceParams.z;float iridescenceThicknessMax=vIridescenceParams.w;float iridescenceThicknessWeight=1.;
#ifdef IRIDESCENCE_TEXTURE
iridescenceIntensity*=iridescenceMapData.x;
#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE
iridescenceThicknessWeight=iridescenceMapData.g;
#endif
#endif
#if defined(IRIDESCENCE_THICKNESS_TEXTURE)
iridescenceThicknessWeight=iridescenceThicknessMapData.g;
#endif
float iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);float topIor=1.; 
#ifdef CLEARCOAT
float clearCoatIntensity=vClearCoatParams.x;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#endif
topIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));
#endif
vec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;}
#endif
`;hi.IncludesShadersStore[BI]=UI;const u5={name:BI,shader:UI},VI="pbrBlockSubSurface",WI=`struct subSurfaceOutParams
{vec3 specularEnvironmentReflectance;
#ifdef SS_REFRACTION
vec3 finalRefraction;vec3 surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
float alpha;
#endif
#ifdef REFLECTION
float refractionFactorForIrradiance;
#endif
#endif
#ifdef SS_TRANSLUCENCY
vec3 transmittance;float translucencyIntensity;
#ifdef REFLECTION
vec3 refractionIrradiance;
#endif
#endif
#if DEBUGMODE>0
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction;vec3 refractionTransmittance;
#endif
#endif
};
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#define pbr_inline
#define inline
vec4 sampleEnvironmentRefraction(
in float ior
,in float thickness
,in float refractionLOD
,in vec3 normalW
,in vec3 vPositionW
,in vec3 viewDirectionW
,in mat4 view
,in vec4 vRefractionInfos
,in mat4 refractionMatrix
,in vec4 vRefractionMicrosurfaceInfos
,in float alphaG
#ifdef SS_REFRACTIONMAP_3D
,in samplerCube refractionSampler
#ifndef LODBASEDMICROSFURACE
,in samplerCube refractionSamplerLow
,in samplerCube refractionSamplerHigh
#endif
#else
,in sampler2D refractionSampler
#ifndef LODBASEDMICROSFURACE
,in sampler2D refractionSamplerLow
,in sampler2D refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,in anisotropicOutParams anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,in vec2 vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,in vec3 refractionPosition
,in vec3 refractionSize
#endif
) {vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef ANISOTROPIC
vec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,ior);
#else
vec3 refractionVector=refract(-viewDirectionW,normalW,ior);
#endif
#ifdef SS_REFRACTIONMAP_OPPOSITEZ
refractionVector.z*=-1.0;
#endif
#ifdef SS_REFRACTIONMAP_3D
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec3 refractionCoords=refractionVector;refractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));
#else
#ifdef SS_USE_THICKNESS_AS_DEPTH
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
#endif
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;
#endif
#ifdef LODBASEDMICROSFURACE
refractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;
#ifdef SS_LODINREFRACTIONALPHA
float automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);float requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);
#else
float requestedRefractionLOD=refractionLOD;
#endif
#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)
environmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);
#else
environmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);
#endif
#else
float lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));float lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;vec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(
sampleRefraction(refractionSamplerHigh,refractionCoords),
environmentRefractionMid,
lodRefractionNormalizedDoubled
);} else {environmentRefraction=mix(
environmentRefractionMid,
sampleRefraction(refractionSamplerLow,refractionCoords),
lodRefractionNormalizedDoubled-1.0
);}
#endif
#ifdef SS_RGBDREFRACTION
environmentRefraction.rgb=fromRGBD(environmentRefraction);
#endif
#ifdef SS_GAMMAREFRACTION
environmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);
#endif
return environmentRefraction;}
#endif
#define pbr_inline
#define inline
void subSurfaceBlock(
in vec3 vSubSurfaceIntensity,
in vec2 vThicknessParam,
in vec4 vTintColor,
in vec3 normalW,
in vec3 specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
in vec4 thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
in vec4 refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
in vec4 translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
in mat4 reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in vec3 irradianceVector_,
#endif
#if defined(REALTIME_FILTERING)
in samplerCube reflectionSampler,
in vec2 vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
in vec3 surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
in vec3 vPositionW,
in vec3 viewDirectionW,
in mat4 view,
in vec4 vRefractionInfos,
in mat4 refractionMatrix,
in vec4 vRefractionMicrosurfaceInfos,
in vec4 vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
in float alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
in float NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
in float roughness,
#endif
in float alphaG,
#ifdef SS_REFRACTIONMAP_3D
in samplerCube refractionSampler,
#ifndef LODBASEDMICROSFURACE
in samplerCube refractionSamplerLow,
in samplerCube refractionSamplerHigh,
#endif
#else
in sampler2D refractionSampler,
#ifndef LODBASEDMICROSFURACE
in sampler2D refractionSamplerLow,
in sampler2D refractionSamplerHigh,
#endif
#endif
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
in vec2 vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
in vec3 refractionPosition,
in vec3 refractionSize,
#endif
#ifdef SS_DISPERSION
in float dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
in vec3 vDiffusionDistance,
#endif
out subSurfaceOutParams outParams
)
{outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;
#ifdef SS_REFRACTION
float refractionIntensity=vSubSurfaceIntensity.x;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
refractionIntensity*=(1.0-alpha);outParams.alpha=1.0;
#endif
#endif
#ifdef SS_TRANSLUCENCY
float translucencyIntensity=vSubSurfaceIntensity.y;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
#if defined(SS_USE_GLTF_TEXTURES)
float thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;
#else
float thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;
#endif
#if DEBUGMODE>0
outParams.thicknessMap=thicknessMap;
#endif
#ifdef SS_MASK_FROM_THICKNESS_TEXTURE
#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)
#if defined(SS_USE_GLTF_TEXTURES)
refractionIntensity*=thicknessMap.r;
#else
refractionIntensity*=thicknessMap.g;
#endif
#endif
#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)
translucencyIntensity*=thicknessMap.b;
#endif
#endif
#else
float thickness=vThicknessParam.y;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
#ifdef SS_USE_GLTF_TEXTURES
refractionIntensity*=refractionIntensityMap.r;
#else
refractionIntensity*=refractionIntensityMap.g;
#endif
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensity*=translucencyIntensityMap.b;
#endif
#ifdef SS_TRANSLUCENCY
thickness=maxEps(thickness);vec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef SS_HAS_THICKNESS
float ior=vRefractionInfos.y;
#else
float ior=vRefractionMicrosurfaceInfos.w;
#endif
#ifdef SS_LODINREFRACTIONALPHA
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);
#elif defined(SS_LINEARSPECULARREFRACTION)
float refractionRoughness=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);
#else
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);
#endif
float refraction_ior=vRefractionInfos.y;
#ifdef SS_DISPERSION
float realIOR=1.0/refraction_ior;float iorDispersionSpread=0.04*dispersion*(realIOR-1.0);vec3 iors=vec3(1.0/(realIOR-iorDispersionSpread),refraction_ior,1.0/(realIOR+iorDispersionSpread));for (int i=0; i<3; i++) {refraction_ior=iors[i];
#endif
vec4 envSample=sampleEnvironmentRefraction(refraction_ior,thickness,refractionLOD,normalW,vPositionW,viewDirectionW,view,vRefractionInfos,refractionMatrix,vRefractionMicrosurfaceInfos,alphaG
#ifdef SS_REFRACTIONMAP_3D
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#else
,refractionSampler
#ifndef LODBASEDMICROSFURACE
,refractionSamplerLow
,refractionSamplerHigh
#endif
#endif
#ifdef ANISOTROPIC
,anisotropicOut
#endif
#ifdef REALTIME_FILTERING
,vRefractionFilteringInfo
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
,refractionPosition
,refractionSize
#endif
);
#ifdef SS_DISPERSION
environmentRefraction[i]=envSample[i];}
#else
environmentRefraction=envSample;
#endif
environmentRefraction.rgb*=vRefractionInfos.x;
#endif
#ifdef SS_REFRACTION
vec3 refractionTransmittance=vec3(refractionIntensity);
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,thickness);
#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)
float maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);vec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);environmentRefraction.rgb*=volumeAlbedo;
#else
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);
#endif
#ifdef SS_ALBEDOFORREFRACTIONTINT
environmentRefraction.rgb*=surfaceAlbedo.rgb;
#endif
outParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);
#ifdef REFLECTION
outParams.refractionFactorForIrradiance=(1.-refractionIntensity);
#endif
#ifdef UNUSED_MULTIPLEBOUNCES
vec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);
#endif
refractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;
#if DEBUGMODE>0
outParams.refractionTransmittance=refractionTransmittance;
#endif
outParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;
#if DEBUGMODE>0
outParams.environmentRefraction=environmentRefraction;
#endif
#endif
#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)
#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#else
vec3 irradianceVector=irradianceVector_;
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP)
#if defined(REALTIME_FILTERING)
vec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);
#else
vec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);
#endif
#elif defined(USEIRRADIANCEMAP)
#ifdef REFLECTIONMAP_3D
vec3 irradianceCoords=irradianceVector;
#else
vec2 irradianceCoords=irradianceVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
irradianceCoords/=irradianceVector.z;
#endif
irradianceCoords.y=1.0-irradianceCoords.y;
#endif
vec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);
#ifdef RGBDREFLECTION
refractionIrradiance.rgb=fromRGBD(refractionIrradiance);
#endif
#ifdef GAMMAREFLECTION
refractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);
#endif
#else
vec4 refractionIrradiance=vec4(0.);
#endif
refractionIrradiance.rgb*=transmittance;
#ifdef SS_ALBEDOFORTRANSLUCENCYTINT
refractionIrradiance.rgb*=surfaceAlbedo.rgb;
#endif
outParams.refractionIrradiance=refractionIrradiance.rgb;
#endif
}
#endif
`;hi.IncludesShadersStore[VI]=WI;const d5={name:VI,shader:WI},HI="pbrBlockNormalGeometric",XI=`vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#endif
vec3 geometricNormalW=normalW;
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
geometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;
#endif
`;hi.IncludesShadersStore[HI]=XI;const f5={name:HI,shader:XI},jI="bumpFragment",YI=`vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;hi.IncludesShadersStore[jI]=YI;const m5={name:jI,shader:YI},$I="pbrBlockNormalFinal",JI=`#if defined(FORCENORMALFORWARD) && defined(NORMAL)
vec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#if defined(TWOSIDEDLIGHTING)
faceNormal=gl_FrontFacing ? faceNormal : -faceNormal;
#endif
normalW*=sign(dot(normalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
`;hi.IncludesShadersStore[$I]=JI;const g5={name:$I,shader:JI},tR="depthPrePass",aR=`#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);return;
#endif
`;hi.IncludesShadersStore[tR]=aR;const _5={name:tR,shader:aR},xR="pbrBlockLightmapInit",lR=`#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
#ifdef GAMMALIGHTMAP
lightmapColor.rgb=toLinearSpace(lightmapColor.rgb);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
`;hi.IncludesShadersStore[xR]=lR;const y5={name:xR,shader:lR},hR="pbrBlockGeometryInfo",uR=`float NdotVUnclamped=dot(normalW,viewDirectionW);float NdotV=absEps(NdotVUnclamped);float alphaG=convertRoughnessToAverageSlope(roughness);vec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);
#ifdef SPECULARAA
alphaG+=AARoughnessFactors.y;
#endif
#if defined(ENVIRONMENTBRDF)
vec3 environmentBrdf=getBRDFLookup(NdotV,roughness);
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
#ifdef AMBIENTINGRAYSCALE
float ambientMonochrome=aoOut.ambientOcclusionColor.r;
#else
float ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);
#endif
float seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);
#endif
#endif
#endif
#endif
`;hi.IncludesShadersStore[hR]=uR;const b5={name:hR,shader:uR},dR="pbrBlockReflectance0",fR=`float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);vec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);
#else 
vec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);
#endif
#ifdef ALPHAFRESNEL
float reflectance90=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;
#endif
`;hi.IncludesShadersStore[dR]=fR;const E5={name:dR,shader:fR},mR="pbrBlockReflectance",gR=`#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);
#ifdef RADIANCEOCCLUSION
specularEnvironmentReflectance*=seo;
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
specularEnvironmentReflectance*=eho;
#endif
#endif
#endif
#else
vec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));
#endif
#ifdef CLEARCOAT
specularEnvironmentReflectance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
specularEnvironmentReflectance*=clearcoatOut.absorption;
#endif
#endif
`;hi.IncludesShadersStore[mR]=gR;const v5={name:mR,shader:gR},_R="pbrBlockDirectLighting",yR=`vec3 diffuseBase=vec3(0.,0.,0.);
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
#ifdef CLEARCOAT
vec3 clearCoatBase=vec3(0.,0.,0.);
#endif
#ifdef SHEEN
vec3 sheenBase=vec3(0.,0.,0.);
#endif
preLightingInfo preInfo;lightingInfo info;float shadow=1.; 
float aggShadow=0.;float numLights=0.;
#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
vec3 absorption=vec3(0.);
#endif
`;hi.IncludesShadersStore[_R]=yR;const R5={name:_R,shader:yR},bR="lightFragment",ER=`#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;hi.IncludesShadersStore[bR]=ER;const M5={name:bR,shader:ER},vR="pbrBlockFinalLitComponents",IR=`aggShadow=aggShadow/numLights;
#if defined(ENVIRONMENTBRDF)
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);
#endif
#endif
#ifndef METALLICWORKFLOW
#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION
surfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;
#endif
#endif
#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)
surfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;
#endif
#ifdef REFLECTION
vec3 finalIrradiance=reflectionOut.environmentIrradiance;
#if defined(CLEARCOAT)
finalIrradiance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
finalIrradiance*=clearcoatOut.absorption;
#endif
#endif
#if defined(SS_REFRACTION)
finalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;
#endif
#if defined(SS_TRANSLUCENCY)
finalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;
#endif
finalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase;finalSpecular=max(finalSpecular,0.0);vec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalSpecularScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalSpecularScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef REFLECTION
vec3 finalRadiance=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;vec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalRadianceScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalRadianceScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef SHEEN
vec3 finalSheen=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,0.0);vec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;
#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef CLEARCOAT
vec3 finalClearCoat=clearCoatBase;finalClearCoat=max(finalClearCoat,0.0);vec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;
#ifdef CLEARCOAT_TINT
subSurfaceOut.finalRefraction*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef ALPHABLEND
float luminanceOverAlpha=0.0;
#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)
luminanceOverAlpha+=getLuminance(finalRadianceScaled);
#if defined(CLEARCOAT)
luminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);
#endif
#endif
#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)
luminanceOverAlpha+=getLuminance(finalSpecularScaled);
#endif
#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)
luminanceOverAlpha+=getLuminance(finalClearCoatScaled);
#endif
#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)
alpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);
#endif
#endif
`;hi.IncludesShadersStore[vR]=IR;const B5={name:vR,shader:IR},RR="pbrBlockFinalUnlitComponents",MR=`vec3 finalDiffuse=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,0.0);finalDiffuse*=vLightingIntensity.x;vec3 finalAmbient=vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;vec3 finalEmissive=vEmissiveColor;
#ifdef EMISSIVE
vec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;
#ifdef GAMMAEMISSIVE
finalEmissive*=toLinearSpace(emissiveColorTex.rgb);
#else
finalEmissive*=emissiveColorTex.rgb;
#endif
finalEmissive*= vEmissiveInfos.y;
#endif
finalEmissive*=vLightingIntensity.y;
#ifdef AMBIENT
vec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);
#else
vec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;
#endif
finalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;
`;hi.IncludesShadersStore[RR]=MR;const U5={name:RR,shader:MR},BR="pbrBlockFinalColorComposition",UR=`vec4 finalColor=vec4(
#ifndef UNLIT
#ifdef REFLECTION
finalIrradiance +
#endif
#ifdef SPECULARTERM
finalSpecularScaled +
#endif
#ifdef SHEEN
finalSheenScaled +
#endif
#ifdef CLEARCOAT
finalClearCoatScaled +
#endif
#ifdef REFLECTION
finalRadianceScaled +
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled +
#endif
#ifdef CLEARCOAT
clearcoatOut.finalClearCoatRadianceScaled +
#endif
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction +
#endif
#endif
finalAmbient +
finalDiffuse,
alpha);
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
finalColor.rgb*=lightmapColor.rgb;
#else
finalColor.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
finalColor.rgb+=finalEmissive;
#define CUSTOM_FRAGMENT_BEFORE_FOG
finalColor=max(finalColor,0.0);
`;hi.IncludesShadersStore[BR]=UR;const V5={name:BR,shader:UR},VR="logDepthFragment",WR=`#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;hi.IncludesShadersStore[VR]=WR;const W5={name:VR,shader:WR},HR="fogFragment",XR=`#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;hi.IncludesShadersStore[HR]=XR;const H5={name:HR,shader:XR},jR="pbrBlockImageProcessing",YR=`#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)
#if !defined(SKIPFINALCOLORCLAMP)
finalColor.rgb=clamp(finalColor.rgb,0.,30.0);
#endif
#else
finalColor=applyImageProcessing(finalColor);
#endif
finalColor.a*=visibility;
#ifdef PREMULTIPLYALPHA
finalColor.rgb*=finalColor.a;
#endif
`;hi.IncludesShadersStore[jR]=YR;const X5={name:jR,shader:YR},$R="oitFragment",JR=`#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);return;}
#endif
`;hi.IncludesShadersStore[$R]=JR;const j5={name:$R,shader:JR},tM="pbrDebug",aM=`#if DEBUGMODE>0
if (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {
#if DEBUGMODE==1
gl_FragColor.rgb=vPositionW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==2 && defined(NORMAL)
gl_FragColor.rgb=vNormalW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==5
gl_FragColor.rgb=normalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==6 && defined(MAINUV1)
gl_FragColor.rgb=vec3(vMainUV1,0.0);
#elif DEBUGMODE==7 && defined(MAINUV2)
gl_FragColor.rgb=vec3(vMainUV2,0.0);
#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==10 && defined(CLEARCOAT)
gl_FragColor.rgb=clearcoatOut.clearCoatNormalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==11 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicNormal;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==12 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicTangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==13 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicBitangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==20 && defined(ALBEDO)
gl_FragColor.rgb=albedoTexture.rgb;
#ifndef GAMMAALBEDO
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==21 && defined(AMBIENT)
gl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;
#elif DEBUGMODE==22 && defined(OPACITY)
gl_FragColor.rgb=opacityMap.rgb;
#elif DEBUGMODE==23 && defined(EMISSIVE)
gl_FragColor.rgb=emissiveColorTex.rgb;
#ifndef GAMMAEMISSIVE
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==24 && defined(LIGHTMAP)
gl_FragColor.rgb=lightmapColor.rgb;
#ifndef GAMMALIGHTMAP
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;
#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);
#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
gl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;
#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)
gl_FragColor.rgb=sheenOut.sheenMapData.rgb;
#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)
gl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;
#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)
gl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;
#elif DEBUGMODE==32 && defined(BUMP)
gl_FragColor.rgb=texture2D(bumpSampler,vBumpUV).rgb;
#elif DEBUGMODE==40 && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==41 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)
gl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==50
gl_FragColor.rgb=diffuseBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==51 && defined(SPECULARTERM)
gl_FragColor.rgb=specularBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==52 && defined(CLEARCOAT)
gl_FragColor.rgb=clearCoatBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==53 && defined(SHEEN)
gl_FragColor.rgb=sheenBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==54 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==60
gl_FragColor.rgb=surfaceAlbedo.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==61
gl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);
#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.metallicF0;
#elif DEBUGMODE==63
gl_FragColor.rgb=vec3(roughness);
#elif DEBUGMODE==64
gl_FragColor.rgb=vec3(alphaG);
#elif DEBUGMODE==65
gl_FragColor.rgb=vec3(NdotV);
#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
gl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==67 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);
#elif DEBUGMODE==68 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);
#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)
gl_FragColor.rgb=subSurfaceOut.transmittance;
#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.refractionTransmittance;
#elif DEBUGMODE==72
gl_FragColor.rgb=vec3(microSurface);
#elif DEBUGMODE==73
gl_FragColor.rgb=vAlbedoColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=vReflectivityColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==75
gl_FragColor.rgb=vEmissiveColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)
gl_FragColor.rgb=vec3(seo);
#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
gl_FragColor.rgb=vec3(eho);
#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)
gl_FragColor.rgb=vec3(energyConservationFactor);
#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=specularEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)
gl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==86 && defined(ALPHABLEND)
gl_FragColor.rgb=vec3(luminanceOverAlpha);
#elif DEBUGMODE==87
gl_FragColor.rgb=vec3(alpha);
#elif DEBUGMODE==88 && defined(ALBEDO)
gl_FragColor.rgb=vec3(albedoTexture.a);
#else
float stripeWidth=30.;float stripePos=floor((gl_FragCoord.x+gl_FragCoord.y)/stripeWidth);float whichColor=mod(stripePos,2.);vec3 color1=vec3(.6,.2,.2);vec3 color2=vec3(.3,.1,.1);gl_FragColor.rgb=mix(color1,color2,whichColor);
#endif
gl_FragColor.rgb*=vDebugMode.y;
#ifdef DEBUGMODE_NORMALIZE
gl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;
#endif
#ifdef DEBUGMODE_GAMMA
gl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);
#endif
gl_FragColor.a=1.0;
#ifdef PREPASS
gl_FragData[0]=toLinearSpace(gl_FragColor); 
gl_FragData[1]=vec4(0.,0.,0.,0.); 
#endif
#ifdef DEBUGMODE_FORCERETURN
return;
#endif
}
#endif
`;hi.IncludesShadersStore[tM]=aM;const Y5={name:tM,shader:aM},xM="pbrPixelShader",lM=`#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#extension GL_OES_standard_derivatives : enable
#endif
#ifdef LODBASEDMICROSFURACE
#extension GL_EXT_shader_texture_lod : enable
#endif
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
precision highp float;
#include<oitDeclaration>
#ifndef FROMLINEARSPACE
#define FROMLINEARSPACE
#endif
#include<__decl__pbrFragment>
#include<pbrFragmentExtraDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<pbrFragmentSamplersDeclaration>
#include<imageProcessingDeclaration>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#include<helperFunctions>
#include<subSurfaceScatteringFunctions>
#include<importanceSampling>
#include<pbrHelperFunctions>
#include<imageProcessingFunctions>
#include<shadowsFragmentFunctions>
#include<harmonicsFunctions>
#include<pbrDirectLightingSetupFunctions>
#include<pbrDirectLightingFalloffFunctions>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
#include<pbrDirectLightingFunctions>
#include<pbrIBLFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#ifdef REFLECTION
#include<reflectionFunction>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
#include<pbrBlockAlbedoOpacity>
#include<pbrBlockReflectivity>
#include<pbrBlockAmbientOcclusion>
#include<pbrBlockAlphaFresnel>
#include<pbrBlockAnisotropic>
#include<pbrBlockReflection>
#include<pbrBlockSheen>
#include<pbrBlockClearcoat>
#include<pbrBlockIridescence>
#include<pbrBlockSubSurface>
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#include<pbrBlockNormalGeometric>
#include<bumpFragment>
#include<pbrBlockNormalFinal>
albedoOpacityOutParams albedoOpacityOut;
#ifdef ALBEDO
vec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#endif
#ifdef DECAL
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#endif
albedoOpacityBlock(
vAlbedoColor,
#ifdef ALBEDO
albedoTexture,
vAlbedoInfos,
#endif
#ifdef OPACITY
opacityMap,
vOpacityInfos,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
#ifdef DECAL
decalColor,
vDecalInfos,
#endif
albedoOpacityOut
);vec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;float alpha=albedoOpacityOut.alpha;
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
#include<depthPrePass>
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
ambientOcclusionOutParams aoOut;
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;
#endif
ambientOcclusionBlock(
#ifdef AMBIENT
ambientOcclusionColorMap,
vAmbientInfos,
#endif
aoOut
);
#include<pbrBlockLightmapInit>
#ifdef UNLIT
vec3 diffuseBase=vec3(1.,1.,1.);
#else
vec3 baseColor=surfaceAlbedo;reflectivityOutParams reflectivityOut;
#if defined(REFLECTIVITY)
vec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);vec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;
#ifndef METALLICWORKFLOW
#ifdef REFLECTIVITY_GAMMA
surfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);
#endif
surfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;
#endif
#endif
#if defined(MICROSURFACEMAP)
vec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;
#endif
#ifdef METALLICWORKFLOW
vec4 metallicReflectanceFactors=vMetallicReflectanceFactors;
#ifdef REFLECTANCE
vec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);
#ifdef REFLECTANCE_GAMMA
reflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);
#endif
metallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;
#endif
#ifdef METALLIC_REFLECTANCE
vec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);
#ifdef METALLIC_REFLECTANCE_GAMMA
metallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);
#endif
#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY
metallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;
#endif
metallicReflectanceFactors*=metallicReflectanceFactorsMap.a;
#endif
#endif
reflectivityBlock(
vReflectivityColor,
#ifdef METALLICWORKFLOW
surfaceAlbedo,
metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
vReflectivityInfos,
surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor,
#endif
#ifdef MICROSURFACEMAP
microSurfaceTexel,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
reflectivityOut
);float microSurface=reflectivityOut.microSurface;float roughness=reflectivityOut.roughness;
#ifdef METALLICWORKFLOW
surfaceAlbedo=reflectivityOut.surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;
#endif
#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
alphaFresnelOutParams alphaFresnelOut;alphaFresnelBlock(
normalW,
viewDirectionW,
alpha,
microSurface,
alphaFresnelOut
);alpha=alphaFresnelOut.alpha;
#endif
#endif
#include<pbrBlockGeometryInfo>
#ifdef ANISOTROPIC
anisotropicOutParams anisotropicOut;
#ifdef ANISOTROPIC_TEXTURE
vec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;
#endif
anisotropicBlock(
vAnisotropy,
roughness,
#ifdef ANISOTROPIC_TEXTURE
anisotropyMapData,
#endif
TBN,
normalW,
viewDirectionW,
anisotropicOut
);
#endif
#ifdef REFLECTION
reflectionOutParams reflectionOut;
#ifndef USE_CUSTOM_REFLECTION
reflectionBlock(
vPositionW,
normalW,
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
reflectionSampler,
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
reflectionOut
);
#else
#define CUSTOM_REFLECTION
#endif
#endif
#include<pbrBlockReflectance0>
#ifdef SHEEN
sheenOutParams sheenOut;
#ifdef SHEEN_TEXTURE
vec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);
#endif
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;
#endif
sheenBlock(
vSheenColor,
#ifdef SHEEN_ROUGHNESS
vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
sheenMapRoughnessData,
#endif
#endif
roughness,
#ifdef SHEEN_TEXTURE
sheenMapData,
vSheenInfos.y,
#endif
reflectance,
#ifdef SHEEN_LINKWITHALBEDO
baseColor,
surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
NdotV,
environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
AARoughnessFactors,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
reflectionOut.reflectionCoords,
NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
eho,
#endif
#endif
sheenOut
);
#ifdef SHEEN_LINKWITHALBEDO
surfaceAlbedo=sheenOut.surfaceAlbedo;
#endif
#endif
#ifdef CLEARCOAT
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;
#endif
#endif
#ifdef IRIDESCENCE
iridescenceOutParams iridescenceOut;
#ifdef IRIDESCENCE_TEXTURE
vec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
vec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;
#endif
iridescenceBlock(
vIridescenceParams,
NdotV,
specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#endif
iridescenceOut
);float iridescenceIntensity=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;
#endif
clearcoatOutParams clearcoatOut;
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);
#endif
#ifdef CLEARCOAT_BUMP
vec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);
#endif
clearcoatBlock(
vPositionW,
geometricNormalW,
viewDirectionW,
vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
clearCoatMapRoughnessData,
#endif
specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
vClearCoatTintParams,
clearCoatColorAtDistance,
vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
vClearCoatBumpInfos,
clearCoatBumpMapData,
vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
vTBN,
#else
vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
faceNormal,
#endif
#ifdef REFLECTION
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
(gl_FrontFacing ? 1. : -1.),
#endif
clearcoatOut
);
#else
clearcoatOut.specularEnvironmentR0=specularEnvironmentR0;
#endif
#include<pbrBlockReflectance>
subSurfaceOutParams subSurfaceOut;
#ifdef SUBSURFACE
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
vec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
vec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);
#endif
subSurfaceBlock(
vSubSurfaceIntensity,
vThicknessParam,
vTintColor,
normalW,
specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionOut.irradianceVector,
#endif
#if defined(REALTIME_FILTERING)
reflectionSampler,
vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
vPositionW,
viewDirectionW,
view,
vRefractionInfos,
refractionMatrix,
vRefractionMicrosurfaceInfos,
vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
roughness,
#endif
alphaG,
refractionSampler,
#ifndef LODBASEDMICROSFURACE
refractionSamplerLow,
refractionSamplerHigh,
#endif
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
vRefractionPosition,
vRefractionSize,
#endif
#ifdef SS_DISPERSION
dispersion,
#endif
#endif
#ifdef SS_TRANSLUCENCY
vDiffusionDistance,
#endif
subSurfaceOut
);
#ifdef SS_REFRACTION
surfaceAlbedo=subSurfaceOut.surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha=subSurfaceOut.alpha;
#endif
#endif
#else
subSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;
#endif
#include<pbrBlockDirectLighting>
#include<lightFragment>[0..maxSimultaneousLights]
#include<pbrBlockFinalLitComponents>
#endif 
#include<pbrBlockFinalUnlitComponents>
#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION
#include<pbrBlockFinalColorComposition>
#include<logDepthFragment>
#include<fogFragment>(color,finalColor)
#include<pbrBlockImageProcessing>
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO_SQRT
vec3 sqAlbedo=sqrt(surfaceAlbedo); 
#endif
#ifdef PREPASS_IRRADIANCE
vec3 irradiance=finalDiffuse;
#ifndef UNLIT
#ifdef REFLECTION
irradiance+=finalIrradiance;
#endif
#endif
#ifdef SS_SCATTERING
gl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); 
irradiance/=sqAlbedo;
#else
gl_FragData[0]=finalColor; 
float scatteringDiffusionProfile=255.;
#endif
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); 
#else
gl_FragData[0]=vec4(finalColor.rgb,finalColor.a);
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); 
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); 
#endif
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#ifndef UNLIT
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=finalColor;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);} else {backColor+=finalColor;}
#endif
#include<pbrDebug>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;hi.ShadersStore[xM]=lM;const $5={name:xM,shader:lM},hM="decalVertexDeclaration",uM=`#ifdef DECAL
uniform vec4 vDecalInfos;uniform mat4 decalMatrix;
#endif
`;hi.IncludesShadersStore[hM]=uM;const J5={name:hM,shader:uM},dM="pbrVertexDeclaration",fM=`uniform mat4 view;uniform mat4 viewProjection;
#ifdef ALBEDO
uniform mat4 albedoMatrix;uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec4 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#ifdef REFLECTIVITY 
uniform vec3 vReflectivityInfos;uniform mat4 reflectivityMatrix;
#endif
#ifdef METALLIC_REFLECTANCE
uniform vec2 vMetallicReflectanceInfos;uniform mat4 metallicReflectanceMatrix;
#endif
#ifdef REFLECTANCE
uniform vec2 vReflectanceInfos;uniform mat4 reflectanceMatrix;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;uniform mat4 microSurfaceSamplerMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;
#endif
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#ifdef IRIDESCENCE
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
#endif
#ifdef NORMAL
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`;hi.IncludesShadersStore[dM]=fM;const t9={name:dM,shader:fM},mM="uvAttributeDeclaration",gM=`#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;hi.IncludesShadersStore[mM]=gM;const a9={name:mM,shader:gM},_M="prePassVertexDeclaration",yM=`#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#endif
`;hi.IncludesShadersStore[_M]=yM;const x9={name:_M,shader:yM},bM="samplerVertexDeclaration",EM=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;hi.IncludesShadersStore[bM]=EM;const l9={name:bM,shader:EM},vM="bumpVertexDeclaration",IM=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;hi.IncludesShadersStore[vM]=IM;const h9={name:vM,shader:IM},RM="fogVertexDeclaration",MM=`#ifdef FOG
varying vec3 vFogDistance;
#endif
`;hi.IncludesShadersStore[RM]=MM;const u9={name:RM,shader:MM},BM="lightVxFragmentDeclaration",UM=`#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;hi.IncludesShadersStore[BM]=UM;const d9={name:BM,shader:UM},VM="lightVxUboDeclaration",WM=`#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;hi.IncludesShadersStore[VM]=WM;const f9={name:VM,shader:WM},HM="prePassVertex",XM=`#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;hi.IncludesShadersStore[HM]=XM;const m9={name:HM,shader:XM},jM="uvVariableDeclaration",YM=`#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;hi.IncludesShadersStore[jM]=YM;const g9={name:jM,shader:YM},$M="samplerVertexImplementation",JM=`#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}
#ifdef UV2
else if (v_INFONAME_==1.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}
#endif
#endif
`;hi.IncludesShadersStore[$M]=JM;const _9={name:$M,shader:JM},tw="bumpVertex",aw=`#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;hi.IncludesShadersStore[tw]=aw;const y9={name:tw,shader:aw},xw="fogVertex",lw=`#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;hi.IncludesShadersStore[xw]=lw;const b9={name:xw,shader:lw},hw="shadowsVertex",uw=`#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;hi.IncludesShadersStore[hw]=uw;const E9={name:hw,shader:uw},dw="vertexColorMixing",fw=`#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;hi.IncludesShadersStore[dw]=fw;const v9={name:dw,shader:fw},mw="logDepthVertex",gw=`#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;hi.IncludesShadersStore[mw]=gw;const I9={name:mw,shader:gw},_w="pbrVertexShader",yw=`precision highp float;
#include<__decl__pbrVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#include<mainUVVaryingDeclaration>[1..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)
#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)
#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
#ifdef CLEARCOAT
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)
#endif
#ifdef SUBSURFACE
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)
#endif
varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#include<harmonicsFunctions>
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vPositionW=vec3(worldPos);
#include<prePassVertex>
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
vec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
vEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#if DEBUGMODE>0
vClipSpacePosition=gl_Position;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#ifdef CLEARCOAT
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)
#endif
#ifdef SHEEN
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheenRoughness,_INFONAME_,SheenInfos.z)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)
#endif
#ifdef SUBSURFACE
#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)
#endif
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;hi.ShadersStore[_w]=yw;const R9={name:_w,shader:yw};class UL extends Jc{constructor(){super(...arguments),this.CLEARCOAT=!1,this.CLEARCOAT_DEFAULTIOR=!1,this.CLEARCOAT_TEXTURE=!1,this.CLEARCOAT_TEXTURE_ROUGHNESS=!1,this.CLEARCOAT_TEXTUREDIRECTUV=0,this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV=0,this.CLEARCOAT_BUMP=!1,this.CLEARCOAT_BUMPDIRECTUV=0,this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,this.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL=!1,this.CLEARCOAT_REMAP_F0=!1,this.CLEARCOAT_TINT=!1,this.CLEARCOAT_TINT_TEXTURE=!1,this.CLEARCOAT_TINT_TEXTUREDIRECTUV=0,this.CLEARCOAT_TINT_GAMMATEXTURE=!1}}class xo extends jl{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(a,x=!0){super(a,"PBRClearCoat",100,new UL,x),this._isEnabled=!1,this.isEnabled=!1,this.intensity=1,this.roughness=0,this._indexOfRefraction=xo._DefaultIndexOfRefraction,this.indexOfRefraction=xo._DefaultIndexOfRefraction,this._texture=null,this.texture=null,this._useRoughnessFromMainTexture=!0,this.useRoughnessFromMainTexture=!0,this._textureRoughness=null,this.textureRoughness=null,this._remapF0OnInterfaceChange=!0,this.remapF0OnInterfaceChange=!0,this._bumpTexture=null,this.bumpTexture=null,this._isTintEnabled=!1,this.isTintEnabled=!1,this.tintColor=Bs.White(),this.tintColorAtDistance=1,this.tintThickness=1,this._tintTexture=null,this.tintTexture=null,this._internalMarkAllSubMeshesAsTexturesDirty=a._dirtyCallbacks[1]}isReadyForSubMesh(a,x,c){if(!this._isEnabled)return!0;const u=this._material._disableBumpMap;return!(a._areTexturesDirty&&x.texturesEnabled&&(this._texture&&$i.ClearCoatTextureEnabled&&!this._texture.isReadyOrNotBlocking()||this._textureRoughness&&$i.ClearCoatTextureEnabled&&!this._textureRoughness.isReadyOrNotBlocking()||c.getCaps().standardDerivatives&&this._bumpTexture&&$i.ClearCoatBumpTextureEnabled&&!u&&!this._bumpTexture.isReady()||this._isTintEnabled&&this._tintTexture&&$i.ClearCoatTintTextureEnabled&&!this._tintTexture.isReadyOrNotBlocking()))}prepareDefinesBeforeAttributes(a,x){this._isEnabled?(a.CLEARCOAT=!0,a.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE=this._useRoughnessFromMainTexture,a.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL=this._texture!==null&&this._texture._texture===this._textureRoughness?._texture&&this._texture.checkTransformsAreIdentical(this._textureRoughness),a.CLEARCOAT_REMAP_F0=this._remapF0OnInterfaceChange,a._areTexturesDirty&&x.texturesEnabled&&(this._texture&&$i.ClearCoatTextureEnabled?$a(this._texture,a,"CLEARCOAT_TEXTURE"):a.CLEARCOAT_TEXTURE=!1,this._textureRoughness&&$i.ClearCoatTextureEnabled?$a(this._textureRoughness,a,"CLEARCOAT_TEXTURE_ROUGHNESS"):a.CLEARCOAT_TEXTURE_ROUGHNESS=!1,this._bumpTexture&&$i.ClearCoatBumpTextureEnabled?$a(this._bumpTexture,a,"CLEARCOAT_BUMP"):a.CLEARCOAT_BUMP=!1,a.CLEARCOAT_DEFAULTIOR=this._indexOfRefraction===xo._DefaultIndexOfRefraction,this._isTintEnabled?(a.CLEARCOAT_TINT=!0,this._tintTexture&&$i.ClearCoatTintTextureEnabled?($a(this._tintTexture,a,"CLEARCOAT_TINT_TEXTURE"),a.CLEARCOAT_TINT_GAMMATEXTURE=this._tintTexture.gammaSpace):a.CLEARCOAT_TINT_TEXTURE=!1):(a.CLEARCOAT_TINT=!1,a.CLEARCOAT_TINT_TEXTURE=!1))):(a.CLEARCOAT=!1,a.CLEARCOAT_TEXTURE=!1,a.CLEARCOAT_TEXTURE_ROUGHNESS=!1,a.CLEARCOAT_BUMP=!1,a.CLEARCOAT_TINT=!1,a.CLEARCOAT_TINT_TEXTURE=!1,a.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,a.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL=!1,a.CLEARCOAT_DEFAULTIOR=!1,a.CLEARCOAT_TEXTUREDIRECTUV=0,a.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV=0,a.CLEARCOAT_BUMPDIRECTUV=0,a.CLEARCOAT_REMAP_F0=!1,a.CLEARCOAT_TINT_TEXTUREDIRECTUV=0,a.CLEARCOAT_TINT_GAMMATEXTURE=!1)}bindForSubMesh(a,x,c,u){if(!this._isEnabled)return;const g=u.materialDefines,y=this._material.isFrozen,v=this._material._disableBumpMap,w=this._material._invertNormalMapX,B=this._material._invertNormalMapY,W=g.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;if(!a.useUbo||!y||!a.isSync){W&&$i.ClearCoatTextureEnabled?(a.updateFloat4("vClearCoatInfos",this._texture.coordinatesIndex,this._texture.level,-1,-1),ba(this._texture,a,"clearCoat")):(this._texture||this._textureRoughness)&&$i.ClearCoatTextureEnabled&&(a.updateFloat4("vClearCoatInfos",this._texture?.coordinatesIndex??0,this._texture?.level??0,this._textureRoughness?.coordinatesIndex??0,this._textureRoughness?.level??0),this._texture&&ba(this._texture,a,"clearCoat"),this._textureRoughness&&!W&&!g.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE&&ba(this._textureRoughness,a,"clearCoatRoughness")),this._bumpTexture&&c.getCaps().standardDerivatives&&$i.ClearCoatTextureEnabled&&!v&&(a.updateFloat2("vClearCoatBumpInfos",this._bumpTexture.coordinatesIndex,this._bumpTexture.level),ba(this._bumpTexture,a,"clearCoatBump"),x._mirroredCameraPosition?a.updateFloat2("vClearCoatTangentSpaceParams",w?1:-1,B?1:-1):a.updateFloat2("vClearCoatTangentSpaceParams",w?-1:1,B?-1:1)),this._tintTexture&&$i.ClearCoatTintTextureEnabled&&(a.updateFloat2("vClearCoatTintInfos",this._tintTexture.coordinatesIndex,this._tintTexture.level),ba(this._tintTexture,a,"clearCoatTint")),a.updateFloat2("vClearCoatParams",this.intensity,this.roughness);const ae=1-this._indexOfRefraction,ue=1+this._indexOfRefraction,fe=Math.pow(-ae/ue,2),Re=1/this._indexOfRefraction;a.updateFloat4("vClearCoatRefractionParams",fe,Re,ae,ue),this._isTintEnabled&&(a.updateFloat4("vClearCoatTintParams",this.tintColor.r,this.tintColor.g,this.tintColor.b,Math.max(1e-5,this.tintThickness)),a.updateFloat("clearCoatColorAtDistance",Math.max(1e-5,this.tintColorAtDistance)))}x.texturesEnabled&&(this._texture&&$i.ClearCoatTextureEnabled&&a.setTexture("clearCoatSampler",this._texture),this._textureRoughness&&!W&&!g.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE&&$i.ClearCoatTextureEnabled&&a.setTexture("clearCoatRoughnessSampler",this._textureRoughness),this._bumpTexture&&c.getCaps().standardDerivatives&&$i.ClearCoatBumpTextureEnabled&&!v&&a.setTexture("clearCoatBumpSampler",this._bumpTexture),this._isTintEnabled&&this._tintTexture&&$i.ClearCoatTintTextureEnabled&&a.setTexture("clearCoatTintSampler",this._tintTexture))}hasTexture(a){return this._texture===a||this._textureRoughness===a||this._bumpTexture===a||this._tintTexture===a}getActiveTextures(a){this._texture&&a.push(this._texture),this._textureRoughness&&a.push(this._textureRoughness),this._bumpTexture&&a.push(this._bumpTexture),this._tintTexture&&a.push(this._tintTexture)}getAnimatables(a){this._texture&&this._texture.animations&&this._texture.animations.length>0&&a.push(this._texture),this._textureRoughness&&this._textureRoughness.animations&&this._textureRoughness.animations.length>0&&a.push(this._textureRoughness),this._bumpTexture&&this._bumpTexture.animations&&this._bumpTexture.animations.length>0&&a.push(this._bumpTexture),this._tintTexture&&this._tintTexture.animations&&this._tintTexture.animations.length>0&&a.push(this._tintTexture)}dispose(a){a&&(this._texture?.dispose(),this._textureRoughness?.dispose(),this._bumpTexture?.dispose(),this._tintTexture?.dispose())}getClassName(){return"PBRClearCoatConfiguration"}addFallbacks(a,x,c){return a.CLEARCOAT_BUMP&&x.addFallback(c++,"CLEARCOAT_BUMP"),a.CLEARCOAT_TINT&&x.addFallback(c++,"CLEARCOAT_TINT"),a.CLEARCOAT&&x.addFallback(c++,"CLEARCOAT"),c}getSamplers(a){a.push("clearCoatSampler","clearCoatRoughnessSampler","clearCoatBumpSampler","clearCoatTintSampler")}getUniforms(){return{ubo:[{name:"vClearCoatParams",size:2,type:"vec2"},{name:"vClearCoatRefractionParams",size:4,type:"vec4"},{name:"vClearCoatInfos",size:4,type:"vec4"},{name:"clearCoatMatrix",size:16,type:"mat4"},{name:"clearCoatRoughnessMatrix",size:16,type:"mat4"},{name:"vClearCoatBumpInfos",size:2,type:"vec2"},{name:"vClearCoatTangentSpaceParams",size:2,type:"vec2"},{name:"clearCoatBumpMatrix",size:16,type:"mat4"},{name:"vClearCoatTintParams",size:4,type:"vec4"},{name:"clearCoatColorAtDistance",size:1,type:"float"},{name:"vClearCoatTintInfos",size:2,type:"vec2"},{name:"clearCoatTintMatrix",size:16,type:"mat4"}]}}}xo._DefaultIndexOfRefraction=1.5,Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],xo.prototype,"isEnabled",void 0),Ye([ht()],xo.prototype,"intensity",void 0),Ye([ht()],xo.prototype,"roughness",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],xo.prototype,"indexOfRefraction",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],xo.prototype,"texture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],xo.prototype,"useRoughnessFromMainTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],xo.prototype,"textureRoughness",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],xo.prototype,"remapF0OnInterfaceChange",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],xo.prototype,"bumpTexture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],xo.prototype,"isTintEnabled",void 0),Ye([va()],xo.prototype,"tintColor",void 0),Ye([ht()],xo.prototype,"tintColorAtDistance",void 0),Ye([ht()],xo.prototype,"tintThickness",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],xo.prototype,"tintTexture",void 0);class VL extends Jc{constructor(){super(...arguments),this.IRIDESCENCE=!1,this.IRIDESCENCE_TEXTURE=!1,this.IRIDESCENCE_TEXTUREDIRECTUV=0,this.IRIDESCENCE_THICKNESS_TEXTURE=!1,this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV=0,this.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE=!1}}class ax extends jl{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(a,x=!0){super(a,"PBRIridescence",110,new VL,x),this._isEnabled=!1,this.isEnabled=!1,this.intensity=1,this.minimumThickness=ax._DefaultMinimumThickness,this.maximumThickness=ax._DefaultMaximumThickness,this.indexOfRefraction=ax._DefaultIndexOfRefraction,this._texture=null,this.texture=null,this._thicknessTexture=null,this.thicknessTexture=null,this._internalMarkAllSubMeshesAsTexturesDirty=a._dirtyCallbacks[1]}isReadyForSubMesh(a,x){return this._isEnabled?!(a._areTexturesDirty&&x.texturesEnabled&&(this._texture&&$i.IridescenceTextureEnabled&&!this._texture.isReadyOrNotBlocking()||this._thicknessTexture&&$i.IridescenceTextureEnabled&&!this._thicknessTexture.isReadyOrNotBlocking())):!0}prepareDefinesBeforeAttributes(a,x){this._isEnabled?(a.IRIDESCENCE=!0,a.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE=this._texture!==null&&this._texture._texture===this._thicknessTexture?._texture&&this._texture.checkTransformsAreIdentical(this._thicknessTexture),a._areTexturesDirty&&x.texturesEnabled&&(this._texture&&$i.IridescenceTextureEnabled?$a(this._texture,a,"IRIDESCENCE_TEXTURE"):a.IRIDESCENCE_TEXTURE=!1,!a.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE&&this._thicknessTexture&&$i.IridescenceTextureEnabled?$a(this._thicknessTexture,a,"IRIDESCENCE_THICKNESS_TEXTURE"):a.IRIDESCENCE_THICKNESS_TEXTURE=!1)):(a.IRIDESCENCE=!1,a.IRIDESCENCE_TEXTURE=!1,a.IRIDESCENCE_THICKNESS_TEXTURE=!1,a.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE=!1,a.IRIDESCENCE_TEXTUREDIRECTUV=0,a.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV=0)}bindForSubMesh(a,x,c,u){if(!this._isEnabled)return;const g=u.materialDefines,y=this._material.isFrozen,v=g.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE;(!a.useUbo||!y||!a.isSync)&&(v&&$i.IridescenceTextureEnabled?(a.updateFloat4("vIridescenceInfos",this._texture.coordinatesIndex,this._texture.level,-1,-1),ba(this._texture,a,"iridescence")):(this._texture||this._thicknessTexture)&&$i.IridescenceTextureEnabled&&(a.updateFloat4("vIridescenceInfos",this._texture?.coordinatesIndex??0,this._texture?.level??0,this._thicknessTexture?.coordinatesIndex??0,this._thicknessTexture?.level??0),this._texture&&ba(this._texture,a,"iridescence"),this._thicknessTexture&&!v&&!g.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE&&ba(this._thicknessTexture,a,"iridescenceThickness")),a.updateFloat4("vIridescenceParams",this.intensity,this.indexOfRefraction,this.minimumThickness,this.maximumThickness)),x.texturesEnabled&&(this._texture&&$i.IridescenceTextureEnabled&&a.setTexture("iridescenceSampler",this._texture),this._thicknessTexture&&!v&&!g.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE&&$i.IridescenceTextureEnabled&&a.setTexture("iridescenceThicknessSampler",this._thicknessTexture))}hasTexture(a){return this._texture===a||this._thicknessTexture===a}getActiveTextures(a){this._texture&&a.push(this._texture),this._thicknessTexture&&a.push(this._thicknessTexture)}getAnimatables(a){this._texture&&this._texture.animations&&this._texture.animations.length>0&&a.push(this._texture),this._thicknessTexture&&this._thicknessTexture.animations&&this._thicknessTexture.animations.length>0&&a.push(this._thicknessTexture)}dispose(a){a&&(this._texture?.dispose(),this._thicknessTexture?.dispose())}getClassName(){return"PBRIridescenceConfiguration"}addFallbacks(a,x,c){return a.IRIDESCENCE&&x.addFallback(c++,"IRIDESCENCE"),c}getSamplers(a){a.push("iridescenceSampler","iridescenceThicknessSampler")}getUniforms(){return{ubo:[{name:"vIridescenceParams",size:4,type:"vec4"},{name:"vIridescenceInfos",size:4,type:"vec4"},{name:"iridescenceMatrix",size:16,type:"mat4"},{name:"iridescenceThicknessMatrix",size:16,type:"mat4"}]}}}ax._DefaultMinimumThickness=100,ax._DefaultMaximumThickness=400,ax._DefaultIndexOfRefraction=1.3,Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],ax.prototype,"isEnabled",void 0),Ye([ht()],ax.prototype,"intensity",void 0),Ye([ht()],ax.prototype,"minimumThickness",void 0),Ye([ht()],ax.prototype,"maximumThickness",void 0),Ye([ht()],ax.prototype,"indexOfRefraction",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],ax.prototype,"texture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],ax.prototype,"thicknessTexture",void 0);class WL extends Jc{constructor(){super(...arguments),this.ANISOTROPIC=!1,this.ANISOTROPIC_TEXTURE=!1,this.ANISOTROPIC_TEXTUREDIRECTUV=0,this.ANISOTROPIC_LEGACY=!1,this.MAINUV1=!1}}class Xu extends jl{set angle(a){this.direction.x=Math.cos(a),this.direction.y=Math.sin(a)}get angle(){return Math.atan2(this.direction.y,this.direction.x)}_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}_markAllSubMeshesAsMiscDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsMiscDirty()}constructor(a,x=!0){super(a,"PBRAnisotropic",110,new WL,x),this._isEnabled=!1,this.isEnabled=!1,this.intensity=1,this.direction=new mr(1,0),this._texture=null,this.texture=null,this._legacy=!1,this.legacy=!1,this._internalMarkAllSubMeshesAsTexturesDirty=a._dirtyCallbacks[1],this._internalMarkAllSubMeshesAsMiscDirty=a._dirtyCallbacks[16]}isReadyForSubMesh(a,x){return this._isEnabled?!(a._areTexturesDirty&&x.texturesEnabled&&this._texture&&$i.AnisotropicTextureEnabled&&!this._texture.isReadyOrNotBlocking()):!0}prepareDefinesBeforeAttributes(a,x,c){this._isEnabled?(a.ANISOTROPIC=this._isEnabled,this._isEnabled&&!c.isVerticesDataPresent(Ve.TangentKind)&&(a._needUVs=!0,a.MAINUV1=!0),a._areTexturesDirty&&x.texturesEnabled&&(this._texture&&$i.AnisotropicTextureEnabled?$a(this._texture,a,"ANISOTROPIC_TEXTURE"):a.ANISOTROPIC_TEXTURE=!1),a._areMiscDirty&&(a.ANISOTROPIC_LEGACY=this._legacy)):(a.ANISOTROPIC=!1,a.ANISOTROPIC_TEXTURE=!1,a.ANISOTROPIC_TEXTUREDIRECTUV=0,a.ANISOTROPIC_LEGACY=!1)}bindForSubMesh(a,x){if(!this._isEnabled)return;const c=this._material.isFrozen;(!a.useUbo||!c||!a.isSync)&&(this._texture&&$i.AnisotropicTextureEnabled&&(a.updateFloat2("vAnisotropyInfos",this._texture.coordinatesIndex,this._texture.level),ba(this._texture,a,"anisotropy")),a.updateFloat3("vAnisotropy",this.direction.x,this.direction.y,this.intensity)),x.texturesEnabled&&this._texture&&$i.AnisotropicTextureEnabled&&a.setTexture("anisotropySampler",this._texture)}hasTexture(a){return this._texture===a}getActiveTextures(a){this._texture&&a.push(this._texture)}getAnimatables(a){this._texture&&this._texture.animations&&this._texture.animations.length>0&&a.push(this._texture)}dispose(a){a&&this._texture&&this._texture.dispose()}getClassName(){return"PBRAnisotropicConfiguration"}addFallbacks(a,x,c){return a.ANISOTROPIC&&x.addFallback(c++,"ANISOTROPIC"),c}getSamplers(a){a.push("anisotropySampler")}getUniforms(){return{ubo:[{name:"vAnisotropy",size:3,type:"vec3"},{name:"vAnisotropyInfos",size:2,type:"vec2"},{name:"anisotropyMatrix",size:16,type:"mat4"}]}}parse(a,x,c){super.parse(a,x,c),a.legacy===void 0&&(this.legacy=!0)}}Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],Xu.prototype,"isEnabled",void 0),Ye([ht()],Xu.prototype,"intensity",void 0),Ye([Vh()],Xu.prototype,"direction",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],Xu.prototype,"texture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsMiscDirty")],Xu.prototype,"legacy",void 0);class HL extends Jc{constructor(){super(...arguments),this.SHEEN=!1,this.SHEEN_TEXTURE=!1,this.SHEEN_GAMMATEXTURE=!1,this.SHEEN_TEXTURE_ROUGHNESS=!1,this.SHEEN_TEXTUREDIRECTUV=0,this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV=0,this.SHEEN_LINKWITHALBEDO=!1,this.SHEEN_ROUGHNESS=!1,this.SHEEN_ALBEDOSCALING=!1,this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL=!1}}class b2 extends jl{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(a,x=!0){super(a,"Sheen",120,new HL,x),this._isEnabled=!1,this.isEnabled=!1,this._linkSheenWithAlbedo=!1,this.linkSheenWithAlbedo=!1,this.intensity=1,this.color=Bs.White(),this._texture=null,this.texture=null,this._useRoughnessFromMainTexture=!0,this.useRoughnessFromMainTexture=!0,this._roughness=null,this.roughness=null,this._textureRoughness=null,this.textureRoughness=null,this._albedoScaling=!1,this.albedoScaling=!1,this._internalMarkAllSubMeshesAsTexturesDirty=a._dirtyCallbacks[1]}isReadyForSubMesh(a,x){return this._isEnabled?!(a._areTexturesDirty&&x.texturesEnabled&&(this._texture&&$i.SheenTextureEnabled&&!this._texture.isReadyOrNotBlocking()||this._textureRoughness&&$i.SheenTextureEnabled&&!this._textureRoughness.isReadyOrNotBlocking())):!0}prepareDefinesBeforeAttributes(a,x){this._isEnabled?(a.SHEEN=!0,a.SHEEN_LINKWITHALBEDO=this._linkSheenWithAlbedo,a.SHEEN_ROUGHNESS=this._roughness!==null,a.SHEEN_ALBEDOSCALING=this._albedoScaling,a.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE=this._useRoughnessFromMainTexture,a.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL=this._texture!==null&&this._texture._texture===this._textureRoughness?._texture&&this._texture.checkTransformsAreIdentical(this._textureRoughness),a._areTexturesDirty&&x.texturesEnabled&&(this._texture&&$i.SheenTextureEnabled?($a(this._texture,a,"SHEEN_TEXTURE"),a.SHEEN_GAMMATEXTURE=this._texture.gammaSpace):a.SHEEN_TEXTURE=!1,this._textureRoughness&&$i.SheenTextureEnabled?$a(this._textureRoughness,a,"SHEEN_TEXTURE_ROUGHNESS"):a.SHEEN_TEXTURE_ROUGHNESS=!1)):(a.SHEEN=!1,a.SHEEN_TEXTURE=!1,a.SHEEN_TEXTURE_ROUGHNESS=!1,a.SHEEN_LINKWITHALBEDO=!1,a.SHEEN_ROUGHNESS=!1,a.SHEEN_ALBEDOSCALING=!1,a.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE=!1,a.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL=!1,a.SHEEN_GAMMATEXTURE=!1,a.SHEEN_TEXTUREDIRECTUV=0,a.SHEEN_TEXTURE_ROUGHNESSDIRECTUV=0)}bindForSubMesh(a,x,c,u){if(!this._isEnabled)return;const g=u.materialDefines,y=this._material.isFrozen,v=g.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;(!a.useUbo||!y||!a.isSync)&&(v&&$i.SheenTextureEnabled?(a.updateFloat4("vSheenInfos",this._texture.coordinatesIndex,this._texture.level,-1,-1),ba(this._texture,a,"sheen")):(this._texture||this._textureRoughness)&&$i.SheenTextureEnabled&&(a.updateFloat4("vSheenInfos",this._texture?.coordinatesIndex??0,this._texture?.level??0,this._textureRoughness?.coordinatesIndex??0,this._textureRoughness?.level??0),this._texture&&ba(this._texture,a,"sheen"),this._textureRoughness&&!v&&!g.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE&&ba(this._textureRoughness,a,"sheenRoughness")),a.updateFloat4("vSheenColor",this.color.r,this.color.g,this.color.b,this.intensity),this._roughness!==null&&a.updateFloat("vSheenRoughness",this._roughness)),x.texturesEnabled&&(this._texture&&$i.SheenTextureEnabled&&a.setTexture("sheenSampler",this._texture),this._textureRoughness&&!v&&!g.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE&&$i.SheenTextureEnabled&&a.setTexture("sheenRoughnessSampler",this._textureRoughness))}hasTexture(a){return this._texture===a||this._textureRoughness===a}getActiveTextures(a){this._texture&&a.push(this._texture),this._textureRoughness&&a.push(this._textureRoughness)}getAnimatables(a){this._texture&&this._texture.animations&&this._texture.animations.length>0&&a.push(this._texture),this._textureRoughness&&this._textureRoughness.animations&&this._textureRoughness.animations.length>0&&a.push(this._textureRoughness)}dispose(a){a&&(this._texture?.dispose(),this._textureRoughness?.dispose())}getClassName(){return"PBRSheenConfiguration"}addFallbacks(a,x,c){return a.SHEEN&&x.addFallback(c++,"SHEEN"),c}getSamplers(a){a.push("sheenSampler","sheenRoughnessSampler")}getUniforms(){return{ubo:[{name:"vSheenColor",size:4,type:"vec4"},{name:"vSheenRoughness",size:1,type:"float"},{name:"vSheenInfos",size:4,type:"vec4"},{name:"sheenMatrix",size:16,type:"mat4"},{name:"sheenRoughnessMatrix",size:16,type:"mat4"}]}}}Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],b2.prototype,"isEnabled",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],b2.prototype,"linkSheenWithAlbedo",void 0),Ye([ht()],b2.prototype,"intensity",void 0),Ye([va()],b2.prototype,"color",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],b2.prototype,"texture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],b2.prototype,"useRoughnessFromMainTexture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],b2.prototype,"roughness",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],b2.prototype,"textureRoughness",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],b2.prototype,"albedoScaling",void 0);class XL extends Jc{constructor(){super(...arguments),this.SUBSURFACE=!1,this.SS_REFRACTION=!1,this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=!1,this.SS_TRANSLUCENCY=!1,this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=!1,this.SS_SCATTERING=!1,this.SS_DISPERSION=!1,this.SS_THICKNESSANDMASK_TEXTURE=!1,this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV=0,this.SS_HAS_THICKNESS=!1,this.SS_REFRACTIONINTENSITY_TEXTURE=!1,this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV=0,this.SS_TRANSLUCENCYINTENSITY_TEXTURE=!1,this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV=0,this.SS_REFRACTIONMAP_3D=!1,this.SS_REFRACTIONMAP_OPPOSITEZ=!1,this.SS_LODINREFRACTIONALPHA=!1,this.SS_GAMMAREFRACTION=!1,this.SS_RGBDREFRACTION=!1,this.SS_LINEARSPECULARREFRACTION=!1,this.SS_LINKREFRACTIONTOTRANSPARENCY=!1,this.SS_ALBEDOFORREFRACTIONTINT=!1,this.SS_ALBEDOFORTRANSLUCENCYTINT=!1,this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=!1,this.SS_USE_THICKNESS_AS_DEPTH=!1,this.SS_MASK_FROM_THICKNESS_TEXTURE=!1,this.SS_USE_GLTF_TEXTURES=!1}}class ma extends jl{get scatteringDiffusionProfile(){return this._scene.subSurfaceConfiguration?this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex]:null}set scatteringDiffusionProfile(a){this._scene.enableSubSurfaceForPrePass()&&a&&(this._scatteringDiffusionProfileIndex=this._scene.subSurfaceConfiguration.addDiffusionProfile(a))}get volumeIndexOfRefraction(){return this._volumeIndexOfRefraction>=1?this._volumeIndexOfRefraction:this._indexOfRefraction}set volumeIndexOfRefraction(a){a>=1?this._volumeIndexOfRefraction=a:this._volumeIndexOfRefraction=-1}_markAllSubMeshesAsTexturesDirty(){this._enable(this._isRefractionEnabled||this._isTranslucencyEnabled||this._isScatteringEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}_markScenePrePassDirty(){this._internalMarkAllSubMeshesAsTexturesDirty(),this._internalMarkScenePrePassDirty()}constructor(a,x=!0){super(a,"PBRSubSurface",130,new XL,x),this._isRefractionEnabled=!1,this.isRefractionEnabled=!1,this._isTranslucencyEnabled=!1,this.isTranslucencyEnabled=!1,this._isDispersionEnabled=!1,this.isDispersionEnabled=!1,this._isScatteringEnabled=!1,this.isScatteringEnabled=!1,this._scatteringDiffusionProfileIndex=0,this.refractionIntensity=1,this.translucencyIntensity=1,this.useAlbedoToTintRefraction=!1,this.useAlbedoToTintTranslucency=!1,this._thicknessTexture=null,this.thicknessTexture=null,this._refractionTexture=null,this.refractionTexture=null,this._indexOfRefraction=1.5,this.indexOfRefraction=1.5,this._volumeIndexOfRefraction=-1,this._invertRefractionY=!1,this.invertRefractionY=!1,this._linkRefractionWithTransparency=!1,this.linkRefractionWithTransparency=!1,this.minimumThickness=0,this.maximumThickness=1,this.useThicknessAsDepth=!1,this.tintColor=Bs.White(),this.tintColorAtDistance=1,this.dispersion=0,this.diffusionDistance=Bs.White(),this._useMaskFromThicknessTexture=!1,this.useMaskFromThicknessTexture=!1,this._refractionIntensityTexture=null,this.refractionIntensityTexture=null,this._translucencyIntensityTexture=null,this.translucencyIntensityTexture=null,this._useGltfStyleTextures=!1,this.useGltfStyleTextures=!1,this._scene=a.getScene(),this.registerForExtraEvents=!0,this._internalMarkAllSubMeshesAsTexturesDirty=a._dirtyCallbacks[1],this._internalMarkScenePrePassDirty=a._dirtyCallbacks[32]}isReadyForSubMesh(a,x){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled)return!0;if(a._areTexturesDirty&&x.texturesEnabled){if(this._thicknessTexture&&$i.ThicknessTextureEnabled&&!this._thicknessTexture.isReadyOrNotBlocking())return!1;const c=this._getRefractionTexture(x);if(c&&$i.RefractionTextureEnabled&&!c.isReadyOrNotBlocking())return!1}return!0}prepareDefinesBeforeAttributes(a,x){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled){a.SUBSURFACE=!1,a.SS_DISPERSION=!1,a.SS_TRANSLUCENCY=!1,a.SS_SCATTERING=!1,a.SS_REFRACTION=!1,a.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=!1,a.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=!1,a.SS_THICKNESSANDMASK_TEXTURE=!1,a.SS_THICKNESSANDMASK_TEXTUREDIRECTUV=0,a.SS_HAS_THICKNESS=!1,a.SS_REFRACTIONINTENSITY_TEXTURE=!1,a.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV=0,a.SS_TRANSLUCENCYINTENSITY_TEXTURE=!1,a.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV=0,a.SS_REFRACTIONMAP_3D=!1,a.SS_REFRACTIONMAP_OPPOSITEZ=!1,a.SS_LODINREFRACTIONALPHA=!1,a.SS_GAMMAREFRACTION=!1,a.SS_RGBDREFRACTION=!1,a.SS_LINEARSPECULARREFRACTION=!1,a.SS_LINKREFRACTIONTOTRANSPARENCY=!1,a.SS_ALBEDOFORREFRACTIONTINT=!1,a.SS_ALBEDOFORTRANSLUCENCYTINT=!1,a.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=!1,a.SS_USE_THICKNESS_AS_DEPTH=!1,a.SS_MASK_FROM_THICKNESS_TEXTURE=!1,a.SS_USE_GLTF_TEXTURES=!1;return}if(a._areTexturesDirty){a.SUBSURFACE=!0,a.SS_DISPERSION=this._isDispersionEnabled,a.SS_TRANSLUCENCY=this._isTranslucencyEnabled,a.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=!1,a.SS_SCATTERING=this._isScatteringEnabled,a.SS_THICKNESSANDMASK_TEXTURE=!1,a.SS_REFRACTIONINTENSITY_TEXTURE=!1,a.SS_TRANSLUCENCYINTENSITY_TEXTURE=!1,a.SS_HAS_THICKNESS=!1,a.SS_MASK_FROM_THICKNESS_TEXTURE=!1,a.SS_USE_GLTF_TEXTURES=!1,a.SS_REFRACTION=!1,a.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=!1,a.SS_REFRACTIONMAP_3D=!1,a.SS_GAMMAREFRACTION=!1,a.SS_RGBDREFRACTION=!1,a.SS_LINEARSPECULARREFRACTION=!1,a.SS_REFRACTIONMAP_OPPOSITEZ=!1,a.SS_LODINREFRACTIONALPHA=!1,a.SS_LINKREFRACTIONTOTRANSPARENCY=!1,a.SS_ALBEDOFORREFRACTIONTINT=!1,a.SS_ALBEDOFORTRANSLUCENCYTINT=!1,a.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=!1,a.SS_USE_THICKNESS_AS_DEPTH=!1;const c=!!this._thicknessTexture&&!!this._refractionIntensityTexture&&this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture)&&this._refractionIntensityTexture._texture===this._thicknessTexture._texture,u=!!this._thicknessTexture&&!!this._translucencyIntensityTexture&&this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture)&&this._translucencyIntensityTexture._texture===this._thicknessTexture._texture,g=(c||!this._refractionIntensityTexture)&&(u||!this._translucencyIntensityTexture);if(a._areTexturesDirty&&x.texturesEnabled&&(this._thicknessTexture&&$i.ThicknessTextureEnabled&&$a(this._thicknessTexture,a,"SS_THICKNESSANDMASK_TEXTURE"),this._refractionIntensityTexture&&$i.RefractionIntensityTextureEnabled&&!g&&$a(this._refractionIntensityTexture,a,"SS_REFRACTIONINTENSITY_TEXTURE"),this._translucencyIntensityTexture&&$i.TranslucencyIntensityTextureEnabled&&!g&&$a(this._translucencyIntensityTexture,a,"SS_TRANSLUCENCYINTENSITY_TEXTURE")),a.SS_HAS_THICKNESS=this.maximumThickness-this.minimumThickness!==0,a.SS_MASK_FROM_THICKNESS_TEXTURE=(this._useMaskFromThicknessTexture||!!this._refractionIntensityTexture||!!this._translucencyIntensityTexture)&&g,a.SS_USE_GLTF_TEXTURES=this._useGltfStyleTextures,a.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE=(this._useMaskFromThicknessTexture||!!this._refractionIntensityTexture)&&g,a.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE=(this._useMaskFromThicknessTexture||!!this._translucencyIntensityTexture)&&g,this._isRefractionEnabled&&x.texturesEnabled){const y=this._getRefractionTexture(x);y&&$i.RefractionTextureEnabled&&(a.SS_REFRACTION=!0,a.SS_REFRACTIONMAP_3D=y.isCube,a.SS_GAMMAREFRACTION=y.gammaSpace,a.SS_RGBDREFRACTION=y.isRGBD,a.SS_LINEARSPECULARREFRACTION=y.linearSpecularLOD,a.SS_REFRACTIONMAP_OPPOSITEZ=this._scene.useRightHandedSystem&&y.isCube?!y.invertZ:y.invertZ,a.SS_LODINREFRACTIONALPHA=y.lodLevelInAlpha,a.SS_LINKREFRACTIONTOTRANSPARENCY=this._linkRefractionWithTransparency,a.SS_ALBEDOFORREFRACTIONTINT=this.useAlbedoToTintRefraction,a.SS_USE_LOCAL_REFRACTIONMAP_CUBIC=y.isCube&&y.boundingBoxSize,a.SS_USE_THICKNESS_AS_DEPTH=this.useThicknessAsDepth)}this._isTranslucencyEnabled&&(a.SS_ALBEDOFORTRANSLUCENCYTINT=this.useAlbedoToTintTranslucency)}}hardBindForSubMesh(a,x,c,u){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled)return;u.getRenderingMesh().getWorldMatrix().decompose(Yt.Vector3[0]);const g=Math.max(Math.abs(Yt.Vector3[0].x),Math.abs(Yt.Vector3[0].y),Math.abs(Yt.Vector3[0].z));a.updateFloat2("vThicknessParam",this.minimumThickness*g,(this.maximumThickness-this.minimumThickness)*g)}bindForSubMesh(a,x,c,u){if(!this._isRefractionEnabled&&!this._isTranslucencyEnabled&&!this._isScatteringEnabled)return;const g=u.materialDefines,y=this._material.isFrozen,v=this._material.realTimeFiltering,w=g.LODBASEDMICROSFURACE,B=this._getRefractionTexture(x);if(!a.useUbo||!y||!a.isSync){if(this._thicknessTexture&&$i.ThicknessTextureEnabled&&(a.updateFloat2("vThicknessInfos",this._thicknessTexture.coordinatesIndex,this._thicknessTexture.level),ba(this._thicknessTexture,a,"thickness")),this._refractionIntensityTexture&&$i.RefractionIntensityTextureEnabled&&g.SS_REFRACTIONINTENSITY_TEXTURE&&(a.updateFloat2("vRefractionIntensityInfos",this._refractionIntensityTexture.coordinatesIndex,this._refractionIntensityTexture.level),ba(this._refractionIntensityTexture,a,"refractionIntensity")),this._translucencyIntensityTexture&&$i.TranslucencyIntensityTextureEnabled&&g.SS_TRANSLUCENCYINTENSITY_TEXTURE&&(a.updateFloat2("vTranslucencyIntensityInfos",this._translucencyIntensityTexture.coordinatesIndex,this._translucencyIntensityTexture.level),ba(this._translucencyIntensityTexture,a,"translucencyIntensity")),B&&$i.RefractionTextureEnabled){a.updateMatrix("refractionMatrix",B.getRefractionTextureMatrix());let W=1;B.isCube||B.depth&&(W=B.depth);const ae=B.getSize().width,ue=this.volumeIndexOfRefraction;if(a.updateFloat4("vRefractionInfos",B.level,1/ue,W,this._invertRefractionY?-1:1),a.updateFloat4("vRefractionMicrosurfaceInfos",ae,B.lodGenerationScale,B.lodGenerationOffset,1/this.indexOfRefraction),v&&a.updateFloat2("vRefractionFilteringInfo",ae,_n.Log2(ae)),B.boundingBoxSize){const fe=B;a.updateVector3("vRefractionPosition",fe.boundingBoxPosition),a.updateVector3("vRefractionSize",fe.boundingBoxSize)}}this._isScatteringEnabled&&a.updateFloat("scatteringDiffusionProfile",this._scatteringDiffusionProfileIndex),a.updateColor3("vDiffusionDistance",this.diffusionDistance),a.updateFloat4("vTintColor",this.tintColor.r,this.tintColor.g,this.tintColor.b,Math.max(1e-5,this.tintColorAtDistance)),a.updateFloat3("vSubSurfaceIntensity",this.refractionIntensity,this.translucencyIntensity,0),a.updateFloat("dispersion",this.dispersion)}x.texturesEnabled&&(this._thicknessTexture&&$i.ThicknessTextureEnabled&&a.setTexture("thicknessSampler",this._thicknessTexture),this._refractionIntensityTexture&&$i.RefractionIntensityTextureEnabled&&g.SS_REFRACTIONINTENSITY_TEXTURE&&a.setTexture("refractionIntensitySampler",this._refractionIntensityTexture),this._translucencyIntensityTexture&&$i.TranslucencyIntensityTextureEnabled&&g.SS_TRANSLUCENCYINTENSITY_TEXTURE&&a.setTexture("translucencyIntensitySampler",this._translucencyIntensityTexture),B&&$i.RefractionTextureEnabled&&(w?a.setTexture("refractionSampler",B):(a.setTexture("refractionSampler",B._lodTextureMid||B),a.setTexture("refractionSamplerLow",B._lodTextureLow||B),a.setTexture("refractionSamplerHigh",B._lodTextureHigh||B))))}_getRefractionTexture(a){return this._refractionTexture?this._refractionTexture:this._isRefractionEnabled?a.environmentTexture:null}get disableAlphaBlending(){return this._isRefractionEnabled&&this._linkRefractionWithTransparency}fillRenderTargetTextures(a){$i.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget&&a.push(this._refractionTexture)}hasTexture(a){return this._thicknessTexture===a||this._refractionTexture===a||this._refractionIntensityTexture===a||this._translucencyIntensityTexture===a}hasRenderTargetTextures(){return!!($i.RefractionTextureEnabled&&this._refractionTexture&&this._refractionTexture.isRenderTarget)}getActiveTextures(a){this._thicknessTexture&&a.push(this._thicknessTexture),this._refractionTexture&&a.push(this._refractionTexture)}getAnimatables(a){this._thicknessTexture&&this._thicknessTexture.animations&&this._thicknessTexture.animations.length>0&&a.push(this._thicknessTexture),this._refractionTexture&&this._refractionTexture.animations&&this._refractionTexture.animations.length>0&&a.push(this._refractionTexture)}dispose(a){a&&(this._thicknessTexture&&this._thicknessTexture.dispose(),this._refractionTexture&&this._refractionTexture.dispose())}getClassName(){return"PBRSubSurfaceConfiguration"}addFallbacks(a,x,c){return a.SS_SCATTERING&&x.addFallback(c++,"SS_SCATTERING"),a.SS_TRANSLUCENCY&&x.addFallback(c++,"SS_TRANSLUCENCY"),c}getSamplers(a){a.push("thicknessSampler","refractionIntensitySampler","translucencyIntensitySampler","refractionSampler","refractionSamplerLow","refractionSamplerHigh")}getUniforms(){return{ubo:[{name:"vRefractionMicrosurfaceInfos",size:4,type:"vec4"},{name:"vRefractionFilteringInfo",size:2,type:"vec2"},{name:"vTranslucencyIntensityInfos",size:2,type:"vec2"},{name:"vRefractionInfos",size:4,type:"vec4"},{name:"refractionMatrix",size:16,type:"mat4"},{name:"vThicknessInfos",size:2,type:"vec2"},{name:"vRefractionIntensityInfos",size:2,type:"vec2"},{name:"thicknessMatrix",size:16,type:"mat4"},{name:"refractionIntensityMatrix",size:16,type:"mat4"},{name:"translucencyIntensityMatrix",size:16,type:"mat4"},{name:"vThicknessParam",size:2,type:"vec2"},{name:"vDiffusionDistance",size:3,type:"vec3"},{name:"vTintColor",size:4,type:"vec4"},{name:"vSubSurfaceIntensity",size:3,type:"vec3"},{name:"vRefractionPosition",size:3,type:"vec3"},{name:"vRefractionSize",size:3,type:"vec3"},{name:"scatteringDiffusionProfile",size:1,type:"float"},{name:"dispersion",size:1,type:"float"}]}}}Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"isRefractionEnabled",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"isTranslucencyEnabled",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"isDispersionEnabled",void 0),Ye([ht(),Ji("_markScenePrePassDirty")],ma.prototype,"isScatteringEnabled",void 0),Ye([ht()],ma.prototype,"_scatteringDiffusionProfileIndex",void 0),Ye([ht()],ma.prototype,"refractionIntensity",void 0),Ye([ht()],ma.prototype,"translucencyIntensity",void 0),Ye([ht()],ma.prototype,"useAlbedoToTintRefraction",void 0),Ye([ht()],ma.prototype,"useAlbedoToTintTranslucency",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"thicknessTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"refractionTexture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"indexOfRefraction",void 0),Ye([ht()],ma.prototype,"_volumeIndexOfRefraction",void 0),Ye([Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"volumeIndexOfRefraction",null),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"invertRefractionY",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"linkRefractionWithTransparency",void 0),Ye([ht()],ma.prototype,"minimumThickness",void 0),Ye([ht()],ma.prototype,"maximumThickness",void 0),Ye([ht()],ma.prototype,"useThicknessAsDepth",void 0),Ye([va()],ma.prototype,"tintColor",void 0),Ye([ht()],ma.prototype,"tintColorAtDistance",void 0),Ye([ht()],ma.prototype,"dispersion",void 0),Ye([va()],ma.prototype,"diffusionDistance",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"useMaskFromThicknessTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"refractionIntensityTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"translucencyIntensityTexture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],ma.prototype,"useGltfStyleTextures",void 0);class jL extends Jc{constructor(){super(...arguments),this.DETAIL=!1,this.DETAILDIRECTUV=0,this.DETAIL_NORMALBLENDMETHOD=0}}class $h extends jl{_markAllSubMeshesAsTexturesDirty(){this._enable(this._isEnabled),this._internalMarkAllSubMeshesAsTexturesDirty()}constructor(a,x=!0){super(a,"DetailMap",140,new jL,x),this._texture=null,this.diffuseBlendLevel=1,this.roughnessBlendLevel=1,this.bumpLevel=1,this._normalBlendMethod=ui.MATERIAL_NORMALBLENDMETHOD_WHITEOUT,this._isEnabled=!1,this.isEnabled=!1,this._internalMarkAllSubMeshesAsTexturesDirty=a._dirtyCallbacks[1]}isReadyForSubMesh(a,x,c){return this._isEnabled?!(a._areTexturesDirty&&x.texturesEnabled&&c.getCaps().standardDerivatives&&this._texture&&$i.DetailTextureEnabled&&!this._texture.isReady()):!0}prepareDefines(a,x){if(this._isEnabled){a.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod;const c=x.getEngine();a._areTexturesDirty&&(c.getCaps().standardDerivatives&&this._texture&&$i.DetailTextureEnabled&&this._isEnabled?($a(this._texture,a,"DETAIL"),a.DETAIL_NORMALBLENDMETHOD=this._normalBlendMethod):a.DETAIL=!1)}else a.DETAIL=!1}bindForSubMesh(a,x){if(!this._isEnabled)return;const c=this._material.isFrozen;(!a.useUbo||!c||!a.isSync)&&this._texture&&$i.DetailTextureEnabled&&(a.updateFloat4("vDetailInfos",this._texture.coordinatesIndex,this.diffuseBlendLevel,this.bumpLevel,this.roughnessBlendLevel),ba(this._texture,a,"detail")),x.texturesEnabled&&this._texture&&$i.DetailTextureEnabled&&a.setTexture("detailSampler",this._texture)}hasTexture(a){return this._texture===a}getActiveTextures(a){this._texture&&a.push(this._texture)}getAnimatables(a){this._texture&&this._texture.animations&&this._texture.animations.length>0&&a.push(this._texture)}dispose(a){a&&this._texture?.dispose()}getClassName(){return"DetailMapConfiguration"}getSamplers(a){a.push("detailSampler")}getUniforms(){return{ubo:[{name:"vDetailInfos",size:4,type:"vec4"},{name:"detailMatrix",size:16,type:"mat4"}]}}}Ye([gn("detailTexture"),Ji("_markAllSubMeshesAsTexturesDirty")],$h.prototype,"texture",void 0),Ye([ht()],$h.prototype,"diffuseBlendLevel",void 0),Ye([ht()],$h.prototype,"roughnessBlendLevel",void 0),Ye([ht()],$h.prototype,"bumpLevel",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],$h.prototype,"normalBlendMethod",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],$h.prototype,"isEnabled",void 0);const ju={effect:null,subMesh:null};class bw extends Jc{constructor(a){super(a),this.PBR=!0,this.NUM_SAMPLES="0",this.REALTIME_FILTERING=!1,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.ALBEDO=!1,this.GAMMAALBEDO=!1,this.ALBEDODIRECTUV=0,this.VERTEXCOLOR=!1,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.AMBIENT=!1,this.AMBIENTDIRECTUV=0,this.AMBIENTINGRAYSCALE=!1,this.OPACITY=!1,this.VERTEXALPHA=!1,this.OPACITYDIRECTUV=0,this.OPACITYRGB=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHABLEND=!1,this.ALPHAFROMALBEDO=!1,this.ALPHATESTVALUE="0.5",this.SPECULAROVERALPHA=!1,this.RADIANCEOVERALPHA=!1,this.ALPHAFRESNEL=!1,this.LINEARALPHAFRESNEL=!1,this.PREMULTIPLYALPHA=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.GAMMAEMISSIVE=!1,this.REFLECTIVITY=!1,this.REFLECTIVITY_GAMMA=!1,this.REFLECTIVITYDIRECTUV=0,this.SPECULARTERM=!1,this.MICROSURFACEFROMREFLECTIVITYMAP=!1,this.MICROSURFACEAUTOMATIC=!1,this.LODBASEDMICROSFURACE=!1,this.MICROSURFACEMAP=!1,this.MICROSURFACEMAPDIRECTUV=0,this.METALLICWORKFLOW=!1,this.ROUGHNESSSTOREINMETALMAPALPHA=!1,this.ROUGHNESSSTOREINMETALMAPGREEN=!1,this.METALLNESSSTOREINMETALMAPBLUE=!1,this.AOSTOREINMETALMAPRED=!1,this.METALLIC_REFLECTANCE=!1,this.METALLIC_REFLECTANCE_GAMMA=!1,this.METALLIC_REFLECTANCEDIRECTUV=0,this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY=!1,this.REFLECTANCE=!1,this.REFLECTANCE_GAMMA=!1,this.REFLECTANCEDIRECTUV=0,this.ENVIRONMENTBRDF=!1,this.ENVIRONMENTBRDF_RGBD=!1,this.NORMAL=!1,this.TANGENT=!1,this.BUMP=!1,this.BUMPDIRECTUV=0,this.OBJECTSPACE_NORMALMAP=!1,this.PARALLAX=!1,this.PARALLAX_RHS=!1,this.PARALLAXOCCLUSION=!1,this.NORMALXYSCALE=!0,this.LIGHTMAP=!1,this.LIGHTMAPDIRECTUV=0,this.USELIGHTMAPASSHADOWMAP=!1,this.GAMMALIGHTMAP=!1,this.RGBDLIGHTMAP=!1,this.REFLECTION=!1,this.REFLECTIONMAP_3D=!1,this.REFLECTIONMAP_SPHERICAL=!1,this.REFLECTIONMAP_PLANAR=!1,this.REFLECTIONMAP_CUBIC=!1,this.USE_LOCAL_REFLECTIONMAP_CUBIC=!1,this.REFLECTIONMAP_PROJECTION=!1,this.REFLECTIONMAP_SKYBOX=!1,this.REFLECTIONMAP_EXPLICIT=!1,this.REFLECTIONMAP_EQUIRECTANGULAR=!1,this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,this.INVERTCUBICMAP=!1,this.USESPHERICALFROMREFLECTIONMAP=!1,this.USEIRRADIANCEMAP=!1,this.USESPHERICALINVERTEX=!1,this.REFLECTIONMAP_OPPOSITEZ=!1,this.LODINREFLECTIONALPHA=!1,this.GAMMAREFLECTION=!1,this.RGBDREFLECTION=!1,this.LINEARSPECULARREFLECTION=!1,this.RADIANCEOCCLUSION=!1,this.HORIZONOCCLUSION=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.INSTANCESCOLOR=!1,this.PREPASS=!1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_NORMAL_WORLDSPACE=!1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.NONUNIFORMSCALING=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_TEXTURE=!1,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=!1,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.DITHER=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.EXPOSURE=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.USEPHYSICALLIGHTFALLOFF=!1,this.USEGLTFLIGHTFALLOFF=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.POINTSIZE=!1,this.FOG=!1,this.LOGARITHMICDEPTH=!1,this.CAMERA_ORTHOGRAPHIC=!1,this.CAMERA_PERSPECTIVE=!1,this.FORCENORMALFORWARD=!1,this.SPECULARAA=!1,this.UNLIT=!1,this.DECAL_AFTER_DETAIL=!1,this.DEBUGMODE=0,this.rebuild()}reset(){super.reset(),this.ALPHATESTVALUE="0.5",this.PBR=!0,this.NORMALXYSCALE=!0}}class Xn extends yb{get realTimeFiltering(){return this._realTimeFiltering}set realTimeFiltering(a){this._realTimeFiltering=a,this.markAsDirty(1)}get realTimeFilteringQuality(){return this._realTimeFilteringQuality}set realTimeFilteringQuality(a){this._realTimeFilteringQuality=a,this.markAsDirty(1)}get canRenderToMRT(){return!0}_attachImageProcessingConfiguration(a){a!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),a?this._imageProcessingConfiguration=a:this._imageProcessingConfiguration=this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add(()=>{this._markAllSubMeshesAsImageProcessingDirty()})))}constructor(a,x){super(a,x),this._directIntensity=1,this._emissiveIntensity=1,this._environmentIntensity=1,this._specularIntensity=1,this._lightingInfos=new an(this._directIntensity,this._emissiveIntensity,this._environmentIntensity,this._specularIntensity),this._disableBumpMap=!1,this._albedoTexture=null,this._ambientTexture=null,this._ambientTextureStrength=1,this._ambientTextureImpactOnAnalyticalLights=Xn.DEFAULT_AO_ON_ANALYTICAL_LIGHTS,this._opacityTexture=null,this._reflectionTexture=null,this._emissiveTexture=null,this._reflectivityTexture=null,this._metallicTexture=null,this._metallic=null,this._roughness=null,this._metallicF0Factor=1,this._metallicReflectanceColor=Bs.White(),this._useOnlyMetallicFromMetallicReflectanceTexture=!1,this._metallicReflectanceTexture=null,this._reflectanceTexture=null,this._microSurfaceTexture=null,this._bumpTexture=null,this._lightmapTexture=null,this._ambientColor=new Bs(0,0,0),this._albedoColor=new Bs(1,1,1),this._reflectivityColor=new Bs(1,1,1),this._reflectionColor=new Bs(1,1,1),this._emissiveColor=new Bs(0,0,0),this._microSurface=.9,this._useLightmapAsShadowmap=!1,this._useHorizonOcclusion=!0,this._useRadianceOcclusion=!0,this._useAlphaFromAlbedoTexture=!1,this._useSpecularOverAlpha=!0,this._useMicroSurfaceFromReflectivityMapAlpha=!1,this._useRoughnessFromMetallicTextureAlpha=!0,this._useRoughnessFromMetallicTextureGreen=!1,this._useMetallnessFromMetallicTextureBlue=!1,this._useAmbientOcclusionFromMetallicTextureRed=!1,this._useAmbientInGrayScale=!1,this._useAutoMicroSurfaceFromReflectivityMap=!1,this._lightFalloff=Xn.LIGHTFALLOFF_PHYSICAL,this._useRadianceOverAlpha=!0,this._useObjectSpaceNormalMap=!1,this._useParallax=!1,this._useParallaxOcclusion=!1,this._parallaxScaleBias=.05,this._disableLighting=!1,this._maxSimultaneousLights=4,this._invertNormalMapX=!1,this._invertNormalMapY=!1,this._twoSidedLighting=!1,this._alphaCutOff=.4,this._forceAlphaTest=!1,this._useAlphaFresnel=!1,this._useLinearAlphaFresnel=!1,this._environmentBRDFTexture=null,this._forceIrradianceInFragment=!1,this._realTimeFiltering=!1,this._realTimeFilteringQuality=8,this._forceNormalForward=!1,this._enableSpecularAntiAliasing=!1,this._imageProcessingObserver=null,this._renderTargets=new lt(16),this._globalAmbientColor=new Bs(0,0,0),this._unlit=!1,this._applyDecalMapAfterDetailMap=!1,this._debugMode=0,this.debugMode=0,this.debugLimit=-1,this.debugFactor=1,this._cacheHasRenderTargetTextures=!1,this.brdf=new Eo(this),this.clearCoat=new xo(this),this.iridescence=new ax(this),this.anisotropy=new Xu(this),this.sheen=new b2(this),this.subSurface=new ma(this),this.detailMap=new $h(this),this._attachImageProcessingConfiguration(null),this.getRenderTargetTextures=()=>(this._renderTargets.reset(),$i.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget&&this._renderTargets.push(this._reflectionTexture),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets),this._environmentBRDFTexture=A_(this.getScene()),this.prePassConfiguration=new C_}get hasRenderTargetTextures(){return $i.ReflectionTextureEnabled&&this._reflectionTexture&&this._reflectionTexture.isRenderTarget?!0:this._cacheHasRenderTargetTextures}get isPrePassCapable(){return!this.disableDepthWrite}getClassName(){return"PBRBaseMaterial"}get _disableAlphaBlending(){return this._transparencyMode===Xn.PBRMATERIAL_OPAQUE||this._transparencyMode===Xn.PBRMATERIAL_ALPHATEST||this.subSurface?.disableAlphaBlending}needAlphaBlending(){return this._disableAlphaBlending?!1:this.alpha<1||this._opacityTexture!=null||this._shouldUseAlphaFromAlbedoTexture()}needAlphaTesting(){return this._forceAlphaTest?!0:this.subSurface?.disableAlphaBlending?!1:this._hasAlphaChannel()&&(this._transparencyMode==null||this._transparencyMode===Xn.PBRMATERIAL_ALPHATEST)}_shouldUseAlphaFromAlbedoTexture(){return this._albedoTexture!=null&&this._albedoTexture.hasAlpha&&this._useAlphaFromAlbedoTexture&&this._transparencyMode!==Xn.PBRMATERIAL_OPAQUE}_hasAlphaChannel(){return this._albedoTexture!=null&&this._albedoTexture.hasAlpha||this._opacityTexture!=null}getAlphaTestTexture(){return this._albedoTexture}isReadyForSubMesh(a,x,c){this._uniformBufferLayoutBuilt||this.buildUniformLayout();const u=x._drawWrapper;if(u.effect&&this.isFrozen&&u._wasPreviouslyReady&&u._wasPreviouslyUsingInstances===c)return!0;x.materialDefines||(this._callbackPluginEventGeneric(bo.GetDefineNames,this._eventInfo),x.materialDefines=new bw(this._eventInfo.defineNames));const g=x.materialDefines;if(this._isReadyForSubMesh(x))return!0;const y=this.getScene(),v=y.getEngine();if(g._areTexturesDirty&&(this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,y.texturesEnabled)){if(this._albedoTexture&&$i.DiffuseTextureEnabled&&!this._albedoTexture.isReadyOrNotBlocking()||this._ambientTexture&&$i.AmbientTextureEnabled&&!this._ambientTexture.isReadyOrNotBlocking()||this._opacityTexture&&$i.OpacityTextureEnabled&&!this._opacityTexture.isReadyOrNotBlocking())return!1;const ue=this._getReflectionTexture();if(ue&&$i.ReflectionTextureEnabled){if(!ue.isReadyOrNotBlocking())return!1;if(ue.irradianceTexture){if(!ue.irradianceTexture.isReadyOrNotBlocking())return!1}else if(!ue.sphericalPolynomial&&ue.getInternalTexture()?._sphericalPolynomialPromise)return!1}if(this._lightmapTexture&&$i.LightmapTextureEnabled&&!this._lightmapTexture.isReadyOrNotBlocking()||this._emissiveTexture&&$i.EmissiveTextureEnabled&&!this._emissiveTexture.isReadyOrNotBlocking())return!1;if($i.SpecularTextureEnabled){if(this._metallicTexture){if(!this._metallicTexture.isReadyOrNotBlocking())return!1}else if(this._reflectivityTexture&&!this._reflectivityTexture.isReadyOrNotBlocking())return!1;if(this._metallicReflectanceTexture&&!this._metallicReflectanceTexture.isReadyOrNotBlocking()||this._reflectanceTexture&&!this._reflectanceTexture.isReadyOrNotBlocking()||this._microSurfaceTexture&&!this._microSurfaceTexture.isReadyOrNotBlocking())return!1}if(v.getCaps().standardDerivatives&&this._bumpTexture&&$i.BumpTextureEnabled&&!this._disableBumpMap&&!this._bumpTexture.isReady()||this._environmentBRDFTexture&&$i.ReflectionTextureEnabled&&!this._environmentBRDFTexture.isReady())return!1}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=g,this._eventInfo.subMesh=x,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh||g._areImageProcessingDirty&&this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.isReady())return!1;!v.getCaps().standardDerivatives&&!a.isVerticesDataPresent(Ve.NormalKind)&&(a.createNormals(!0),Qt.Warn("PBRMaterial: Normals have been created for the mesh: "+a.name));const w=x.effect,B=g._areLightsDisposed;let W=this._prepareEffect(a,g,this.onCompiled,this.onError,c,null,x.getRenderingMesh().hasThinInstances),ae=!1;if(W)if(this._onEffectCreatedObservable&&(ju.effect=W,ju.subMesh=x,this._onEffectCreatedObservable.notifyObservers(ju)),this.allowShaderHotSwapping&&w&&!W.isReady()){if(W=w,g.markAsUnprocessed(),ae=this.isFrozen,B)return g._areLightsDisposed=!0,!1}else y.resetCachedMaterial(),x.setEffect(W,g,this._materialContext);return!x.effect||!x.effect.isReady()?!1:(g._renderId=y.getRenderId(),u._wasPreviouslyReady=!ae,u._wasPreviouslyUsingInstances=!!c,this._checkScenePerformancePriority(),!0)}isMetallicWorkflow(){return!!(this._metallic!=null||this._roughness!=null||this._metallicTexture)}_prepareEffect(a,x,c=null,u=null,g=null,y=null,v){if(this._prepareDefines(a,x,g,y,v),!x.isDirty)return null;x.markAsProcessed();const B=this.getScene().getEngine(),W=new m_;let ae=0;x.USESPHERICALINVERTEX&&W.addFallback(ae++,"USESPHERICALINVERTEX"),x.FOG&&W.addFallback(ae,"FOG"),x.SPECULARAA&&W.addFallback(ae,"SPECULARAA"),x.POINTSIZE&&W.addFallback(ae,"POINTSIZE"),x.LOGARITHMICDEPTH&&W.addFallback(ae,"LOGARITHMICDEPTH"),x.PARALLAX&&W.addFallback(ae,"PARALLAX"),x.PARALLAX_RHS&&W.addFallback(ae,"PARALLAX_RHS"),x.PARALLAXOCCLUSION&&W.addFallback(ae++,"PARALLAXOCCLUSION"),x.ENVIRONMENTBRDF&&W.addFallback(ae++,"ENVIRONMENTBRDF"),x.TANGENT&&W.addFallback(ae++,"TANGENT"),x.BUMP&&W.addFallback(ae++,"BUMP"),ae=mO(x,W,this._maxSimultaneousLights,ae++),x.SPECULARTERM&&W.addFallback(ae++,"SPECULARTERM"),x.USESPHERICALFROMREFLECTIONMAP&&W.addFallback(ae++,"USESPHERICALFROMREFLECTIONMAP"),x.USEIRRADIANCEMAP&&W.addFallback(ae++,"USEIRRADIANCEMAP"),x.LIGHTMAP&&W.addFallback(ae++,"LIGHTMAP"),x.NORMAL&&W.addFallback(ae++,"NORMAL"),x.AMBIENT&&W.addFallback(ae++,"AMBIENT"),x.EMISSIVE&&W.addFallback(ae++,"EMISSIVE"),x.VERTEXCOLOR&&W.addFallback(ae++,"VERTEXCOLOR"),x.MORPHTARGETS&&W.addFallback(ae++,"MORPHTARGETS"),x.MULTIVIEW&&W.addFallback(0,"MULTIVIEW");const ue=[Ve.PositionKind];x.NORMAL&&ue.push(Ve.NormalKind),x.TANGENT&&ue.push(Ve.TangentKind);for(let dt=1;dt<=6;++dt)x["UV"+dt]&&ue.push(`uv${dt===1?"":dt}`);x.VERTEXCOLOR&&ue.push(Ve.ColorKind),dO(ue,a,x,W),fO(ue,x),$T(ue,a,x),JT(ue,a,x);let fe="pbr";const Re=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","vAlbedoColor","vReflectivityColor","vMetallicReflectanceFactors","vEmissiveColor","visibility","vReflectionColor","vFogInfos","vFogColor","pointSize","vAlbedoInfos","vAmbientInfos","vOpacityInfos","vReflectionInfos","vReflectionPosition","vReflectionSize","vEmissiveInfos","vReflectivityInfos","vReflectionFilteringInfo","vMetallicReflectanceInfos","vReflectanceInfos","vMicroSurfaceSamplerInfos","vBumpInfos","vLightmapInfos","mBones","albedoMatrix","ambientMatrix","opacityMatrix","reflectionMatrix","emissiveMatrix","reflectivityMatrix","normalMatrix","microSurfaceSamplerMatrix","bumpMatrix","lightmapMatrix","metallicReflectanceMatrix","reflectanceMatrix","vLightingIntensity","logarithmicDepthConstant","vSphericalX","vSphericalY","vSphericalZ","vSphericalXX_ZZ","vSphericalYY_ZZ","vSphericalZZ","vSphericalXY","vSphericalYZ","vSphericalZX","vSphericalL00","vSphericalL1_1","vSphericalL10","vSphericalL11","vSphericalL2_2","vSphericalL2_1","vSphericalL20","vSphericalL21","vSphericalL22","vReflectionMicrosurfaceInfos","vTangentSpaceParams","boneTextureWidth","vDebugMode","morphTargetTextureInfo","morphTargetTextureIndices"],_e=["albedoSampler","reflectivitySampler","ambientSampler","emissiveSampler","bumpSampler","lightmapSampler","opacitySampler","reflectionSampler","reflectionSamplerLow","reflectionSamplerHigh","irradianceSampler","microSurfaceSampler","environmentBrdfSampler","boneSampler","metallicReflectanceSampler","reflectanceSampler","morphTargets","oitDepthSampler","oitFrontColorSampler"],Be=["Material","Scene","Mesh"],tt={maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:x.NUM_MORPH_INFLUENCERS};this._eventInfo.fallbacks=W,this._eventInfo.fallbackRank=ae,this._eventInfo.defines=x,this._eventInfo.uniforms=Re,this._eventInfo.attributes=ue,this._eventInfo.samplers=_e,this._eventInfo.uniformBuffersNames=Be,this._eventInfo.customCode=void 0,this._eventInfo.mesh=a,this._eventInfo.indexParameters=tt,this._callbackPluginEventGeneric(bo.PrepareEffect,this._eventInfo),C_.AddUniforms(Re),C_.AddSamplers(_e),dg(Re),un&&(un.PrepareUniforms(Re,x),un.PrepareSamplers(_e,x)),XO({uniformsNames:Re,uniformBuffersNames:Be,samplers:_e,defines:x,maxSimultaneousLights:this._maxSimultaneousLights});const $e={};this.customShaderNameResolve&&(fe=this.customShaderNameResolve(fe,Re,Be,_e,x,ue,$e));const Et=x.toString(),ft=B.createEffect(fe,{attributes:ue,uniformsNames:Re,uniformBuffersNames:Be,samplers:_e,defines:Et,fallbacks:W,onCompiled:c,onError:u,indexParameters:tt,processFinalCode:$e.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:x.PREPASS},B);return this._eventInfo.customCode=void 0,ft}_prepareDefines(a,x,c=null,u=null,g=!1){const y=this.getScene(),v=y.getEngine();yO(y,a,x,!0,this._maxSimultaneousLights,this._disableLighting),x._needNormals=!0,BO(y,x);const w=this.needAlphaBlendingForMesh(a)&&this.getScene().useOrderIndependentTransparency;if(VO(y,x,this.canRenderToMRT&&!w),UO(y,x,w),x.METALLICWORKFLOW=this.isMetallicWorkflow(),x._areTexturesDirty){x._needUVs=!1;for(let B=1;B<=6;++B)x["MAINUV"+B]=!1;if(y.texturesEnabled){x.ALBEDODIRECTUV=0,x.AMBIENTDIRECTUV=0,x.OPACITYDIRECTUV=0,x.EMISSIVEDIRECTUV=0,x.REFLECTIVITYDIRECTUV=0,x.MICROSURFACEMAPDIRECTUV=0,x.METALLIC_REFLECTANCEDIRECTUV=0,x.REFLECTANCEDIRECTUV=0,x.BUMPDIRECTUV=0,x.LIGHTMAPDIRECTUV=0,v.getCaps().textureLOD&&(x.LODBASEDMICROSFURACE=!0),this._albedoTexture&&$i.DiffuseTextureEnabled?($a(this._albedoTexture,x,"ALBEDO"),x.GAMMAALBEDO=this._albedoTexture.gammaSpace):x.ALBEDO=!1,this._ambientTexture&&$i.AmbientTextureEnabled?($a(this._ambientTexture,x,"AMBIENT"),x.AMBIENTINGRAYSCALE=this._useAmbientInGrayScale):x.AMBIENT=!1,this._opacityTexture&&$i.OpacityTextureEnabled?($a(this._opacityTexture,x,"OPACITY"),x.OPACITYRGB=this._opacityTexture.getAlphaFromRGB):x.OPACITY=!1;const B=this._getReflectionTexture();if(B&&$i.ReflectionTextureEnabled){switch(x.REFLECTION=!0,x.GAMMAREFLECTION=B.gammaSpace,x.RGBDREFLECTION=B.isRGBD,x.LODINREFLECTIONALPHA=B.lodLevelInAlpha,x.LINEARSPECULARREFLECTION=B.linearSpecularLOD,this.realTimeFiltering&&this.realTimeFilteringQuality>0?(x.NUM_SAMPLES=""+this.realTimeFilteringQuality,v._features.needTypeSuffixInShaderConstants&&(x.NUM_SAMPLES=x.NUM_SAMPLES+"u"),x.REALTIME_FILTERING=!0):x.REALTIME_FILTERING=!1,x.INVERTCUBICMAP=B.coordinatesMode===fi.INVCUBIC_MODE,x.REFLECTIONMAP_3D=B.isCube,x.REFLECTIONMAP_OPPOSITEZ=x.REFLECTIONMAP_3D&&this.getScene().useRightHandedSystem?!B.invertZ:B.invertZ,x.REFLECTIONMAP_CUBIC=!1,x.REFLECTIONMAP_EXPLICIT=!1,x.REFLECTIONMAP_PLANAR=!1,x.REFLECTIONMAP_PROJECTION=!1,x.REFLECTIONMAP_SKYBOX=!1,x.REFLECTIONMAP_SPHERICAL=!1,x.REFLECTIONMAP_EQUIRECTANGULAR=!1,x.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,x.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,B.coordinatesMode){case fi.EXPLICIT_MODE:x.REFLECTIONMAP_EXPLICIT=!0;break;case fi.PLANAR_MODE:x.REFLECTIONMAP_PLANAR=!0;break;case fi.PROJECTION_MODE:x.REFLECTIONMAP_PROJECTION=!0;break;case fi.SKYBOX_MODE:x.REFLECTIONMAP_SKYBOX=!0;break;case fi.SPHERICAL_MODE:x.REFLECTIONMAP_SPHERICAL=!0;break;case fi.EQUIRECTANGULAR_MODE:x.REFLECTIONMAP_EQUIRECTANGULAR=!0;break;case fi.FIXED_EQUIRECTANGULAR_MODE:x.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!0;break;case fi.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:x.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!0;break;case fi.CUBIC_MODE:case fi.INVCUBIC_MODE:default:x.REFLECTIONMAP_CUBIC=!0,x.USE_LOCAL_REFLECTIONMAP_CUBIC=!!B.boundingBoxSize;break}B.coordinatesMode!==fi.SKYBOX_MODE&&(B.irradianceTexture?(x.USEIRRADIANCEMAP=!0,x.USESPHERICALFROMREFLECTIONMAP=!1):B.isCube&&(x.USESPHERICALFROMREFLECTIONMAP=!0,x.USEIRRADIANCEMAP=!1,this._forceIrradianceInFragment||this.realTimeFiltering||this._twoSidedLighting||v.getCaps().maxVaryingVectors<=8?x.USESPHERICALINVERTEX=!1:x.USESPHERICALINVERTEX=!0))}else x.REFLECTION=!1,x.REFLECTIONMAP_3D=!1,x.REFLECTIONMAP_SPHERICAL=!1,x.REFLECTIONMAP_PLANAR=!1,x.REFLECTIONMAP_CUBIC=!1,x.USE_LOCAL_REFLECTIONMAP_CUBIC=!1,x.REFLECTIONMAP_PROJECTION=!1,x.REFLECTIONMAP_SKYBOX=!1,x.REFLECTIONMAP_EXPLICIT=!1,x.REFLECTIONMAP_EQUIRECTANGULAR=!1,x.REFLECTIONMAP_EQUIRECTANGULAR_FIXED=!1,x.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED=!1,x.INVERTCUBICMAP=!1,x.USESPHERICALFROMREFLECTIONMAP=!1,x.USEIRRADIANCEMAP=!1,x.USESPHERICALINVERTEX=!1,x.REFLECTIONMAP_OPPOSITEZ=!1,x.LODINREFLECTIONALPHA=!1,x.GAMMAREFLECTION=!1,x.RGBDREFLECTION=!1,x.LINEARSPECULARREFLECTION=!1;if(this._lightmapTexture&&$i.LightmapTextureEnabled?($a(this._lightmapTexture,x,"LIGHTMAP"),x.USELIGHTMAPASSHADOWMAP=this._useLightmapAsShadowmap,x.GAMMALIGHTMAP=this._lightmapTexture.gammaSpace,x.RGBDLIGHTMAP=this._lightmapTexture.isRGBD):x.LIGHTMAP=!1,this._emissiveTexture&&$i.EmissiveTextureEnabled?($a(this._emissiveTexture,x,"EMISSIVE"),x.GAMMAEMISSIVE=this._emissiveTexture.gammaSpace):x.EMISSIVE=!1,$i.SpecularTextureEnabled){if(this._metallicTexture?($a(this._metallicTexture,x,"REFLECTIVITY"),x.ROUGHNESSSTOREINMETALMAPALPHA=this._useRoughnessFromMetallicTextureAlpha,x.ROUGHNESSSTOREINMETALMAPGREEN=!this._useRoughnessFromMetallicTextureAlpha&&this._useRoughnessFromMetallicTextureGreen,x.METALLNESSSTOREINMETALMAPBLUE=this._useMetallnessFromMetallicTextureBlue,x.AOSTOREINMETALMAPRED=this._useAmbientOcclusionFromMetallicTextureRed,x.REFLECTIVITY_GAMMA=!1):this._reflectivityTexture?($a(this._reflectivityTexture,x,"REFLECTIVITY"),x.MICROSURFACEFROMREFLECTIVITYMAP=this._useMicroSurfaceFromReflectivityMapAlpha,x.MICROSURFACEAUTOMATIC=this._useAutoMicroSurfaceFromReflectivityMap,x.REFLECTIVITY_GAMMA=this._reflectivityTexture.gammaSpace):x.REFLECTIVITY=!1,this._metallicReflectanceTexture||this._reflectanceTexture){const W=this._metallicReflectanceTexture!==null&&this._metallicReflectanceTexture._texture===this._reflectanceTexture?._texture&&this._metallicReflectanceTexture.checkTransformsAreIdentical(this._reflectanceTexture);x.METALLIC_REFLECTANCE_USE_ALPHA_ONLY=this._useOnlyMetallicFromMetallicReflectanceTexture&&!W,this._metallicReflectanceTexture?($a(this._metallicReflectanceTexture,x,"METALLIC_REFLECTANCE"),x.METALLIC_REFLECTANCE_GAMMA=this._metallicReflectanceTexture.gammaSpace):x.METALLIC_REFLECTANCE=!1,this._reflectanceTexture&&!W&&(!this._metallicReflectanceTexture||this._metallicReflectanceTexture&&this._useOnlyMetallicFromMetallicReflectanceTexture)?($a(this._reflectanceTexture,x,"REFLECTANCE"),x.REFLECTANCE_GAMMA=this._reflectanceTexture.gammaSpace):x.REFLECTANCE=!1}else x.METALLIC_REFLECTANCE=!1,x.REFLECTANCE=!1;this._microSurfaceTexture?$a(this._microSurfaceTexture,x,"MICROSURFACEMAP"):x.MICROSURFACEMAP=!1}else x.REFLECTIVITY=!1,x.MICROSURFACEMAP=!1;v.getCaps().standardDerivatives&&this._bumpTexture&&$i.BumpTextureEnabled&&!this._disableBumpMap?($a(this._bumpTexture,x,"BUMP"),this._useParallax&&this._albedoTexture&&$i.DiffuseTextureEnabled?(x.PARALLAX=!0,x.PARALLAX_RHS=y.useRightHandedSystem,x.PARALLAXOCCLUSION=!!this._useParallaxOcclusion):x.PARALLAX=!1,x.OBJECTSPACE_NORMALMAP=this._useObjectSpaceNormalMap):(x.BUMP=!1,x.PARALLAX=!1,x.PARALLAX_RHS=!1,x.PARALLAXOCCLUSION=!1,x.OBJECTSPACE_NORMALMAP=!1),this._environmentBRDFTexture&&$i.ReflectionTextureEnabled?(x.ENVIRONMENTBRDF=!0,x.ENVIRONMENTBRDF_RGBD=this._environmentBRDFTexture.isRGBD):(x.ENVIRONMENTBRDF=!1,x.ENVIRONMENTBRDF_RGBD=!1),this._shouldUseAlphaFromAlbedoTexture()?x.ALPHAFROMALBEDO=!0:x.ALPHAFROMALBEDO=!1}x.SPECULAROVERALPHA=this._useSpecularOverAlpha,this._lightFalloff===Xn.LIGHTFALLOFF_STANDARD?(x.USEPHYSICALLIGHTFALLOFF=!1,x.USEGLTFLIGHTFALLOFF=!1):this._lightFalloff===Xn.LIGHTFALLOFF_GLTF?(x.USEPHYSICALLIGHTFALLOFF=!1,x.USEGLTFLIGHTFALLOFF=!0):(x.USEPHYSICALLIGHTFALLOFF=!0,x.USEGLTFLIGHTFALLOFF=!1),x.RADIANCEOVERALPHA=this._useRadianceOverAlpha,!this.backFaceCulling&&this._twoSidedLighting?x.TWOSIDEDLIGHTING=!0:x.TWOSIDEDLIGHTING=!1,x.SPECULARAA=v.getCaps().standardDerivatives&&this._enableSpecularAntiAliasing}(x._areTexturesDirty||x._areMiscDirty)&&(x.ALPHATESTVALUE=`${this._alphaCutOff}${this._alphaCutOff%1===0?".":""}`,x.PREMULTIPLYALPHA=this.alphaMode===7||this.alphaMode===8,x.ALPHABLEND=this.needAlphaBlendingForMesh(a),x.ALPHAFRESNEL=this._useAlphaFresnel||this._useLinearAlphaFresnel,x.LINEARALPHAFRESNEL=this._useLinearAlphaFresnel),x._areImageProcessingDirty&&this._imageProcessingConfiguration&&this._imageProcessingConfiguration.prepareDefines(x),x.FORCENORMALFORWARD=this._forceNormalForward,x.RADIANCEOCCLUSION=this._useRadianceOcclusion,x.HORIZONOCCLUSION=this._useHorizonOcclusion,x._areMiscDirty&&(_O(a,y,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this._shouldTurnAlphaTestOn(a)||this._forceAlphaTest,x,this._applyDecalMapAfterDetailMap),x.UNLIT=this._unlit||(this.pointsCloud||this.wireframe)&&!a.isVerticesDataPresent(Ve.NormalKind),x.DEBUGMODE=this._debugMode),EO(y,v,this,x,!!c,u,g),this._eventInfo.defines=x,this._eventInfo.mesh=a,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),MO(a,x,!0,!0,!0,this._transparencyMode!==Xn.PBRMATERIAL_OPAQUE),this._callbackPluginEventPrepareDefines(this._eventInfo)}forceCompilation(a,x,c){const u={clipPlane:!1,useInstances:!1,...c};this._uniformBufferLayoutBuilt||this.buildUniformLayout(),this._callbackPluginEventGeneric(bo.GetDefineNames,this._eventInfo);const g=new bw(this._eventInfo.defineNames),y=this._prepareEffect(a,g,void 0,void 0,u.useInstances,u.clipPlane,a.hasThinInstances);this._onEffectCreatedObservable&&(ju.effect=y,ju.subMesh=null,this._onEffectCreatedObservable.notifyObservers(ju)),y.isReady()?x&&x(this):y.onCompileObservable.add(()=>{x&&x(this)})}buildUniformLayout(){const a=this._uniformBuffer;a.addUniform("vAlbedoInfos",2),a.addUniform("vAmbientInfos",4),a.addUniform("vOpacityInfos",2),a.addUniform("vEmissiveInfos",2),a.addUniform("vLightmapInfos",2),a.addUniform("vReflectivityInfos",3),a.addUniform("vMicroSurfaceSamplerInfos",2),a.addUniform("vReflectionInfos",2),a.addUniform("vReflectionFilteringInfo",2),a.addUniform("vReflectionPosition",3),a.addUniform("vReflectionSize",3),a.addUniform("vBumpInfos",3),a.addUniform("albedoMatrix",16),a.addUniform("ambientMatrix",16),a.addUniform("opacityMatrix",16),a.addUniform("emissiveMatrix",16),a.addUniform("lightmapMatrix",16),a.addUniform("reflectivityMatrix",16),a.addUniform("microSurfaceSamplerMatrix",16),a.addUniform("bumpMatrix",16),a.addUniform("vTangentSpaceParams",2),a.addUniform("reflectionMatrix",16),a.addUniform("vReflectionColor",3),a.addUniform("vAlbedoColor",4),a.addUniform("vLightingIntensity",4),a.addUniform("vReflectionMicrosurfaceInfos",3),a.addUniform("pointSize",1),a.addUniform("vReflectivityColor",4),a.addUniform("vEmissiveColor",3),a.addUniform("vAmbientColor",3),a.addUniform("vDebugMode",2),a.addUniform("vMetallicReflectanceFactors",4),a.addUniform("vMetallicReflectanceInfos",2),a.addUniform("metallicReflectanceMatrix",16),a.addUniform("vReflectanceInfos",2),a.addUniform("reflectanceMatrix",16),a.addUniform("vSphericalL00",3),a.addUniform("vSphericalL1_1",3),a.addUniform("vSphericalL10",3),a.addUniform("vSphericalL11",3),a.addUniform("vSphericalL2_2",3),a.addUniform("vSphericalL2_1",3),a.addUniform("vSphericalL20",3),a.addUniform("vSphericalL21",3),a.addUniform("vSphericalL22",3),a.addUniform("vSphericalX",3),a.addUniform("vSphericalY",3),a.addUniform("vSphericalZ",3),a.addUniform("vSphericalXX_ZZ",3),a.addUniform("vSphericalYY_ZZ",3),a.addUniform("vSphericalZZ",3),a.addUniform("vSphericalXY",3),a.addUniform("vSphericalYZ",3),a.addUniform("vSphericalZX",3),super.buildUniformLayout()}bindForSubMesh(a,x,c){const u=this.getScene(),g=c.materialDefines;if(!g)return;const y=c.effect;if(!y)return;this._activeEffect=y,x.getMeshUniformBuffer().bindToEffect(y,"Mesh"),x.transferToEffect(a);const v=u.getEngine();this._uniformBuffer.bindToEffect(y,"Material"),this.prePassConfiguration.bindForSubMesh(this._activeEffect,u,x,a,this.isFrozen),this._eventInfo.subMesh=c,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),g.OBJECTSPACE_NORMALMAP&&(a.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const w=this._mustRebind(u,y,c,x.visibility);tb(x,this._activeEffect,this.prePassConfiguration);let B=null;const W=this._uniformBuffer;if(w){if(this.bindViewProjection(y),B=this._getReflectionTexture(),!W.useUbo||!this.isFrozen||!W.isSync||c._drawWrapper._forceRebindOnNextCall){if(u.texturesEnabled){if(this._albedoTexture&&$i.DiffuseTextureEnabled&&(W.updateFloat2("vAlbedoInfos",this._albedoTexture.coordinatesIndex,this._albedoTexture.level),ba(this._albedoTexture,W,"albedo")),this._ambientTexture&&$i.AmbientTextureEnabled&&(W.updateFloat4("vAmbientInfos",this._ambientTexture.coordinatesIndex,this._ambientTexture.level,this._ambientTextureStrength,this._ambientTextureImpactOnAnalyticalLights),ba(this._ambientTexture,W,"ambient")),this._opacityTexture&&$i.OpacityTextureEnabled&&(W.updateFloat2("vOpacityInfos",this._opacityTexture.coordinatesIndex,this._opacityTexture.level),ba(this._opacityTexture,W,"opacity")),B&&$i.ReflectionTextureEnabled){if(W.updateMatrix("reflectionMatrix",B.getReflectionTextureMatrix()),W.updateFloat2("vReflectionInfos",B.level,0),B.boundingBoxSize){const ae=B;W.updateVector3("vReflectionPosition",ae.boundingBoxPosition),W.updateVector3("vReflectionSize",ae.boundingBoxSize)}if(this.realTimeFiltering){const ae=B.getSize().width;W.updateFloat2("vReflectionFilteringInfo",ae,_n.Log2(ae))}if(!g.USEIRRADIANCEMAP){const ae=B.sphericalPolynomial;if(g.USESPHERICALFROMREFLECTIONMAP&&ae)if(g.SPHERICAL_HARMONICS){const ue=ae.preScaledHarmonics;W.updateVector3("vSphericalL00",ue.l00),W.updateVector3("vSphericalL1_1",ue.l1_1),W.updateVector3("vSphericalL10",ue.l10),W.updateVector3("vSphericalL11",ue.l11),W.updateVector3("vSphericalL2_2",ue.l2_2),W.updateVector3("vSphericalL2_1",ue.l2_1),W.updateVector3("vSphericalL20",ue.l20),W.updateVector3("vSphericalL21",ue.l21),W.updateVector3("vSphericalL22",ue.l22)}else W.updateFloat3("vSphericalX",ae.x.x,ae.x.y,ae.x.z),W.updateFloat3("vSphericalY",ae.y.x,ae.y.y,ae.y.z),W.updateFloat3("vSphericalZ",ae.z.x,ae.z.y,ae.z.z),W.updateFloat3("vSphericalXX_ZZ",ae.xx.x-ae.zz.x,ae.xx.y-ae.zz.y,ae.xx.z-ae.zz.z),W.updateFloat3("vSphericalYY_ZZ",ae.yy.x-ae.zz.x,ae.yy.y-ae.zz.y,ae.yy.z-ae.zz.z),W.updateFloat3("vSphericalZZ",ae.zz.x,ae.zz.y,ae.zz.z),W.updateFloat3("vSphericalXY",ae.xy.x,ae.xy.y,ae.xy.z),W.updateFloat3("vSphericalYZ",ae.yz.x,ae.yz.y,ae.yz.z),W.updateFloat3("vSphericalZX",ae.zx.x,ae.zx.y,ae.zx.z)}W.updateFloat3("vReflectionMicrosurfaceInfos",B.getSize().width,B.lodGenerationScale,B.lodGenerationOffset)}this._emissiveTexture&&$i.EmissiveTextureEnabled&&(W.updateFloat2("vEmissiveInfos",this._emissiveTexture.coordinatesIndex,this._emissiveTexture.level),ba(this._emissiveTexture,W,"emissive")),this._lightmapTexture&&$i.LightmapTextureEnabled&&(W.updateFloat2("vLightmapInfos",this._lightmapTexture.coordinatesIndex,this._lightmapTexture.level),ba(this._lightmapTexture,W,"lightmap")),$i.SpecularTextureEnabled&&(this._metallicTexture?(W.updateFloat3("vReflectivityInfos",this._metallicTexture.coordinatesIndex,this._metallicTexture.level,this._ambientTextureStrength),ba(this._metallicTexture,W,"reflectivity")):this._reflectivityTexture&&(W.updateFloat3("vReflectivityInfos",this._reflectivityTexture.coordinatesIndex,this._reflectivityTexture.level,1),ba(this._reflectivityTexture,W,"reflectivity")),this._metallicReflectanceTexture&&(W.updateFloat2("vMetallicReflectanceInfos",this._metallicReflectanceTexture.coordinatesIndex,this._metallicReflectanceTexture.level),ba(this._metallicReflectanceTexture,W,"metallicReflectance")),this._reflectanceTexture&&g.REFLECTANCE&&(W.updateFloat2("vReflectanceInfos",this._reflectanceTexture.coordinatesIndex,this._reflectanceTexture.level),ba(this._reflectanceTexture,W,"reflectance")),this._microSurfaceTexture&&(W.updateFloat2("vMicroSurfaceSamplerInfos",this._microSurfaceTexture.coordinatesIndex,this._microSurfaceTexture.level),ba(this._microSurfaceTexture,W,"microSurfaceSampler"))),this._bumpTexture&&v.getCaps().standardDerivatives&&$i.BumpTextureEnabled&&!this._disableBumpMap&&(W.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,this._bumpTexture.level,this._parallaxScaleBias),ba(this._bumpTexture,W,"bump"),u._mirroredCameraPosition?W.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):W.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1))}if(this.pointsCloud&&W.updateFloat("pointSize",this.pointSize),g.METALLICWORKFLOW){Rl.Color3[0].r=this._metallic===void 0||this._metallic===null?1:this._metallic,Rl.Color3[0].g=this._roughness===void 0||this._roughness===null?1:this._roughness,W.updateColor4("vReflectivityColor",Rl.Color3[0],1);const ae=this.subSurface?._indexOfRefraction??1.5,ue=1,fe=Math.pow((ae-ue)/(ae+ue),2);this._metallicReflectanceColor.scaleToRef(fe*this._metallicF0Factor,Rl.Color3[0]);const Re=this._metallicF0Factor;W.updateColor4("vMetallicReflectanceFactors",Rl.Color3[0],Re)}else W.updateColor4("vReflectivityColor",this._reflectivityColor,this._microSurface);W.updateColor3("vEmissiveColor",$i.EmissiveTextureEnabled?this._emissiveColor:Bs.BlackReadOnly),W.updateColor3("vReflectionColor",this._reflectionColor),!g.SS_REFRACTION&&this.subSurface?._linkRefractionWithTransparency?W.updateColor4("vAlbedoColor",this._albedoColor,1):W.updateColor4("vAlbedoColor",this._albedoColor,this.alpha),this._lightingInfos.x=this._directIntensity,this._lightingInfos.y=this._emissiveIntensity,this._lightingInfos.z=this._environmentIntensity*u.environmentIntensity,this._lightingInfos.w=this._specularIntensity,W.updateVector4("vLightingIntensity",this._lightingInfos),u.ambientColor.multiplyToRef(this._ambientColor,this._globalAmbientColor),W.updateColor3("vAmbientColor",this._globalAmbientColor),W.updateFloat2("vDebugMode",this.debugLimit,this.debugFactor)}u.texturesEnabled&&(this._albedoTexture&&$i.DiffuseTextureEnabled&&W.setTexture("albedoSampler",this._albedoTexture),this._ambientTexture&&$i.AmbientTextureEnabled&&W.setTexture("ambientSampler",this._ambientTexture),this._opacityTexture&&$i.OpacityTextureEnabled&&W.setTexture("opacitySampler",this._opacityTexture),B&&$i.ReflectionTextureEnabled&&(g.LODBASEDMICROSFURACE?W.setTexture("reflectionSampler",B):(W.setTexture("reflectionSampler",B._lodTextureMid||B),W.setTexture("reflectionSamplerLow",B._lodTextureLow||B),W.setTexture("reflectionSamplerHigh",B._lodTextureHigh||B)),g.USEIRRADIANCEMAP&&W.setTexture("irradianceSampler",B.irradianceTexture)),g.ENVIRONMENTBRDF&&W.setTexture("environmentBrdfSampler",this._environmentBRDFTexture),this._emissiveTexture&&$i.EmissiveTextureEnabled&&W.setTexture("emissiveSampler",this._emissiveTexture),this._lightmapTexture&&$i.LightmapTextureEnabled&&W.setTexture("lightmapSampler",this._lightmapTexture),$i.SpecularTextureEnabled&&(this._metallicTexture?W.setTexture("reflectivitySampler",this._metallicTexture):this._reflectivityTexture&&W.setTexture("reflectivitySampler",this._reflectivityTexture),this._metallicReflectanceTexture&&W.setTexture("metallicReflectanceSampler",this._metallicReflectanceTexture),this._reflectanceTexture&&g.REFLECTANCE&&W.setTexture("reflectanceSampler",this._reflectanceTexture),this._microSurfaceTexture&&W.setTexture("microSurfaceSampler",this._microSurfaceTexture)),this._bumpTexture&&v.getCaps().standardDerivatives&&$i.BumpTextureEnabled&&!this._disableBumpMap&&W.setTexture("bumpSampler",this._bumpTexture)),this.getScene().useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(x)&&this.getScene().depthPeelingRenderer.bind(y),this._eventInfo.subMesh=c,this._callbackPluginEventBindForSubMesh(this._eventInfo),fg(this._activeEffect,this,u),this.bindEyePosition(y)}else u.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);(w||!this.isFrozen)&&(u.lightsEnabled&&!this._disableLighting&&uO(u,x,this._activeEffect,g,this._maxSimultaneousLights),(u.fogEnabled&&x.applyFog&&u.fogMode!==H0.FOGMODE_NONE||B||this.subSurface.refractionTexture||x.receiveShadows||g.PREPASS)&&this.bindView(y),jT(u,x,this._activeEffect,!0),g.NUM_MORPH_INFLUENCERS&&gg(x,this._activeEffect),g.BAKED_VERTEX_ANIMATION_TEXTURE&&x.bakedVertexAnimationManager?.bind(y,g.INSTANCES),this._imageProcessingConfiguration.bind(this._activeEffect),XT(g,this._activeEffect,u)),this._afterBind(x,this._activeEffect,c),W.update()}getAnimatables(){const a=super.getAnimatables();return this._albedoTexture&&this._albedoTexture.animations&&this._albedoTexture.animations.length>0&&a.push(this._albedoTexture),this._ambientTexture&&this._ambientTexture.animations&&this._ambientTexture.animations.length>0&&a.push(this._ambientTexture),this._opacityTexture&&this._opacityTexture.animations&&this._opacityTexture.animations.length>0&&a.push(this._opacityTexture),this._reflectionTexture&&this._reflectionTexture.animations&&this._reflectionTexture.animations.length>0&&a.push(this._reflectionTexture),this._emissiveTexture&&this._emissiveTexture.animations&&this._emissiveTexture.animations.length>0&&a.push(this._emissiveTexture),this._metallicTexture&&this._metallicTexture.animations&&this._metallicTexture.animations.length>0?a.push(this._metallicTexture):this._reflectivityTexture&&this._reflectivityTexture.animations&&this._reflectivityTexture.animations.length>0&&a.push(this._reflectivityTexture),this._bumpTexture&&this._bumpTexture.animations&&this._bumpTexture.animations.length>0&&a.push(this._bumpTexture),this._lightmapTexture&&this._lightmapTexture.animations&&this._lightmapTexture.animations.length>0&&a.push(this._lightmapTexture),this._metallicReflectanceTexture&&this._metallicReflectanceTexture.animations&&this._metallicReflectanceTexture.animations.length>0&&a.push(this._metallicReflectanceTexture),this._reflectanceTexture&&this._reflectanceTexture.animations&&this._reflectanceTexture.animations.length>0&&a.push(this._reflectanceTexture),this._microSurfaceTexture&&this._microSurfaceTexture.animations&&this._microSurfaceTexture.animations.length>0&&a.push(this._microSurfaceTexture),a}_getReflectionTexture(){return this._reflectionTexture?this._reflectionTexture:this.getScene().environmentTexture}getActiveTextures(){const a=super.getActiveTextures();return this._albedoTexture&&a.push(this._albedoTexture),this._ambientTexture&&a.push(this._ambientTexture),this._opacityTexture&&a.push(this._opacityTexture),this._reflectionTexture&&a.push(this._reflectionTexture),this._emissiveTexture&&a.push(this._emissiveTexture),this._reflectivityTexture&&a.push(this._reflectivityTexture),this._metallicTexture&&a.push(this._metallicTexture),this._metallicReflectanceTexture&&a.push(this._metallicReflectanceTexture),this._reflectanceTexture&&a.push(this._reflectanceTexture),this._microSurfaceTexture&&a.push(this._microSurfaceTexture),this._bumpTexture&&a.push(this._bumpTexture),this._lightmapTexture&&a.push(this._lightmapTexture),a}hasTexture(a){return!!(super.hasTexture(a)||this._albedoTexture===a||this._ambientTexture===a||this._opacityTexture===a||this._reflectionTexture===a||this._emissiveTexture===a||this._reflectivityTexture===a||this._metallicTexture===a||this._metallicReflectanceTexture===a||this._reflectanceTexture===a||this._microSurfaceTexture===a||this._bumpTexture===a||this._lightmapTexture===a)}setPrePassRenderer(){if(!this.subSurface?.isScatteringEnabled)return!1;const a=this.getScene().enableSubSurfaceForPrePass();return a&&(a.enabled=!0),!0}dispose(a,x){x&&(this._environmentBRDFTexture&&this.getScene().environmentBRDFTexture!==this._environmentBRDFTexture&&this._environmentBRDFTexture.dispose(),this._albedoTexture?.dispose(),this._ambientTexture?.dispose(),this._opacityTexture?.dispose(),this._reflectionTexture?.dispose(),this._emissiveTexture?.dispose(),this._metallicTexture?.dispose(),this._reflectivityTexture?.dispose(),this._bumpTexture?.dispose(),this._lightmapTexture?.dispose(),this._metallicReflectanceTexture?.dispose(),this._reflectanceTexture?.dispose(),this._microSurfaceTexture?.dispose()),this._renderTargets.dispose(),this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(a,x)}}Xn.PBRMATERIAL_OPAQUE=ui.MATERIAL_OPAQUE,Xn.PBRMATERIAL_ALPHATEST=ui.MATERIAL_ALPHATEST,Xn.PBRMATERIAL_ALPHABLEND=ui.MATERIAL_ALPHABLEND,Xn.PBRMATERIAL_ALPHATESTANDBLEND=ui.MATERIAL_ALPHATESTANDBLEND,Xn.DEFAULT_AO_ON_ANALYTICAL_LIGHTS=0,Xn.LIGHTFALLOFF_PHYSICAL=0,Xn.LIGHTFALLOFF_GLTF=1,Xn.LIGHTFALLOFF_STANDARD=2,Ye([_P()],Xn.prototype,"_imageProcessingConfiguration",void 0),Ye([Ji("_markAllSubMeshesAsMiscDirty")],Xn.prototype,"debugMode",void 0);class fs extends Xn{get refractionTexture(){return this.subSurface.refractionTexture}set refractionTexture(a){this.subSurface.refractionTexture=a,a?this.subSurface.isRefractionEnabled=!0:this.subSurface.linkRefractionWithTransparency||(this.subSurface.isRefractionEnabled=!1)}get indexOfRefraction(){return this.subSurface.indexOfRefraction}set indexOfRefraction(a){this.subSurface.indexOfRefraction=a}get invertRefractionY(){return this.subSurface.invertRefractionY}set invertRefractionY(a){this.subSurface.invertRefractionY=a}get linkRefractionWithTransparency(){return this.subSurface.linkRefractionWithTransparency}set linkRefractionWithTransparency(a){this.subSurface.linkRefractionWithTransparency=a,a&&(this.subSurface.isRefractionEnabled=!0)}get usePhysicalLightFalloff(){return this._lightFalloff===Xn.LIGHTFALLOFF_PHYSICAL}set usePhysicalLightFalloff(a){a!==this.usePhysicalLightFalloff&&(this._markAllSubMeshesAsTexturesDirty(),a?this._lightFalloff=Xn.LIGHTFALLOFF_PHYSICAL:this._lightFalloff=Xn.LIGHTFALLOFF_STANDARD)}get useGLTFLightFalloff(){return this._lightFalloff===Xn.LIGHTFALLOFF_GLTF}set useGLTFLightFalloff(a){a!==this.useGLTFLightFalloff&&(this._markAllSubMeshesAsTexturesDirty(),a?this._lightFalloff=Xn.LIGHTFALLOFF_GLTF:this._lightFalloff=Xn.LIGHTFALLOFF_STANDARD)}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(a){this._attachImageProcessingConfiguration(a),this._markAllSubMeshesAsTexturesDirty()}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(a){this.imageProcessingConfiguration.colorCurvesEnabled=a}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(a){this.imageProcessingConfiguration.colorGradingEnabled=a}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(a){this._imageProcessingConfiguration.toneMappingEnabled=a}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(a){this._imageProcessingConfiguration.exposure=a}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(a){this._imageProcessingConfiguration.contrast=a}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(a){this._imageProcessingConfiguration.colorGradingTexture=a}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(a){this._imageProcessingConfiguration.colorCurves=a}constructor(a,x){super(a,x),this.directIntensity=1,this.emissiveIntensity=1,this.environmentIntensity=1,this.specularIntensity=1,this.disableBumpMap=!1,this.ambientTextureStrength=1,this.ambientTextureImpactOnAnalyticalLights=fs.DEFAULT_AO_ON_ANALYTICAL_LIGHTS,this.metallicF0Factor=1,this.metallicReflectanceColor=Bs.White(),this.useOnlyMetallicFromMetallicReflectanceTexture=!1,this.ambientColor=new Bs(0,0,0),this.albedoColor=new Bs(1,1,1),this.reflectivityColor=new Bs(1,1,1),this.reflectionColor=new Bs(1,1,1),this.emissiveColor=new Bs(0,0,0),this.microSurface=1,this.useLightmapAsShadowmap=!1,this.useAlphaFromAlbedoTexture=!1,this.forceAlphaTest=!1,this.alphaCutOff=.4,this.useSpecularOverAlpha=!0,this.useMicroSurfaceFromReflectivityMapAlpha=!1,this.useRoughnessFromMetallicTextureAlpha=!0,this.useRoughnessFromMetallicTextureGreen=!1,this.useMetallnessFromMetallicTextureBlue=!1,this.useAmbientOcclusionFromMetallicTextureRed=!1,this.useAmbientInGrayScale=!1,this.useAutoMicroSurfaceFromReflectivityMap=!1,this.useRadianceOverAlpha=!0,this.useObjectSpaceNormalMap=!1,this.useParallax=!1,this.useParallaxOcclusion=!1,this.parallaxScaleBias=.05,this.disableLighting=!1,this.forceIrradianceInFragment=!1,this.maxSimultaneousLights=4,this.invertNormalMapX=!1,this.invertNormalMapY=!1,this.twoSidedLighting=!1,this.useAlphaFresnel=!1,this.useLinearAlphaFresnel=!1,this.environmentBRDFTexture=null,this.forceNormalForward=!1,this.enableSpecularAntiAliasing=!1,this.useHorizonOcclusion=!0,this.useRadianceOcclusion=!0,this.unlit=!1,this.applyDecalMapAfterDetailMap=!1,this._environmentBRDFTexture=A_(this.getScene())}getClassName(){return"PBRMaterial"}clone(a,x=!0,c=""){const u=hr.Clone(()=>new fs(a,this.getScene()),this,{cloneTexturesOnlyOnce:x});return u.id=a,u.name=a,this.stencil.copyTo(u.stencil),this._clonePlugins(u,c),u}serialize(){const a=super.serialize();return a.customType="BABYLON.PBRMaterial",a}static Parse(a,x,c){const u=hr.Parse(()=>new fs(a.name,x),a,x,c);return a.stencil&&u.stencil.parse(a.stencil,x,c),ui._ParsePlugins(a,u,x,c),a.clearCoat&&u.clearCoat.parse(a.clearCoat,x,c),a.anisotropy&&u.anisotropy.parse(a.anisotropy,x,c),a.brdf&&u.brdf.parse(a.brdf,x,c),a.sheen&&u.sheen.parse(a.sheen,x,c),a.subSurface&&u.subSurface.parse(a.subSurface,x,c),a.iridescence&&u.iridescence.parse(a.iridescence,x,c),u}}fs.PBRMATERIAL_OPAQUE=Xn.PBRMATERIAL_OPAQUE,fs.PBRMATERIAL_ALPHATEST=Xn.PBRMATERIAL_ALPHATEST,fs.PBRMATERIAL_ALPHABLEND=Xn.PBRMATERIAL_ALPHABLEND,fs.PBRMATERIAL_ALPHATESTANDBLEND=Xn.PBRMATERIAL_ALPHATESTANDBLEND,fs.DEFAULT_AO_ON_ANALYTICAL_LIGHTS=Xn.DEFAULT_AO_ON_ANALYTICAL_LIGHTS,Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"directIntensity",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"emissiveIntensity",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"environmentIntensity",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"specularIntensity",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"disableBumpMap",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"albedoTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"ambientTexture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"ambientTextureStrength",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"ambientTextureImpactOnAnalyticalLights",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesAndMiscDirty")],fs.prototype,"opacityTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"reflectionTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"emissiveTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"reflectivityTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"metallicTexture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"metallic",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"roughness",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"metallicF0Factor",void 0),Ye([va(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"metallicReflectanceColor",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useOnlyMetallicFromMetallicReflectanceTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"metallicReflectanceTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"reflectanceTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"microSurfaceTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"bumpTexture",void 0),Ye([gn(),Ji("_markAllSubMeshesAsTexturesDirty",null)],fs.prototype,"lightmapTexture",void 0),Ye([va("ambient"),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"ambientColor",void 0),Ye([va("albedo"),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"albedoColor",void 0),Ye([va("reflectivity"),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"reflectivityColor",void 0),Ye([va("reflection"),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"reflectionColor",void 0),Ye([va("emissive"),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"emissiveColor",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"microSurface",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useLightmapAsShadowmap",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesAndMiscDirty")],fs.prototype,"useAlphaFromAlbedoTexture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesAndMiscDirty")],fs.prototype,"forceAlphaTest",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesAndMiscDirty")],fs.prototype,"alphaCutOff",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useSpecularOverAlpha",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useMicroSurfaceFromReflectivityMapAlpha",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useRoughnessFromMetallicTextureAlpha",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useRoughnessFromMetallicTextureGreen",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useMetallnessFromMetallicTextureBlue",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useAmbientOcclusionFromMetallicTextureRed",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useAmbientInGrayScale",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useAutoMicroSurfaceFromReflectivityMap",void 0),Ye([ht()],fs.prototype,"usePhysicalLightFalloff",null),Ye([ht()],fs.prototype,"useGLTFLightFalloff",null),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useRadianceOverAlpha",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useObjectSpaceNormalMap",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useParallax",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useParallaxOcclusion",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"parallaxScaleBias",void 0),Ye([ht(),Ji("_markAllSubMeshesAsLightsDirty")],fs.prototype,"disableLighting",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"forceIrradianceInFragment",void 0),Ye([ht(),Ji("_markAllSubMeshesAsLightsDirty")],fs.prototype,"maxSimultaneousLights",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"invertNormalMapX",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"invertNormalMapY",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"twoSidedLighting",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useAlphaFresnel",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useLinearAlphaFresnel",void 0),Ye([Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"environmentBRDFTexture",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"forceNormalForward",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"enableSpecularAntiAliasing",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useHorizonOcclusion",void 0),Ye([ht(),Ji("_markAllSubMeshesAsTexturesDirty")],fs.prototype,"useRadianceOcclusion",void 0),Ye([ht(),Ji("_markAllSubMeshesAsMiscDirty")],fs.prototype,"unlit",void 0),Ye([ht(),Ji("_markAllSubMeshesAsMiscDirty")],fs.prototype,"applyDecalMapAfterDetailMap",void 0),as("BABYLON.PBRMaterial",fs);class go{get boundingBias(){return this._boundingBias}set boundingBias(a){this._boundingBias?this._boundingBias.copyFrom(a):this._boundingBias=a.clone(),this._updateBoundingInfo(!0,null)}static CreateGeometryForMesh(a){const x=new go(go.RandomId(),a.getScene());return x.applyToMesh(a),x}get meshes(){return this._meshes}constructor(a,x,c,u=!1,g=null){this.delayLoadState=0,this._totalVertices=0,this._isDisposed=!1,this._indexBufferIsUpdatable=!1,this._positionsCache=[],this._parentContainer=null,this.useBoundingInfoFromGeometry=!1,this._scene=x||tr.LastCreatedScene,this._scene&&(this.id=a,this.uniqueId=this._scene.getUniqueId(),this._engine=this._scene.getEngine(),this._meshes=[],this._vertexBuffers={},this._indices=[],this._updatable=u,c?this.setAllVerticesData(c,u):this._totalVertices=0,this._engine.getCaps().vertexArrayObject&&(this._vertexArrayObjects={}),g&&(this.applyToMesh(g),g.computeWorldMatrix(!0)))}get extend(){return this._extend}getScene(){return this._scene}getEngine(){return this._engine}isReady(){return this.delayLoadState===1||this.delayLoadState===0}get doNotSerialize(){for(let a=0;a<this._meshes.length;a++)if(!this._meshes[a].doNotSerialize)return!1;return!0}_rebuild(){this._vertexArrayObjects&&(this._vertexArrayObjects={}),this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer"));const a=new Set;for(const x in this._vertexBuffers)a.add(this._vertexBuffers[x].getWrapperBuffer());a.forEach(x=>{x._rebuild()})}setAllVerticesData(a,x){a.applyToGeometry(this,x),this._notifyUpdate()}setVerticesData(a,x,c=!1,u){c&&Array.isArray(x)&&(x=new Float32Array(x));const g=new Ve(this._engine,x,a,{updatable:c,postponeInternalCreation:this._meshes.length===0,stride:u,label:"Geometry_"+this.id+"_"+a});this.setVerticesBuffer(g)}removeVerticesData(a){this._vertexBuffers[a]&&(this._vertexBuffers[a].dispose(),delete this._vertexBuffers[a]),this._vertexArrayObjects&&this._disposeVertexArrayObjects()}setVerticesBuffer(a,x=null,c=!0){const u=a.getKind();this._vertexBuffers[u]&&c&&this._vertexBuffers[u].dispose(),a._buffer&&a._buffer._increaseReferences(),this._vertexBuffers[u]=a;const g=this._meshes,y=g.length;if(u===Ve.PositionKind){this._totalVertices=x??a._maxVerticesCount,this._updateExtend(a.getFloatData(this._totalVertices)),this._resetPointsArrayCache();const v=this._extend&&this._extend.minimum||new Ee(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),w=this._extend&&this._extend.maximum||new Ee(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);for(let B=0;B<y;B++){const W=g[B];W.buildBoundingInfo(v,w),W._createGlobalSubMesh(W.isUnIndexed),W.computeWorldMatrix(!0),W.synchronizeInstances()}}this._notifyUpdate(u)}updateVerticesDataDirectly(a,x,c,u=!1){const g=this.getVertexBuffer(a);g&&(g.updateDirectly(x,c,u),this._notifyUpdate(a))}updateVerticesData(a,x,c=!1){const u=this.getVertexBuffer(a);u&&(u.update(x),a===Ve.PositionKind&&this._updateBoundingInfo(c,x),this._notifyUpdate(a))}_updateBoundingInfo(a,x){if(a&&this._updateExtend(x),this._resetPointsArrayCache(),a){const c=this._meshes;for(const u of c){u.hasBoundingInfo?u.getBoundingInfo().reConstruct(this._extend.minimum,this._extend.maximum):u.buildBoundingInfo(this._extend.minimum,this._extend.maximum);const g=u.subMeshes;for(const y of g)y.refreshBoundingInfo()}}}_bind(a,x,c,u){if(!a)return;x===void 0&&(x=this._indexBuffer);const g=this.getVertexBuffers();if(!g)return;if(x!=this._indexBuffer||!this._vertexArrayObjects&&!u){this._engine.bindBuffers(g,x,a,c);return}const y=u||this._vertexArrayObjects;y[a.key]||(y[a.key]=this._engine.recordVertexArrayObject(g,x,a,c)),this._engine.bindVertexArrayObject(y[a.key],x)}getTotalVertices(){return this.isReady()?this._totalVertices:0}getVerticesData(a,x,c){const u=this.getVertexBuffer(a);return u?u.getFloatData(this._totalVertices,c||x&&this._meshes.length!==1):null}isVertexBufferUpdatable(a){const x=this._vertexBuffers[a];return x?x.isUpdatable():!1}getVertexBuffer(a){return this.isReady()?this._vertexBuffers[a]:null}getVertexBuffers(){return this.isReady()?this._vertexBuffers:null}isVerticesDataPresent(a){return this._vertexBuffers?this._vertexBuffers[a]!==void 0:this._delayInfo?this._delayInfo.indexOf(a)!==-1:!1}getVerticesDataKinds(){const a=[];let x;if(!this._vertexBuffers&&this._delayInfo)for(x in this._delayInfo)a.push(x);else for(x in this._vertexBuffers)a.push(x);return a}updateIndices(a,x,c=!1){if(this._indexBuffer)if(!this._indexBufferIsUpdatable)this.setIndices(a,null,!0);else{const u=a.length!==this._indices.length;if(c||(this._indices=a.slice()),this._engine.updateDynamicIndexBuffer(this._indexBuffer,a,x),u)for(const g of this._meshes)g._createGlobalSubMesh(!0)}}setIndexBuffer(a,x,c){this._indices=[],this._indexBufferIsUpdatable=!1,this._indexBuffer=a,this._totalVertices=x,this._totalIndices=c,a.is32Bits||(a.is32Bits=this._totalIndices>65535);for(const u of this._meshes)u._createGlobalSubMesh(!0),u.synchronizeInstances();this._notifyUpdate()}setIndices(a,x=null,c=!1){this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indices=a,this._indexBufferIsUpdatable=c,this._meshes.length!==0&&this._indices&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,c,"Geometry_"+this.id+"_IndexBuffer")),x!=null&&(this._totalVertices=x);for(const u of this._meshes)u._createGlobalSubMesh(!0),u.synchronizeInstances();this._notifyUpdate()}getTotalIndices(){return this.isReady()?this._totalIndices!==void 0?this._totalIndices:this._indices.length:0}getIndices(a,x){if(!this.isReady())return null;const c=this._indices;return!x&&(!a||this._meshes.length===1)?c:c.slice()}getIndexBuffer(){return this.isReady()?this._indexBuffer:null}_releaseVertexArrayObject(a=null){!a||!this._vertexArrayObjects||this._vertexArrayObjects[a.key]&&(this._engine.releaseVertexArrayObject(this._vertexArrayObjects[a.key]),delete this._vertexArrayObjects[a.key])}releaseForMesh(a,x){const c=this._meshes,u=c.indexOf(a);u!==-1&&(c.splice(u,1),this._vertexArrayObjects&&a._invalidateInstanceVertexArrayObject(),a._geometry=null,c.length===0&&x&&this.dispose())}applyToMesh(a){if(a._geometry===this)return;const x=a._geometry;x&&x.releaseForMesh(a),this._vertexArrayObjects&&a._invalidateInstanceVertexArrayObject();const c=this._meshes;a._geometry=this,a._internalAbstractMeshDataInfo._positions=null,this._scene.pushGeometry(this),c.push(a),this.isReady()?this._applyToMesh(a):this._boundingInfo&&a.setBoundingInfo(this._boundingInfo)}_updateExtend(a=null){if(this.useBoundingInfoFromGeometry&&this._boundingInfo)this._extend={minimum:this._boundingInfo.minimum.clone(),maximum:this._boundingInfo.maximum.clone()};else{if(!a&&(a=this.getVerticesData(Ve.PositionKind),!a))return;this._extend=VT(a,0,this._totalVertices,this.boundingBias,3)}}_applyToMesh(a){const x=this._meshes.length;for(const c in this._vertexBuffers)x===1&&this._vertexBuffers[c].create(),c===Ve.PositionKind&&(this._extend||this._updateExtend(),a.buildBoundingInfo(this._extend.minimum,this._extend.maximum),a._createGlobalSubMesh(a.isUnIndexed),a._updateBoundingInfo());x===1&&this._indices&&this._indices.length>0&&(this._indexBuffer=this._engine.createIndexBuffer(this._indices,this._updatable,"Geometry_"+this.id+"_IndexBuffer")),a._syncGeometryWithMorphTargetManager(),a.synchronizeInstances()}_notifyUpdate(a){this.onGeometryUpdated&&this.onGeometryUpdated(this,a),this._vertexArrayObjects&&this._disposeVertexArrayObjects();for(const x of this._meshes)x._markSubMeshesAsAttributesDirty()}load(a,x){if(this.delayLoadState!==2){if(this.isReady()){x&&x();return}this.delayLoadState=2,this._queueLoad(a,x)}}_queueLoad(a,x){this.delayLoadingFile&&(a.addPendingData(this),a._loadFile(this.delayLoadingFile,c=>{if(!this._delayLoadingFunction)return;this._delayLoadingFunction(JSON.parse(c),this),this.delayLoadState=1,this._delayInfo=[],a.removePendingData(this);const u=this._meshes,g=u.length;for(let y=0;y<g;y++)this._applyToMesh(u[y]);x&&x()},void 0,!0))}toLeftHanded(){const a=this.getIndices(!1);if(a!=null&&a.length>0){for(let u=0;u<a.length;u+=3){const g=a[u+0];a[u+0]=a[u+2],a[u+2]=g}this.setIndices(a)}const x=this.getVerticesData(Ve.PositionKind,!1);if(x!=null&&x.length>0){for(let u=0;u<x.length;u+=3)x[u+2]=-x[u+2];this.setVerticesData(Ve.PositionKind,x,!1)}const c=this.getVerticesData(Ve.NormalKind,!1);if(c!=null&&c.length>0){for(let u=0;u<c.length;u+=3)c[u+2]=-c[u+2];this.setVerticesData(Ve.NormalKind,c,!1)}}_resetPointsArrayCache(){this._positions=null}_generatePointsArray(){if(this._positions)return!0;const a=this.getVerticesData(Ve.PositionKind);if(!a||a.length===0)return!1;for(let x=this._positionsCache.length*3,c=this._positionsCache.length;x<a.length;x+=3,++c)this._positionsCache[c]=Ee.FromArray(a,x);for(let x=0,c=0;x<a.length;x+=3,++c)this._positionsCache[c].set(a[0+x],a[1+x],a[2+x]);return this._positionsCache.length=a.length/3,this._positions=this._positionsCache,!0}isDisposed(){return this._isDisposed}_disposeVertexArrayObjects(){if(this._vertexArrayObjects){for(const c in this._vertexArrayObjects)this._engine.releaseVertexArrayObject(this._vertexArrayObjects[c]);this._vertexArrayObjects={};const a=this._meshes,x=a.length;for(let c=0;c<x;c++)a[c]._invalidateInstanceVertexArrayObject()}}dispose(){const a=this._meshes,x=a.length;let c;for(c=0;c<x;c++)this.releaseForMesh(a[c]);this._meshes.length=0,this._disposeVertexArrayObjects();for(const u in this._vertexBuffers)this._vertexBuffers[u].dispose();if(this._vertexBuffers={},this._totalVertices=0,this._indexBuffer&&this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null,this._indices=[],this.delayLoadState=0,this.delayLoadingFile=null,this._delayLoadingFunction=null,this._delayInfo=[],this._boundingInfo=null,this._scene.removeGeometry(this),this._parentContainer){const u=this._parentContainer.geometries.indexOf(this);u>-1&&this._parentContainer.geometries.splice(u,1),this._parentContainer=null}this._isDisposed=!0}copy(a){const x=new fr;x.indices=[];const c=this.getIndices();if(c)for(let w=0;w<c.length;w++)x.indices.push(c[w]);let u=!1,g=!1,y;for(y in this._vertexBuffers){const w=this.getVerticesData(y);if(w&&(w instanceof Float32Array?x.set(new Float32Array(w),y):x.set(w.slice(0),y),!g)){const B=this.getVertexBuffer(y);B&&(u=B.isUpdatable(),g=!u)}}const v=new go(a,this._scene,x,u);v.delayLoadState=this.delayLoadState,v.delayLoadingFile=this.delayLoadingFile,v._delayLoadingFunction=this._delayLoadingFunction;for(y in this._delayInfo)v._delayInfo=v._delayInfo||[],v._delayInfo.push(y);return v._boundingInfo=new tx(this._extend.minimum,this._extend.maximum),v}serialize(){const a={};return a.id=this.id,a.uniqueId=this.uniqueId,a.updatable=this._updatable,Vt&&Vt.HasTags(this)&&(a.tags=Vt.GetTags(this)),a}_toNumberArray(a){return Array.isArray(a)?a:Array.prototype.slice.call(a)}clearCachedData(){this._indices=[],this._resetPointsArrayCache();for(const a in this._vertexBuffers)Object.prototype.hasOwnProperty.call(this._vertexBuffers,a)&&(this._vertexBuffers[a]._buffer._data=null)}serializeVerticeData(){const a=this.serialize();return this.isVerticesDataPresent(Ve.PositionKind)&&(a.positions=this._toNumberArray(this.getVerticesData(Ve.PositionKind)),this.isVertexBufferUpdatable(Ve.PositionKind)&&(a.positions._updatable=!0)),this.isVerticesDataPresent(Ve.NormalKind)&&(a.normals=this._toNumberArray(this.getVerticesData(Ve.NormalKind)),this.isVertexBufferUpdatable(Ve.NormalKind)&&(a.normals._updatable=!0)),this.isVerticesDataPresent(Ve.TangentKind)&&(a.tangents=this._toNumberArray(this.getVerticesData(Ve.TangentKind)),this.isVertexBufferUpdatable(Ve.TangentKind)&&(a.tangents._updatable=!0)),this.isVerticesDataPresent(Ve.UVKind)&&(a.uvs=this._toNumberArray(this.getVerticesData(Ve.UVKind)),this.isVertexBufferUpdatable(Ve.UVKind)&&(a.uvs._updatable=!0)),this.isVerticesDataPresent(Ve.UV2Kind)&&(a.uvs2=this._toNumberArray(this.getVerticesData(Ve.UV2Kind)),this.isVertexBufferUpdatable(Ve.UV2Kind)&&(a.uvs2._updatable=!0)),this.isVerticesDataPresent(Ve.UV3Kind)&&(a.uvs3=this._toNumberArray(this.getVerticesData(Ve.UV3Kind)),this.isVertexBufferUpdatable(Ve.UV3Kind)&&(a.uvs3._updatable=!0)),this.isVerticesDataPresent(Ve.UV4Kind)&&(a.uvs4=this._toNumberArray(this.getVerticesData(Ve.UV4Kind)),this.isVertexBufferUpdatable(Ve.UV4Kind)&&(a.uvs4._updatable=!0)),this.isVerticesDataPresent(Ve.UV5Kind)&&(a.uvs5=this._toNumberArray(this.getVerticesData(Ve.UV5Kind)),this.isVertexBufferUpdatable(Ve.UV5Kind)&&(a.uvs5._updatable=!0)),this.isVerticesDataPresent(Ve.UV6Kind)&&(a.uvs6=this._toNumberArray(this.getVerticesData(Ve.UV6Kind)),this.isVertexBufferUpdatable(Ve.UV6Kind)&&(a.uvs6._updatable=!0)),this.isVerticesDataPresent(Ve.ColorKind)&&(a.colors=this._toNumberArray(this.getVerticesData(Ve.ColorKind)),this.isVertexBufferUpdatable(Ve.ColorKind)&&(a.colors._updatable=!0)),this.isVerticesDataPresent(Ve.MatricesIndicesKind)&&(a.matricesIndices=this._toNumberArray(this.getVerticesData(Ve.MatricesIndicesKind)),a.matricesIndices._isExpanded=!0,this.isVertexBufferUpdatable(Ve.MatricesIndicesKind)&&(a.matricesIndices._updatable=!0)),this.isVerticesDataPresent(Ve.MatricesWeightsKind)&&(a.matricesWeights=this._toNumberArray(this.getVerticesData(Ve.MatricesWeightsKind)),this.isVertexBufferUpdatable(Ve.MatricesWeightsKind)&&(a.matricesWeights._updatable=!0)),a.indices=this._toNumberArray(this.getIndices()),a}static ExtractFromMesh(a,x){const c=a._geometry;return c?c.copy(x):null}static RandomId(){return _t.RandomId()}static _GetGeometryByLoadedUniqueId(a,x){for(let c=0;c<x.geometries.length;c++)if(x.geometries[c]._loadedUniqueId===a)return x.geometries[c];return null}static _ImportGeometry(a,x){const c=x.getScene(),u=a.geometryUniqueId,g=a.geometryId;if(u||g){const y=u?this._GetGeometryByLoadedUniqueId(u,c):c.getGeometryById(g);y&&y.applyToMesh(x)}else if(a instanceof ArrayBuffer){const y=x._binaryInfo;if(y.positionsAttrDesc&&y.positionsAttrDesc.count>0){const v=new Float32Array(a,y.positionsAttrDesc.offset,y.positionsAttrDesc.count);x.setVerticesData(Ve.PositionKind,v,!1)}if(y.normalsAttrDesc&&y.normalsAttrDesc.count>0){const v=new Float32Array(a,y.normalsAttrDesc.offset,y.normalsAttrDesc.count);x.setVerticesData(Ve.NormalKind,v,!1)}if(y.tangetsAttrDesc&&y.tangetsAttrDesc.count>0){const v=new Float32Array(a,y.tangetsAttrDesc.offset,y.tangetsAttrDesc.count);x.setVerticesData(Ve.TangentKind,v,!1)}if(y.uvsAttrDesc&&y.uvsAttrDesc.count>0){const v=new Float32Array(a,y.uvsAttrDesc.offset,y.uvsAttrDesc.count);if(ac.UseOpenGLOrientationForUV)for(let w=1;w<v.length;w+=2)v[w]=1-v[w];x.setVerticesData(Ve.UVKind,v,!1)}if(y.uvs2AttrDesc&&y.uvs2AttrDesc.count>0){const v=new Float32Array(a,y.uvs2AttrDesc.offset,y.uvs2AttrDesc.count);if(ac.UseOpenGLOrientationForUV)for(let w=1;w<v.length;w+=2)v[w]=1-v[w];x.setVerticesData(Ve.UV2Kind,v,!1)}if(y.uvs3AttrDesc&&y.uvs3AttrDesc.count>0){const v=new Float32Array(a,y.uvs3AttrDesc.offset,y.uvs3AttrDesc.count);if(ac.UseOpenGLOrientationForUV)for(let w=1;w<v.length;w+=2)v[w]=1-v[w];x.setVerticesData(Ve.UV3Kind,v,!1)}if(y.uvs4AttrDesc&&y.uvs4AttrDesc.count>0){const v=new Float32Array(a,y.uvs4AttrDesc.offset,y.uvs4AttrDesc.count);if(ac.UseOpenGLOrientationForUV)for(let w=1;w<v.length;w+=2)v[w]=1-v[w];x.setVerticesData(Ve.UV4Kind,v,!1)}if(y.uvs5AttrDesc&&y.uvs5AttrDesc.count>0){const v=new Float32Array(a,y.uvs5AttrDesc.offset,y.uvs5AttrDesc.count);if(ac.UseOpenGLOrientationForUV)for(let w=1;w<v.length;w+=2)v[w]=1-v[w];x.setVerticesData(Ve.UV5Kind,v,!1)}if(y.uvs6AttrDesc&&y.uvs6AttrDesc.count>0){const v=new Float32Array(a,y.uvs6AttrDesc.offset,y.uvs6AttrDesc.count);if(ac.UseOpenGLOrientationForUV)for(let w=1;w<v.length;w+=2)v[w]=1-v[w];x.setVerticesData(Ve.UV6Kind,v,!1)}if(y.colorsAttrDesc&&y.colorsAttrDesc.count>0){const v=new Float32Array(a,y.colorsAttrDesc.offset,y.colorsAttrDesc.count);x.setVerticesData(Ve.ColorKind,v,!1,y.colorsAttrDesc.stride)}if(y.matricesIndicesAttrDesc&&y.matricesIndicesAttrDesc.count>0){const v=new Int32Array(a,y.matricesIndicesAttrDesc.offset,y.matricesIndicesAttrDesc.count),w=[];for(let B=0;B<v.length;B++){const W=v[B];w.push(W&255),w.push((W&65280)>>8),w.push((W&16711680)>>16),w.push(W>>24&255)}x.setVerticesData(Ve.MatricesIndicesKind,w,!1)}if(y.matricesIndicesExtraAttrDesc&&y.matricesIndicesExtraAttrDesc.count>0){const v=new Int32Array(a,y.matricesIndicesExtraAttrDesc.offset,y.matricesIndicesExtraAttrDesc.count),w=[];for(let B=0;B<v.length;B++){const W=v[B];w.push(W&255),w.push((W&65280)>>8),w.push((W&16711680)>>16),w.push(W>>24&255)}x.setVerticesData(Ve.MatricesIndicesExtraKind,w,!1)}if(y.matricesWeightsAttrDesc&&y.matricesWeightsAttrDesc.count>0){const v=new Float32Array(a,y.matricesWeightsAttrDesc.offset,y.matricesWeightsAttrDesc.count);x.setVerticesData(Ve.MatricesWeightsKind,v,!1)}if(y.indicesAttrDesc&&y.indicesAttrDesc.count>0){const v=new Int32Array(a,y.indicesAttrDesc.offset,y.indicesAttrDesc.count);x.setIndices(v,null)}if(y.subMeshesAttrDesc&&y.subMeshesAttrDesc.count>0){const v=new Int32Array(a,y.subMeshesAttrDesc.offset,y.subMeshesAttrDesc.count*5);x.subMeshes=[];for(let w=0;w<y.subMeshesAttrDesc.count;w++){const B=v[w*5+0],W=v[w*5+1],ae=v[w*5+2],ue=v[w*5+3],fe=v[w*5+4];ul.AddToMesh(B,W,ae,ue,fe,x)}}}else if(a.positions&&a.normals&&a.indices){if(x.setVerticesData(Ve.PositionKind,a.positions,a.positions._updatable),x.setVerticesData(Ve.NormalKind,a.normals,a.normals._updatable),a.tangents&&x.setVerticesData(Ve.TangentKind,a.tangents,a.tangents._updatable),a.uvs&&x.setVerticesData(Ve.UVKind,a.uvs,a.uvs._updatable),a.uvs2&&x.setVerticesData(Ve.UV2Kind,a.uvs2,a.uvs2._updatable),a.uvs3&&x.setVerticesData(Ve.UV3Kind,a.uvs3,a.uvs3._updatable),a.uvs4&&x.setVerticesData(Ve.UV4Kind,a.uvs4,a.uvs4._updatable),a.uvs5&&x.setVerticesData(Ve.UV5Kind,a.uvs5,a.uvs5._updatable),a.uvs6&&x.setVerticesData(Ve.UV6Kind,a.uvs6,a.uvs6._updatable),a.colors&&x.setVerticesData(Ve.ColorKind,Yr.CheckColors4(a.colors,a.positions.length/3),a.colors._updatable),a.matricesIndices)if(a.matricesIndices._isExpanded)delete a.matricesIndices._isExpanded,x.setVerticesData(Ve.MatricesIndicesKind,a.matricesIndices,a.matricesIndices._updatable);else{const y=[];for(let v=0;v<a.matricesIndices.length;v++){const w=a.matricesIndices[v];y.push(w&255),y.push((w&65280)>>8),y.push((w&16711680)>>16),y.push(w>>24&255)}x.setVerticesData(Ve.MatricesIndicesKind,y,a.matricesIndices._updatable)}if(a.matricesIndicesExtra)if(a.matricesIndicesExtra._isExpanded)delete a.matricesIndices._isExpanded,x.setVerticesData(Ve.MatricesIndicesExtraKind,a.matricesIndicesExtra,a.matricesIndicesExtra._updatable);else{const y=[];for(let v=0;v<a.matricesIndicesExtra.length;v++){const w=a.matricesIndicesExtra[v];y.push(w&255),y.push((w&65280)>>8),y.push((w&16711680)>>16),y.push(w>>24&255)}x.setVerticesData(Ve.MatricesIndicesExtraKind,y,a.matricesIndicesExtra._updatable)}a.matricesWeights&&(go._CleanMatricesWeights(a,x),x.setVerticesData(Ve.MatricesWeightsKind,a.matricesWeights,a.matricesWeights._updatable)),a.matricesWeightsExtra&&x.setVerticesData(Ve.MatricesWeightsExtraKind,a.matricesWeightsExtra,a.matricesWeights._updatable),x.setIndices(a.indices,null)}if(a.subMeshes){x.subMeshes=[];for(let y=0;y<a.subMeshes.length;y++){const v=a.subMeshes[y];ul.AddToMesh(v.materialIndex,v.verticesStart,v.verticesCount,v.indexStart,v.indexCount,x)}}x._shouldGenerateFlatShading&&(x.convertToFlatShadedMesh(),x._shouldGenerateFlatShading=!1),x.computeWorldMatrix(!0),c.onMeshImportedObservable.notifyObservers(x)}static _CleanMatricesWeights(a,x){if(!f0.CleanBoneMatrixWeights)return;let u=0;if(a.skeletonId>-1){const ae=x.getScene().getLastSkeletonById(a.skeletonId);if(!ae)return;u=ae.bones.length}else return;const g=x.getVerticesData(Ve.MatricesIndicesKind),y=x.getVerticesData(Ve.MatricesIndicesExtraKind),v=a.matricesWeights,w=a.matricesWeightsExtra,B=a.numBoneInfluencer,W=v.length;for(let ae=0;ae<W;ae+=4){let ue=0,fe=-1;for(let Re=0;Re<4;Re++){const _e=v[ae+Re];ue+=_e,_e<.001&&fe<0&&(fe=Re)}if(w)for(let Re=0;Re<4;Re++){const _e=w[ae+Re];ue+=_e,_e<.001&&fe<0&&(fe=Re+4)}if((fe<0||fe>B-1)&&(fe=B-1),ue>.001){const Re=1/ue;for(let _e=0;_e<4;_e++)v[ae+_e]*=Re;if(w)for(let _e=0;_e<4;_e++)w[ae+_e]*=Re}else fe>=4?(w[ae+fe-4]=1-ue,y[ae+fe-4]=u):(v[ae+fe]=1-ue,g[ae+fe]=u)}x.setVerticesData(Ve.MatricesIndicesKind,g),a.matricesWeightsExtra&&x.setVerticesData(Ve.MatricesIndicesExtraKind,y)}static Parse(a,x,c){const u=new go(a.id,x,void 0,a.updatable);return u._loadedUniqueId=a.uniqueId,Vt&&Vt.AddTagsTo(u,a.tags),a.delayLoadingFile?(u.delayLoadState=4,u.delayLoadingFile=c+a.delayLoadingFile,u._boundingInfo=new tx(Ee.FromArray(a.boundingBoxMinimum),Ee.FromArray(a.boundingBoxMaximum)),u._delayInfo=[],a.hasUVs&&u._delayInfo.push(Ve.UVKind),a.hasUVs2&&u._delayInfo.push(Ve.UV2Kind),a.hasUVs3&&u._delayInfo.push(Ve.UV3Kind),a.hasUVs4&&u._delayInfo.push(Ve.UV4Kind),a.hasUVs5&&u._delayInfo.push(Ve.UV5Kind),a.hasUVs6&&u._delayInfo.push(Ve.UV6Kind),a.hasColors&&u._delayInfo.push(Ve.ColorKind),a.hasMatricesIndices&&u._delayInfo.push(Ve.MatricesIndicesKind),a.hasMatricesWeights&&u._delayInfo.push(Ve.MatricesWeightsKind),u._delayLoadingFunction=fr.ImportVertexData):fr.ImportVertexData(a,u),x.pushGeometry(u,!0),u}}class Yu extends ui{get subMaterials(){return this._subMaterials}set subMaterials(a){this._subMaterials=a,this._hookArray(a)}getChildren(){return this.subMaterials}constructor(a,x){super(a,x,!0),this._waitingSubMaterialsUniqueIds=[],this.getScene().addMultiMaterial(this),this.subMaterials=[],this._storeEffectOnSubMeshes=!0}_hookArray(a){const x=a.push;a.push=(...u)=>{const g=x.apply(a,u);return this._markAllSubMeshesAsTexturesDirty(),g};const c=a.splice;a.splice=(u,g)=>{const y=c.apply(a,[u,g]);return this._markAllSubMeshesAsTexturesDirty(),y}}getSubMaterial(a){return a<0||a>=this.subMaterials.length?this.getScene().defaultMaterial:this.subMaterials[a]}getActiveTextures(){return super.getActiveTextures().concat(...this.subMaterials.map(a=>a?a.getActiveTextures():[]))}hasTexture(a){if(super.hasTexture(a))return!0;for(let x=0;x<this.subMaterials.length;x++)if(this.subMaterials[x]?.hasTexture(a))return!0;return!1}getClassName(){return"MultiMaterial"}isReadyForSubMesh(a,x,c){for(let u=0;u<this.subMaterials.length;u++){const g=this.subMaterials[u];if(g){if(g._storeEffectOnSubMeshes){if(!g.isReadyForSubMesh(a,x,c))return!1;continue}if(!g.isReady(a))return!1}}return!0}clone(a,x){const c=new Yu(a,this.getScene());for(let u=0;u<this.subMaterials.length;u++){let g=null;const y=this.subMaterials[u];x&&y?g=y.clone(a+"-"+y.name):g=this.subMaterials[u],c.subMaterials.push(g)}return c}serialize(){const a={};a.name=this.name,a.id=this.id,a.uniqueId=this.uniqueId,Vt&&(a.tags=Vt.GetTags(this)),a.materialsUniqueIds=[],a.materials=[];for(let x=0;x<this.subMaterials.length;x++){const c=this.subMaterials[x];c?(a.materialsUniqueIds.push(c.uniqueId),a.materials.push(c.id)):(a.materialsUniqueIds.push(null),a.materials.push(null))}return a}dispose(a,x,c){const u=this.getScene();if(!u)return;if(c)for(let y=0;y<this.subMaterials.length;y++){const v=this.subMaterials[y];v&&v.dispose(a,x)}const g=u.multiMaterials.indexOf(this);g>=0&&u.multiMaterials.splice(g,1),super.dispose(a,x)}static ParseMultiMaterial(a,x){const c=new Yu(a.name,x);return c.id=a.id,c._loadedUniqueId=a.uniqueId,Vt&&Vt.AddTagsTo(c,a.tags),a.materialsUniqueIds?c._waitingSubMaterialsUniqueIds=a.materialsUniqueIds:a.materials.forEach(u=>c.subMaterials.push(x.getLastMaterialById(u))),c}}as("BABYLON.MultiMaterial",Yu);class YL{constructor(a,x){this.distanceOrScreenCoverage=a,this.mesh=x}}class M9{}class $L{constructor(){this.visibleInstances={},this.batchCache=new Ew,this.batchCacheReplacementModeInFrozenMode=new Ew,this.instancesBufferSize=32*16*4}}class Ew{constructor(){this.mustReturn=!1,this.visibleInstances=new Array,this.renderSelf=[],this.hardwareInstancedRendering=[]}}class JL{constructor(){this.instancesCount=0,this.matrixBuffer=null,this.previousMatrixBuffer=null,this.matrixBufferSize=32*16,this.matrixData=null,this.boundingVectors=[],this.worldMatrices=null}}class tF{constructor(){this._areNormalsFrozen=!1,this._source=null,this.meshMap=null,this._preActivateId=-1,this._LODLevels=new Array,this._useLODScreenCoverage=!1,this._effectiveMaterial=null,this._forcedInstanceCount=0,this._overrideRenderingFillMode=null}}class sr extends mo{static _GetDefaultSideOrientation(a){return a||sr.FRONTSIDE}get useLODScreenCoverage(){return this._internalMeshDataInfo._useLODScreenCoverage}set useLODScreenCoverage(a){this._internalMeshDataInfo._useLODScreenCoverage=a,this._sortLODLevels()}get computeBonesUsingShaders(){return this._internalAbstractMeshDataInfo._computeBonesUsingShaders}set computeBonesUsingShaders(a){this._internalAbstractMeshDataInfo._computeBonesUsingShaders!==a&&(a&&this._internalMeshDataInfo._sourcePositions&&(this.setVerticesData(Ve.PositionKind,this._internalMeshDataInfo._sourcePositions,!0),this._internalMeshDataInfo._sourceNormals&&this.setVerticesData(Ve.NormalKind,this._internalMeshDataInfo._sourceNormals,!0),this._internalMeshDataInfo._sourcePositions=null,this._internalMeshDataInfo._sourceNormals=null),this._internalAbstractMeshDataInfo._computeBonesUsingShaders=a,this._markSubMeshesAsAttributesDirty())}get onBeforeRenderObservable(){return this._internalMeshDataInfo._onBeforeRenderObservable||(this._internalMeshDataInfo._onBeforeRenderObservable=new Jt),this._internalMeshDataInfo._onBeforeRenderObservable}get onBeforeBindObservable(){return this._internalMeshDataInfo._onBeforeBindObservable||(this._internalMeshDataInfo._onBeforeBindObservable=new Jt),this._internalMeshDataInfo._onBeforeBindObservable}get onAfterRenderObservable(){return this._internalMeshDataInfo._onAfterRenderObservable||(this._internalMeshDataInfo._onAfterRenderObservable=new Jt),this._internalMeshDataInfo._onAfterRenderObservable}get onBetweenPassObservable(){return this._internalMeshDataInfo._onBetweenPassObservable||(this._internalMeshDataInfo._onBetweenPassObservable=new Jt),this._internalMeshDataInfo._onBetweenPassObservable}get onBeforeDrawObservable(){return this._internalMeshDataInfo._onBeforeDrawObservable||(this._internalMeshDataInfo._onBeforeDrawObservable=new Jt),this._internalMeshDataInfo._onBeforeDrawObservable}set onBeforeDraw(a){this._onBeforeDrawObserver&&this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver),this._onBeforeDrawObserver=this.onBeforeDrawObservable.add(a)}get hasInstances(){return this.instances.length>0}get hasThinInstances(){return(this.forcedInstanceCount||this._thinInstanceDataStorage.instancesCount||0)>0}get forcedInstanceCount(){return this._internalMeshDataInfo._forcedInstanceCount}set forcedInstanceCount(a){this._internalMeshDataInfo._forcedInstanceCount=a}get overrideRenderingFillMode(){return this._internalMeshDataInfo._overrideRenderingFillMode}set overrideRenderingFillMode(a){this._internalMeshDataInfo._overrideRenderingFillMode=a}get source(){return this._internalMeshDataInfo._source}get cloneMeshMap(){return this._internalMeshDataInfo.meshMap}get isUnIndexed(){return this._unIndexed}set isUnIndexed(a){this._unIndexed!==a&&(this._unIndexed=a,this._markSubMeshesAsAttributesDirty())}get worldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesData}get previousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.instancesPreviousData}get manualUpdateOfWorldMatrixInstancedBuffer(){return this._instanceDataStorage.manualUpdate}set manualUpdateOfWorldMatrixInstancedBuffer(a){this._instanceDataStorage.manualUpdate=a}get manualUpdateOfPreviousWorldMatrixInstancedBuffer(){return this._instanceDataStorage.previousManualUpdate}set manualUpdateOfPreviousWorldMatrixInstancedBuffer(a){this._instanceDataStorage.previousManualUpdate=a}get forceWorldMatrixInstancedBufferUpdate(){return this._instanceDataStorage.forceMatrixUpdates}set forceWorldMatrixInstancedBufferUpdate(a){this._instanceDataStorage.forceMatrixUpdates=a}constructor(a,x=null,c=null,u=null,g,y=!0){if(super(a,x),this._internalMeshDataInfo=new tF,this.delayLoadState=0,this.instances=[],this._creationDataStorage=null,this._geometry=null,this._instanceDataStorage=new $L,this._thinInstanceDataStorage=new JL,this._shouldGenerateFlatShading=!1,this._originalBuilderSideOrientation=sr.DEFAULTSIDE,this.overrideMaterialSideOrientation=null,this.ignoreCameraMaxZ=!1,x=this.getScene(),this._onBeforeDraw=(v,w,B)=>{v&&B&&(this._uniformBuffer?this.transferToEffect(w):B.bindOnlyWorldMatrix(w))},u){if(u._geometry&&u._geometry.applyToMesh(this),$x.DeepCopy(u,this,["name","material","skeleton","instances","parent","uniqueId","source","metadata","morphTargetManager","hasInstances","worldMatrixInstancedBuffer","previousWorldMatrixInstancedBuffer","hasLODLevels","geometry","isBlocked","areNormalsFrozen","facetNb","isFacetDataEnabled","lightSources","useBones","isAnInstance","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","cloneMeshMap","hasBoundingInfo","physicsBody","physicsImpostor"],["_poseMatrix"]),this._internalMeshDataInfo._source=u,x.useClonedMeshMap&&(u._internalMeshDataInfo.meshMap||(u._internalMeshDataInfo.meshMap={}),u._internalMeshDataInfo.meshMap[this.uniqueId]=this),this._originalBuilderSideOrientation=u._originalBuilderSideOrientation,this._creationDataStorage=u._creationDataStorage,u._ranges){const v=u._ranges;for(const w in v)Object.prototype.hasOwnProperty.call(v,w)&&v[w]&&this.createAnimationRange(w,v[w].from,v[w].to)}if(u.metadata&&u.metadata.clone?this.metadata=u.metadata.clone():this.metadata=u.metadata,this._internalMetadata=u._internalMetadata,Vt&&Vt.HasTags(u)&&Vt.AddTagsTo(this,Vt.GetTags(u,!0)),this.setEnabled(u.isEnabled(!1)),this.parent=u.parent,this.setPivotMatrix(u.getPivotMatrix(),this._postMultiplyPivotMatrix),this.id=a+"."+u.id,this.material=u.material,!g){const v=u.getDescendants(!0);for(let w=0;w<v.length;w++){const B=v[w];B.clone&&B.clone(a+"."+B.name,this)}}if(u.morphTargetManager&&(this.morphTargetManager=u.morphTargetManager),x.getPhysicsEngine){const v=x.getPhysicsEngine();if(y&&v)if(v.getPluginVersion()===1){const w=v.getImpostorForPhysicsObject(u);w&&(this.physicsImpostor=w.clone(this))}else v.getPluginVersion()===2&&u.physicsBody&&u.physicsBody.clone(this)}for(let v=0;v<x.particleSystems.length;v++){const w=x.particleSystems[v];w.emitter===u&&w.clone(w.name,this)}this.skeleton=u.skeleton,this.refreshBoundingInfo(!0,!0),this.computeWorldMatrix(!0)}c!==null&&(this.parent=c),this._instanceDataStorage.hardwareInstancedRendering=this.getEngine().getCaps().instancedArrays,this._internalMeshDataInfo._onMeshReadyObserverAdded=v=>{v.unregisterOnNextCall=!0,this.isReady(!0)?this.onMeshReadyObservable.notifyObservers(this):this._internalMeshDataInfo._checkReadinessObserver||(this._internalMeshDataInfo._checkReadinessObserver=this._scene.onBeforeRenderObservable.add(()=>{this.isReady(!0)&&(this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),this._internalMeshDataInfo._checkReadinessObserver=null,this.onMeshReadyObservable.notifyObservers(this))}))},this.onMeshReadyObservable=new Jt(this._internalMeshDataInfo._onMeshReadyObserverAdded),u&&u.onClonedObservable.notifyObservers(this)}instantiateHierarchy(a=null,x,c){const u=this.getTotalVertices()===0||x&&x.doNotInstantiate&&(x.doNotInstantiate===!0||x.doNotInstantiate(this))?this.clone("Clone of "+(this.name||this.id),a||this.parent,!0):this.createInstance("instance of "+(this.name||this.id));u.parent=a||this.parent,u.position=this.position.clone(),u.scaling=this.scaling.clone(),this.rotationQuaternion?u.rotationQuaternion=this.rotationQuaternion.clone():u.rotation=this.rotation.clone(),c&&c(this,u);for(const g of this.getChildTransformNodes(!0))g.getClassName()==="InstancedMesh"&&u.getClassName()==="Mesh"&&g.sourceMesh===this?g.instantiateHierarchy(u,{doNotInstantiate:x&&x.doNotInstantiate||!1,newSourcedMesh:u},c):g.instantiateHierarchy(u,x,c);return u}getClassName(){return"Mesh"}get _isMesh(){return!0}toString(a){let x=super.toString(a);if(x+=", n vertices: "+this.getTotalVertices(),x+=", parent: "+(this._waitingParentId?this._waitingParentId:this.parent?this.parent.name:"NONE"),this.animations)for(let c=0;c<this.animations.length;c++)x+=", animation[0]: "+this.animations[c].toString(a);if(a)if(this._geometry){const c=this.getIndices(),u=this.getVerticesData(Ve.PositionKind);u&&c&&(x+=", flat shading: "+(u.length/3===c.length?"YES":"NO"))}else x+=", flat shading: UNKNOWN";return x}_unBindEffect(){super._unBindEffect();for(const a of this.instances)a._unBindEffect()}get hasLODLevels(){return this._internalMeshDataInfo._LODLevels.length>0}getLODLevels(){return this._internalMeshDataInfo._LODLevels}_sortLODLevels(){const a=this._internalMeshDataInfo._useLODScreenCoverage?-1:1;this._internalMeshDataInfo._LODLevels.sort((x,c)=>x.distanceOrScreenCoverage<c.distanceOrScreenCoverage?a:x.distanceOrScreenCoverage>c.distanceOrScreenCoverage?-a:0)}addLODLevel(a,x){if(x&&x._masterMesh)return Qt.Warn("You cannot use a mesh as LOD level twice"),this;const c=new YL(a,x);return this._internalMeshDataInfo._LODLevels.push(c),x&&(x._masterMesh=this),this._sortLODLevels(),this}getLODLevelAtDistance(a){const x=this._internalMeshDataInfo;for(let c=0;c<x._LODLevels.length;c++){const u=x._LODLevels[c];if(u.distanceOrScreenCoverage===a)return u.mesh}return null}removeLODLevel(a){const x=this._internalMeshDataInfo;for(let c=0;c<x._LODLevels.length;c++)x._LODLevels[c].mesh===a&&(x._LODLevels.splice(c,1),a&&(a._masterMesh=null));return this._sortLODLevels(),this}getLOD(a,x){const c=this._internalMeshDataInfo;if(!c._LODLevels||c._LODLevels.length===0)return this;const u=x||this.getBoundingInfo().boundingSphere,g=a.mode===gr.ORTHOGRAPHIC_CAMERA?a.minZ:u.centerWorld.subtract(a.globalPosition).length();let y=g,v=1;if(c._useLODScreenCoverage){const w=a.screenArea;let B=u.radiusWorld*a.minZ/g;B=B*B*Math.PI,y=B/w,v=-1}if(v*c._LODLevels[c._LODLevels.length-1].distanceOrScreenCoverage>v*y)return this.onLODLevelSelection&&this.onLODLevelSelection(y,this,this),this;for(let w=0;w<c._LODLevels.length;w++){const B=c._LODLevels[w];if(v*B.distanceOrScreenCoverage<v*y){if(B.mesh){if(B.mesh.delayLoadState===4)return B.mesh._checkDelayState(),this;if(B.mesh.delayLoadState===2)return this;B.mesh._preActivate(),B.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)}return this.onLODLevelSelection&&this.onLODLevelSelection(y,this,B.mesh),B.mesh}}return this.onLODLevelSelection&&this.onLODLevelSelection(y,this,this),this}get geometry(){return this._geometry}getTotalVertices(){return this._geometry===null||this._geometry===void 0?0:this._geometry.getTotalVertices()}getVerticesData(a,x,c,u){if(!this._geometry)return null;let g=u?void 0:this._userInstancedBuffersStorage?.vertexBuffers[a]?.getFloatData(this.instances.length+1,c||x&&this._geometry.meshes.length!==1);return g||(g=this._geometry.getVerticesData(a,x,c)),g}getVertexBuffer(a,x){return this._geometry?(x?void 0:this._userInstancedBuffersStorage?.vertexBuffers[a])??this._geometry.getVertexBuffer(a):null}isVerticesDataPresent(a,x){return this._geometry?!x&&this._userInstancedBuffersStorage?.vertexBuffers[a]!==void 0||this._geometry.isVerticesDataPresent(a):this._delayInfo?this._delayInfo.indexOf(a)!==-1:!1}isVertexBufferUpdatable(a,x){if(!this._geometry)return this._delayInfo?this._delayInfo.indexOf(a)!==-1:!1;if(!x){const c=this._userInstancedBuffersStorage?.vertexBuffers[a];if(c)return c.isUpdatable()}return this._geometry.isVertexBufferUpdatable(a)}getVerticesDataKinds(a){if(!this._geometry){const c=[];return this._delayInfo&&this._delayInfo.forEach(function(u){c.push(u)}),c}const x=this._geometry.getVerticesDataKinds();if(!a&&this._userInstancedBuffersStorage)for(const c in this._userInstancedBuffersStorage.vertexBuffers)x.indexOf(c)===-1&&x.push(c);return x}getTotalIndices(){return this._geometry?this._geometry.getTotalIndices():0}getIndices(a,x){return this._geometry?this._geometry.getIndices(a,x):[]}get isBlocked(){return this._masterMesh!==null&&this._masterMesh!==void 0}isReady(a=!1,x=!1){if(this.delayLoadState===2||!super.isReady(a))return!1;if(!this.subMeshes||this.subMeshes.length===0||!a)return!0;const c=this.getEngine(),u=this.getScene(),g=x||c.getCaps().instancedArrays&&(this.instances.length>0||this.hasThinInstances);this.computeWorldMatrix();const y=this.material||u.defaultMaterial;if(y){if(y._storeEffectOnSubMeshes)for(const w of this.subMeshes){const B=w.getMaterial();if(B){if(B._storeEffectOnSubMeshes){if(!B.isReadyForSubMesh(this,w,g))return!1}else if(!B.isReady(this,g))return!1}}else if(!y.isReady(this,g))return!1}const v=c.currentRenderPassId;for(const w of this.lightSources){const B=w.getShadowGenerators();if(!B)continue;const W=B.values();for(let ae=W.next();ae.done!==!0;ae=W.next()){const ue=ae.value;if(ue&&(!ue.getShadowMap()?.renderList||ue.getShadowMap()?.renderList&&ue.getShadowMap()?.renderList?.indexOf(this)!==-1)){const Re=ue.getShadowMap().renderPassIds??[c.currentRenderPassId];for(let _e=0;_e<Re.length;++_e){c.currentRenderPassId=Re[_e];for(const Be of this.subMeshes)if(!ue.isReady(Be,g,Be.getMaterial()?.needAlphaBlendingForMesh(this)??!1))return c.currentRenderPassId=v,!1}c.currentRenderPassId=v}}}for(const w of this._internalMeshDataInfo._LODLevels)if(w.mesh&&!w.mesh.isReady(g))return!1;return!0}get areNormalsFrozen(){return this._internalMeshDataInfo._areNormalsFrozen}freezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!0,this}unfreezeNormals(){return this._internalMeshDataInfo._areNormalsFrozen=!1,this}set overridenInstanceCount(a){this._instanceDataStorage.overridenInstanceCount=a}_preActivate(){const a=this._internalMeshDataInfo,x=this.getScene().getRenderId();return a._preActivateId===x?this:(a._preActivateId=x,this._instanceDataStorage.visibleInstances=null,this)}_preActivateForIntermediateRendering(a){return this._instanceDataStorage.visibleInstances&&(this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId=a),this}_registerInstanceForRenderId(a,x){return this._instanceDataStorage.visibleInstances||(this._instanceDataStorage.visibleInstances={defaultRenderId:x,selfDefaultRenderId:this._renderId}),this._instanceDataStorage.visibleInstances[x]||(this._instanceDataStorage.previousRenderId!==void 0&&this._instanceDataStorage.isFrozen&&(this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId]=null),this._instanceDataStorage.previousRenderId=x,this._instanceDataStorage.visibleInstances[x]=new Array),this._instanceDataStorage.visibleInstances[x].push(a),this}_afterComputeWorldMatrix(){super._afterComputeWorldMatrix(),this.hasThinInstances&&(this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1))}_postActivate(){this.edgesShareWithInstances&&this.edgesRenderer&&this.edgesRenderer.isEnabled&&this._renderingGroup&&(this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer),this.edgesRenderer.customInstances.push(this.getWorldMatrix()))}refreshBoundingInfo(a=!1,x=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const c=this.geometry?this.geometry.boundingBias:null;return this._refreshBoundingInfo(this._getPositionData(a,x),c),this}_createGlobalSubMesh(a){const x=this.getTotalVertices();if(!x||!this.getIndices())return null;if(this.subMeshes&&this.subMeshes.length>0){const c=this.getIndices();if(!c)return null;const u=c.length;let g=!1;if(a)g=!0;else for(const y of this.subMeshes){if(y.indexStart+y.indexCount>u){g=!0;break}if(y.verticesStart+y.verticesCount>x){g=!0;break}}if(!g)return this.subMeshes[0]}return this.releaseSubMeshes(),new ul(0,0,x,0,this.getTotalIndices(),this)}subdivide(a){if(a<1)return;const x=this.getTotalIndices();let c=x/a|0,u=0;for(;c%3!==0;)c++;this.releaseSubMeshes();for(let g=0;g<a&&!(u>=x);g++)ul.CreateFromIndices(0,u,g===a-1?x-u:c,this,void 0,!1),u+=c;this.refreshBoundingInfo(),this.synchronizeInstances()}setVerticesData(a,x,c=!1,u){if(this._geometry)this._geometry.setVerticesData(a,x,c,u);else{const g=new fr;g.set(x,a);const y=this.getScene();new go(go.RandomId(),y,g,c,this)}return this}removeVerticesData(a){this._geometry&&this._geometry.removeVerticesData(a)}markVerticesDataAsUpdatable(a,x=!0){const c=this.getVertexBuffer(a);!c||c.isUpdatable()===x||this.setVerticesData(a,this.getVerticesData(a),x)}setVerticesBuffer(a,x=!0){return this._geometry||(this._geometry=go.CreateGeometryForMesh(this)),this._geometry.setVerticesBuffer(a,null,x),this}updateVerticesData(a,x,c,u){return this._geometry?(u?(this.makeGeometryUnique(),this.updateVerticesData(a,x,c,!1)):this._geometry.updateVerticesData(a,x,c),this):this}updateMeshPositions(a,x=!0){const c=this.getVerticesData(Ve.PositionKind);if(!c)return this;if(a(c),this.updateVerticesData(Ve.PositionKind,c,!1,!1),x){const u=this.getIndices(),g=this.getVerticesData(Ve.NormalKind);if(!g)return this;fr.ComputeNormals(c,u,g),this.updateVerticesData(Ve.NormalKind,g,!1,!1)}return this}makeGeometryUnique(){if(!this._geometry)return this;if(this._geometry.meshes.length===1)return this;const a=this._geometry,x=this._geometry.copy(go.RandomId());return a.releaseForMesh(this,!0),x.applyToMesh(this),this}setIndexBuffer(a,x,c){let u=this._geometry;u||(u=new go(go.RandomId(),this.getScene(),void 0,void 0,this)),u.setIndexBuffer(a,x,c)}setIndices(a,x=null,c=!1){if(this._geometry)this._geometry.setIndices(a,x,c);else{const u=new fr;u.indices=a;const g=this.getScene();new go(go.RandomId(),g,u,c,this)}return this}updateIndices(a,x,c=!1){return this._geometry?(this._geometry.updateIndices(a,x,c),this):this}toLeftHanded(){return this._geometry?(this._geometry.toLeftHanded(),this):this}_bind(a,x,c,u=!0){if(!this._geometry)return this;const g=this.getScene().getEngine();this.morphTargetManager&&this.morphTargetManager.isUsingTextureForTargets&&this.morphTargetManager._bind(x);let y;if(this._unIndexed)y=null;else switch(this._getRenderingFillMode(c)){case ui.PointFillMode:y=null;break;case ui.WireFrameFillMode:y=a._getLinesIndexBuffer(this.getIndices(),g);break;default:case ui.TriangleFillMode:y=this._geometry.getIndexBuffer();break}return!u||!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(x,y):this._geometry._bind(x,y,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),this}_draw(a,x,c){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;this._internalMeshDataInfo._onBeforeDrawObservable&&this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);const g=this.getScene().getEngine();return this._unIndexed||x==ui.PointFillMode?g.drawArraysType(x,a.verticesStart,a.verticesCount,this.forcedInstanceCount||c):x==ui.WireFrameFillMode?g.drawElementsType(x,0,a._linesIndexCount,this.forcedInstanceCount||c):g.drawElementsType(x,a.indexStart,a.indexCount,this.forcedInstanceCount||c),this}registerBeforeRender(a){return this.onBeforeRenderObservable.add(a),this}unregisterBeforeRender(a){return this.onBeforeRenderObservable.removeCallback(a),this}registerAfterRender(a){return this.onAfterRenderObservable.add(a),this}unregisterAfterRender(a){return this.onAfterRenderObservable.removeCallback(a),this}_getInstancesRenderList(a,x=!1){if(this._instanceDataStorage.isFrozen){if(x)return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[a]=!1,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[a]=!0,this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;if(this._instanceDataStorage.previousBatch)return this._instanceDataStorage.previousBatch}const c=this.getScene(),u=c._isInIntermediateRendering(),g=u?this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate:this._internalAbstractMeshDataInfo._onlyForInstances,y=this._instanceDataStorage.batchCache;if(y.mustReturn=!1,y.renderSelf[a]=x||!g&&this.isEnabled()&&this.isVisible,y.visibleInstances[a]=null,this._instanceDataStorage.visibleInstances&&!x){const v=this._instanceDataStorage.visibleInstances,w=c.getRenderId(),B=u?v.intermediateDefaultRenderId:v.defaultRenderId;y.visibleInstances[a]=v[w],!y.visibleInstances[a]&&B&&(y.visibleInstances[a]=v[B])}return y.hardwareInstancedRendering[a]=!x&&this._instanceDataStorage.hardwareInstancedRendering&&y.visibleInstances[a]!==null&&y.visibleInstances[a]!==void 0,this._instanceDataStorage.previousBatch=y,y}_renderWithInstances(a,x,c,u,g){const y=c.visibleInstances[a._id],v=y?y.length:0,w=this._instanceDataStorage,B=w.instancesBufferSize;let W=w.instancesBuffer,ae=w.instancesPreviousBuffer;const fe=(v+1)*16*4;for(;w.instancesBufferSize<fe;)w.instancesBufferSize*=2;(!w.instancesData||B!=w.instancesBufferSize)&&(w.instancesData=new Float32Array(w.instancesBufferSize/4)),(this._scene.needsPreviousWorldMatrices&&!w.instancesPreviousData||B!=w.instancesBufferSize)&&(w.instancesPreviousData=new Float32Array(w.instancesBufferSize/4));let Re=0,_e=0;const Be=c.renderSelf[a._id],tt=!W||B!==w.instancesBufferSize||this._scene.needsPreviousWorldMatrices&&!w.instancesPreviousBuffer;if(!this._instanceDataStorage.manualUpdate&&(!w.isFrozen||tt)){const $e=this.getWorldMatrix();if(Be&&(this._scene.needsPreviousWorldMatrices&&(w.masterMeshPreviousWorldMatrix?(w.masterMeshPreviousWorldMatrix.copyToArray(w.instancesPreviousData,Re),w.masterMeshPreviousWorldMatrix.copyFrom($e)):(w.masterMeshPreviousWorldMatrix=$e.clone(),w.masterMeshPreviousWorldMatrix.copyToArray(w.instancesPreviousData,Re))),$e.copyToArray(w.instancesData,Re),Re+=16,_e++),y){if(sr.INSTANCEDMESH_SORT_TRANSPARENT&&this._scene.activeCamera&&a.getMaterial()?.needAlphaBlendingForMesh(a.getRenderingMesh())){const Et=this._scene.activeCamera.globalPosition;for(let ft=0;ft<y.length;ft++){const dt=y[ft];dt._distanceToCamera=Ee.Distance(dt.getBoundingInfo().boundingSphere.centerWorld,Et)}y.sort((ft,dt)=>ft._distanceToCamera>dt._distanceToCamera?-1:ft._distanceToCamera<dt._distanceToCamera?1:0)}for(let Et=0;Et<y.length;Et++){const ft=y[Et],dt=ft.getWorldMatrix();dt.copyToArray(w.instancesData,Re),this._scene.needsPreviousWorldMatrices&&(ft._previousWorldMatrix?(ft._previousWorldMatrix.copyToArray(w.instancesPreviousData,Re),ft._previousWorldMatrix.copyFrom(dt)):(ft._previousWorldMatrix=dt.clone(),ft._previousWorldMatrix.copyToArray(w.instancesPreviousData,Re))),Re+=16,_e++}}}else _e=(Be?1:0)+v;return tt?(W&&W.dispose(),ae&&ae.dispose(),W=new mu(g,w.instancesData,!0,16,!1,!0),w.instancesBuffer=W,this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this._userInstancedBuffersStorage.vertexBuffers.world0=W.createVertexBuffer("world0",0,4),this._userInstancedBuffersStorage.vertexBuffers.world1=W.createVertexBuffer("world1",4,4),this._userInstancedBuffersStorage.vertexBuffers.world2=W.createVertexBuffer("world2",8,4),this._userInstancedBuffersStorage.vertexBuffers.world3=W.createVertexBuffer("world3",12,4),this._scene.needsPreviousWorldMatrices&&(ae=new mu(g,w.instancesPreviousData,!0,16,!1,!0),w.instancesPreviousBuffer=ae,this._userInstancedBuffersStorage.vertexBuffers.previousWorld0=ae.createVertexBuffer("previousWorld0",0,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld1=ae.createVertexBuffer("previousWorld1",4,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld2=ae.createVertexBuffer("previousWorld2",8,4),this._userInstancedBuffersStorage.vertexBuffers.previousWorld3=ae.createVertexBuffer("previousWorld3",12,4)),this._invalidateInstanceVertexArrayObject()):(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&(W.updateDirectly(w.instancesData,0,_e),this._scene.needsPreviousWorldMatrices&&(!this._instanceDataStorage.manualUpdate||this._instanceDataStorage.previousManualUpdate)&&ae.updateDirectly(w.instancesPreviousData,0,_e)),this._processInstancedBuffers(y,Be),this.getScene()._activeIndices.addCount(a.indexCount*_e,!1),g._currentDrawContext&&(g._currentDrawContext.useInstancing=!0),this._bind(a,u,x),this._draw(a,x,_e),this._scene.needsPreviousWorldMatrices&&!tt&&this._instanceDataStorage.manualUpdate&&(!this._instanceDataStorage.isFrozen||this._instanceDataStorage.forceMatrixUpdates)&&!this._instanceDataStorage.previousManualUpdate&&ae.updateDirectly(w.instancesData,0,_e),g.unbindInstanceAttributes(),this}_renderWithThinInstances(a,x,c,u){const g=this._thinInstanceDataStorage?.instancesCount??0;this.getScene()._activeIndices.addCount(a.indexCount*g,!1),u._currentDrawContext&&(u._currentDrawContext.useInstancing=!0),this._bind(a,c,x),this._draw(a,x,g),this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&this._thinInstanceDataStorage.matrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData,0,g):this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.matrixData,!1)),u.unbindInstanceAttributes()}_processInstancedBuffers(a,x){}_processRendering(a,x,c,u,g,y,v,w){const B=this.getScene(),W=B.getEngine();if(u=this._getRenderingFillMode(u),y&&x.getRenderingMesh().hasThinInstances)return this._renderWithThinInstances(x,u,c,W),this;if(y)this._renderWithInstances(x,u,g,c,W);else{W._currentDrawContext&&(W._currentDrawContext.useInstancing=!1);let ae=0;g.renderSelf[x._id]&&(v&&v(!1,a.getWorldMatrix(),w),ae++,this._draw(x,u,this._instanceDataStorage.overridenInstanceCount));const ue=g.visibleInstances[x._id];if(ue){const fe=ue.length;ae+=fe;for(let Re=0;Re<fe;Re++){const Be=ue[Re].getWorldMatrix();v&&v(!0,Be,w),this._draw(x,u)}}B._activeIndices.addCount(x.indexCount*ae,!1)}return this}_rebuild(a=!1){if(this._instanceDataStorage.instancesBuffer&&(a&&this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null),this._userInstancedBuffersStorage){for(const x in this._userInstancedBuffersStorage.vertexBuffers){const c=this._userInstancedBuffersStorage.vertexBuffers[x];c&&(a&&c.dispose(),this._userInstancedBuffersStorage.vertexBuffers[x]=null)}this._userInstancedBuffersStorage.vertexArrayObjects&&(this._userInstancedBuffersStorage.vertexArrayObjects={})}this._internalMeshDataInfo._effectiveMaterial=null,super._rebuild(a)}_freeze(){if(this.subMeshes){for(let a=0;a<this.subMeshes.length;a++)this._getInstancesRenderList(a);this._internalMeshDataInfo._effectiveMaterial=null,this._instanceDataStorage.isFrozen=!0}}_unFreeze(){this._instanceDataStorage.isFrozen=!1,this._instanceDataStorage.previousBatch=null}renderWithRenderPassId(a,x,c,u,g=!0){const y=this._scene.getEngine(),v=y.currentRenderPassId;if(a!==void 0&&(y.currentRenderPassId=a),u)(!g||g&&u.isInFrustum(this._scene._frustumPlanes))&&this.render(u,!!x,c);else for(let w=0;w<this.subMeshes.length;w++){const B=this.subMeshes[w];(!g||g&&B.isInFrustum(this._scene._frustumPlanes))&&this.render(B,!!x,c)}return a!==void 0&&(y.currentRenderPassId=v),this}render(a,x,c){const u=this.getScene();this._internalAbstractMeshDataInfo._isActiveIntermediate?this._internalAbstractMeshDataInfo._isActiveIntermediate=!1:this._internalAbstractMeshDataInfo._isActive=!1;const g=u.activeCameras?.length??0;if((g>1&&u.activeCamera===u.activeCameras[0]||g<=1)&&this._checkOcclusionQuery()&&!this._occlusionDataStorage.forceRenderingWhenOccluded)return this;const v=this._getInstancesRenderList(a._id,!!c);if(v.mustReturn)return this;if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const w=u.getEngine();let B=0,W=null;this.ignoreCameraMaxZ&&u.activeCamera&&!u._isInIntermediateRendering()&&(B=u.activeCamera.maxZ,W=u.activeCamera,u.activeCamera.maxZ=0,u.updateTransformMatrix(!0)),this._internalMeshDataInfo._onBeforeRenderObservable&&this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);const ae=a.getRenderingMesh(),ue=v.hardwareInstancedRendering[a._id]||ae.hasThinInstances||!!this._userInstancedBuffersStorage&&!a.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh,fe=this._instanceDataStorage,Re=a.getMaterial();if(!Re)return W&&(W.maxZ=B,u.updateTransformMatrix(!0)),this;if(!fe.isFrozen||!this._internalMeshDataInfo._effectiveMaterial||this._internalMeshDataInfo._effectiveMaterial!==Re){if(Re._storeEffectOnSubMeshes){if(!Re.isReadyForSubMesh(this,a,ue))return W&&(W.maxZ=B,u.updateTransformMatrix(!0)),this}else if(!Re.isReady(this,ue))return W&&(W.maxZ=B,u.updateTransformMatrix(!0)),this;this._internalMeshDataInfo._effectiveMaterial=Re}else if(Re._storeEffectOnSubMeshes&&!a._drawWrapper?._wasPreviouslyReady||!Re._storeEffectOnSubMeshes&&!Re._getDrawWrapper()._wasPreviouslyReady)return W&&(W.maxZ=B,u.updateTransformMatrix(!0)),this;x&&w.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);let _e;this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes?_e=a._drawWrapper:_e=this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();const Be=_e?.effect??null;for(const Mt of u._beforeRenderingMeshStage)Mt.action(this,a,v,Be);if(!_e||!Be)return W&&(W.maxZ=B,u.updateTransformMatrix(!0)),this;const tt=c||this;let $e;if(!fe.isFrozen&&(this._internalMeshDataInfo._effectiveMaterial.backFaceCulling||this.overrideMaterialSideOrientation!==null||this._internalMeshDataInfo._effectiveMaterial.twoSidedLighting)){const Mt=tt._getWorldMatrixDeterminant();$e=this.overrideMaterialSideOrientation,$e==null&&($e=this._internalMeshDataInfo._effectiveMaterial.sideOrientation),Mt<0&&($e=$e===ui.ClockWiseSideOrientation?ui.CounterClockWiseSideOrientation:ui.ClockWiseSideOrientation),fe.sideOrientation=$e}else $e=fe.sideOrientation;const Et=this._internalMeshDataInfo._effectiveMaterial._preBind(_e,$e);this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite&&w.setDepthWrite(!0);const ft=this._internalMeshDataInfo._effectiveMaterial,dt=ft.fillMode;this._internalMeshDataInfo._onBeforeBindObservable&&this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this),ue||this._bind(a,Be,dt,!1);const ut=tt.getWorldMatrix();ft._storeEffectOnSubMeshes?ft.bindForSubMesh(ut,this,a):ft.bind(ut,this),!ft.backFaceCulling&&ft.separateCullingPass&&(w.setState(!0,ft.zOffset,!1,!Et,ft.cullBackFaces,ft.stencil,ft.zOffsetUnits),this._processRendering(this,a,Be,dt,v,ue,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),w.setState(!0,ft.zOffset,!1,Et,ft.cullBackFaces,ft.stencil,ft.zOffsetUnits),this._internalMeshDataInfo._onBetweenPassObservable&&this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(a)),this._processRendering(this,a,Be,dt,v,ue,this._onBeforeDraw,this._internalMeshDataInfo._effectiveMaterial),this._internalMeshDataInfo._effectiveMaterial.unbind();for(const Mt of u._afterRenderingMeshStage)Mt.action(this,a,v,Be);return this._internalMeshDataInfo._onAfterRenderObservable&&this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this),W&&(W.maxZ=B,u.updateTransformMatrix(!0)),u.performancePriority===g2.Aggressive&&!fe.isFrozen&&this._freeze(),this}cleanMatrixWeights(){this.isVerticesDataPresent(Ve.MatricesWeightsKind)&&(this.isVerticesDataPresent(Ve.MatricesWeightsExtraKind)?this._normalizeSkinWeightsAndExtra():this._normalizeSkinFourWeights())}_normalizeSkinFourWeights(){const a=this.getVerticesData(Ve.MatricesWeightsKind),x=a.length;for(let c=0;c<x;c+=4){const u=a[c]+a[c+1]+a[c+2]+a[c+3];if(u===0)a[c]=1;else{const g=1/u;a[c]*=g,a[c+1]*=g,a[c+2]*=g,a[c+3]*=g}}this.setVerticesData(Ve.MatricesWeightsKind,a)}_normalizeSkinWeightsAndExtra(){const a=this.getVerticesData(Ve.MatricesWeightsExtraKind),x=this.getVerticesData(Ve.MatricesWeightsKind),c=x.length;for(let u=0;u<c;u+=4){let g=x[u]+x[u+1]+x[u+2]+x[u+3];if(g+=a[u]+a[u+1]+a[u+2]+a[u+3],g===0)x[u]=1;else{const y=1/g;x[u]*=y,x[u+1]*=y,x[u+2]*=y,x[u+3]*=y,a[u]*=y,a[u+1]*=y,a[u+2]*=y,a[u+3]*=y}}this.setVerticesData(Ve.MatricesWeightsKind,x),this.setVerticesData(Ve.MatricesWeightsKind,a)}validateSkinning(){const a=this.getVerticesData(Ve.MatricesWeightsExtraKind),x=this.getVerticesData(Ve.MatricesWeightsKind);if(x===null||this.skeleton==null)return{skinned:!1,valid:!0,report:"not skinned"};const c=x.length;let u=0,g=0,y=0,v=0;const w=a===null?4:8,B=[];for(let Be=0;Be<=w;Be++)B[Be]=0;const W=.001;for(let Be=0;Be<c;Be+=4){let tt=x[Be],$e=tt,Et=$e===0?0:1;for(let ft=1;ft<w;ft++){const dt=ft<4?x[Be+ft]:a[Be+ft-4];dt>tt&&u++,dt!==0&&Et++,$e+=dt,tt=dt}if(B[Et]++,Et>y&&(y=Et),$e===0)g++;else{const ft=1/$e;let dt=0;for(let ut=0;ut<w;ut++)ut<4?dt+=Math.abs(x[Be+ut]-x[Be+ut]*ft):dt+=Math.abs(a[Be+ut-4]-a[Be+ut-4]*ft);dt>W&&v++}}const ae=this.skeleton.bones.length,ue=this.getVerticesData(Ve.MatricesIndicesKind),fe=this.getVerticesData(Ve.MatricesIndicesExtraKind);let Re=0;for(let Be=0;Be<c;Be+=4)for(let tt=0;tt<w;tt++){const $e=tt<4?ue[Be+tt]:fe[Be+tt-4];($e>=ae||$e<0)&&Re++}const _e="Number of Weights = "+c/4+`
Maximum influences = `+y+`
Missing Weights = `+g+`
Not Sorted = `+u+`
Not Normalized = `+v+`
WeightCounts = [`+B+`]
Number of bones = `+ae+`
Bad Bone Indices = `+Re;return{skinned:!0,valid:g===0&&v===0&&Re===0,report:_e}}_checkDelayState(){const a=this.getScene();return this._geometry?this._geometry.load(a):this.delayLoadState===4&&(this.delayLoadState=2,this._queueLoad(a)),this}_queueLoad(a){a.addPendingData(this);const x=this.delayLoadingFile.indexOf(".babylonbinarymeshdata")!==-1;return _t.LoadFile(this.delayLoadingFile,c=>{c instanceof ArrayBuffer?this._delayLoadingFunction(c,this):this._delayLoadingFunction(JSON.parse(c),this),this.instances.forEach(u=>{u.refreshBoundingInfo(),u._syncSubMeshes()}),this.delayLoadState=1,a.removePendingData(this)},()=>{},a.offlineProvider,x),this}isInFrustum(a){return this.delayLoadState===2||!super.isInFrustum(a)?!1:(this._checkDelayState(),!0)}setMaterialById(a){const x=this.getScene().materials;let c;for(c=x.length-1;c>-1;c--)if(x[c].id===a)return this.material=x[c],this;const u=this.getScene().multiMaterials;for(c=u.length-1;c>-1;c--)if(u[c].id===a)return this.material=u[c],this;return this}getAnimatables(){const a=[];return this.material&&a.push(this.material),this.skeleton&&a.push(this.skeleton),a}bakeTransformIntoVertices(a){if(!this.isVerticesDataPresent(Ve.PositionKind))return this;const x=this.subMeshes.splice(0);this._resetPointsArrayCache();let c=this.getVerticesData(Ve.PositionKind);const u=Ee.Zero();let g;for(g=0;g<c.length;g+=3)Ee.TransformCoordinatesFromFloatsToRef(c[g],c[g+1],c[g+2],a,u).toArray(c,g);if(this.setVerticesData(Ve.PositionKind,c,this.getVertexBuffer(Ve.PositionKind).isUpdatable()),this.isVerticesDataPresent(Ve.NormalKind)){for(c=this.getVerticesData(Ve.NormalKind),g=0;g<c.length;g+=3)Ee.TransformNormalFromFloatsToRef(c[g],c[g+1],c[g+2],a,u).normalize().toArray(c,g);this.setVerticesData(Ve.NormalKind,c,this.getVertexBuffer(Ve.NormalKind).isUpdatable())}if(this.isVerticesDataPresent(Ve.TangentKind)){for(c=this.getVerticesData(Ve.TangentKind),g=0;g<c.length;g+=4)Ee.TransformNormalFromFloatsToRef(c[g],c[g+1],c[g+2],a,u).normalize().toArray(c,g);this.setVerticesData(Ve.TangentKind,c,this.getVertexBuffer(Ve.TangentKind).isUpdatable())}return a.determinant()<0&&this.flipFaces(),this.releaseSubMeshes(),this.subMeshes=x,this}bakeCurrentTransformIntoVertices(a=!0){return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)),this.resetLocalMatrix(a),this}get _positions(){return this._internalAbstractMeshDataInfo._positions?this._internalAbstractMeshDataInfo._positions:this._geometry?this._geometry._positions:null}_resetPointsArrayCache(){return this._geometry&&this._geometry._resetPointsArrayCache(),this}_generatePointsArray(){return this._geometry?this._geometry._generatePointsArray():!1}clone(a="",x=null,c,u=!0){return new sr(a,this.getScene(),x,this,c,u)}dispose(a,x=!1){this.morphTargetManager=null,this._geometry&&this._geometry.releaseForMesh(this,!0);const c=this._internalMeshDataInfo;if(c._onBeforeDrawObservable&&c._onBeforeDrawObservable.clear(),c._onBeforeBindObservable&&c._onBeforeBindObservable.clear(),c._onBeforeRenderObservable&&c._onBeforeRenderObservable.clear(),c._onAfterRenderObservable&&c._onAfterRenderObservable.clear(),c._onBetweenPassObservable&&c._onBetweenPassObservable.clear(),this._scene.useClonedMeshMap){if(c.meshMap)for(const u in c.meshMap){const g=c.meshMap[u];g&&(g._internalMeshDataInfo._source=null,c.meshMap[u]=void 0)}c._source&&c._source._internalMeshDataInfo.meshMap&&(c._source._internalMeshDataInfo.meshMap[this.uniqueId]=void 0)}else{const u=this.getScene().meshes;for(const g of u){const y=g;y._internalMeshDataInfo&&y._internalMeshDataInfo._source&&y._internalMeshDataInfo._source===this&&(y._internalMeshDataInfo._source=null)}}c._source=null,this._instanceDataStorage.visibleInstances={},this._disposeInstanceSpecificData(),this._disposeThinInstanceSpecificData(),this._internalMeshDataInfo._checkReadinessObserver&&this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),super.dispose(a,x)}_disposeInstanceSpecificData(){}_disposeThinInstanceSpecificData(){}_invalidateInstanceVertexArrayObject(){}applyDisplacementMap(a,x,c,u,g,y,v=!1,w){const B=this.getScene(),W=ae=>{const ue=ae.width,fe=ae.height,_e=this.getEngine().createCanvas(ue,fe).getContext("2d");_e.drawImage(ae,0,0);const Be=_e.getImageData(0,0,ue,fe).data;this.applyDisplacementMapFromBuffer(Be,ue,fe,x,c,g,y,v),u&&u(this)};return _t.LoadImage(a,W,w||(()=>{}),B.offlineProvider),this}applyDisplacementMapFromBuffer(a,x,c,u,g,y,v,w=!1){if(!this.isVerticesDataPresent(Ve.PositionKind)||!this.isVerticesDataPresent(Ve.NormalKind)||!this.isVerticesDataPresent(Ve.UVKind))return Qt.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"),this;const B=this.getVerticesData(Ve.PositionKind,!0,!0),W=this.getVerticesData(Ve.NormalKind),ae=this.getVerticesData(Ve.UVKind);let ue=Ee.Zero();const fe=Ee.Zero(),Re=mr.Zero();y=y||mr.Zero(),v=v||new mr(1,1);for(let _e=0;_e<B.length;_e+=3){Ee.FromArrayToRef(B,_e,ue),Ee.FromArrayToRef(W,_e,fe),mr.FromArrayToRef(ae,_e/3*2,Re);const Be=Math.abs(Re.x*v.x+y.x%1)*(x-1)%x|0,tt=Math.abs(Re.y*v.y+y.y%1)*(c-1)%c|0,$e=(Be+tt*x)*4,Et=a[$e]/255,ft=a[$e+1]/255,dt=a[$e+2]/255,ut=Et*.3+ft*.59+dt*.11;fe.normalize(),fe.scaleInPlace(u+(g-u)*ut),ue=ue.add(fe),ue.toArray(B,_e)}return fr.ComputeNormals(B,this.getIndices(),W),w?(this.setVerticesData(Ve.PositionKind,B),this.setVerticesData(Ve.NormalKind,W),this.setVerticesData(Ve.UVKind,ae)):(this.updateVerticesData(Ve.PositionKind,B),this.updateVerticesData(Ve.NormalKind,W)),this}_getFlattenedNormals(a,x){const c=new Float32Array(a.length*3);let u=0;const g=this.overrideMaterialSideOrientation===(this._scene.useRightHandedSystem?1:0);for(let y=0;y<a.length;y+=3){const v=Ee.FromArray(x,a[y]*3),w=Ee.FromArray(x,a[y+1]*3),B=Ee.FromArray(x,a[y+2]*3),W=v.subtract(w),ae=B.subtract(w),ue=Ee.Normalize(Ee.Cross(W,ae));g&&ue.scaleInPlace(-1);for(let fe=0;fe<3;fe++)c[u++]=ue.x,c[u++]=ue.y,c[u++]=ue.z}return c}_convertToUnIndexedMesh(a=!1){const x=this.getVerticesDataKinds(),c=this.getIndices(),u={},g=(v,w)=>{const B=new Float32Array(c.length*w);let W=0;for(let ae=0;ae<c.length;ae++)for(let ue=0;ue<w;ue++)B[W++]=v[c[ae]*w+ue];return B},y=this.geometry?this.subMeshes.slice(0):[];for(const v of x)u[v]=this.getVerticesData(v);for(const v of x){const w=this.getVertexBuffer(v),B=w.getStrideSize();if(a&&v===Ve.NormalKind){const W=this._getFlattenedNormals(c,u[Ve.PositionKind]);this.setVerticesData(Ve.NormalKind,W,w.isUpdatable(),B)}else this.setVerticesData(v,g(u[v],B),w.isUpdatable(),B)}if(this.morphTargetManager){for(let v=0;v<this.morphTargetManager.numTargets;v++){const w=this.morphTargetManager.getTarget(v),B=w.getPositions();w.setPositions(g(B,3));const W=w.getNormals();W&&w.setNormals(a?this._getFlattenedNormals(c,B):g(W,3));const ae=w.getTangents();ae&&w.setTangents(g(ae,3));const ue=w.getUVs();ue&&w.setUVs(g(ue,2))}this.morphTargetManager.synchronize()}for(let v=0;v<c.length;v++)c[v]=v;this.setIndices(c),this._unIndexed=!0,this.releaseSubMeshes();for(const v of y)ul.AddToMesh(v.materialIndex,v.indexStart,v.indexCount,v.indexStart,v.indexCount,this);return this.synchronizeInstances(),this}convertToFlatShadedMesh(){return this._convertToUnIndexedMesh(!0)}convertToUnIndexedMesh(){return this._convertToUnIndexedMesh()}flipFaces(a=!1){const x=fr.ExtractFromMesh(this);let c;if(a&&this.isVerticesDataPresent(Ve.NormalKind)&&x.normals)for(c=0;c<x.normals.length;c++)x.normals[c]*=-1;if(x.indices){let u;for(c=0;c<x.indices.length;c+=3)u=x.indices[c+1],x.indices[c+1]=x.indices[c+2],x.indices[c+2]=u}return x.applyToMesh(this,this.isVertexBufferUpdatable(Ve.PositionKind)),this}increaseVertices(a=1){const x=fr.ExtractFromMesh(this),c=x.indices&&!Array.isArray(x.indices)&&Array.from?Array.from(x.indices):x.indices,u=x.positions&&!Array.isArray(x.positions)&&Array.from?Array.from(x.positions):x.positions,g=x.uvs&&!Array.isArray(x.uvs)&&Array.from?Array.from(x.uvs):x.uvs,y=x.normals&&!Array.isArray(x.normals)&&Array.from?Array.from(x.normals):x.normals;if(!c||!u)Qt.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");else{x.indices=c,x.positions=u,g&&(x.uvs=g),y&&(x.normals=y);const v=a+1,w=new Array;for(let dt=0;dt<v+1;dt++)w[dt]=new Array;let B,W;const ae=new Ee(0,0,0),ue=new Ee(0,0,0),fe=new mr(0,0),Re=new Array,_e=new Array,Be=new Array;let tt,$e=u.length,Et;g&&(Et=g.length);let ft;y&&(ft=y.length);for(let dt=0;dt<c.length;dt+=3){_e[0]=c[dt],_e[1]=c[dt+1],_e[2]=c[dt+2];for(let ut=0;ut<3;ut++)if(B=_e[ut],W=_e[(ut+1)%3],Be[B]===void 0&&Be[W]===void 0?(Be[B]=new Array,Be[W]=new Array):(Be[B]===void 0&&(Be[B]=new Array),Be[W]===void 0&&(Be[W]=new Array)),Be[B][W]===void 0&&Be[W][B]===void 0){Be[B][W]=[],ae.x=(u[3*W]-u[3*B])/v,ae.y=(u[3*W+1]-u[3*B+1])/v,ae.z=(u[3*W+2]-u[3*B+2])/v,y&&(ue.x=(y[3*W]-y[3*B])/v,ue.y=(y[3*W+1]-y[3*B+1])/v,ue.z=(y[3*W+2]-y[3*B+2])/v),g&&(fe.x=(g[2*W]-g[2*B])/v,fe.y=(g[2*W+1]-g[2*B+1])/v),Be[B][W].push(B);for(let Mt=1;Mt<v;Mt++)Be[B][W].push(u.length/3),u[$e++]=u[3*B]+Mt*ae.x,u[$e++]=u[3*B+1]+Mt*ae.y,u[$e++]=u[3*B+2]+Mt*ae.z,y&&(y[ft++]=y[3*B]+Mt*ue.x,y[ft++]=y[3*B+1]+Mt*ue.y,y[ft++]=y[3*B+2]+Mt*ue.z),g&&(g[Et++]=g[2*B]+Mt*fe.x,g[Et++]=g[2*B+1]+Mt*fe.y);Be[B][W].push(W),Be[W][B]=new Array,tt=Be[B][W].length;for(let Mt=0;Mt<tt;Mt++)Be[W][B][Mt]=Be[B][W][tt-1-Mt]}w[0][0]=c[dt],w[1][0]=Be[c[dt]][c[dt+1]][1],w[1][1]=Be[c[dt]][c[dt+2]][1];for(let ut=2;ut<v;ut++){w[ut][0]=Be[c[dt]][c[dt+1]][ut],w[ut][ut]=Be[c[dt]][c[dt+2]][ut],ae.x=(u[3*w[ut][ut]]-u[3*w[ut][0]])/ut,ae.y=(u[3*w[ut][ut]+1]-u[3*w[ut][0]+1])/ut,ae.z=(u[3*w[ut][ut]+2]-u[3*w[ut][0]+2])/ut,y&&(ue.x=(y[3*w[ut][ut]]-y[3*w[ut][0]])/ut,ue.y=(y[3*w[ut][ut]+1]-y[3*w[ut][0]+1])/ut,ue.z=(y[3*w[ut][ut]+2]-y[3*w[ut][0]+2])/ut),g&&(fe.x=(g[2*w[ut][ut]]-g[2*w[ut][0]])/ut,fe.y=(g[2*w[ut][ut]+1]-g[2*w[ut][0]+1])/ut);for(let Mt=1;Mt<ut;Mt++)w[ut][Mt]=u.length/3,u[$e++]=u[3*w[ut][0]]+Mt*ae.x,u[$e++]=u[3*w[ut][0]+1]+Mt*ae.y,u[$e++]=u[3*w[ut][0]+2]+Mt*ae.z,y&&(y[ft++]=y[3*w[ut][0]]+Mt*ue.x,y[ft++]=y[3*w[ut][0]+1]+Mt*ue.y,y[ft++]=y[3*w[ut][0]+2]+Mt*ue.z),g&&(g[Et++]=g[2*w[ut][0]]+Mt*fe.x,g[Et++]=g[2*w[ut][0]+1]+Mt*fe.y)}w[v]=Be[c[dt+1]][c[dt+2]],Re.push(w[0][0],w[1][0],w[1][1]);for(let ut=1;ut<v;ut++){let Mt;for(Mt=0;Mt<ut;Mt++)Re.push(w[ut][Mt],w[ut+1][Mt],w[ut+1][Mt+1]),Re.push(w[ut][Mt],w[ut+1][Mt+1],w[ut][Mt+1]);Re.push(w[ut][Mt],w[ut+1][Mt],w[ut+1][Mt+1])}}x.indices=Re,x.applyToMesh(this,this.isVertexBufferUpdatable(Ve.PositionKind))}}forceSharedVertices(){const a=fr.ExtractFromMesh(this),x=a.uvs,c=a.indices,u=a.positions,g=a.colors,y=a.matricesIndices,v=a.matricesWeights,w=a.matricesIndicesExtra,B=a.matricesWeightsExtra;if(c===void 0||u===void 0||c===null||u===null)Qt.Warn("VertexData contains empty entries");else{const W=new Array,ae=new Array,ue=new Array,fe=new Array,Re=new Array,_e=new Array,Be=new Array,tt=new Array;let $e=new Array,Et=0;const ft={};let dt,ut;for(let ai=0;ai<c.length;ai+=3){ut=[c[ai],c[ai+1],c[ai+2]],$e=[];for(let Yi=0;Yi<3;Yi++){$e[Yi]="";for(let Vi=0;Vi<3;Vi++)Math.abs(u[3*ut[Yi]+Vi])<1e-8&&(u[3*ut[Yi]+Vi]=0),$e[Yi]+=u[3*ut[Yi]+Vi]+"|"}if(!($e[0]==$e[1]||$e[0]==$e[2]||$e[1]==$e[2]))for(let Yi=0;Yi<3;Yi++){if(dt=ft[$e[Yi]],dt===void 0){ft[$e[Yi]]=Et,dt=Et++;for(let Vi=0;Vi<3;Vi++)W.push(u[3*ut[Yi]+Vi]);if(g!=null)for(let Vi=0;Vi<4;Vi++)fe.push(g[4*ut[Yi]+Vi]);if(x!=null)for(let Vi=0;Vi<2;Vi++)ue.push(x[2*ut[Yi]+Vi]);if(y!=null)for(let Vi=0;Vi<4;Vi++)Re.push(y[4*ut[Yi]+Vi]);if(v!=null)for(let Vi=0;Vi<4;Vi++)_e.push(v[4*ut[Yi]+Vi]);if(w!=null)for(let Vi=0;Vi<4;Vi++)Be.push(w[4*ut[Yi]+Vi]);if(B!=null)for(let Vi=0;Vi<4;Vi++)tt.push(B[4*ut[Yi]+Vi])}ae.push(dt)}}const Mt=new Array;fr.ComputeNormals(W,ae,Mt),a.positions=W,a.indices=ae,a.normals=Mt,x!=null&&(a.uvs=ue),g!=null&&(a.colors=fe),y!=null&&(a.matricesIndices=Re),v!=null&&(a.matricesWeights=_e),w!=null&&(a.matricesIndicesExtra=Be),v!=null&&(a.matricesWeightsExtra=tt),a.applyToMesh(this,this.isVertexBufferUpdatable(Ve.PositionKind))}}static _instancedMeshFactory(a,x){throw js("InstancedMesh")}static _PhysicsImpostorParser(a,x,c){throw js("PhysicsImpostor")}createInstance(a){return sr._instancedMeshFactory(a,this)}synchronizeInstances(){for(let a=0;a<this.instances.length;a++)this.instances[a]._syncSubMeshes();return this}optimizeIndices(a){const x=this.getIndices(),c=this.getVerticesData(Ve.PositionKind);if(!c||!x)return this;const u=[];for(let y=0;y<c.length;y=y+3)u.push(Ee.FromArray(c,y));const g=[];return Xe.SyncAsyncForLoop(u.length,40,y=>{const v=u.length-1-y,w=u[v];for(let B=0;B<v;++B){const W=u[B];if(w.equals(W)){g[v]=B;break}}},()=>{for(let v=0;v<x.length;++v)x[v]=g[x[v]]||x[v];const y=this.subMeshes.slice(0);this.setIndices(x),this.subMeshes=y,a&&a(this)}),this}serialize(a={}){a.name=this.name,a.id=this.id,a.uniqueId=this.uniqueId,a.type=this.getClassName(),Vt&&Vt.HasTags(this)&&(a.tags=Vt.GetTags(this)),a.position=this.position.asArray(),this.rotationQuaternion?a.rotationQuaternion=this.rotationQuaternion.asArray():this.rotation&&(a.rotation=this.rotation.asArray()),a.scaling=this.scaling.asArray(),this._postMultiplyPivotMatrix?a.pivotMatrix=this.getPivotMatrix().asArray():a.localMatrix=this.getPivotMatrix().asArray(),a.isEnabled=this.isEnabled(!1),a.isVisible=this.isVisible,a.infiniteDistance=this.infiniteDistance,a.pickable=this.isPickable,a.receiveShadows=this.receiveShadows,a.billboardMode=this.billboardMode,a.visibility=this.visibility,a.alwaysSelectAsActiveMesh=this.alwaysSelectAsActiveMesh,a.checkCollisions=this.checkCollisions,a.ellipsoid=this.ellipsoid.asArray(),a.ellipsoidOffset=this.ellipsoidOffset.asArray(),a.doNotSyncBoundingInfo=this.doNotSyncBoundingInfo,a.isBlocker=this.isBlocker,a.overrideMaterialSideOrientation=this.overrideMaterialSideOrientation,this.parent&&this.parent._serializeAsParent(a),a.isUnIndexed=this.isUnIndexed;const x=this._geometry;if(x&&this.subMeshes){a.geometryUniqueId=x.uniqueId,a.geometryId=x.id,a.subMeshes=[];for(let c=0;c<this.subMeshes.length;c++){const u=this.subMeshes[c];a.subMeshes.push({materialIndex:u.materialIndex,verticesStart:u.verticesStart,verticesCount:u.verticesCount,indexStart:u.indexStart,indexCount:u.indexCount})}}if(this.material?this.material.doNotSerialize||(a.materialUniqueId=this.material.uniqueId,a.materialId=this.material.id):(this.material=null,a.materialUniqueId=this._scene.defaultMaterial.uniqueId,a.materialId=this._scene.defaultMaterial.id),this.morphTargetManager&&(a.morphTargetManagerId=this.morphTargetManager.uniqueId),this.skeleton&&(a.skeletonId=this.skeleton.id,a.numBoneInfluencers=this.numBoneInfluencers),this.getScene()._getComponent(Xs.NAME_PHYSICSENGINE)){const c=this.getPhysicsImpostor();c&&(a.physicsMass=c.getParam("mass"),a.physicsFriction=c.getParam("friction"),a.physicsRestitution=c.getParam("mass"),a.physicsImpostor=c.type)}this.metadata&&(a.metadata=this.metadata),a.instances=[];for(let c=0;c<this.instances.length;c++){const u=this.instances[c];if(u.doNotSerialize)continue;const g={name:u.name,id:u.id,isEnabled:u.isEnabled(!1),isVisible:u.isVisible,isPickable:u.isPickable,checkCollisions:u.checkCollisions,position:u.position.asArray(),scaling:u.scaling.asArray()};if(u.parent&&u.parent._serializeAsParent(g),u.rotationQuaternion?g.rotationQuaternion=u.rotationQuaternion.asArray():u.rotation&&(g.rotation=u.rotation.asArray()),this.getScene()._getComponent(Xs.NAME_PHYSICSENGINE)){const y=u.getPhysicsImpostor();y&&(g.physicsMass=y.getParam("mass"),g.physicsFriction=y.getParam("friction"),g.physicsRestitution=y.getParam("mass"),g.physicsImpostor=y.type)}u.metadata&&(g.metadata=u.metadata),u.actionManager&&(g.actions=u.actionManager.serialize(u.name)),a.instances.push(g),hr.AppendSerializedAnimations(u,g),g.ranges=u.serializeAnimationRanges()}if(this._thinInstanceDataStorage.instancesCount&&this._thinInstanceDataStorage.matrixData&&(a.thinInstances={instancesCount:this._thinInstanceDataStorage.instancesCount,matrixData:Array.from(this._thinInstanceDataStorage.matrixData),matrixBufferSize:this._thinInstanceDataStorage.matrixBufferSize,enablePicking:this.thinInstanceEnablePicking},this._userThinInstanceBuffersStorage)){const c={data:{},sizes:{},strides:{}};for(const u in this._userThinInstanceBuffersStorage.data)c.data[u]=Array.from(this._userThinInstanceBuffersStorage.data[u]),c.sizes[u]=this._userThinInstanceBuffersStorage.sizes[u],c.strides[u]=this._userThinInstanceBuffersStorage.strides[u];a.thinInstances.userThinInstance=c}return hr.AppendSerializedAnimations(this,a),a.ranges=this.serializeAnimationRanges(),a.layerMask=this.layerMask,a.alphaIndex=this.alphaIndex,a.hasVertexAlpha=this.hasVertexAlpha,a.overlayAlpha=this.overlayAlpha,a.overlayColor=this.overlayColor.asArray(),a.renderOverlay=this.renderOverlay,a.applyFog=this.applyFog,this.actionManager&&(a.actions=this.actionManager.serialize(this.name)),a}_syncGeometryWithMorphTargetManager(){if(!this.geometry)return;this._markSubMeshesAsAttributesDirty();const a=this._internalAbstractMeshDataInfo._morphTargetManager;if(a&&a.vertexCount){if(a.vertexCount!==this.getTotalVertices()){Qt.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."),this.morphTargetManager=null;return}if(a.isUsingTextureForTargets)return;for(let x=0;x<a.numInfluencers;x++){const c=a.getActiveTarget(x),u=c.getPositions();if(!u){Qt.Error("Invalid morph target. Target must have positions.");return}this.geometry.setVerticesData(Ve.PositionKind+x,u,!1,3);const g=c.getNormals();g&&this.geometry.setVerticesData(Ve.NormalKind+x,g,!1,3);const y=c.getTangents();y&&this.geometry.setVerticesData(Ve.TangentKind+x,y,!1,3);const v=c.getUVs();v&&this.geometry.setVerticesData(Ve.UVKind+"_"+x,v,!1,2)}}else{let x=0;for(;this.geometry.isVerticesDataPresent(Ve.PositionKind+x);)this.geometry.removeVerticesData(Ve.PositionKind+x),this.geometry.isVerticesDataPresent(Ve.NormalKind+x)&&this.geometry.removeVerticesData(Ve.NormalKind+x),this.geometry.isVerticesDataPresent(Ve.TangentKind+x)&&this.geometry.removeVerticesData(Ve.TangentKind+x),this.geometry.isVerticesDataPresent(Ve.UVKind+x)&&this.geometry.removeVerticesData(Ve.UVKind+"_"+x),x++}}static Parse(a,x,c){let u;if(a.type&&a.type==="LinesMesh"?u=sr._LinesMeshParser(a,x):a.type&&a.type==="GroundMesh"?u=sr._GroundMeshParser(a,x):a.type&&a.type==="GoldbergMesh"?u=sr._GoldbergMeshParser(a,x):a.type&&a.type==="GreasedLineMesh"?u=sr._GreasedLineMeshParser(a,x):a.type&&a.type==="TrailMesh"?u=sr._TrailMeshParser(a,x):u=new sr(a.name,x),u.id=a.id,u._waitingParsedUniqueId=a.uniqueId,Vt&&Vt.AddTagsTo(u,a.tags),u.position=Ee.FromArray(a.position),a.metadata!==void 0&&(u.metadata=a.metadata),a.rotationQuaternion?u.rotationQuaternion=Wi.FromArray(a.rotationQuaternion):a.rotation&&(u.rotation=Ee.FromArray(a.rotation)),u.scaling=Ee.FromArray(a.scaling),a.localMatrix?u.setPreTransformMatrix(vt.FromArray(a.localMatrix)):a.pivotMatrix&&u.setPivotMatrix(vt.FromArray(a.pivotMatrix)),u.setEnabled(a.isEnabled),u.isVisible=a.isVisible,u.infiniteDistance=a.infiniteDistance,u.alwaysSelectAsActiveMesh=!!a.alwaysSelectAsActiveMesh,u.showBoundingBox=a.showBoundingBox,u.showSubMeshesBoundingBox=a.showSubMeshesBoundingBox,a.applyFog!==void 0&&(u.applyFog=a.applyFog),a.pickable!==void 0&&(u.isPickable=a.pickable),a.alphaIndex!==void 0&&(u.alphaIndex=a.alphaIndex),u.receiveShadows=a.receiveShadows,a.billboardMode!==void 0&&(u.billboardMode=a.billboardMode),a.visibility!==void 0&&(u.visibility=a.visibility),u.checkCollisions=a.checkCollisions,u.doNotSyncBoundingInfo=!!a.doNotSyncBoundingInfo,a.ellipsoid&&(u.ellipsoid=Ee.FromArray(a.ellipsoid)),a.ellipsoidOffset&&(u.ellipsoidOffset=Ee.FromArray(a.ellipsoidOffset)),a.overrideMaterialSideOrientation!==void 0&&(u.overrideMaterialSideOrientation=a.overrideMaterialSideOrientation),a.isBlocker!==void 0&&(u.isBlocker=a.isBlocker),u._shouldGenerateFlatShading=a.useFlatShading,a.freezeWorldMatrix&&(u._waitingData.freezeWorldMatrix=a.freezeWorldMatrix),a.parentId!==void 0&&(u._waitingParentId=a.parentId),a.parentInstanceIndex!==void 0&&(u._waitingParentInstanceIndex=a.parentInstanceIndex),a.actions!==void 0&&(u._waitingData.actions=a.actions),a.overlayAlpha!==void 0&&(u.overlayAlpha=a.overlayAlpha),a.overlayColor!==void 0&&(u.overlayColor=Bs.FromArray(a.overlayColor)),a.renderOverlay!==void 0&&(u.renderOverlay=a.renderOverlay),u.isUnIndexed=!!a.isUnIndexed,u.hasVertexAlpha=a.hasVertexAlpha,a.delayLoadingFile?(u.delayLoadState=4,u.delayLoadingFile=c+a.delayLoadingFile,u.buildBoundingInfo(Ee.FromArray(a.boundingBoxMinimum),Ee.FromArray(a.boundingBoxMaximum)),a._binaryInfo&&(u._binaryInfo=a._binaryInfo),u._delayInfo=[],a.hasUVs&&u._delayInfo.push(Ve.UVKind),a.hasUVs2&&u._delayInfo.push(Ve.UV2Kind),a.hasUVs3&&u._delayInfo.push(Ve.UV3Kind),a.hasUVs4&&u._delayInfo.push(Ve.UV4Kind),a.hasUVs5&&u._delayInfo.push(Ve.UV5Kind),a.hasUVs6&&u._delayInfo.push(Ve.UV6Kind),a.hasColors&&u._delayInfo.push(Ve.ColorKind),a.hasMatricesIndices&&u._delayInfo.push(Ve.MatricesIndicesKind),a.hasMatricesWeights&&u._delayInfo.push(Ve.MatricesWeightsKind),u._delayLoadingFunction=go._ImportGeometry,f0.ForceFullSceneLoadingForIncremental&&u._checkDelayState()):go._ImportGeometry(a,u),a.materialUniqueId?u._waitingMaterialId=a.materialUniqueId:a.materialId&&(u._waitingMaterialId=a.materialId),a.morphTargetManagerId>-1&&(u.morphTargetManager=x.getMorphTargetManagerById(a.morphTargetManagerId)),a.skeletonId!==void 0&&a.skeletonId!==null&&(u.skeleton=x.getLastSkeletonById(a.skeletonId),a.numBoneInfluencers&&(u.numBoneInfluencers=a.numBoneInfluencers)),a.animations){for(let g=0;g<a.animations.length;g++){const y=a.animations[g],v=Ua("BABYLON.Animation");v&&u.animations.push(v.Parse(y))}fa.ParseAnimationRanges(u,a,x)}if(a.autoAnimate&&x.beginAnimation(u,a.autoAnimateFrom,a.autoAnimateTo,a.autoAnimateLoop,a.autoAnimateSpeed||1),a.layerMask&&!isNaN(a.layerMask)?u.layerMask=Math.abs(parseInt(a.layerMask)):u.layerMask=268435455,a.physicsImpostor&&sr._PhysicsImpostorParser(x,u,a),a.lodMeshIds&&(u._waitingData.lods={ids:a.lodMeshIds,distances:a.lodDistances?a.lodDistances:null,coverages:a.lodCoverages?a.lodCoverages:null}),a.instances)for(let g=0;g<a.instances.length;g++){const y=a.instances[g],v=u.createInstance(y.name);if(y.id&&(v.id=y.id),Vt&&(y.tags?Vt.AddTagsTo(v,y.tags):Vt.AddTagsTo(v,a.tags)),v.position=Ee.FromArray(y.position),y.metadata!==void 0&&(v.metadata=y.metadata),y.parentId!==void 0&&(v._waitingParentId=y.parentId),y.parentInstanceIndex!==void 0&&(v._waitingParentInstanceIndex=y.parentInstanceIndex),y.isEnabled!==void 0&&y.isEnabled!==null&&v.setEnabled(y.isEnabled),y.isVisible!==void 0&&y.isVisible!==null&&(v.isVisible=y.isVisible),y.isPickable!==void 0&&y.isPickable!==null&&(v.isPickable=y.isPickable),y.rotationQuaternion?v.rotationQuaternion=Wi.FromArray(y.rotationQuaternion):y.rotation&&(v.rotation=Ee.FromArray(y.rotation)),v.scaling=Ee.FromArray(y.scaling),y.checkCollisions!=null&&y.checkCollisions!=null&&(v.checkCollisions=y.checkCollisions),y.pickable!=null&&y.pickable!=null&&(v.isPickable=y.pickable),y.showBoundingBox!=null&&y.showBoundingBox!=null&&(v.showBoundingBox=y.showBoundingBox),y.showSubMeshesBoundingBox!=null&&y.showSubMeshesBoundingBox!=null&&(v.showSubMeshesBoundingBox=y.showSubMeshesBoundingBox),y.alphaIndex!=null&&y.showSubMeshesBoundingBox!=null&&(v.alphaIndex=y.alphaIndex),y.physicsImpostor&&sr._PhysicsImpostorParser(x,v,y),y.actions!==void 0&&(v._waitingData.actions=y.actions),y.animations){for(let w=0;w<y.animations.length;w++){const B=y.animations[w],W=Ua("BABYLON.Animation");W&&v.animations.push(W.Parse(B))}fa.ParseAnimationRanges(v,y,x),y.autoAnimate&&x.beginAnimation(v,y.autoAnimateFrom,y.autoAnimateTo,y.autoAnimateLoop,y.autoAnimateSpeed||1)}}if(a.thinInstances){const g=a.thinInstances;if(u.thinInstanceEnablePicking=!!g.enablePicking,g.matrixData?(u.thinInstanceSetBuffer("matrix",new Float32Array(g.matrixData),16,!1),u._thinInstanceDataStorage.matrixBufferSize=g.matrixBufferSize,u._thinInstanceDataStorage.instancesCount=g.instancesCount):u._thinInstanceDataStorage.matrixBufferSize=g.matrixBufferSize,a.thinInstances.userThinInstance){const y=a.thinInstances.userThinInstance;for(const v in y.data)u.thinInstanceSetBuffer(v,new Float32Array(y.data[v]),y.strides[v],!1),u._userThinInstanceBuffersStorage.sizes[v]=y.sizes[v]}}return u}setPositionsForCPUSkinning(){const a=this._internalMeshDataInfo;if(!a._sourcePositions){const x=this.getVerticesData(Ve.PositionKind);if(!x)return a._sourcePositions;a._sourcePositions=new Float32Array(x),this.isVertexBufferUpdatable(Ve.PositionKind)||this.setVerticesData(Ve.PositionKind,x,!0)}return a._sourcePositions}setNormalsForCPUSkinning(){const a=this._internalMeshDataInfo;if(!a._sourceNormals){const x=this.getVerticesData(Ve.NormalKind);if(!x)return a._sourceNormals;a._sourceNormals=new Float32Array(x),this.isVertexBufferUpdatable(Ve.NormalKind)||this.setVerticesData(Ve.NormalKind,x,!0)}return a._sourceNormals}applySkeleton(a){if(!this.geometry)return this;if(this.geometry._softwareSkinningFrameId==this.getScene().getFrameId())return this;if(this.geometry._softwareSkinningFrameId=this.getScene().getFrameId(),!this.isVerticesDataPresent(Ve.PositionKind))return this;if(!this.isVerticesDataPresent(Ve.MatricesIndicesKind))return this;if(!this.isVerticesDataPresent(Ve.MatricesWeightsKind))return this;const x=this.isVerticesDataPresent(Ve.NormalKind),c=this._internalMeshDataInfo;if(!c._sourcePositions){const tt=this.subMeshes.slice();this.setPositionsForCPUSkinning(),this.subMeshes=tt}x&&!c._sourceNormals&&this.setNormalsForCPUSkinning();let u=this.getVerticesData(Ve.PositionKind);if(!u)return this;u instanceof Float32Array||(u=new Float32Array(u));let g=this.getVerticesData(Ve.NormalKind);if(x){if(!g)return this;g instanceof Float32Array||(g=new Float32Array(g))}const y=this.getVerticesData(Ve.MatricesIndicesKind),v=this.getVerticesData(Ve.MatricesWeightsKind);if(!v||!y)return this;const w=this.numBoneInfluencers>4,B=w?this.getVerticesData(Ve.MatricesIndicesExtraKind):null,W=w?this.getVerticesData(Ve.MatricesWeightsExtraKind):null,ae=a.getTransformMatrices(this),ue=Ee.Zero(),fe=new vt,Re=new vt;let _e=0,Be;for(let tt=0;tt<u.length;tt+=3,_e+=4){let $e;for(Be=0;Be<4;Be++)$e=v[_e+Be],$e>0&&(vt.FromFloat32ArrayToRefScaled(ae,Math.floor(y[_e+Be]*16),$e,Re),fe.addToSelf(Re));if(w)for(Be=0;Be<4;Be++)$e=W[_e+Be],$e>0&&(vt.FromFloat32ArrayToRefScaled(ae,Math.floor(B[_e+Be]*16),$e,Re),fe.addToSelf(Re));Ee.TransformCoordinatesFromFloatsToRef(c._sourcePositions[tt],c._sourcePositions[tt+1],c._sourcePositions[tt+2],fe,ue),ue.toArray(u,tt),x&&(Ee.TransformNormalFromFloatsToRef(c._sourceNormals[tt],c._sourceNormals[tt+1],c._sourceNormals[tt+2],fe,ue),ue.toArray(g,tt)),fe.reset()}return this.updateVerticesData(Ve.PositionKind,u),x&&this.updateVerticesData(Ve.NormalKind,g),this}static MinMax(a){let x=null,c=null;return a.forEach(function(u){const y=u.getBoundingInfo().boundingBox;!x||!c?(x=y.minimumWorld,c=y.maximumWorld):(x.minimizeInPlace(y.minimumWorld),c.maximizeInPlace(y.maximumWorld))}),!x||!c?{min:Ee.Zero(),max:Ee.Zero()}:{min:x,max:c}}static Center(a){const x=a instanceof Array?sr.MinMax(a):a;return Ee.Center(x.min,x.max)}static MergeMeshes(a,x=!0,c,u,g,y){return f_(sr._MergeMeshesCoroutine(a,x,c,u,g,y,!1))}static MergeMeshesAsync(a,x=!0,c,u,g,y){return _b(sr._MergeMeshesCoroutine(a,x,c,u,g,y,!0),$O())}static*_MergeMeshesCoroutine(a,x=!0,c,u,g,y,v){if(a=a.filter(Boolean),a.length===0)return null;let w;if(!c){let Mt=0;for(w=0;w<a.length;w++)if(Mt+=a[w].getTotalVertices(),Mt>=65536)return Qt.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"),null}y&&(g=!1);const B=new Array,W=new Array,ae=new Array,ue=a[0].overrideMaterialSideOrientation;for(w=0;w<a.length;w++){const Mt=a[w];if(Mt.isAnInstance)return Qt.Warn("Cannot merge instance meshes."),null;if(ue!==Mt.overrideMaterialSideOrientation)return Qt.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."),null;if(g&&ae.push(Mt.getTotalIndices()),y)if(Mt.material){const ai=Mt.material;if(ai instanceof Yu){for(let Yi=0;Yi<ai.subMaterials.length;Yi++)B.indexOf(ai.subMaterials[Yi])<0&&B.push(ai.subMaterials[Yi]);for(let Yi=0;Yi<Mt.subMeshes.length;Yi++)W.push(B.indexOf(ai.subMaterials[Mt.subMeshes[Yi].materialIndex])),ae.push(Mt.subMeshes[Yi].indexCount)}else{B.indexOf(ai)<0&&B.push(ai);for(let Yi=0;Yi<Mt.subMeshes.length;Yi++)W.push(B.indexOf(ai)),ae.push(Mt.subMeshes[Yi].indexCount)}}else for(let ai=0;ai<Mt.subMeshes.length;ai++)W.push(0),ae.push(Mt.subMeshes[ai].indexCount)}const fe=a[0],Re=Mt=>{const ai=Mt.computeWorldMatrix(!0);return{vertexData:fr.ExtractFromMesh(Mt,!1,!1),transform:ai}},{vertexData:_e,transform:Be}=Re(fe);v&&(yield);const tt=new Array(a.length-1);for(let Mt=1;Mt<a.length;Mt++)tt[Mt-1]=Re(a[Mt]),v&&(yield);const $e=_e._mergeCoroutine(Be,tt,c,v,!x);let Et=$e.next();for(;!Et.done;)v&&(yield),Et=$e.next();const ft=Et.value;u||(u=new sr(fe.name+"_merged",fe.getScene()));const dt=ft._applyToCoroutine(u,void 0,v);let ut=dt.next();for(;!ut.done;)v&&(yield),ut=dt.next();if(u.checkCollisions=fe.checkCollisions,u.overrideMaterialSideOrientation=fe.overrideMaterialSideOrientation,x)for(w=0;w<a.length;w++)a[w].dispose();if(g||y){u.releaseSubMeshes(),w=0;let Mt=0;for(;w<ae.length;)ul.CreateFromIndices(0,Mt,ae[w],u,void 0,!1),Mt+=ae[w],w++;for(const ai of u.subMeshes)ai.refreshBoundingInfo();u.computeWorldMatrix(!0)}if(y){const Mt=new Yu(fe.name+"_merged",fe.getScene());Mt.subMaterials=B;for(let ai=0;ai<u.subMeshes.length;ai++)u.subMeshes[ai].materialIndex=W[ai];u.material=Mt}else u.material=fe.material;return u}addInstance(a){a._indexInSourceMeshInstanceArray=this.instances.length,this.instances.push(a)}removeInstance(a){const x=a._indexInSourceMeshInstanceArray;if(x!=-1){if(x!==this.instances.length-1){const c=this.instances[this.instances.length-1];this.instances[x]=c,c._indexInSourceMeshInstanceArray=x}a._indexInSourceMeshInstanceArray=-1,this.instances.pop()}}_shouldConvertRHS(){return this.overrideMaterialSideOrientation===ui.CounterClockWiseSideOrientation}_getRenderingFillMode(a){const x=this.getScene();return x.forcePointsCloud?ui.PointFillMode:x.forceWireframe?ui.WireFrameFillMode:this.overrideRenderingFillMode??a}setMaterialByID(a){return this.setMaterialById(a)}static CreateRibbon(a,x,c,u,g,y,v,w,B){throw new Error("Import MeshBuilder to populate this function")}static CreateDisc(a,x,c,u,g,y){throw new Error("Import MeshBuilder to populate this function")}static CreateBox(a,x,c,u,g){throw new Error("Import MeshBuilder to populate this function")}static CreateSphere(a,x,c,u,g,y){throw new Error("Import MeshBuilder to populate this function")}static CreateHemisphere(a,x,c,u){throw new Error("Import MeshBuilder to populate this function")}static CreateCylinder(a,x,c,u,g,y,v,w,B){throw new Error("Import MeshBuilder to populate this function")}static CreateTorus(a,x,c,u,g,y,v){throw new Error("Import MeshBuilder to populate this function")}static CreateTorusKnot(a,x,c,u,g,y,v,w,B,W){throw new Error("Import MeshBuilder to populate this function")}static CreateLines(a,x,c,u,g){throw new Error("Import MeshBuilder to populate this function")}static CreateDashedLines(a,x,c,u,g,y,v,w){throw new Error("Import MeshBuilder to populate this function")}static CreatePolygon(a,x,c,u,g,y,v){throw new Error("Import MeshBuilder to populate this function")}static ExtrudePolygon(a,x,c,u,g,y,v,w){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShape(a,x,c,u,g,y,v,w,B,W){throw new Error("Import MeshBuilder to populate this function")}static ExtrudeShapeCustom(a,x,c,u,g,y,v,w,B,W,ae,ue){throw new Error("Import MeshBuilder to populate this function")}static CreateLathe(a,x,c,u,g,y,v){throw new Error("Import MeshBuilder to populate this function")}static CreatePlane(a,x,c,u,g){throw new Error("Import MeshBuilder to populate this function")}static CreateGround(a,x,c,u,g,y){throw new Error("Import MeshBuilder to populate this function")}static CreateTiledGround(a,x,c,u,g,y,v,w,B){throw new Error("Import MeshBuilder to populate this function")}static CreateGroundFromHeightMap(a,x,c,u,g,y,v,w,B,W,ae){throw new Error("Import MeshBuilder to populate this function")}static CreateTube(a,x,c,u,g,y,v,w,B,W){throw new Error("Import MeshBuilder to populate this function")}static CreatePolyhedron(a,x,c){throw new Error("Import MeshBuilder to populate this function")}static CreateIcoSphere(a,x,c){throw new Error("Import MeshBuilder to populate this function")}static CreateDecal(a,x,c,u,g,y){throw new Error("Import MeshBuilder to populate this function")}static CreateCapsule(a,x,c){throw new Error("Import MeshBuilder to populate this function")}static ExtendToGoldberg(a){throw new Error("Import MeshBuilder to populate this function")}}sr.FRONTSIDE=fr.FRONTSIDE,sr.BACKSIDE=fr.BACKSIDE,sr.DOUBLESIDE=fr.DOUBLESIDE,sr.DEFAULTSIDE=fr.DEFAULTSIDE,sr.NO_CAP=0,sr.CAP_START=1,sr.CAP_END=2,sr.CAP_ALL=3,sr.NO_FLIP=0,sr.FLIP_TILE=1,sr.ROTATE_TILE=2,sr.FLIP_ROW=3,sr.ROTATE_ROW=4,sr.FLIP_N_ROTATE_TILE=5,sr.FLIP_N_ROTATE_ROW=6,sr.CENTER=0,sr.LEFT=1,sr.RIGHT=2,sr.TOP=3,sr.BOTTOM=4,sr.INSTANCEDMESH_SORT_TRANSPARENT=!1,sr._GroundMeshParser=(F,a)=>{throw js("GroundMesh")},sr._GoldbergMeshParser=(F,a)=>{throw js("GoldbergMesh")},sr._LinesMeshParser=(F,a)=>{throw js("LinesMesh")},sr._GreasedLineMeshParser=(F,a)=>{throw js("GreasedLineMesh")},sr._GreasedLineRibbonMeshParser=(F,a)=>{throw js("GreasedLineRibbonMesh")},sr._TrailMeshParser=(F,a)=>{throw js("TrailMesh")},as("BABYLON.Mesh",sr);class Jh{get influence(){return this._influence}set influence(a){if(this._influence===a)return;const x=this._influence;this._influence=a,this.onInfluenceChanged.hasObservers()&&this.onInfluenceChanged.notifyObservers(x===0||a===0)}get animationPropertiesOverride(){return!this._animationPropertiesOverride&&this._scene?this._scene.animationPropertiesOverride:this._animationPropertiesOverride}set animationPropertiesOverride(a){this._animationPropertiesOverride=a}constructor(a,x=0,c=null){this.name=a,this.animations=[],this._positions=null,this._normals=null,this._tangents=null,this._uvs=null,this._uniqueId=0,this.onInfluenceChanged=new Jt,this._onDataLayoutChanged=new Jt,this._animationPropertiesOverride=null,this._scene=c||tr.LastCreatedScene,this.influence=x,this._scene&&(this._uniqueId=this._scene.getUniqueId())}get uniqueId(){return this._uniqueId}get hasPositions(){return!!this._positions}get hasNormals(){return!!this._normals}get hasTangents(){return!!this._tangents}get hasUVs(){return!!this._uvs}setPositions(a){const x=this.hasPositions;this._positions=a,x!==this.hasPositions&&this._onDataLayoutChanged.notifyObservers(void 0)}getPositions(){return this._positions}setNormals(a){const x=this.hasNormals;this._normals=a,x!==this.hasNormals&&this._onDataLayoutChanged.notifyObservers(void 0)}getNormals(){return this._normals}setTangents(a){const x=this.hasTangents;this._tangents=a,x!==this.hasTangents&&this._onDataLayoutChanged.notifyObservers(void 0)}getTangents(){return this._tangents}setUVs(a){const x=this.hasUVs;this._uvs=a,x!==this.hasUVs&&this._onDataLayoutChanged.notifyObservers(void 0)}getUVs(){return this._uvs}clone(){const a=hr.Clone(()=>new Jh(this.name,this.influence,this._scene),this);return a._positions=this._positions,a._normals=this._normals,a._tangents=this._tangents,a._uvs=this._uvs,a}serialize(){const a={};return a.name=this.name,a.influence=this.influence,a.positions=Array.prototype.slice.call(this.getPositions()),this.id!=null&&(a.id=this.id),this.hasNormals&&(a.normals=Array.prototype.slice.call(this.getNormals())),this.hasTangents&&(a.tangents=Array.prototype.slice.call(this.getTangents())),this.hasUVs&&(a.uvs=Array.prototype.slice.call(this.getUVs())),hr.AppendSerializedAnimations(this,a),a}getClassName(){return"MorphTarget"}static Parse(a,x){const c=new Jh(a.name,a.influence);if(c.setPositions(a.positions),a.id!=null&&(c.id=a.id),a.normals&&c.setNormals(a.normals),a.tangents&&c.setTangents(a.tangents),a.uvs&&c.setUVs(a.uvs),a.animations){for(let u=0;u<a.animations.length;u++){const g=a.animations[u],y=Ua("BABYLON.Animation");y&&c.animations.push(y.Parse(g))}a.autoAnimate&&x&&x.beginAnimation(c,a.autoAnimateFrom,a.autoAnimateTo,a.autoAnimateLoop,a.autoAnimateSpeed||1)}return c}static FromMesh(a,x,c){x||(x=a.name);const u=new Jh(x,c,a.getScene());return u.setPositions(a.getVerticesData(Ve.PositionKind)),a.isVerticesDataPresent(Ve.NormalKind)&&u.setNormals(a.getVerticesData(Ve.NormalKind)),a.isVerticesDataPresent(Ve.TangentKind)&&u.setTangents(a.getVerticesData(Ve.TangentKind)),a.isVerticesDataPresent(Ve.UVKind)&&u.setUVs(a.getVerticesData(Ve.UVKind)),u}}Ye([ht()],Jh.prototype,"id",void 0);class I_ extends fi{get depth(){return this._depth}constructor(a,x,c,u,g,y,v=!0,w=!1,B=fi.TRILINEAR_SAMPLINGMODE,W=0,ae){super(null,y,!v,w),this.format=g,this._texture=y.getEngine().createRawTexture2DArray(a,x,c,u,g,v,w,B,null,W,ae),this._depth=u,this.is2DArray=!0}update(a){this._texture&&this._getEngine().updateRawTexture2DArray(this._texture,a,this._texture.format,this._texture.invertY,null,this._texture.type)}static CreateRGBATexture(a,x,c,u,g,y=!0,v=!1,w=3,B=0){return new I_(a,x,c,u,5,g,y,v,w,B)}}class lh{set areUpdatesFrozen(a){a?this._blockCounter++:(this._blockCounter--,this._blockCounter<=0&&(this._blockCounter=0,this._syncActiveTargets(!0)))}get areUpdatesFrozen(){return this._blockCounter>0}constructor(a=null){if(this._targets=new Array,this._targetInfluenceChangedObservers=new Array,this._targetDataLayoutChangedObservers=new Array,this._activeTargets=new lt(16),this._supportsNormals=!1,this._supportsTangents=!1,this._supportsUVs=!1,this._vertexCount=0,this._textureVertexStride=0,this._textureWidth=0,this._textureHeight=1,this._uniqueId=0,this._tempInfluences=new Array,this._canUseTextureForTargets=!1,this._blockCounter=0,this._parentContainer=null,this.optimizeInfluencers=!0,this.enableNormalMorphing=!0,this.enableTangentMorphing=!0,this.enableUVMorphing=!0,this._numMaxInfluencers=0,this._useTextureToStoreTargets=!0,a||(a=tr.LastCreatedScene),this._scene=a,this._scene){this._scene.addMorphTargetManager(this),this._uniqueId=this._scene.getUniqueId();const x=this._scene.getEngine().getCaps();this._canUseTextureForTargets=x.canUseGLVertexID&&x.textureFloat&&x.maxVertexTextureImageUnits>0&&x.texture2DArrayMaxLayerCount>1}}get numMaxInfluencers(){return this._numMaxInfluencers}set numMaxInfluencers(a){this._numMaxInfluencers!==a&&(this._numMaxInfluencers=a,this._syncActiveTargets(!0))}get uniqueId(){return this._uniqueId}get vertexCount(){return this._vertexCount}get supportsNormals(){return this._supportsNormals&&this.enableNormalMorphing}get supportsTangents(){return this._supportsTangents&&this.enableTangentMorphing}get supportsUVs(){return this._supportsUVs&&this.enableUVMorphing}get numTargets(){return this._targets.length}get numInfluencers(){return this._activeTargets.length}get influences(){return this._influences}get useTextureToStoreTargets(){return this._useTextureToStoreTargets}set useTextureToStoreTargets(a){this._useTextureToStoreTargets=a}get isUsingTextureForTargets(){return lh.EnableTextureStorage&&this.useTextureToStoreTargets&&this._canUseTextureForTargets&&!this._scene?.getEngine().getCaps().disableMorphTargetTexture}getActiveTarget(a){return this._activeTargets.data[a]}getTarget(a){return this._targets[a]}addTarget(a){this._targets.push(a),this._targetInfluenceChangedObservers.push(a.onInfluenceChanged.add(x=>{this._syncActiveTargets(x)})),this._targetDataLayoutChangedObservers.push(a._onDataLayoutChanged.add(()=>{this._syncActiveTargets(!0)})),this._syncActiveTargets(!0)}removeTarget(a){const x=this._targets.indexOf(a);x>=0&&(this._targets.splice(x,1),a.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(x,1)[0]),a._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(x,1)[0]),this._syncActiveTargets(!0)),this._scene&&this._scene.stopAnimation(a)}_bind(a){a.setFloat3("morphTargetTextureInfo",this._textureVertexStride,this._textureWidth,this._textureHeight),a.setFloatArray("morphTargetTextureIndices",this._morphTargetTextureIndices),a.setTexture("morphTargets",this._targetStoreTexture),a.setInt("morphTargetCount",this.numInfluencers)}clone(){const a=new lh(this._scene);for(const x of this._targets)a.addTarget(x.clone());return a.enableNormalMorphing=this.enableNormalMorphing,a.enableTangentMorphing=this.enableTangentMorphing,a.enableUVMorphing=this.enableUVMorphing,a}serialize(){const a={};a.id=this.uniqueId,a.targets=[];for(const x of this._targets)a.targets.push(x.serialize());return a}_syncActiveTargets(a){if(this.areUpdatesFrozen)return;let x=0;this._activeTargets.reset(),this._supportsNormals=!0,this._supportsTangents=!0,this._supportsUVs=!0,this._vertexCount=0,this._scene&&this._targets.length>this._scene.getEngine().getCaps().texture2DArrayMaxLayerCount&&(this.useTextureToStoreTargets=!1),(!this._morphTargetTextureIndices||this._morphTargetTextureIndices.length!==this._targets.length)&&(this._morphTargetTextureIndices=new Float32Array(this._targets.length));let c=-1;for(const u of this._targets){if(c++,u.influence===0&&this.optimizeInfluencers)continue;if(this._activeTargets.length>=lh.MaxActiveMorphTargetsInVertexAttributeMode&&!this.isUsingTextureForTargets)break;this._activeTargets.push(u),this._morphTargetTextureIndices[x]=c,this._tempInfluences[x++]=u.influence,this._supportsNormals=this._supportsNormals&&u.hasNormals,this._supportsTangents=this._supportsTangents&&u.hasTangents,this._supportsUVs=this._supportsUVs&&u.hasUVs;const g=u.getPositions();if(g){const y=g.length/3;if(this._vertexCount===0)this._vertexCount=y;else if(this._vertexCount!==y){Qt.Error("Incompatible target. Targets must all have the same vertices count.");return}}}this._morphTargetTextureIndices.length!==x&&(this._morphTargetTextureIndices=this._morphTargetTextureIndices.slice(0,x)),(!this._influences||this._influences.length!==x)&&(this._influences=new Float32Array(x));for(let u=0;u<x;u++)this._influences[u]=this._tempInfluences[u];a&&this.synchronize()}synchronize(){if(!(!this._scene||this.areUpdatesFrozen)){if(this.isUsingTextureForTargets&&(this._vertexCount||this.numMaxInfluencers>0)){this._textureVertexStride=1,this._supportsNormals&&this._textureVertexStride++,this._supportsTangents&&this._textureVertexStride++,this._supportsUVs&&this._textureVertexStride++,this._textureWidth=this._vertexCount*this._textureVertexStride||1,this._textureHeight=1;const a=this._scene.getEngine().getCaps().maxTextureSize;this._textureWidth>a&&(this._textureHeight=Math.ceil(this._textureWidth/a),this._textureWidth=a);let x=!0;if(this._targetStoreTexture){const c=this._targetStoreTexture.getSize();c.width===this._textureWidth&&c.height===this._textureHeight&&this._targetStoreTexture.depth===this._targets.length&&(x=!1)}if(x){this._targetStoreTexture&&this._targetStoreTexture.dispose();const c=this._targets.length,u=new Float32Array(c*this._textureWidth*this._textureHeight*4);let g=0;for(let y=0;y<c;y++){const v=this._targets[y],w=v.getPositions(),B=v.getNormals(),W=v.getUVs(),ae=v.getTangents();if(!w){y===0&&Qt.Error("Invalid morph target. Target must have positions.");return}g=y*this._textureWidth*this._textureHeight*4;for(let ue=0;ue<this._vertexCount;ue++)u[g]=w[ue*3],u[g+1]=w[ue*3+1],u[g+2]=w[ue*3+2],g+=4,this._supportsNormals&&B&&(u[g]=B[ue*3],u[g+1]=B[ue*3+1],u[g+2]=B[ue*3+2],g+=4),this._supportsUVs&&W&&(u[g]=W[ue*2],u[g+1]=W[ue*2+1],g+=4),this._supportsTangents&&ae&&(u[g]=ae[ue*3],u[g+1]=ae[ue*3+1],u[g+2]=ae[ue*3+2],g+=4)}this._targetStoreTexture=I_.CreateRGBATexture(u,this._textureWidth,this._textureHeight,c,this._scene,!1,!1,1,1)}}for(const a of this._scene.meshes)a.morphTargetManager===this&&a._syncGeometryWithMorphTargetManager()}}dispose(){if(this._targetStoreTexture&&this._targetStoreTexture.dispose(),this._targetStoreTexture=null,this._scene){if(this._scene.removeMorphTargetManager(this),this._parentContainer){const a=this._parentContainer.morphTargetManagers.indexOf(this);a>-1&&this._parentContainer.morphTargetManagers.splice(a,1),this._parentContainer=null}for(const a of this._targets)this._scene.stopAnimation(a)}}static Parse(a,x){const c=new lh(x);c._uniqueId=a.id;for(const u of a.targets)c.addTarget(Jh.Parse(u,x));return c}}lh.EnableTextureStorage=!0,lh.MaxActiveMorphTargetsInVertexAttributeMode=8,sr._instancedMeshFactory=(F,a)=>{const x=new vw(F,a);if(a.instancedBuffers){x.instancedBuffers={};for(const c in a.instancedBuffers)x.instancedBuffers[c]=a.instancedBuffers[c]}return x};class vw extends mo{constructor(a,x){super(a,x.getScene()),this._indexInSourceMeshInstanceArray=-1,this._distanceToCamera=0,x.addInstance(this),this._sourceMesh=x,this._unIndexed=x._unIndexed,this.position.copyFrom(x.position),this.rotation.copyFrom(x.rotation),this.scaling.copyFrom(x.scaling),x.rotationQuaternion&&(this.rotationQuaternion=x.rotationQuaternion.clone()),this.animations=x.animations.slice();for(const c of x.getAnimationRanges())c!=null&&this.createAnimationRange(c.name,c.from,c.to);this.infiniteDistance=x.infiniteDistance,this.setPivotMatrix(x.getPivotMatrix()),this.refreshBoundingInfo(!0,!0),this._syncSubMeshes()}getClassName(){return"InstancedMesh"}get lightSources(){return this._sourceMesh._lightSources}_resyncLightSources(){}_resyncLightSource(){}_removeLightSource(){}get receiveShadows(){return this._sourceMesh.receiveShadows}set receiveShadows(a){this._sourceMesh?.receiveShadows!==a&&_t.Warn("Setting receiveShadows on an instanced mesh has no effect")}get material(){return this._sourceMesh.material}set material(a){this._sourceMesh?.material!==a&&_t.Warn("Setting material on an instanced mesh has no effect")}get visibility(){return this._sourceMesh.visibility}set visibility(a){this._sourceMesh?.visibility!==a&&_t.Warn("Setting visibility on an instanced mesh has no effect")}get skeleton(){return this._sourceMesh.skeleton}set skeleton(a){this._sourceMesh?.skeleton!==a&&_t.Warn("Setting skeleton on an instanced mesh has no effect")}get renderingGroupId(){return this._sourceMesh.renderingGroupId}set renderingGroupId(a){!this._sourceMesh||a===this._sourceMesh.renderingGroupId||Qt.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")}getTotalVertices(){return this._sourceMesh?this._sourceMesh.getTotalVertices():0}getTotalIndices(){return this._sourceMesh.getTotalIndices()}get sourceMesh(){return this._sourceMesh}createInstance(a){return this._sourceMesh.createInstance(a)}isReady(a=!1){return this._sourceMesh.isReady(a,!0)}getVerticesData(a,x,c){return this._sourceMesh.getVerticesData(a,x,c)}setVerticesData(a,x,c,u){return this.sourceMesh&&this.sourceMesh.setVerticesData(a,x,c,u),this.sourceMesh}updateVerticesData(a,x,c,u){return this.sourceMesh&&this.sourceMesh.updateVerticesData(a,x,c,u),this.sourceMesh}setIndices(a,x=null){return this.sourceMesh&&this.sourceMesh.setIndices(a,x),this.sourceMesh}isVerticesDataPresent(a){return this._sourceMesh.isVerticesDataPresent(a)}getIndices(){return this._sourceMesh.getIndices()}get _positions(){return this._sourceMesh._positions}refreshBoundingInfo(a=!1,x=!1){if(this.hasBoundingInfo&&this.getBoundingInfo().isLocked)return this;const c=this._sourceMesh.geometry?this._sourceMesh.geometry.boundingBias:null;return this._refreshBoundingInfo(this._sourceMesh._getPositionData(a,x),c),this}_preActivate(){return this._currentLOD&&this._currentLOD._preActivate(),this}_activate(a,x){if(super._activate(a,x),this._sourceMesh.subMeshes||Qt.Warn("Instances should only be created for meshes with geometry."),this._currentLOD){if(this._currentLOD._getWorldMatrixDeterminant()>=0!=this._getWorldMatrixDeterminant()>=0)return this._internalAbstractMeshDataInfo._actAsRegularMesh=!0,!0;if(this._internalAbstractMeshDataInfo._actAsRegularMesh=!1,this._currentLOD._registerInstanceForRenderId(this,a),x){if(!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!0,!0}else if(!this._currentLOD._internalAbstractMeshDataInfo._isActive)return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances=!0,!0}return!1}_postActivate(){this._sourceMesh.edgesShareWithInstances&&this._sourceMesh._edgesRenderer&&this._sourceMesh._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup?(this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())):this._edgesRenderer&&this._edgesRenderer.isEnabled&&this._sourceMesh._renderingGroup&&this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)}getWorldMatrix(){if(this._currentLOD&&this._currentLOD.billboardMode!==$s.BILLBOARDMODE_NONE&&this._currentLOD._masterMesh!==this){this._billboardWorldMatrix||(this._billboardWorldMatrix=new vt);const a=this._currentLOD._masterMesh;return this._currentLOD._masterMesh=this,Yt.Vector3[7].copyFrom(this._currentLOD.position),this._currentLOD.position.set(0,0,0),this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),this._currentLOD.position.copyFrom(Yt.Vector3[7]),this._currentLOD._masterMesh=a,this._billboardWorldMatrix}return super.getWorldMatrix()}get isAnInstance(){return!0}getLOD(a){if(!a)return this;const x=this.sourceMesh.getLODLevels();if(!x||x.length===0)this._currentLOD=this.sourceMesh;else{const c=this.getBoundingInfo();this._currentLOD=this.sourceMesh.getLOD(a,c.boundingSphere)}return this._currentLOD}_preActivateForIntermediateRendering(a){return this.sourceMesh._preActivateForIntermediateRendering(a)}_syncSubMeshes(){if(this.releaseSubMeshes(),this._sourceMesh.subMeshes)for(let a=0;a<this._sourceMesh.subMeshes.length;a++)this._sourceMesh.subMeshes[a].clone(this,this._sourceMesh);return this}_generatePointsArray(){return this._sourceMesh._generatePointsArray()}_updateBoundingInfo(){return this.hasBoundingInfo?this.getBoundingInfo().update(this.worldMatrixFromCache):this.buildBoundingInfo(this.absolutePosition,this.absolutePosition,this.worldMatrixFromCache),this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),this}clone(a,x=null,c,u){const g=(u||this._sourceMesh).createInstance(a);if($x.DeepCopy(this,g,["name","subMeshes","uniqueId","parent","lightSources","receiveShadows","material","visibility","skeleton","sourceMesh","isAnInstance","facetNb","isFacetDataEnabled","isBlocked","useBones","hasInstances","collider","edgesRenderer","forward","up","right","absolutePosition","absoluteScaling","absoluteRotationQuaternion","isWorldMatrixFrozen","nonUniformScaling","behaviors","worldMatrixFromCache","hasThinInstances","hasBoundingInfo"],[]),this.refreshBoundingInfo(),x&&(g.parent=x),!c)for(let y=0;y<this.getScene().meshes.length;y++){const v=this.getScene().meshes[y];v.parent===this&&v.clone(v.name,g)}return g.computeWorldMatrix(!0),this.onClonedObservable.notifyObservers(g),g}dispose(a,x=!1){this._sourceMesh.removeInstance(this),super.dispose(a,x)}_serializeAsParent(a){super._serializeAsParent(a),a.parentId=this._sourceMesh.uniqueId,a.parentInstanceIndex=this._indexInSourceMeshInstanceArray}instantiateHierarchy(a=null,x,c){const u=this.clone("Clone of "+(this.name||this.id),a||this.parent,!0,x&&x.newSourcedMesh);u&&c&&c(this,u);for(const g of this.getChildTransformNodes(!0))g.instantiateHierarchy(u,x,c);return u}}sr.prototype.registerInstancedBuffer=function(F,a){if(this._userInstancedBuffersStorage?.vertexBuffers[F]?.dispose(),!this.instancedBuffers){this.instancedBuffers={};for(const x of this.instances)x.instancedBuffers={}}this._userInstancedBuffersStorage||(this._userInstancedBuffersStorage={data:{},vertexBuffers:{},strides:{},sizes:{},vertexArrayObjects:this.getEngine().getCaps().vertexArrayObject?{}:void 0}),this.instancedBuffers[F]=null,this._userInstancedBuffersStorage.strides[F]=a,this._userInstancedBuffersStorage.sizes[F]=a*32,this._userInstancedBuffersStorage.data[F]=new Float32Array(this._userInstancedBuffersStorage.sizes[F]),this._userInstancedBuffersStorage.vertexBuffers[F]=new Ve(this.getEngine(),this._userInstancedBuffersStorage.data[F],F,!0,!1,a,!0);for(const x of this.instances)x.instancedBuffers[F]=null;this._invalidateInstanceVertexArrayObject(),this._markSubMeshesAsAttributesDirty()},sr.prototype._processInstancedBuffers=function(F,a){const x=F?F.length:0;for(const c in this.instancedBuffers){let u=this._userInstancedBuffersStorage.sizes[c];const g=this._userInstancedBuffersStorage.strides[c],y=(x+1)*g;for(;u<y;)u*=2;this._userInstancedBuffersStorage.data[c].length!=u&&(this._userInstancedBuffersStorage.data[c]=new Float32Array(u),this._userInstancedBuffersStorage.sizes[c]=u,this._userInstancedBuffersStorage.vertexBuffers[c]&&(this._userInstancedBuffersStorage.vertexBuffers[c].dispose(),this._userInstancedBuffersStorage.vertexBuffers[c]=null));const v=this._userInstancedBuffersStorage.data[c];let w=0;if(a){const B=this.instancedBuffers[c];B.toArray?B.toArray(v,w):B.copyToArray?B.copyToArray(v,w):v[w]=B,w+=g}for(let B=0;B<x;B++){const ae=F[B].instancedBuffers[c];ae.toArray?ae.toArray(v,w):ae.copyToArray?ae.copyToArray(v,w):v[w]=ae,w+=g}this._userInstancedBuffersStorage.vertexBuffers[c]?this._userInstancedBuffersStorage.vertexBuffers[c].updateDirectly(v,0):(this._userInstancedBuffersStorage.vertexBuffers[c]=new Ve(this.getEngine(),this._userInstancedBuffersStorage.data[c],c,!0,!1,g,!0),this._invalidateInstanceVertexArrayObject())}},sr.prototype._invalidateInstanceVertexArrayObject=function(){if(!(!this._userInstancedBuffersStorage||this._userInstancedBuffersStorage.vertexArrayObjects===void 0)){for(const F in this._userInstancedBuffersStorage.vertexArrayObjects)this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[F]);this._userInstancedBuffersStorage.vertexArrayObjects={}}},sr.prototype._disposeInstanceSpecificData=function(){for(this._instanceDataStorage.instancesBuffer&&(this._instanceDataStorage.instancesBuffer.dispose(),this._instanceDataStorage.instancesBuffer=null);this.instances.length;)this.instances[0].dispose();for(const F in this.instancedBuffers)this._userInstancedBuffersStorage.vertexBuffers[F]&&this._userInstancedBuffersStorage.vertexBuffers[F].dispose();this._invalidateInstanceVertexArrayObject(),this.instancedBuffers={}};class aF extends Wc{}class xF{constructor(){this.rootNodes=[],this.skeletons=[],this.animationGroups=[]}dispose(){this.rootNodes.slice(0).forEach(a=>{a.dispose()}),this.rootNodes.length=0,this.skeletons.slice(0).forEach(a=>{a.dispose()}),this.skeletons.length=0,this.animationGroups.slice(0).forEach(a=>{a.dispose()}),this.animationGroups.length=0}}class lF extends Wc{constructor(a){super(),this._wasAddedToScene=!1,a=a||tr.LastCreatedScene,a&&(this.scene=a,this.sounds=[],this.effectLayers=[],this.layers=[],this.lensFlareSystems=[],this.proceduralTextures=[],this.reflectionProbes=[],a.onDisposeObservable.add(()=>{this._wasAddedToScene||this.dispose()}),this._onContextRestoredObserver=a.getEngine().onContextRestoredObservable.add(()=>{for(const x of this.geometries)x._rebuild();for(const x of this.meshes)x._rebuild();for(const x of this.particleSystems)x.rebuild();for(const x of this.textures)x._rebuild()}))}_topologicalSort(a){const x=new Map;for(const v of a)x.set(v.uniqueId,v);const c={dependsOn:new Map,dependedBy:new Map};for(const v of a){const w=v.uniqueId;c.dependsOn.set(w,new Set),c.dependedBy.set(w,new Set)}for(const v of a){const w=v.uniqueId,B=c.dependsOn.get(w);if(v instanceof vw){const ae=v.sourceMesh;x.has(ae.uniqueId)&&(B.add(ae.uniqueId),c.dependedBy.get(ae.uniqueId).add(w))}const W=c.dependedBy.get(w);for(const ae of v.getDescendants()){const ue=ae.uniqueId;x.has(ue)&&(W.add(ue),c.dependsOn.get(ue).add(w))}}const u=[],g=[];for(const v of a){const w=v.uniqueId;c.dependsOn.get(w).size===0&&(g.push(v),x.delete(w))}const y=g;for(;y.length>0;){const v=y.shift();u.push(v);const w=c.dependedBy.get(v.uniqueId);for(const B of Array.from(w.values())){const W=c.dependsOn.get(B);W.delete(v.uniqueId),W.size===0&&x.get(B)&&(y.push(x.get(B)),x.delete(B))}}return x.size>0&&(Qt.Error("SceneSerializer._topologicalSort: There were unvisited nodes:"),x.forEach(v=>Qt.Error(v.name))),u}_addNodeAndDescendantsToList(a,x,c,u){if(!(!c||u&&!u(c)||x.has(c.uniqueId))){a.push(c),x.add(c.uniqueId);for(const g of c.getDescendants(!0))this._addNodeAndDescendantsToList(a,x,g,u)}}_isNodeInContainer(a){return a instanceof mo&&this.meshes.indexOf(a)!==-1||a instanceof $s&&this.transformNodes.indexOf(a)!==-1||a instanceof Wr&&this.lights.indexOf(a)!==-1||a instanceof gr&&this.cameras.indexOf(a)!==-1}_isValidHierarchy(){for(const a of this.meshes)if(a.parent&&!this._isNodeInContainer(a.parent))return Qt.Warn(`Node ${a.name} has a parent that is not in the container.`),!1;for(const a of this.transformNodes)if(a.parent&&!this._isNodeInContainer(a.parent))return Qt.Warn(`Node ${a.name} has a parent that is not in the container.`),!1;for(const a of this.lights)if(a.parent&&!this._isNodeInContainer(a.parent))return Qt.Warn(`Node ${a.name} has a parent that is not in the container.`),!1;for(const a of this.cameras)if(a.parent&&!this._isNodeInContainer(a.parent))return Qt.Warn(`Node ${a.name} has a parent that is not in the container.`),!1;return!0}instantiateModelsToScene(a,x=!1,c){this._isValidHierarchy()||_t.Warn("SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.");const u={},g={},y=new xF,v=[],w=[],B={doNotInstantiate:!0,...c},W=(_e,Be)=>{if(u[_e.uniqueId]=Be.uniqueId,g[Be.uniqueId]=Be,a&&(Be.name=a(_e.name)),Be instanceof sr){const tt=Be;if(tt.morphTargetManager){const $e=_e.morphTargetManager;tt.morphTargetManager=$e.clone();for(let Et=0;Et<$e.numTargets;Et++){const ft=$e.getTarget(Et),dt=tt.morphTargetManager.getTarget(Et);u[ft.uniqueId]=dt.uniqueId,g[dt.uniqueId]=dt}}}},ae=[],ue=new Set;for(const _e of this.transformNodes)_e.parent===null&&this._addNodeAndDescendantsToList(ae,ue,_e,B.predicate);for(const _e of this.meshes)_e.parent===null&&this._addNodeAndDescendantsToList(ae,ue,_e,B.predicate);const fe=this._topologicalSort(ae),Re=(_e,Be)=>{if(W(_e,Be),_e.parent){const tt=u[_e.parent.uniqueId],$e=g[tt];$e?Be.parent=$e:Be.parent=_e.parent}if(Be.position&&_e.position&&Be.position.copyFrom(_e.position),Be.rotationQuaternion&&_e.rotationQuaternion&&Be.rotationQuaternion.copyFrom(_e.rotationQuaternion),Be.rotation&&_e.rotation&&Be.rotation.copyFrom(_e.rotation),Be.scaling&&_e.scaling&&Be.scaling.copyFrom(_e.scaling),Be.material){const tt=Be;if(tt.material)if(x){const $e=_e.material;if(w.indexOf($e)===-1){let Et=$e.clone(a?a($e.name):"Clone of "+$e.name);if(w.push($e),u[$e.uniqueId]=Et.uniqueId,g[Et.uniqueId]=Et,$e.getClassName()==="MultiMaterial"){const ft=$e;for(const dt of ft.subMaterials)dt&&(Et=dt.clone(a?a(dt.name):"Clone of "+dt.name),w.push(dt),u[dt.uniqueId]=Et.uniqueId,g[Et.uniqueId]=Et);ft.subMaterials=ft.subMaterials.map(dt=>dt&&g[u[dt.uniqueId]])}}tt.getClassName()!=="InstancedMesh"&&(tt.material=g[u[$e.uniqueId]])}else tt.material.getClassName()==="MultiMaterial"?this.scene.multiMaterials.indexOf(tt.material)===-1&&this.scene.addMultiMaterial(tt.material):this.scene.materials.indexOf(tt.material)===-1&&this.scene.addMaterial(tt.material)}Be.parent===null&&y.rootNodes.push(Be)};return fe.forEach(_e=>{if(_e.getClassName()==="InstancedMesh"){const Be=_e,tt=Be.sourceMesh,$e=u[tt.uniqueId],ft=(typeof $e=="number"?g[$e]:tt).createInstance(Be.name);Re(Be,ft)}else{let Be=!0;_e.getClassName()==="TransformNode"||_e.getClassName()==="Node"||_e.skeleton||!_e.getTotalVertices||_e.getTotalVertices()===0?Be=!1:B.doNotInstantiate&&(typeof B.doNotInstantiate=="function"?Be=!B.doNotInstantiate(_e):Be=!B.doNotInstantiate);const tt=Be?_e.createInstance(`instance of ${_e.name}`):_e.clone(`Clone of ${_e.name}`,null,!0);if(!tt)throw new Error(`Could not clone or instantiate node on Asset Container ${_e.name}`);Re(_e,tt)}}),this.skeletons.forEach(_e=>{if(B.predicate&&!B.predicate(_e))return;const Be=_e.clone(a?a(_e.name):"Clone of "+_e.name);for(const tt of this.meshes)if(tt.skeleton===_e&&!tt.isAnInstance){const $e=g[u[tt.uniqueId]];if(!$e||$e.isAnInstance||($e.skeleton=Be,v.indexOf(Be)!==-1))continue;v.push(Be);for(const Et of Be.bones)Et._linkedTransformNode&&(Et._linkedTransformNode=g[u[Et._linkedTransformNode.uniqueId]])}y.skeletons.push(Be)}),this.animationGroups.forEach(_e=>{if(B.predicate&&!B.predicate(_e))return;const Be=_e.clone(a?a(_e.name):"Clone of "+_e.name,tt=>g[u[tt.uniqueId]]||tt);y.animationGroups.push(Be)}),y}addAllToScene(){if(!this._wasAddedToScene){this._isValidHierarchy()||_t.Warn("SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid."),this._wasAddedToScene=!0,this.addToScene(null),this.environmentTexture&&(this.scene.environmentTexture=this.environmentTexture);for(const a of this.scene._serializableComponents)a.addFromContainer(this);this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null}}addToScene(a=null){const x=[];this.cameras.forEach(c=>{a&&!a(c)||(this.scene.addCamera(c),x.push(c))}),this.lights.forEach(c=>{a&&!a(c)||(this.scene.addLight(c),x.push(c))}),this.meshes.forEach(c=>{a&&!a(c)||(this.scene.addMesh(c),x.push(c))}),this.skeletons.forEach(c=>{a&&!a(c)||this.scene.addSkeleton(c)}),this.animations.forEach(c=>{a&&!a(c)||this.scene.addAnimation(c)}),this.animationGroups.forEach(c=>{a&&!a(c)||this.scene.addAnimationGroup(c)}),this.multiMaterials.forEach(c=>{a&&!a(c)||this.scene.addMultiMaterial(c)}),this.materials.forEach(c=>{a&&!a(c)||this.scene.addMaterial(c)}),this.morphTargetManagers.forEach(c=>{a&&!a(c)||this.scene.addMorphTargetManager(c)}),this.geometries.forEach(c=>{a&&!a(c)||this.scene.addGeometry(c)}),this.transformNodes.forEach(c=>{a&&!a(c)||(this.scene.addTransformNode(c),x.push(c))}),this.actionManagers.forEach(c=>{a&&!a(c)||this.scene.addActionManager(c)}),this.textures.forEach(c=>{a&&!a(c)||this.scene.addTexture(c)}),this.reflectionProbes.forEach(c=>{a&&!a(c)||this.scene.addReflectionProbe(c)});for(const c of x)c.parent&&this.scene.getNodes().indexOf(c.parent)===-1&&(c.setParent?c.setParent(null):c.parent=null)}removeAllFromScene(){this._isValidHierarchy()||_t.Warn("SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid."),this._wasAddedToScene=!1,this.removeFromScene(null),this.environmentTexture===this.scene.environmentTexture&&(this.scene.environmentTexture=null);for(const a of this.scene._serializableComponents)a.removeFromContainer(this)}removeFromScene(a=null){this.cameras.forEach(x=>{a&&!a(x)||this.scene.removeCamera(x)}),this.lights.forEach(x=>{a&&!a(x)||this.scene.removeLight(x)}),this.meshes.forEach(x=>{a&&!a(x)||this.scene.removeMesh(x,!0)}),this.skeletons.forEach(x=>{a&&!a(x)||this.scene.removeSkeleton(x)}),this.animations.forEach(x=>{a&&!a(x)||this.scene.removeAnimation(x)}),this.animationGroups.forEach(x=>{a&&!a(x)||this.scene.removeAnimationGroup(x)}),this.multiMaterials.forEach(x=>{a&&!a(x)||this.scene.removeMultiMaterial(x)}),this.materials.forEach(x=>{a&&!a(x)||this.scene.removeMaterial(x)}),this.morphTargetManagers.forEach(x=>{a&&!a(x)||this.scene.removeMorphTargetManager(x)}),this.geometries.forEach(x=>{a&&!a(x)||this.scene.removeGeometry(x)}),this.transformNodes.forEach(x=>{a&&!a(x)||this.scene.removeTransformNode(x)}),this.actionManagers.forEach(x=>{a&&!a(x)||this.scene.removeActionManager(x)}),this.textures.forEach(x=>{a&&!a(x)||this.scene.removeTexture(x)}),this.reflectionProbes.forEach(x=>{a&&!a(x)||this.scene.removeReflectionProbe(x)})}dispose(){this.cameras.slice(0).forEach(a=>{a.dispose()}),this.cameras.length=0,this.lights.slice(0).forEach(a=>{a.dispose()}),this.lights.length=0,this.meshes.slice(0).forEach(a=>{a.dispose()}),this.meshes.length=0,this.skeletons.slice(0).forEach(a=>{a.dispose()}),this.skeletons.length=0,this.animationGroups.slice(0).forEach(a=>{a.dispose()}),this.animationGroups.length=0,this.multiMaterials.slice(0).forEach(a=>{a.dispose()}),this.multiMaterials.length=0,this.materials.slice(0).forEach(a=>{a.dispose()}),this.materials.length=0,this.geometries.slice(0).forEach(a=>{a.dispose()}),this.geometries.length=0,this.transformNodes.slice(0).forEach(a=>{a.dispose()}),this.transformNodes.length=0,this.actionManagers.slice(0).forEach(a=>{a.dispose()}),this.actionManagers.length=0,this.textures.slice(0).forEach(a=>{a.dispose()}),this.textures.length=0,this.reflectionProbes.slice(0).forEach(a=>{a.dispose()}),this.reflectionProbes.length=0,this.morphTargetManagers.slice(0).forEach(a=>{a.dispose()}),this.morphTargetManagers.length=0,this.environmentTexture&&(this.environmentTexture.dispose(),this.environmentTexture=null);for(const a of this.scene._serializableComponents)a.removeFromContainer(this,!0);this._onContextRestoredObserver&&(this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}_moveAssets(a,x,c){if(!(!a||!x))for(const u of a){let g=!0;if(c){for(const y of c)if(u===y){g=!1;break}}g&&(x.push(u),u._parentContainer=this)}}moveAllFromScene(a){this._wasAddedToScene=!1,a===void 0&&(a=new aF);for(const x in this)Object.prototype.hasOwnProperty.call(this,x)&&(this[x]=this[x]||(x==="_environmentTexture"?null:[]),this._moveAssets(this.scene[x],this[x],a[x]));this.environmentTexture=this.scene.environmentTexture,this.removeAllFromScene()}createRootMesh(){const a=new sr("assetContainerRootMesh",this.scene);return this.meshes.forEach(x=>{x.parent||a.addChild(x)}),this.meshes.unshift(a),a}mergeAnimationsTo(a=tr.LastCreatedScene,x,c=null){if(!a)return Qt.Error("No scene available to merge animations to"),[];const u=c||(v=>{let w=null;const B=v.animations.length?v.animations[0].targetProperty:"",W=v.name.split(".").join("").split("_primitive")[0];switch(B){case"position":case"rotationQuaternion":w=a.getTransformNodeByName(v.name)||a.getTransformNodeByName(W);break;case"influence":w=a.getMorphTargetByName(v.name)||a.getMorphTargetByName(W);break;default:w=a.getNodeByName(v.name)||a.getNodeByName(W)}return w});this.getNodes().forEach(v=>{const w=u(v);if(w!==null){for(const B of v.animations){const W=w.animations.filter(ae=>ae.targetProperty===B.targetProperty);for(const ae of W){const ue=w.animations.indexOf(ae,0);ue>-1&&w.animations.splice(ue,1)}}w.animations=w.animations.concat(v.animations)}});const y=[];return this.animationGroups.slice().forEach(v=>{y.push(v.clone(v.name,u)),v.animatables.forEach(w=>{w.stop()})}),x.forEach(v=>{const w=u(v.target);w&&(a.beginAnimation(w,v.fromFrame,v.toFrame,v.loopAnimation,v.speedRatio,v.onAnimationEnd?v.onAnimationEnd:void 0,void 0,!0,void 0,v.onAnimationLoop?v.onAnimationLoop:void 0),a.stopAnimation(v.target))}),y}populateRootNodes(){this.rootNodes.length=0,this.meshes.forEach(a=>{!a.parent&&this.rootNodes.indexOf(a)===-1&&this.rootNodes.push(a)}),this.transformNodes.forEach(a=>{!a.parent&&this.rootNodes.indexOf(a)===-1&&this.rootNodes.push(a)}),this.lights.forEach(a=>{!a.parent&&this.rootNodes.indexOf(a)===-1&&this.rootNodes.push(a)}),this.cameras.forEach(a=>{!a.parent&&this.rootNodes.indexOf(a)===-1&&this.rootNodes.push(a)})}addAllAssetsToContainer(a){if(!a)return;const x=[],c=new Set;for(x.push(a);x.length>0;){const u=x.pop();if(u instanceof sr?(u.geometry&&this.geometries.indexOf(u.geometry)===-1&&this.geometries.push(u.geometry),this.meshes.push(u)):u instanceof $s?this.transformNodes.push(u):u instanceof Wr?this.lights.push(u):u instanceof gr&&this.cameras.push(u),u instanceof mo){if(u.material&&this.materials.indexOf(u.material)===-1){this.materials.push(u.material);for(const g of u.material.getActiveTextures())this.textures.indexOf(g)===-1&&this.textures.push(g)}u.skeleton&&this.skeletons.indexOf(u.skeleton)===-1&&this.skeletons.push(u.skeleton),u.morphTargetManager&&this.morphTargetManagers.indexOf(u.morphTargetManager)===-1&&this.morphTargetManagers.push(u.morphTargetManager)}for(const g of u.getChildren())c.has(g)||x.push(g);c.add(u)}this.populateRootNodes()}}class Bg{constructor(a){this.byteOffset=0,this.buffer=a}loadAsync(a){return this.buffer.readAsync(this.byteOffset,a).then(x=>{this._dataView=new DataView(x.buffer,x.byteOffset,x.byteLength),this._dataByteOffset=0})}readUint32(){const a=this._dataView.getUint32(this._dataByteOffset,!0);return this._dataByteOffset+=4,this.byteOffset+=4,a}readUint8Array(a){const x=new Uint8Array(this._dataView.buffer,this._dataView.byteOffset+this._dataByteOffset,a);return this._dataByteOffset+=a,this.byteOffset+=a,x}readString(a){return Rc(this.readUint8Array(a))}skipBytes(a){this._dataByteOffset+=a,this.byteOffset+=a}}function R_(F,a,x,c){const u={externalResourceFunction:c};return x&&(u.uri=a==="file:"?x:a+x),ArrayBuffer.isView(F)?GLTFValidator.validateBytes(F,u):GLTFValidator.validateString(F,u)}function hF(){const F=[];onmessage=a=>{const x=a.data;switch(x.id){case"init":{importScripts(x.url);break}case"validate":{R_(x.data,x.rootUrl,x.fileName,c=>new Promise((u,g)=>{const y=F.length;F.push({resolve:u,reject:g}),postMessage({id:"getExternalResource",index:y,uri:c})})).then(c=>{postMessage({id:"validate.resolve",value:c})},c=>{postMessage({id:"validate.reject",reason:c})});break}case"getExternalResource.resolve":{F[x.index].resolve(x.value);break}case"getExternalResource.reject":{F[x.index].reject(x.reason);break}}}}class Iw{static ValidateAsync(a,x,c,u){return typeof Worker=="function"?new Promise((g,y)=>{const v=`${R_}(${hF})()`,w=URL.createObjectURL(new Blob([v],{type:"application/javascript"})),B=new Worker(w),W=ue=>{B.removeEventListener("error",W),B.removeEventListener("message",ae),y(ue)},ae=ue=>{const fe=ue.data;switch(fe.id){case"getExternalResource":{u(fe.uri).then(Re=>{B.postMessage({id:"getExternalResource.resolve",index:fe.index,value:Re},[Re])},Re=>{B.postMessage({id:"getExternalResource.reject",index:fe.index,reason:Re})});break}case"validate.resolve":{B.removeEventListener("error",W),B.removeEventListener("message",ae),g(fe.value),B.terminate();break}case"validate.reject":B.removeEventListener("error",W),B.removeEventListener("message",ae),y(fe.reason),B.terminate()}};if(B.addEventListener("error",W),B.addEventListener("message",ae),B.postMessage({id:"init",url:_t.GetBabylonScriptURL(this.Configuration.url)}),ArrayBuffer.isView(a)){const ue=a.slice();B.postMessage({id:"validate",data:ue,rootUrl:x,fileName:c},[ue.buffer])}else B.postMessage({id:"validate",data:a,rootUrl:x,fileName:c})}):(this._LoadScriptPromise||(this._LoadScriptPromise=_t.LoadBabylonScriptAsync(this.Configuration.url)),this._LoadScriptPromise.then(()=>R_(a,x,c,u)))}}Iw.Configuration={url:`${_t._DefaultCdnUrl}/gltf_validator.js`};function Rw(F,a,x){try{return Promise.resolve(new Uint8Array(F,a,x))}catch(c){return Promise.reject(c)}}function uF(F,a,x){try{if(a<0||a>=F.byteLength)throw new RangeError("Offset is out of range.");if(a+x>F.byteLength)throw new RangeError("Length is out of range.");return Promise.resolve(new Uint8Array(F.buffer,F.byteOffset+a,x))}catch(c){return Promise.reject(c)}}var mm;(function(F){F[F.AUTO=0]="AUTO",F[F.FORCE_RIGHT_HANDED=1]="FORCE_RIGHT_HANDED"})(mm||(mm={}));var $u;(function(F){F[F.NONE=0]="NONE",F[F.FIRST=1]="FIRST",F[F.ALL=2]="ALL"})($u||($u={}));var _x;(function(F){F[F.LOADING=0]="LOADING",F[F.READY=1]="READY",F[F.COMPLETE=2]="COMPLETE"})(_x||(_x={}));class M0{constructor(){this.onParsedObservable=new Jt,this.coordinateSystemMode=mm.AUTO,this.animationStartMode=$u.FIRST,this.compileMaterials=!1,this.useClipPlane=!1,this.compileShadowGenerators=!1,this.transparencyAsCoverage=!1,this.useRangeRequests=!1,this.createInstances=!0,this.alwaysComputeBoundingBox=!1,this.loadAllMaterials=!1,this.loadOnlyMaterials=!1,this.skipMaterials=!1,this.useSRGBBuffers=!0,this.targetFps=60,this.alwaysComputeSkeletonRootNode=!1,this.preprocessUrlAsync=a=>Promise.resolve(a),this.onMeshLoadedObservable=new Jt,this.onSkinLoadedObservable=new Jt,this.onTextureLoadedObservable=new Jt,this.onMaterialLoadedObservable=new Jt,this.onCameraLoadedObservable=new Jt,this.onCompleteObservable=new Jt,this.onErrorObservable=new Jt,this.onDisposeObservable=new Jt,this.onExtensionLoadedObservable=new Jt,this.validate=!1,this.onValidatedObservable=new Jt,this._loader=null,this._state=null,this._requests=new Array,this.name="gltf",this.extensions={".gltf":{isBinary:!1},".glb":{isBinary:!0}},this.onLoaderStateChangedObservable=new Jt,this._logIndentLevel=0,this._loggingEnabled=!1,this._log=this._logDisabled,this._capturePerformanceCounters=!1,this._startPerformanceCounter=this._startPerformanceCounterDisabled,this._endPerformanceCounter=this._endPerformanceCounterDisabled}set onParsed(a){this._onParsedObserver&&this.onParsedObservable.remove(this._onParsedObserver),this._onParsedObserver=this.onParsedObservable.add(a)}set onMeshLoaded(a){this._onMeshLoadedObserver&&this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver),this._onMeshLoadedObserver=this.onMeshLoadedObservable.add(a)}set onTextureLoaded(a){this._onTextureLoadedObserver&&this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver),this._onTextureLoadedObserver=this.onTextureLoadedObservable.add(a)}set onMaterialLoaded(a){this._onMaterialLoadedObserver&&this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver),this._onMaterialLoadedObserver=this.onMaterialLoadedObservable.add(a)}set onCameraLoaded(a){this._onCameraLoadedObserver&&this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver),this._onCameraLoadedObserver=this.onCameraLoadedObservable.add(a)}set onComplete(a){this._onCompleteObserver&&this.onCompleteObservable.remove(this._onCompleteObserver),this._onCompleteObserver=this.onCompleteObservable.add(a)}set onError(a){this._onErrorObserver&&this.onErrorObservable.remove(this._onErrorObserver),this._onErrorObserver=this.onErrorObservable.add(a)}set onDispose(a){this._onDisposeObserver&&this.onDisposeObservable.remove(this._onDisposeObserver),this._onDisposeObserver=this.onDisposeObservable.add(a)}set onExtensionLoaded(a){this._onExtensionLoadedObserver&&this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver),this._onExtensionLoadedObserver=this.onExtensionLoadedObservable.add(a)}get loggingEnabled(){return this._loggingEnabled}set loggingEnabled(a){this._loggingEnabled!==a&&(this._loggingEnabled=a,this._loggingEnabled?this._log=this._logEnabled:this._log=this._logDisabled)}get capturePerformanceCounters(){return this._capturePerformanceCounters}set capturePerformanceCounters(a){this._capturePerformanceCounters!==a&&(this._capturePerformanceCounters=a,this._capturePerformanceCounters?(this._startPerformanceCounter=this._startPerformanceCounterEnabled,this._endPerformanceCounter=this._endPerformanceCounterEnabled):(this._startPerformanceCounter=this._startPerformanceCounterDisabled,this._endPerformanceCounter=this._endPerformanceCounterDisabled))}set onValidated(a){this._onValidatedObserver&&this.onValidatedObservable.remove(this._onValidatedObserver),this._onValidatedObserver=this.onValidatedObservable.add(a)}dispose(){this._loader&&(this._loader.dispose(),this._loader=null);for(const a of this._requests)a.abort();this._requests.length=0,delete this._progressCallback,this.preprocessUrlAsync=a=>Promise.resolve(a),this.onMeshLoadedObservable.clear(),this.onSkinLoadedObservable.clear(),this.onTextureLoadedObservable.clear(),this.onMaterialLoadedObservable.clear(),this.onCameraLoadedObservable.clear(),this.onCompleteObservable.clear(),this.onExtensionLoadedObservable.clear(),this.onDisposeObservable.notifyObservers(void 0),this.onDisposeObservable.clear()}loadFile(a,x,c,u,g,y,v,w){if(ArrayBuffer.isView(x))return this._loadBinary(a,x,c,u,v,w),null;this._progressCallback=g;const B=x.name||_t.GetFilename(x);if(y){if(this.useRangeRequests){this.validate&&Qt.Warn("glTF validation is not supported when range requests are enabled");const W={abort:()=>{},onCompleteObservable:new Jt},ae={readAsync:(ue,fe)=>new Promise((Re,_e)=>{this._loadFile(a,x,Be=>{Re(new Uint8Array(Be))},!0,Be=>{_e(Be)},Be=>{Be.setRequestHeader("Range",`bytes=${ue}-${ue+fe-1}`)})}),byteLength:0};return this._unpackBinaryAsync(new Bg(ae)).then(ue=>{W.onCompleteObservable.notifyObservers(W),u(ue)},v?ue=>v(void 0,ue):void 0),W}return this._loadFile(a,x,W=>{this._validate(a,new Uint8Array(W,0,W.byteLength),c,B),this._unpackBinaryAsync(new Bg({readAsync:(ae,ue)=>Rw(W,ae,ue),byteLength:W.byteLength})).then(ae=>{u(ae)},v?ae=>v(void 0,ae):void 0)},!0,v)}else return this._loadFile(a,x,W=>{this._validate(a,W,c,B),u({json:this._parseJson(W)})},!1,v)}_loadBinary(a,x,c,u,g,y){this._validate(a,new Uint8Array(x.buffer,x.byteOffset,x.byteLength),c,y),this._unpackBinaryAsync(new Bg({readAsync:(v,w)=>uF(x,v,w),byteLength:x.byteLength})).then(v=>{u(v)},g?v=>g(void 0,v):void 0)}importMeshAsync(a,x,c,u,g,y){return Promise.resolve().then(()=>(this.onParsedObservable.notifyObservers(c),this.onParsedObservable.clear(),this._log(`Loading ${y||""}`),this._loader=this._getLoader(c),this._loader.importMeshAsync(a,x,null,c,u,g,y)))}loadAsync(a,x,c,u,g){return Promise.resolve().then(()=>(this.onParsedObservable.notifyObservers(x),this.onParsedObservable.clear(),this._log(`Loading ${g||""}`),this._loader=this._getLoader(x),this._loader.loadAsync(a,x,c,u,g)))}loadAssetContainerAsync(a,x,c,u,g){return Promise.resolve().then(()=>{this.onParsedObservable.notifyObservers(x),this.onParsedObservable.clear(),this._log(`Loading ${g||""}`),this._loader=this._getLoader(x);const y=new lF(a),v=[];this.onMaterialLoadedObservable.add(ae=>{v.push(ae)});const w=[];this.onTextureLoadedObservable.add(ae=>{w.push(ae)});const B=[];this.onCameraLoadedObservable.add(ae=>{B.push(ae)});const W=[];return this.onMeshLoadedObservable.add(ae=>{ae.morphTargetManager&&W.push(ae.morphTargetManager)}),this._loader.importMeshAsync(null,a,y,x,c,u,g).then(ae=>(Array.prototype.push.apply(y.geometries,ae.geometries),Array.prototype.push.apply(y.meshes,ae.meshes),Array.prototype.push.apply(y.particleSystems,ae.particleSystems),Array.prototype.push.apply(y.skeletons,ae.skeletons),Array.prototype.push.apply(y.animationGroups,ae.animationGroups),Array.prototype.push.apply(y.materials,v),Array.prototype.push.apply(y.textures,w),Array.prototype.push.apply(y.lights,ae.lights),Array.prototype.push.apply(y.transformNodes,ae.transformNodes),Array.prototype.push.apply(y.cameras,B),Array.prototype.push.apply(y.morphTargetManagers,W),y))})}canDirectLoad(a){return a.indexOf("asset")!==-1&&a.indexOf("version")!==-1||a.startsWith("data:base64,"+M0._MagicBase64Encoded)||a.startsWith("data:;base64,"+M0._MagicBase64Encoded)||a.startsWith("data:application/octet-stream;base64,"+M0._MagicBase64Encoded)||a.startsWith("data:model/gltf-binary;base64,"+M0._MagicBase64Encoded)}directLoad(a,x){if(x.startsWith("base64,"+M0._MagicBase64Encoded)||x.startsWith(";base64,"+M0._MagicBase64Encoded)||x.startsWith("application/octet-stream;base64,"+M0._MagicBase64Encoded)||x.startsWith("model/gltf-binary;base64,"+M0._MagicBase64Encoded)){const c=El(x);return this._validate(a,new Uint8Array(c,0,c.byteLength)),this._unpackBinaryAsync(new Bg({readAsync:(u,g)=>Rw(c,u,g),byteLength:c.byteLength}))}return this._validate(a,x),Promise.resolve({json:this._parseJson(x)})}createPlugin(){return new M0}get loaderState(){return this._state}whenCompleteAsync(){return new Promise((a,x)=>{this.onCompleteObservable.addOnce(()=>{a()}),this.onErrorObservable.addOnce(c=>{x(c)})})}_setState(a){this._state!==a&&(this._state=a,this.onLoaderStateChangedObservable.notifyObservers(this._state),this._log(_x[this._state]))}_loadFile(a,x,c,u,g,y){const v=a._loadFile(x,c,w=>{this._onProgress(w,v)},!0,u,g,y);return v.onCompleteObservable.add(w=>{this._requests.splice(this._requests.indexOf(w),1)}),this._requests.push(v),v}_onProgress(a,x){if(!this._progressCallback)return;x._lengthComputable=a.lengthComputable,x._loaded=a.loaded,x._total=a.total;let c=!0,u=0,g=0;for(const y of this._requests){if(y._lengthComputable===void 0||y._loaded===void 0||y._total===void 0)return;c=c&&y._lengthComputable,u+=y._loaded,g+=y._total}this._progressCallback({lengthComputable:c,loaded:u,total:c?g:0})}_validate(a,x,c="",u=""){this.validate&&(this._startPerformanceCounter("Validate JSON"),Iw.ValidateAsync(x,c,u,g=>this.preprocessUrlAsync(c+g).then(y=>a._loadFileAsync(y,void 0,!0,!0).then(v=>new Uint8Array(v,0,v.byteLength)))).then(g=>{this._endPerformanceCounter("Validate JSON"),this.onValidatedObservable.notifyObservers(g),this.onValidatedObservable.clear()},g=>{this._endPerformanceCounter("Validate JSON"),_t.Warn(`Failed to validate: ${g.message}`),this.onValidatedObservable.clear()}))}_getLoader(a){const x=a.json.asset||{};this._log(`Asset version: ${x.version}`),x.minVersion&&this._log(`Asset minimum version: ${x.minVersion}`),x.generator&&this._log(`Asset generator: ${x.generator}`);const c=M0._parseVersion(x.version);if(!c)throw new Error("Invalid version: "+x.version);if(x.minVersion!==void 0){const y=M0._parseVersion(x.minVersion);if(!y)throw new Error("Invalid minimum version: "+x.minVersion);if(M0._compareVersion(y,{major:2,minor:0})>0)throw new Error("Incompatible minimum version: "+x.minVersion)}const g={1:M0._CreateGLTF1Loader,2:M0._CreateGLTF2Loader}[c.major];if(!g)throw new Error("Unsupported version: "+x.version);return g(this)}_parseJson(a){this._startPerformanceCounter("Parse JSON"),this._log(`JSON length: ${a.length}`);const x=JSON.parse(a);return this._endPerformanceCounter("Parse JSON"),x}_unpackBinaryAsync(a){return this._startPerformanceCounter("Unpack Binary"),a.loadAsync(20).then(()=>{const x={Magic:1179937895},c=a.readUint32();if(c!==x.Magic)throw new Xo("Unexpected magic: "+c,Ho.GLTFLoaderUnexpectedMagicError);const u=a.readUint32();this.loggingEnabled&&this._log(`Binary version: ${u}`);const g=a.readUint32();!this.useRangeRequests&&g!==a.buffer.byteLength&&Qt.Warn(`Length in header does not match actual data length: ${g} != ${a.buffer.byteLength}`);let y;switch(u){case 1:{y=this._unpackBinaryV1Async(a,g);break}case 2:{y=this._unpackBinaryV2Async(a,g);break}default:throw new Error("Unsupported version: "+u)}return this._endPerformanceCounter("Unpack Binary"),y})}_unpackBinaryV1Async(a,x){const c={JSON:0},u=a.readUint32(),g=a.readUint32();if(g!==c.JSON)throw new Error(`Unexpected content format: ${g}`);const y=x-a.byteOffset,v={json:this._parseJson(a.readString(u)),bin:null};if(y!==0){const w=a.byteOffset;v.bin={readAsync:(B,W)=>a.buffer.readAsync(w+B,W),byteLength:y}}return Promise.resolve(v)}_unpackBinaryV2Async(a,x){const c={JSON:1313821514,BIN:5130562},u=a.readUint32();if(a.readUint32()!==c.JSON)throw new Error("First chunk format is not JSON");return a.byteOffset+u===x?a.loadAsync(u).then(()=>({json:this._parseJson(a.readString(u)),bin:null})):a.loadAsync(u+8).then(()=>{const y={json:this._parseJson(a.readString(u)),bin:null},v=()=>{const w=a.readUint32();switch(a.readUint32()){case c.JSON:throw new Error("Unexpected JSON chunk");case c.BIN:{const W=a.byteOffset;y.bin={readAsync:(ae,ue)=>a.buffer.readAsync(W+ae,ue),byteLength:w},a.skipBytes(w);break}default:{a.skipBytes(w);break}}return a.byteOffset!==x?a.loadAsync(8).then(v):Promise.resolve(y)};return v()})}static _parseVersion(a){if(a==="1.0"||a==="1.0.1")return{major:1,minor:0};const x=(a+"").match(/^(\d+)\.(\d+)/);return x?{major:parseInt(x[1]),minor:parseInt(x[2])}:null}static _compareVersion(a,x){return a.major>x.major?1:a.major<x.major?-1:a.minor>x.minor?1:a.minor<x.minor?-1:0}_logOpen(a){this._log(a),this._logIndentLevel++}_logClose(){--this._logIndentLevel}_logEnabled(a){const x=M0._logSpaces.substr(0,this._logIndentLevel*2);Qt.Log(`${x}${a}`)}_logDisabled(a){}_startPerformanceCounterEnabled(a){_t.StartPerformanceCounter(a)}_startPerformanceCounterDisabled(a){}_endPerformanceCounterEnabled(a){_t.EndPerformanceCounter(a)}_endPerformanceCounterDisabled(a){}}M0.IncrementalLoading=!0,M0.HomogeneousCoordinates=!1,M0._MagicBase64Encoded="Z2xURg",M0._logSpaces="                                ",ln&&ln.RegisterPlugin(new M0);function Mw(F,a,x,c){return Ee.FromArray(a,x).scaleInPlace(c)}function dF(F,a,x,c){return Wi.FromArray(a,x).scaleInPlace(c)}function fF(F,a,x,c){const u=new Array(F._numMorphTargets);for(let g=0;g<u.length;g++)u[g]=a[x++]*c;return u}class gm{constructor(a,x,c,u){this.type=a,this.name=x,this.getValue=c,this.getStride=u}_buildAnimation(a,x,c){const u=new xi(a,this.name,x,this.type);return u.setKeys(c),u}}class M_ extends gm{buildAnimations(a,x,c,u,g){g(a._babylonTransformNode,this._buildAnimation(x,c,u))}}class mF extends gm{buildAnimations(a,x,c,u,g){if(a._numMorphTargets)for(let y=0;y<a._numMorphTargets;y++){const v=new xi(`${x}_${y}`,this.name,c,this.type);if(v.setKeys(u.map(w=>({frame:w.frame,inTangent:w.inTangent?w.inTangent[y]:void 0,value:w.value[y],outTangent:w.outTangent?w.outTangent[y]:void 0,interpolation:w.interpolation}))),a._primitiveBabylonMeshes){for(const w of a._primitiveBabylonMeshes)if(w.morphTargetManager){const B=w.morphTargetManager.getTarget(y),W=v.clone();B.animations.push(W),g(B,W)}}}}}const _m={translation:[new M_(xi.ANIMATIONTYPE_VECTOR3,"position",Mw,()=>3)],rotation:[new M_(xi.ANIMATIONTYPE_QUATERNION,"rotationQuaternion",dF,()=>4)],scale:[new M_(xi.ANIMATIONTYPE_VECTOR3,"scaling",Mw,()=>3)],weights:[new mF(xi.ANIMATIONTYPE_FLOAT,"influence",fF,F=>F._numMorphTargets)]};function Bw(...F){const a=x=>x&&typeof x=="object";return F.reduce((x,c)=>(Object.keys(c).forEach(u=>{const g=x[u],y=c[u];Array.isArray(g)&&Array.isArray(y)?x[u]=g.concat(...y):a(g)&&a(y)?x[u]=Bw(g,y):x[u]=y}),x),{})}class lr{static Get(a,x,c){if(!x||c==null||!x[c])throw new Error(`${a}: Failed to find index (${c})`);return x[c]}static TryGet(a,x){return!a||x==null||!a[x]?null:a[x]}static Assign(a){if(a)for(let x=0;x<a.length;x++)a[x].index=x}}class _s{static RegisterExtension(a,x){_s.UnregisterExtension(a)&&Qt.Warn(`Extension with the name '${a}' already exists`),_s._RegisteredExtensions[a]={factory:x}}static UnregisterExtension(a){return _s._RegisteredExtensions[a]?(delete _s._RegisteredExtensions[a],!0):!1}get gltf(){if(!this._gltf)throw new Error("glTF JSON is not available");return this._gltf}get bin(){return this._bin}get parent(){return this._parent}get babylonScene(){if(!this._babylonScene)throw new Error("Scene is not available");return this._babylonScene}get rootBabylonMesh(){return this._rootBabylonMesh}get rootUrl(){return this._rootUrl}constructor(a){this._completePromises=new Array,this._assetContainer=null,this._babylonLights=[],this._disableInstancedMesh=0,this._allMaterialsDirtyRequired=!1,this._extensions=new Array,this._disposed=!1,this._rootUrl=null,this._fileName=null,this._uniqueRootUrl=null,this._bin=null,this._rootBabylonMesh=null,this._defaultBabylonMaterialData={},this._postSceneLoadActions=new Array,this._parent=a}dispose(){this._disposed||(this._disposed=!0,this._completePromises.length=0,this._extensions.forEach(a=>a.dispose&&a.dispose()),this._extensions.length=0,this._gltf=null,this._bin=null,this._babylonScene=null,this._rootBabylonMesh=null,this._defaultBabylonMaterialData={},this._postSceneLoadActions.length=0,this._parent.dispose())}importMeshAsync(a,x,c,u,g,y,v=""){return Promise.resolve().then(()=>{this._babylonScene=x,this._assetContainer=c,this._loadData(u);let w=null;if(a){const B={};if(this._gltf.nodes)for(const ae of this._gltf.nodes)ae.name&&(B[ae.name]=ae.index);w=(a instanceof Array?a:[a]).map(ae=>{const ue=B[ae];if(ue===void 0)throw new Error(`Failed to find node '${ae}'`);return ue})}return this._loadAsync(g,v,w,()=>({meshes:this._getMeshes(),particleSystems:[],skeletons:this._getSkeletons(),animationGroups:this._getAnimationGroups(),lights:this._babylonLights,transformNodes:this._getTransformNodes(),geometries:this._getGeometries(),spriteManagers:[]}))})}loadAsync(a,x,c,u,g=""){return Promise.resolve().then(()=>(this._babylonScene=a,this._loadData(x),this._loadAsync(c,g,null,()=>{})))}_loadAsync(a,x,c,u){return Promise.resolve().then(()=>{this._rootUrl=a,this._uniqueRootUrl=!a.startsWith("file:")&&x?a:`${a}${Date.now()}/`,this._fileName=x,this._allMaterialsDirtyRequired=!1,this._loadExtensions(),this._checkExtensions();const g=`${_x[_x.LOADING]} => ${_x[_x.READY]}`,y=`${_x[_x.LOADING]} => ${_x[_x.COMPLETE]}`;this._parent._startPerformanceCounter(g),this._parent._startPerformanceCounter(y),this._parent._setState(_x.LOADING),this._extensionsOnLoading();const v=new Array,w=this._babylonScene.blockMaterialDirtyMechanism;if(this._babylonScene.blockMaterialDirtyMechanism=!0,!this.parent.loadOnlyMaterials){if(c)v.push(this.loadSceneAsync("/nodes",{nodes:c,index:-1}));else if(this._gltf.scene!=null||this._gltf.scenes&&this._gltf.scenes[0]){const W=lr.Get("/scene",this._gltf.scenes,this._gltf.scene||0);v.push(this.loadSceneAsync(`/scenes/${W.index}`,W))}}if(!this.parent.skipMaterials&&this.parent.loadAllMaterials&&this._gltf.materials)for(let W=0;W<this._gltf.materials.length;++W){const ae=this._gltf.materials[W],ue="/materials/"+W,fe=ui.TriangleFillMode;v.push(this._loadMaterialAsync(ue,ae,null,fe,()=>{}))}return this._allMaterialsDirtyRequired?this._babylonScene.blockMaterialDirtyMechanism=w:this._babylonScene._forceBlockMaterialDirtyMechanism(w),this._parent.compileMaterials&&v.push(this._compileMaterialsAsync()),this._parent.compileShadowGenerators&&v.push(this._compileShadowGeneratorsAsync()),Promise.all(v).then(()=>(this._rootBabylonMesh&&this._rootBabylonMesh!==this._parent.customRootNode&&this._rootBabylonMesh.setEnabled(!0),this._extensionsOnReady(),this._parent._setState(_x.READY),this._startAnimations(),u())).then(W=>(this._parent._endPerformanceCounter(g),_t.SetImmediate(()=>{this._disposed||Promise.all(this._completePromises).then(()=>{this._parent._endPerformanceCounter(y),this._parent._setState(_x.COMPLETE),this._parent.onCompleteObservable.notifyObservers(void 0),this._parent.onCompleteObservable.clear(),this.dispose()},ae=>{this._parent.onErrorObservable.notifyObservers(ae),this._parent.onErrorObservable.clear(),this.dispose()})}),W))}).catch(g=>{throw this._disposed||(this._parent.onErrorObservable.notifyObservers(g),this._parent.onErrorObservable.clear(),this.dispose()),g})}_loadData(a){if(this._gltf=a.json,this._setupData(),a.bin){const x=this._gltf.buffers;if(x&&x[0]&&!x[0].uri){const c=x[0];(c.byteLength<a.bin.byteLength-3||c.byteLength>a.bin.byteLength)&&Qt.Warn(`Binary buffer length (${c.byteLength}) from JSON does not match chunk length (${a.bin.byteLength})`),this._bin=a.bin}else Qt.Warn("Unexpected BIN chunk")}}_setupData(){if(lr.Assign(this._gltf.accessors),lr.Assign(this._gltf.animations),lr.Assign(this._gltf.buffers),lr.Assign(this._gltf.bufferViews),lr.Assign(this._gltf.cameras),lr.Assign(this._gltf.images),lr.Assign(this._gltf.materials),lr.Assign(this._gltf.meshes),lr.Assign(this._gltf.nodes),lr.Assign(this._gltf.samplers),lr.Assign(this._gltf.scenes),lr.Assign(this._gltf.skins),lr.Assign(this._gltf.textures),this._gltf.nodes){const a={};for(const c of this._gltf.nodes)if(c.children)for(const u of c.children)a[u]=c.index;const x=this._createRootNode();for(const c of this._gltf.nodes){const u=a[c.index];c.parent=u===void 0?x:this._gltf.nodes[u]}}}_loadExtensions(){for(const a in _s._RegisteredExtensions){const x=_s._RegisteredExtensions[a].factory(this);x.name!==a&&Qt.Warn(`The name of the glTF loader extension instance does not match the registered name: ${x.name} !== ${a}`),this._extensions.push(x),this._parent.onExtensionLoadedObservable.notifyObservers(x)}this._extensions.sort((a,x)=>(a.order||Number.MAX_VALUE)-(x.order||Number.MAX_VALUE)),this._parent.onExtensionLoadedObservable.clear()}_checkExtensions(){if(this._gltf.extensionsRequired){for(const a of this._gltf.extensionsRequired)if(!this._extensions.some(c=>c.name===a&&c.enabled))throw new Error(`Required extension ${a} is not available`)}}_createRootNode(){if(this._parent.customRootNode!==void 0)return this._rootBabylonMesh=this._parent.customRootNode,{_babylonTransformNode:this._rootBabylonMesh===null?void 0:this._rootBabylonMesh,index:-1};this._babylonScene._blockEntityCollection=!!this._assetContainer;const a=new sr("__root__",this._babylonScene);this._rootBabylonMesh=a,this._rootBabylonMesh._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,this._rootBabylonMesh.setEnabled(!1);const x={_babylonTransformNode:this._rootBabylonMesh,index:-1};switch(this._parent.coordinateSystemMode){case mm.AUTO:{this._babylonScene.useRightHandedSystem||(x.rotation=[0,1,0,0],x.scale=[1,1,-1],_s._LoadTransform(x,this._rootBabylonMesh));break}case mm.FORCE_RIGHT_HANDED:{this._babylonScene.useRightHandedSystem=!0;break}default:throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`)}return this._parent.onMeshLoadedObservable.notifyObservers(a),x}loadSceneAsync(a,x){const c=this._extensionsLoadSceneAsync(a,x);if(c)return c;const u=new Array;if(this.logOpen(`${a} ${x.name||""}`),x.nodes)for(const g of x.nodes){const y=lr.Get(`${a}/nodes/${g}`,this._gltf.nodes,g);u.push(this.loadNodeAsync(`/nodes/${y.index}`,y,v=>{v.parent=this._rootBabylonMesh}))}for(const g of this._postSceneLoadActions)g();return u.push(this._loadAnimationsAsync()),this.logClose(),Promise.all(u).then(()=>{})}_forEachPrimitive(a,x){if(a._primitiveBabylonMeshes)for(const c of a._primitiveBabylonMeshes)x(c)}_getGeometries(){const a=[],x=this._gltf.nodes;if(x)for(const c of x)this._forEachPrimitive(c,u=>{const g=u.geometry;g&&a.indexOf(g)===-1&&a.push(g)});return a}_getMeshes(){const a=[];this._rootBabylonMesh instanceof mo&&a.push(this._rootBabylonMesh);const x=this._gltf.nodes;if(x)for(const c of x)this._forEachPrimitive(c,u=>{a.push(u)});return a}_getTransformNodes(){const a=[],x=this._gltf.nodes;if(x)for(const c of x)c._babylonTransformNode&&c._babylonTransformNode.getClassName()==="TransformNode"&&a.push(c._babylonTransformNode),c._babylonTransformNodeForSkin&&a.push(c._babylonTransformNodeForSkin);return a}_getSkeletons(){const a=[],x=this._gltf.skins;if(x)for(const c of x)c._data&&a.push(c._data.babylonSkeleton);return a}_getAnimationGroups(){const a=[],x=this._gltf.animations;if(x)for(const c of x)c._babylonAnimationGroup&&a.push(c._babylonAnimationGroup);return a}_startAnimations(){switch(this._parent.animationStartMode){case $u.NONE:break;case $u.FIRST:{const a=this._getAnimationGroups();a.length!==0&&a[0].start(!0);break}case $u.ALL:{const a=this._getAnimationGroups();for(const x of a)x.start(!0);break}default:{Qt.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);return}}}loadNodeAsync(a,x,c=()=>{}){const u=this._extensionsLoadNodeAsync(a,x,c);if(u)return u;if(x._babylonTransformNode)throw new Error(`${a}: Invalid recursive node hierarchy`);const g=new Array;this.logOpen(`${a} ${x.name||""}`);const y=v=>{if(_s.AddPointerMetadata(v,a),_s._LoadTransform(x,v),x.camera!=null){const w=lr.Get(`${a}/camera`,this._gltf.cameras,x.camera);g.push(this.loadCameraAsync(`/cameras/${w.index}`,w,B=>{B.parent=v}))}if(x.children)for(const w of x.children){const B=lr.Get(`${a}/children/${w}`,this._gltf.nodes,w);g.push(this.loadNodeAsync(`/nodes/${B.index}`,B,W=>{W.parent=v}))}c(v)};if(x.mesh==null||x.skin!=null){const v=x.name||`node${x.index}`;this._babylonScene._blockEntityCollection=!!this._assetContainer;const w=new $s(v,this._babylonScene);w._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,x.mesh==null?x._babylonTransformNode=w:x._babylonTransformNodeForSkin=w,y(w)}if(x.mesh!=null)if(x.skin==null){const v=lr.Get(`${a}/mesh`,this._gltf.meshes,x.mesh);g.push(this._loadMeshAsync(`/meshes/${v.index}`,x,v,y))}else{const v=lr.Get(`${a}/mesh`,this._gltf.meshes,x.mesh);g.push(this._loadMeshAsync(`/meshes/${v.index}`,x,v,w=>{const B=x._babylonTransformNodeForSkin;w.metadata=Bw(B.metadata,w.metadata||{});const W=lr.Get(`${a}/skin`,this._gltf.skins,x.skin);g.push(this._loadSkinAsync(`/skins/${W.index}`,x,W,ae=>{this._forEachPrimitive(x,ue=>{ue.skeleton=ae}),this._postSceneLoadActions.push(()=>{if(W.skeleton!=null){const ue=lr.Get(`/skins/${W.index}/skeleton`,this._gltf.nodes,W.skeleton).parent;x.index===ue.index?w.parent=B.parent:w.parent=ue._babylonTransformNode}else w.parent=this._rootBabylonMesh;this._parent.onSkinLoadedObservable.notifyObservers({node:B,skinnedNode:w})})}))}))}return this.logClose(),Promise.all(g).then(()=>(this._forEachPrimitive(x,v=>{v.geometry&&v.geometry.useBoundingInfoFromGeometry?v._updateBoundingInfo():v.refreshBoundingInfo(!0,!0)}),x._babylonTransformNode))}_loadMeshAsync(a,x,c,u){const g=c.primitives;if(!g||!g.length)throw new Error(`${a}: Primitives are missing`);g[0].index==null&&lr.Assign(g);const y=new Array;this.logOpen(`${a} ${c.name||""}`);const v=x.name||`node${x.index}`;if(g.length===1){const w=c.primitives[0];y.push(this._loadMeshPrimitiveAsync(`${a}/primitives/${w.index}`,v,x,c,w,B=>{x._babylonTransformNode=B,x._primitiveBabylonMeshes=[B]}))}else{this._babylonScene._blockEntityCollection=!!this._assetContainer,x._babylonTransformNode=new $s(v,this._babylonScene),x._babylonTransformNode._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,x._primitiveBabylonMeshes=[];for(const w of g)y.push(this._loadMeshPrimitiveAsync(`${a}/primitives/${w.index}`,`${v}_primitive${w.index}`,x,c,w,B=>{B.parent=x._babylonTransformNode,x._primitiveBabylonMeshes.push(B)}))}return u(x._babylonTransformNode),this.logClose(),Promise.all(y).then(()=>x._babylonTransformNode)}_loadMeshPrimitiveAsync(a,x,c,u,g,y){const v=this._extensionsLoadMeshPrimitiveAsync(a,x,c,u,g,y);if(v)return v;this.logOpen(`${a}`);const w=this._disableInstancedMesh===0&&this._parent.createInstances&&c.skin==null&&!u.primitives[0].targets;let B,W;if(w&&g._instanceData)this._babylonScene._blockEntityCollection=!!this._assetContainer,B=g._instanceData.babylonSourceMesh.createInstance(x),B._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,W=g._instanceData.promise;else{const ae=new Array;this._babylonScene._blockEntityCollection=!!this._assetContainer;const ue=new sr(x,this._babylonScene);ue._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,ue.overrideMaterialSideOrientation=this._babylonScene.useRightHandedSystem?ui.CounterClockWiseSideOrientation:ui.ClockWiseSideOrientation,this._createMorphTargets(a,c,u,g,ue),ae.push(this._loadVertexDataAsync(a,g,ue).then(Re=>this._loadMorphTargetsAsync(a,g,ue,Re).then(()=>{this._disposed||(this._babylonScene._blockEntityCollection=!!this._assetContainer,Re.applyToMesh(ue),Re._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1)})));const fe=_s._GetDrawMode(a,g.mode);if(g.material==null){let Re=this._defaultBabylonMaterialData[fe];Re||(Re=this._createDefaultMaterial("__GLTFLoader._default",fe),this._parent.onMaterialLoadedObservable.notifyObservers(Re),this._defaultBabylonMaterialData[fe]=Re),ue.material=Re}else if(!this.parent.skipMaterials){const Re=lr.Get(`${a}/material`,this._gltf.materials,g.material);ae.push(this._loadMaterialAsync(`/materials/${Re.index}`,Re,ue,fe,_e=>{ue.material=_e}))}W=Promise.all(ae),w&&(g._instanceData={babylonSourceMesh:ue,promise:W}),B=ue}return _s.AddPointerMetadata(B,a),this._parent.onMeshLoadedObservable.notifyObservers(B),y(B),this.logClose(),W.then(()=>B)}_loadVertexDataAsync(a,x,c){const u=this._extensionsLoadVertexDataAsync(a,x,c);if(u)return u;const g=x.attributes;if(!g)throw new Error(`${a}: Attributes are missing`);const y=new Array,v=new go(c.name,this._babylonScene);if(x.indices==null)c.isUnIndexed=!0;else{const B=lr.Get(`${a}/indices`,this._gltf.accessors,x.indices);y.push(this._loadIndicesAccessorAsync(`/accessors/${B.index}`,B).then(W=>{v.setIndices(W)}))}const w=(B,W,ae)=>{if(g[B]==null)return;c._delayInfo=c._delayInfo||[],c._delayInfo.indexOf(W)===-1&&c._delayInfo.push(W);const ue=lr.Get(`${a}/attributes/${B}`,this._gltf.accessors,g[B]);y.push(this._loadVertexAccessorAsync(`/accessors/${ue.index}`,ue,W).then(fe=>{if(fe.getKind()===Ve.PositionKind&&!this.parent.alwaysComputeBoundingBox&&!c.skeleton&&ue.min&&ue.max){const Re=Yt.Vector3[0].copyFromFloats(...ue.min),_e=Yt.Vector3[1].copyFromFloats(...ue.max);if(ue.normalized&&ue.componentType!==5126){let Be=1;switch(ue.componentType){case 5120:Be=127;break;case 5121:Be=255;break;case 5122:Be=32767;break;case 5123:Be=65535;break}const tt=1/Be;Re.scaleInPlace(tt),_e.scaleInPlace(tt)}v._boundingInfo=new tx(Re,_e),v.useBoundingInfoFromGeometry=!0}v.setVerticesBuffer(fe,ue.count)})),W==Ve.MatricesIndicesExtraKind&&(c.numBoneInfluencers=8),ae&&ae(ue)};return w("POSITION",Ve.PositionKind),w("NORMAL",Ve.NormalKind),w("TANGENT",Ve.TangentKind),w("TEXCOORD_0",Ve.UVKind),w("TEXCOORD_1",Ve.UV2Kind),w("TEXCOORD_2",Ve.UV3Kind),w("TEXCOORD_3",Ve.UV4Kind),w("TEXCOORD_4",Ve.UV5Kind),w("TEXCOORD_5",Ve.UV6Kind),w("JOINTS_0",Ve.MatricesIndicesKind),w("WEIGHTS_0",Ve.MatricesWeightsKind),w("JOINTS_1",Ve.MatricesIndicesExtraKind),w("WEIGHTS_1",Ve.MatricesWeightsExtraKind),w("COLOR_0",Ve.ColorKind,B=>{B.type==="VEC4"&&(c.hasVertexAlpha=!0)}),Promise.all(y).then(()=>v)}_createMorphTargets(a,x,c,u,g){if(!u.targets)return;if(x._numMorphTargets==null)x._numMorphTargets=u.targets.length;else if(u.targets.length!==x._numMorphTargets)throw new Error(`${a}: Primitives do not have the same number of targets`);const y=c.extras?c.extras.targetNames:null;this._babylonScene._blockEntityCollection=!!this._assetContainer,g.morphTargetManager=new lh(this._babylonScene),g.morphTargetManager._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,g.morphTargetManager.areUpdatesFrozen=!0;for(let v=0;v<u.targets.length;v++){const w=x.weights?x.weights[v]:c.weights?c.weights[v]:0,B=y?y[v]:`morphTarget${v}`;g.morphTargetManager.addTarget(new Jh(B,w,g.getScene()))}}_loadMorphTargetsAsync(a,x,c,u){if(!x.targets)return Promise.resolve();const g=new Array,y=c.morphTargetManager;for(let v=0;v<y.numTargets;v++){const w=y.getTarget(v);g.push(this._loadMorphTargetVertexDataAsync(`${a}/targets/${v}`,u,x.targets[v],w))}return Promise.all(g).then(()=>{y.areUpdatesFrozen=!1})}_loadMorphTargetVertexDataAsync(a,x,c,u){const g=new Array,y=(v,w,B)=>{if(c[v]==null)return;const W=x.getVertexBuffer(w);if(!W)return;const ae=lr.Get(`${a}/${v}`,this._gltf.accessors,c[v]);g.push(this._loadFloatAccessorAsync(`/accessors/${ae.index}`,ae).then(ue=>{B(W,ue)}))};return y("POSITION",Ve.PositionKind,(v,w)=>{const B=new Float32Array(w.length);v.forEach(w.length,(W,ae)=>{B[ae]=w[ae]+W}),u.setPositions(B)}),y("NORMAL",Ve.NormalKind,(v,w)=>{const B=new Float32Array(w.length);v.forEach(B.length,(W,ae)=>{B[ae]=w[ae]+W}),u.setNormals(B)}),y("TANGENT",Ve.TangentKind,(v,w)=>{const B=new Float32Array(w.length/3*4);let W=0;v.forEach(w.length/3*4,(ae,ue)=>{(ue+1)%4!==0&&(B[W]=w[W]+ae,W++)}),u.setTangents(B)}),Promise.all(g).then(()=>{})}static _LoadTransform(a,x){if(a.skin!=null)return;let c=Ee.Zero(),u=Wi.Identity(),g=Ee.One();a.matrix?vt.FromArray(a.matrix).decompose(g,u,c):(a.translation&&(c=Ee.FromArray(a.translation)),a.rotation&&(u=Wi.FromArray(a.rotation)),a.scale&&(g=Ee.FromArray(a.scale))),x.position=c,x.rotationQuaternion=u,x.scaling=g}_loadSkinAsync(a,x,c,u){const g=this._extensionsLoadSkinAsync(a,x,c);if(g)return g;if(c._data)return u(c._data.babylonSkeleton),c._data.promise;const y=`skeleton${c.index}`;this._babylonScene._blockEntityCollection=!!this._assetContainer;const v=new Ig(c.name||y,y,this._babylonScene);v._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,this._loadBones(a,c,v);const w=this._loadSkinInverseBindMatricesDataAsync(a,c).then(B=>{this._updateBoneMatrices(v,B)});return c._data={babylonSkeleton:v,promise:w},u(v),w}_loadBones(a,x,c){if(x.skeleton==null||this._parent.alwaysComputeSkeletonRootNode){const g=this._findSkeletonRootNode(`${a}/joints`,x.joints);if(g)if(x.skeleton===void 0)x.skeleton=g.index;else{const y=(w,B)=>{for(;B.parent;B=B.parent)if(B.parent===w)return!0;return!1},v=lr.Get(`${a}/skeleton`,this._gltf.nodes,x.skeleton);v!==g&&!y(v,g)&&(Qt.Warn(`${a}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`),x.skeleton=g.index)}else Qt.Warn(`${a}: Failed to find common root`)}const u={};for(const g of x.joints){const y=lr.Get(`${a}/joints/${g}`,this._gltf.nodes,g);this._loadBone(y,x,c,u)}}_findSkeletonRootNode(a,x){if(x.length===0)return null;const c={};for(const g of x){const y=[];let v=lr.Get(`${a}/${g}`,this._gltf.nodes,g);for(;v.index!==-1;)y.unshift(v),v=v.parent;c[g]=y}let u=null;for(let g=0;;++g){let y=c[x[0]];if(g>=y.length)return u;const v=y[g];for(let w=1;w<x.length;++w)if(y=c[x[w]],g>=y.length||v!==y[g])return u;u=v}}_loadBone(a,x,c,u){let g=u[a.index];if(g)return g;let y=null;a.index!==x.skeleton&&(a.parent&&a.parent.index!==-1?y=this._loadBone(a.parent,x,c,u):x.skeleton!==void 0&&Qt.Warn(`/skins/${x.index}/skeleton: Skeleton node is not a common root`));const v=x.joints.indexOf(a.index);return g=new Hn(a.name||`joint${a.index}`,c,y,this._getNodeMatrix(a),null,null,v),u[a.index]=g,this._postSceneLoadActions.push(()=>{g.linkTransformNode(a._babylonTransformNode)}),g}_loadSkinInverseBindMatricesDataAsync(a,x){if(x.inverseBindMatrices==null)return Promise.resolve(null);const c=lr.Get(`${a}/inverseBindMatrices`,this._gltf.accessors,x.inverseBindMatrices);return this._loadFloatAccessorAsync(`/accessors/${c.index}`,c)}_updateBoneMatrices(a,x){for(const c of a.bones){const u=vt.Identity(),g=c._index;x&&g!==-1&&(vt.FromArrayToRef(x,g*16,u),u.invertToRef(u));const y=c.getParent();y&&u.multiplyToRef(y.getAbsoluteInverseBindMatrix(),u),c.updateMatrix(u,!1,!1),c._updateAbsoluteBindMatrices(void 0,!1)}}_getNodeMatrix(a){return a.matrix?vt.FromArray(a.matrix):vt.Compose(a.scale?Ee.FromArray(a.scale):Ee.One(),a.rotation?Wi.FromArray(a.rotation):Wi.Identity(),a.translation?Ee.FromArray(a.translation):Ee.Zero())}loadCameraAsync(a,x,c=()=>{}){const u=this._extensionsLoadCameraAsync(a,x,c);if(u)return u;const g=new Array;this.logOpen(`${a} ${x.name||""}`),this._babylonScene._blockEntityCollection=!!this._assetContainer;const y=new yu(x.name||`camera${x.index}`,Ee.Zero(),this._babylonScene,!1);switch(y._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,y.ignoreParentScaling=!0,x._babylonCamera=y,y.rotation.set(0,Math.PI,0),x.type){case"perspective":{const v=x.perspective;if(!v)throw new Error(`${a}: Camera perspective properties are missing`);y.fov=v.yfov,y.minZ=v.znear,y.maxZ=v.zfar||0;break}case"orthographic":{if(!x.orthographic)throw new Error(`${a}: Camera orthographic properties are missing`);y.mode=gr.ORTHOGRAPHIC_CAMERA,y.orthoLeft=-x.orthographic.xmag,y.orthoRight=x.orthographic.xmag,y.orthoBottom=-x.orthographic.ymag,y.orthoTop=x.orthographic.ymag,y.minZ=x.orthographic.znear,y.maxZ=x.orthographic.zfar;break}default:throw new Error(`${a}: Invalid camera type (${x.type})`)}return _s.AddPointerMetadata(y,a),this._parent.onCameraLoadedObservable.notifyObservers(y),c(y),this.logClose(),Promise.all(g).then(()=>y)}_loadAnimationsAsync(){const a=this._gltf.animations;if(!a)return Promise.resolve();const x=new Array;for(let c=0;c<a.length;c++){const u=a[c];x.push(this.loadAnimationAsync(`/animations/${u.index}`,u).then(g=>{g.targetedAnimations.length===0&&g.dispose()}))}return Promise.all(x).then(()=>{})}loadAnimationAsync(a,x){const c=this._extensionsLoadAnimationAsync(a,x);if(c)return c;this._babylonScene._blockEntityCollection=!!this._assetContainer;const u=new xc(x.name||`animation${x.index}`,this._babylonScene);u._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,x._babylonAnimationGroup=u;const g=new Array;lr.Assign(x.channels),lr.Assign(x.samplers);for(const y of x.channels)g.push(this._loadAnimationChannelAsync(`${a}/channels/${y.index}`,a,x,y,(v,w)=>{v.animations=v.animations||[],v.animations.push(w),u.addTargetedAnimation(w,v)}));return Promise.all(g).then(()=>(u.normalize(0),u))}_loadAnimationChannelAsync(a,x,c,u,g){const y=this._extensionsLoadAnimationChannelAsync(a,x,c,u,g);if(y)return y;if(u.target.node==null)return Promise.resolve();const v=lr.Get(`${a}/target/node`,this._gltf.nodes,u.target.node);if(u.target.path==="weights"&&!v._numMorphTargets||u.target.path!=="weights"&&!v._babylonTransformNode)return Promise.resolve();let w;switch(u.target.path){case"translation":{w=_m.translation;break}case"rotation":{w=_m.rotation;break}case"scale":{w=_m.scale;break}case"weights":{w=_m.weights;break}default:throw new Error(`${a}/target/path: Invalid value (${u.target.path})`)}const B={object:v,info:w};return this._loadAnimationChannelFromTargetInfoAsync(a,x,c,u,B,g)}_loadAnimationChannelFromTargetInfoAsync(a,x,c,u,g,y){const v=this.parent.targetFps,w=1/v,B=lr.Get(`${a}/sampler`,c.samplers,u.sampler);return this._loadAnimationSamplerAsync(`${x}/samplers/${u.sampler}`,B).then(W=>{let ae=0;const ue=g.object,fe=g.info;for(const Re of fe){const _e=Re.getStride(ue),Be=W.input,tt=W.output,$e=new Array(Be.length);let Et=0;switch(W.interpolation){case"STEP":{for(let ft=0;ft<Be.length;ft++){const dt=Re.getValue(ue,tt,Et,1);Et+=_e,$e[ft]={frame:Be[ft]*v,value:dt,interpolation:vg.STEP}}break}case"CUBICSPLINE":{for(let ft=0;ft<Be.length;ft++){const dt=Re.getValue(ue,tt,Et,w);Et+=_e;const ut=Re.getValue(ue,tt,Et,1);Et+=_e;const Mt=Re.getValue(ue,tt,Et,w);Et+=_e,$e[ft]={frame:Be[ft]*v,inTangent:dt,value:ut,outTangent:Mt}}break}case"LINEAR":{for(let ft=0;ft<Be.length;ft++){const dt=Re.getValue(ue,tt,Et,1);Et+=_e,$e[ft]={frame:Be[ft]*v,value:dt}}break}}if(Et>0){const ft=`${c.name||`animation${c.index}`}_channel${u.index}_${ae}`;Re.buildAnimations(ue,ft,v,$e,(dt,ut)=>{++ae,y(dt,ut)})}}})}_loadAnimationSamplerAsync(a,x){if(x._data)return x._data;const c=x.interpolation||"LINEAR";switch(c){case"STEP":case"LINEAR":case"CUBICSPLINE":break;default:throw new Error(`${a}/interpolation: Invalid value (${x.interpolation})`)}const u=lr.Get(`${a}/input`,this._gltf.accessors,x.input),g=lr.Get(`${a}/output`,this._gltf.accessors,x.output);return x._data=Promise.all([this._loadFloatAccessorAsync(`/accessors/${u.index}`,u),this._loadFloatAccessorAsync(`/accessors/${g.index}`,g)]).then(([y,v])=>({input:y,interpolation:c,output:v})),x._data}loadBufferAsync(a,x,c,u){const g=this._extensionsLoadBufferAsync(a,x,c,u);if(g)return g;if(!x._data)if(x.uri)x._data=this.loadUriAsync(`${a}/uri`,x,x.uri);else{if(!this._bin)throw new Error(`${a}: Uri is missing or the binary glTF is missing its binary chunk`);x._data=this._bin.readAsync(0,x.byteLength)}return x._data.then(y=>{try{return new Uint8Array(y.buffer,y.byteOffset+c,u)}catch(v){throw new Error(`${a}: ${v.message}`)}})}loadBufferViewAsync(a,x){const c=this._extensionsLoadBufferViewAsync(a,x);if(c)return c;if(x._data)return x._data;const u=lr.Get(`${a}/buffer`,this._gltf.buffers,x.buffer);return x._data=this.loadBufferAsync(`/buffers/${u.index}`,u,x.byteOffset||0,x.byteLength),x._data}_loadAccessorAsync(a,x,c){if(x._data)return x._data;const u=_s._GetNumComponents(a,x.type),g=u*Ve.GetTypeByteLength(x.componentType),y=u*x.count;if(x.bufferView==null)x._data=Promise.resolve(new c(y));else{const v=lr.Get(`${a}/bufferView`,this._gltf.bufferViews,x.bufferView);x._data=this.loadBufferViewAsync(`/bufferViews/${v.index}`,v).then(w=>{if(x.componentType===5126&&!x.normalized&&(!v.byteStride||v.byteStride===g))return _s._GetTypedArray(a,x.componentType,w,x.byteOffset,y);{const B=new c(y);return Ve.ForEach(w,x.byteOffset||0,v.byteStride||g,u,x.componentType,B.length,x.normalized||!1,(W,ae)=>{B[ae]=W}),B}})}if(x.sparse){const v=x.sparse;x._data=x._data.then(w=>{const B=w,W=lr.Get(`${a}/sparse/indices/bufferView`,this._gltf.bufferViews,v.indices.bufferView),ae=lr.Get(`${a}/sparse/values/bufferView`,this._gltf.bufferViews,v.values.bufferView);return Promise.all([this.loadBufferViewAsync(`/bufferViews/${W.index}`,W),this.loadBufferViewAsync(`/bufferViews/${ae.index}`,ae)]).then(([ue,fe])=>{const Re=_s._GetTypedArray(`${a}/sparse/indices`,v.indices.componentType,ue,v.indices.byteOffset,v.count),_e=u*v.count;let Be;if(x.componentType===5126&&!x.normalized)Be=_s._GetTypedArray(`${a}/sparse/values`,x.componentType,fe,v.values.byteOffset,_e);else{const $e=_s._GetTypedArray(`${a}/sparse/values`,x.componentType,fe,v.values.byteOffset,_e);Be=new c(_e),Ve.ForEach($e,0,g,u,x.componentType,Be.length,x.normalized||!1,(Et,ft)=>{Be[ft]=Et})}let tt=0;for(let $e=0;$e<Re.length;$e++){let Et=Re[$e]*u;for(let ft=0;ft<u;ft++)B[Et++]=Be[tt++]}return B})})}return x._data}_loadFloatAccessorAsync(a,x){return this._loadAccessorAsync(a,x,Float32Array)}_loadIndicesAccessorAsync(a,x){if(x.type!=="SCALAR")throw new Error(`${a}/type: Invalid value ${x.type}`);if(x.componentType!==5121&&x.componentType!==5123&&x.componentType!==5125)throw new Error(`${a}/componentType: Invalid value ${x.componentType}`);if(x._data)return x._data;if(x.sparse){const c=_s._GetTypedArrayConstructor(`${a}/componentType`,x.componentType);x._data=this._loadAccessorAsync(a,x,c)}else{const c=lr.Get(`${a}/bufferView`,this._gltf.bufferViews,x.bufferView);x._data=this.loadBufferViewAsync(`/bufferViews/${c.index}`,c).then(u=>_s._GetTypedArray(a,x.componentType,u,x.byteOffset,x.count))}return x._data}_loadVertexBufferViewAsync(a){if(a._babylonBuffer)return a._babylonBuffer;const x=this._babylonScene.getEngine();return a._babylonBuffer=this.loadBufferViewAsync(`/bufferViews/${a.index}`,a).then(c=>new mu(x,c,!1)),a._babylonBuffer}_loadVertexAccessorAsync(a,x,c){if(x._babylonVertexBuffer?.[c])return x._babylonVertexBuffer[c];x._babylonVertexBuffer||(x._babylonVertexBuffer={});const u=this._babylonScene.getEngine();if(x.sparse||x.bufferView==null)x._babylonVertexBuffer[c]=this._loadFloatAccessorAsync(a,x).then(g=>new Ve(u,g,c,!1));else{const g=lr.Get(`${a}/bufferView`,this._gltf.bufferViews,x.bufferView);x._babylonVertexBuffer[c]=this._loadVertexBufferViewAsync(g).then(y=>{const v=_s._GetNumComponents(a,x.type);return new Ve(u,y,c,!1,void 0,g.byteStride,void 0,x.byteOffset,v,x.componentType,x.normalized,!0,void 0,!0)})}return x._babylonVertexBuffer[c]}_loadMaterialMetallicRoughnessPropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const u=new Array;return x&&(x.baseColorFactor?(c.albedoColor=Bs.FromArray(x.baseColorFactor),c.alpha=x.baseColorFactor[3]):c.albedoColor=Bs.White(),c.metallic=x.metallicFactor==null?1:x.metallicFactor,c.roughness=x.roughnessFactor==null?1:x.roughnessFactor,x.baseColorTexture&&u.push(this.loadTextureInfoAsync(`${a}/baseColorTexture`,x.baseColorTexture,g=>{g.name=`${c.name} (Base Color)`,c.albedoTexture=g})),x.metallicRoughnessTexture&&(x.metallicRoughnessTexture.nonColorData=!0,u.push(this.loadTextureInfoAsync(`${a}/metallicRoughnessTexture`,x.metallicRoughnessTexture,g=>{g.name=`${c.name} (Metallic Roughness)`,c.metallicTexture=g})),c.useMetallnessFromMetallicTextureBlue=!0,c.useRoughnessFromMetallicTextureGreen=!0,c.useRoughnessFromMetallicTextureAlpha=!1)),Promise.all(u).then(()=>{})}_loadMaterialAsync(a,x,c,u,g=()=>{}){const y=this._extensionsLoadMaterialAsync(a,x,c,u,g);if(y)return y;x._data=x._data||{};let v=x._data[u];if(!v){this.logOpen(`${a} ${x.name||""}`);const w=this.createMaterial(a,x,u);v={babylonMaterial:w,babylonMeshes:[],promise:this.loadMaterialPropertiesAsync(a,x,w)},x._data[u]=v,_s.AddPointerMetadata(w,a),this._parent.onMaterialLoadedObservable.notifyObservers(w),this.logClose()}return c&&(v.babylonMeshes.push(c),c.onDisposeObservable.addOnce(()=>{const w=v.babylonMeshes.indexOf(c);w!==-1&&v.babylonMeshes.splice(w,1)})),g(v.babylonMaterial),v.promise.then(()=>v.babylonMaterial)}_createDefaultMaterial(a,x){this._babylonScene._blockEntityCollection=!!this._assetContainer;const c=new fs(a,this._babylonScene);return c._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,c.fillMode=x,c.enableSpecularAntiAliasing=!0,c.useRadianceOverAlpha=!this._parent.transparencyAsCoverage,c.useSpecularOverAlpha=!this._parent.transparencyAsCoverage,c.transparencyMode=fs.PBRMATERIAL_OPAQUE,c.metallic=1,c.roughness=1,c}createMaterial(a,x,c){const u=this._extensionsCreateMaterial(a,x,c);if(u)return u;const g=x.name||`material${x.index}`;return this._createDefaultMaterial(g,c)}loadMaterialPropertiesAsync(a,x,c){const u=this._extensionsLoadMaterialPropertiesAsync(a,x,c);if(u)return u;const g=new Array;return g.push(this.loadMaterialBasePropertiesAsync(a,x,c)),x.pbrMetallicRoughness&&g.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${a}/pbrMetallicRoughness`,x.pbrMetallicRoughness,c)),this.loadMaterialAlphaProperties(a,x,c),Promise.all(g).then(()=>{})}loadMaterialBasePropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const u=new Array;return c.emissiveColor=x.emissiveFactor?Bs.FromArray(x.emissiveFactor):new Bs(0,0,0),x.doubleSided&&(c.backFaceCulling=!1,c.twoSidedLighting=!0),x.normalTexture&&(x.normalTexture.nonColorData=!0,u.push(this.loadTextureInfoAsync(`${a}/normalTexture`,x.normalTexture,g=>{g.name=`${c.name} (Normal)`,c.bumpTexture=g})),c.invertNormalMapX=!this._babylonScene.useRightHandedSystem,c.invertNormalMapY=this._babylonScene.useRightHandedSystem,x.normalTexture.scale!=null&&c.bumpTexture&&(c.bumpTexture.level=x.normalTexture.scale),c.forceIrradianceInFragment=!0),x.occlusionTexture&&(x.occlusionTexture.nonColorData=!0,u.push(this.loadTextureInfoAsync(`${a}/occlusionTexture`,x.occlusionTexture,g=>{g.name=`${c.name} (Occlusion)`,c.ambientTexture=g})),c.useAmbientInGrayScale=!0,x.occlusionTexture.strength!=null&&(c.ambientTextureStrength=x.occlusionTexture.strength)),x.emissiveTexture&&u.push(this.loadTextureInfoAsync(`${a}/emissiveTexture`,x.emissiveTexture,g=>{g.name=`${c.name} (Emissive)`,c.emissiveTexture=g})),Promise.all(u).then(()=>{})}loadMaterialAlphaProperties(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);switch(x.alphaMode||"OPAQUE"){case"OPAQUE":{c.transparencyMode=fs.PBRMATERIAL_OPAQUE,c.alpha=1;break}case"MASK":{c.transparencyMode=fs.PBRMATERIAL_ALPHATEST,c.alphaCutOff=x.alphaCutoff==null?.5:x.alphaCutoff,c.albedoTexture&&(c.albedoTexture.hasAlpha=!0);break}case"BLEND":{c.transparencyMode=fs.PBRMATERIAL_ALPHABLEND,c.albedoTexture&&(c.albedoTexture.hasAlpha=!0,c.useAlphaFromAlbedoTexture=!0);break}default:throw new Error(`${a}/alphaMode: Invalid value (${x.alphaMode})`)}}loadTextureInfoAsync(a,x,c=()=>{}){const u=this._extensionsLoadTextureInfoAsync(a,x,c);if(u)return u;if(this.logOpen(`${a}`),x.texCoord>=6)throw new Error(`${a}/texCoord: Invalid value (${x.texCoord})`);const g=lr.Get(`${a}/index`,this._gltf.textures,x.index);g._textureInfo=x;const y=this._loadTextureAsync(`/textures/${x.index}`,g,v=>{v.coordinatesIndex=x.texCoord||0,_s.AddPointerMetadata(v,a),this._parent.onTextureLoadedObservable.notifyObservers(v),c(v)});return this.logClose(),y}_loadTextureAsync(a,x,c=()=>{}){const u=this._extensionsLoadTextureAsync(a,x,c);if(u)return u;this.logOpen(`${a} ${x.name||""}`);const g=x.sampler==null?_s.DefaultSampler:lr.Get(`${a}/sampler`,this._gltf.samplers,x.sampler),y=lr.Get(`${a}/source`,this._gltf.images,x.source),v=this._createTextureAsync(a,g,y,c,void 0,!x._textureInfo.nonColorData);return this.logClose(),v}_createTextureAsync(a,x,c,u=()=>{},g,y){const v=this._loadSampler(`/samplers/${x.index}`,x),w=new Array,B=new dm;this._babylonScene._blockEntityCollection=!!this._assetContainer;const W={noMipmap:v.noMipMaps,invertY:!1,samplingMode:v.samplingMode,onLoad:()=>{this._disposed||B.resolve()},onError:(ue,fe)=>{this._disposed||B.reject(new Error(`${a}: ${fe&&fe.message?fe.message:ue||"Failed to load texture"}`))},mimeType:c.mimeType,loaderOptions:g,useSRGBBuffer:!!y&&this._parent.useSRGBBuffers},ae=new fi(null,this._babylonScene,W);return ae._parentContainer=this._assetContainer,this._babylonScene._blockEntityCollection=!1,w.push(B.promise),w.push(this.loadImageAsync(`/images/${c.index}`,c).then(ue=>{const fe=c.uri||`${this._fileName}#image${c.index}`,Re=`data:${this._uniqueRootUrl}${fe}`;ae.updateURL(Re,ue)})),ae.wrapU=v.wrapU,ae.wrapV=v.wrapV,u(ae),Promise.all(w).then(()=>ae)}_loadSampler(a,x){return x._data||(x._data={noMipMaps:x.minFilter===9728||x.minFilter===9729,samplingMode:_s._GetTextureSamplingMode(a,x),wrapU:_s._GetTextureWrapMode(`${a}/wrapS`,x.wrapS),wrapV:_s._GetTextureWrapMode(`${a}/wrapT`,x.wrapT)}),x._data}loadImageAsync(a,x){if(!x._data){if(this.logOpen(`${a} ${x.name||""}`),x.uri)x._data=this.loadUriAsync(`${a}/uri`,x,x.uri);else{const c=lr.Get(`${a}/bufferView`,this._gltf.bufferViews,x.bufferView);x._data=this.loadBufferViewAsync(`/bufferViews/${c.index}`,c)}this.logClose()}return x._data}loadUriAsync(a,x,c){const u=this._extensionsLoadUriAsync(a,x,c);if(u)return u;if(!_s._ValidateUri(c))throw new Error(`${a}: '${c}' is invalid`);if(bl(c)){const g=new Uint8Array(El(c));return this.log(`${a}: Decoded ${c.substr(0,64)}... (${g.length} bytes)`),Promise.resolve(g)}return this.log(`${a}: Loading ${c}`),this._parent.preprocessUrlAsync(this._rootUrl+c).then(g=>new Promise((y,v)=>{this._parent._loadFile(this._babylonScene,g,w=>{this._disposed||(this.log(`${a}: Loaded ${c} (${w.byteLength} bytes)`),y(new Uint8Array(w)))},!0,w=>{v(new gl(`${a}: Failed to load '${c}'${w?": "+w.status+" "+w.statusText:""}`,w))})}))}static AddPointerMetadata(a,x){a.metadata=a.metadata||{};const c=a._internalMetadata=a._internalMetadata||{},u=c.gltf=c.gltf||{};(u.pointers=u.pointers||[]).push(x)}static _GetTextureWrapMode(a,x){switch(x=x??10497,x){case 33071:return fi.CLAMP_ADDRESSMODE;case 33648:return fi.MIRROR_ADDRESSMODE;case 10497:return fi.WRAP_ADDRESSMODE;default:return Qt.Warn(`${a}: Invalid value (${x})`),fi.WRAP_ADDRESSMODE}}static _GetTextureSamplingMode(a,x){const c=x.magFilter==null?9729:x.magFilter,u=x.minFilter==null?9987:x.minFilter;if(c===9729)switch(u){case 9728:return fi.LINEAR_NEAREST;case 9729:return fi.LINEAR_LINEAR;case 9984:return fi.LINEAR_NEAREST_MIPNEAREST;case 9985:return fi.LINEAR_LINEAR_MIPNEAREST;case 9986:return fi.LINEAR_NEAREST_MIPLINEAR;case 9987:return fi.LINEAR_LINEAR_MIPLINEAR;default:return Qt.Warn(`${a}/minFilter: Invalid value (${u})`),fi.LINEAR_LINEAR_MIPLINEAR}else switch(c!==9728&&Qt.Warn(`${a}/magFilter: Invalid value (${c})`),u){case 9728:return fi.NEAREST_NEAREST;case 9729:return fi.NEAREST_LINEAR;case 9984:return fi.NEAREST_NEAREST_MIPNEAREST;case 9985:return fi.NEAREST_LINEAR_MIPNEAREST;case 9986:return fi.NEAREST_NEAREST_MIPLINEAR;case 9987:return fi.NEAREST_LINEAR_MIPLINEAR;default:return Qt.Warn(`${a}/minFilter: Invalid value (${u})`),fi.NEAREST_NEAREST_MIPNEAREST}}static _GetTypedArrayConstructor(a,x){switch(x){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:throw new Error(`${a}: Invalid component type ${x}`)}}static _GetTypedArray(a,x,c,u,g){const y=c.buffer;u=c.byteOffset+(u||0);const v=_s._GetTypedArrayConstructor(`${a}/componentType`,x),w=Ve.GetTypeByteLength(x);return u%w!==0?(Qt.Warn(`${a}: Copying buffer as byte offset (${u}) is not a multiple of component type byte length (${w})`),new v(y.slice(u,u+g*w),0)):new v(y,u,g)}static _GetNumComponents(a,x){switch(x){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4;case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16}throw new Error(`${a}: Invalid type (${x})`)}static _ValidateUri(a){return _t.IsBase64(a)||a.indexOf("..")===-1}static _GetDrawMode(a,x){switch(x==null&&(x=4),x){case 0:return ui.PointListDrawMode;case 1:return ui.LineListDrawMode;case 2:return ui.LineLoopDrawMode;case 3:return ui.LineStripDrawMode;case 4:return ui.TriangleFillMode;case 5:return ui.TriangleStripDrawMode;case 6:return ui.TriangleFanDrawMode}throw new Error(`${a}: Invalid mesh primitive mode (${x})`)}_compileMaterialsAsync(){this._parent._startPerformanceCounter("Compile materials");const a=new Array;if(this._gltf.materials){for(const x of this._gltf.materials)if(x._data)for(const c in x._data){const u=x._data[c];for(const g of u.babylonMeshes){g.computeWorldMatrix(!0);const y=u.babylonMaterial;a.push(y.forceCompilationAsync(g)),a.push(y.forceCompilationAsync(g,{useInstances:!0})),this._parent.useClipPlane&&(a.push(y.forceCompilationAsync(g,{clipPlane:!0})),a.push(y.forceCompilationAsync(g,{clipPlane:!0,useInstances:!0})))}}}return Promise.all(a).then(()=>{this._parent._endPerformanceCounter("Compile materials")})}_compileShadowGeneratorsAsync(){this._parent._startPerformanceCounter("Compile shadow generators");const a=new Array,x=this._babylonScene.lights;for(const c of x){const u=c.getShadowGenerator();u&&a.push(u.forceCompilationAsync())}return Promise.all(a).then(()=>{this._parent._endPerformanceCounter("Compile shadow generators")})}_forEachExtensions(a){for(const x of this._extensions)x.enabled&&a(x)}_applyExtensions(a,x,c){for(const u of this._extensions)if(u.enabled){const g=`${u.name}.${x}`,y=a;y._activeLoaderExtensionFunctions=y._activeLoaderExtensionFunctions||{};const v=y._activeLoaderExtensionFunctions;if(!v[g]){v[g]=!0;try{const w=c(u);if(w)return w}finally{delete v[g]}}}return null}_extensionsOnLoading(){this._forEachExtensions(a=>a.onLoading&&a.onLoading())}_extensionsOnReady(){this._forEachExtensions(a=>a.onReady&&a.onReady())}_extensionsLoadSceneAsync(a,x){return this._applyExtensions(x,"loadScene",c=>c.loadSceneAsync&&c.loadSceneAsync(a,x))}_extensionsLoadNodeAsync(a,x,c){return this._applyExtensions(x,"loadNode",u=>u.loadNodeAsync&&u.loadNodeAsync(a,x,c))}_extensionsLoadCameraAsync(a,x,c){return this._applyExtensions(x,"loadCamera",u=>u.loadCameraAsync&&u.loadCameraAsync(a,x,c))}_extensionsLoadVertexDataAsync(a,x,c){return this._applyExtensions(x,"loadVertexData",u=>u._loadVertexDataAsync&&u._loadVertexDataAsync(a,x,c))}_extensionsLoadMeshPrimitiveAsync(a,x,c,u,g,y){return this._applyExtensions(g,"loadMeshPrimitive",v=>v._loadMeshPrimitiveAsync&&v._loadMeshPrimitiveAsync(a,x,c,u,g,y))}_extensionsLoadMaterialAsync(a,x,c,u,g){return this._applyExtensions(x,"loadMaterial",y=>y._loadMaterialAsync&&y._loadMaterialAsync(a,x,c,u,g))}_extensionsCreateMaterial(a,x,c){return this._applyExtensions(x,"createMaterial",u=>u.createMaterial&&u.createMaterial(a,x,c))}_extensionsLoadMaterialPropertiesAsync(a,x,c){return this._applyExtensions(x,"loadMaterialProperties",u=>u.loadMaterialPropertiesAsync&&u.loadMaterialPropertiesAsync(a,x,c))}_extensionsLoadTextureInfoAsync(a,x,c){return this._applyExtensions(x,"loadTextureInfo",u=>u.loadTextureInfoAsync&&u.loadTextureInfoAsync(a,x,c))}_extensionsLoadTextureAsync(a,x,c){return this._applyExtensions(x,"loadTexture",u=>u._loadTextureAsync&&u._loadTextureAsync(a,x,c))}_extensionsLoadAnimationAsync(a,x){return this._applyExtensions(x,"loadAnimation",c=>c.loadAnimationAsync&&c.loadAnimationAsync(a,x))}_extensionsLoadAnimationChannelAsync(a,x,c,u,g){return this._applyExtensions(c,"loadAnimationChannel",y=>y._loadAnimationChannelAsync&&y._loadAnimationChannelAsync(a,x,c,u,g))}_extensionsLoadSkinAsync(a,x,c){return this._applyExtensions(c,"loadSkin",u=>u._loadSkinAsync&&u._loadSkinAsync(a,x,c))}_extensionsLoadUriAsync(a,x,c){return this._applyExtensions(x,"loadUri",u=>u._loadUriAsync&&u._loadUriAsync(a,x,c))}_extensionsLoadBufferViewAsync(a,x){return this._applyExtensions(x,"loadBufferView",c=>c.loadBufferViewAsync&&c.loadBufferViewAsync(a,x))}_extensionsLoadBufferAsync(a,x,c,u){return this._applyExtensions(x,"loadBuffer",g=>g.loadBufferAsync&&g.loadBufferAsync(a,x,c,u))}static LoadExtensionAsync(a,x,c,u){if(!x.extensions)return null;const y=x.extensions[c];return y?u(`${a}/extensions/${c}`,y):null}static LoadExtraAsync(a,x,c,u){if(!x.extras)return null;const y=x.extras[c];return y?u(`${a}/extras/${c}`,y):null}isExtensionUsed(a){return!!this._gltf.extensionsUsed&&this._gltf.extensionsUsed.indexOf(a)!==-1}logOpen(a){this._parent._logOpen(a)}logClose(){this._parent._logClose()}log(a){this._parent._log(a)}startPerformanceCounter(a){this._parent._startPerformanceCounter(a)}endPerformanceCounter(a){this._parent._endPerformanceCounter(a)}}_s._RegisteredExtensions={},_s.DefaultSampler={index:-1},M0._CreateGLTF2Loader=F=>new _s(F);const Uw="rgbdEncodePixelShader",Vw=`varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);}`;hi.ShadersStore[Uw]=Vw;const B9={name:Uw,shader:Vw},w_="image/png",P_=2,ym=[134,22,135,150,246,214,150,54];function Ww(F){const a=new DataView(F.buffer,F.byteOffset,F.byteLength);let x=0;for(let y=0;y<ym.length;y++)if(a.getUint8(x++)!==ym[y])return Qt.Error("Not a babylon environment map"),null;let c="",u=0;for(;u=a.getUint8(x++);)c+=String.fromCharCode(u);let g=JSON.parse(c);return g=Ug(g),g.specular&&(g.specular.specularDataPosition=x,g.specular.lodGenerationScale=g.specular.lodGenerationScale||.8),g}function Ug(F){if(F.version>P_)throw new Error(`Unsupported babylon environment map version "${F.version}". Latest supported version is "${P_}".`);return F.version===2||(F={...F,version:2,imageType:w_}),F}async function gF(F,a={}){const x=F.getInternalTexture();if(!x)return Promise.reject("The cube texture is invalid.");const c=a.imageType??w_,u=x.getEngine();if(F.textureType!==2&&F.textureType!==1&&F.textureType!==0&&F.textureType!==0&&F.textureType!==7&&F.textureType!==-1)return Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");let g=1;if(!u.getCaps().textureFloatRender&&(g=2,!u.getCaps().textureHalfFloatRender))return Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");F.sphericalPolynomial;const y=F.getInternalTexture()?._sphericalPolynomialPromise,v=x.width,w=new H0(u),B={};u.flushFramebuffer();const W=_n.ILog2(x.width);for(let dt=0;dt<=W;dt++){const ut=Math.pow(2,W-dt);for(let Mt=0;Mt<6;Mt++){let ai=await F.readPixels(Mt,dt,void 0,!1);if(ai&&ai.byteLength===ai.length){const Rr=new Float32Array(ai.byteLength*4);for(let _r=0;_r<ai.byteLength;_r++)Rr[_r]=ai[_r]/255,Rr[_r]=Math.pow(Rr[_r],2.2);ai=Rr}else if(ai&&F.gammaSpace){const Rr=ai;for(let _r=0;_r<Rr.length;_r++)Rr[_r]=Math.pow(Rr[_r],2.2)}const Yi=u.createRawTexture(ai,ut,ut,5,!1,!0,1,null,g);await E_.EncodeTextureToRGBD(Yi,w,g);const Vi=await u._readTexturePixels(Yi,ut,ut),Js=await Mo.DumpDataAsync(ut,ut,Vi,c,void 0,!1,!0,a.imageQuality);B[dt*6+Mt]=Js,Yi.dispose()}}w.dispose(),y&&await y;const ae={version:P_,width:v,imageType:c,irradiance:_F(F),specular:{mipmaps:[],lodGenerationScale:F.lodGenerationScale}};let ue=0;for(let dt=0;dt<=W;dt++)for(let ut=0;ut<6;ut++){const Mt=B[dt*6+ut].byteLength;ae.specular.mipmaps.push({length:Mt,position:ue}),ue+=Mt}const fe=JSON.stringify(ae),Re=new ArrayBuffer(fe.length+1),_e=new Uint8Array(Re);for(let dt=0,ut=fe.length;dt<ut;dt++)_e[dt]=fe.charCodeAt(dt);_e[fe.length]=0;const Be=ym.length+ue+Re.byteLength,tt=new ArrayBuffer(Be),$e=new Uint8Array(tt),Et=new DataView(tt);let ft=0;for(let dt=0;dt<ym.length;dt++)Et.setUint8(ft++,ym[dt]);$e.set(new Uint8Array(Re),ft),ft+=Re.byteLength;for(let dt=0;dt<=W;dt++)for(let ut=0;ut<6;ut++){const Mt=B[dt*6+ut];$e.set(new Uint8Array(Mt),ft),ft+=Mt.byteLength}return tt}function _F(F){const a=F.sphericalPolynomial;return a==null?null:{x:[a.x.x,a.x.y,a.x.z],y:[a.y.x,a.y.y,a.y.z],z:[a.z.x,a.z.y,a.z.z],xx:[a.xx.x,a.xx.y,a.xx.z],yy:[a.yy.x,a.yy.y,a.yy.z],zz:[a.zz.x,a.zz.y,a.zz.z],yz:[a.yz.x,a.yz.y,a.yz.z],zx:[a.zx.x,a.zx.y,a.zx.z],xy:[a.xy.x,a.xy.y,a.xy.z]}}function Hw(F,a){a=Ug(a);const x=a.specular;let c=_n.Log2(a.width);if(c=Math.round(c)+1,x.mipmaps.length!==6*c)throw new Error(`Unsupported specular mipmaps number "${x.mipmaps.length}"`);const u=new Array(c);for(let g=0;g<c;g++){u[g]=new Array(6);for(let y=0;y<6;y++){const v=x.mipmaps[g*6+y];u[g][y]=new Uint8Array(F.buffer,F.byteOffset+x.specularDataPosition+v.position,v.length)}}return u}function Xw(F,a,x){x=Ug(x);const c=x.specular;if(!c)return Promise.resolve();F._lodGenerationScale=c.lodGenerationScale;const u=Hw(a,x);return Vg(F,u,x.imageType)}function jw(F,a,x,c,u,g,y,v,w,B,W){return new Promise((ae,ue)=>{if(x){const fe=a.createTexture(null,!0,!0,null,1,null,Re=>{ue(Re)},F);c.getEffect().executeWhenCompiled(()=>{c.externalTextureSamplerBinding=!0,c.onApply=Re=>{Re._bindTexture("textureSampler",fe),Re.setFloat2("scale",1,a._features.needsInvertingBitmap&&F instanceof ImageBitmap?-1:1)},a.scenes.length&&(a.scenes[0].postProcessManager.directRender([c],B,!0,g,y),a.restoreDefaultFramebuffer(),fe.dispose(),URL.revokeObjectURL(u),ae())})}else{if(a._uploadImageToTexture(W,F,g,y),v){const fe=w[y];fe&&a._uploadImageToTexture(fe._texture,F,g,0)}ae()}})}function Vg(F,a,x=w_){if(!_t.IsExponentOfTwo(F.width))throw new Error("Texture size must be a power of two");const c=_n.ILog2(F.width)+1,u=F.getEngine();let g=!1,y=!1,v=null,w=null,B=null;const W=u.getCaps();if(F.format=5,F.type=0,F.generateMipMaps=!0,F._cachedAnisotropicFilteringLevel=null,u.updateTextureSamplingMode(3,F),W.textureLOD?u._features.supportRenderAndCopyToLodForFloatTextures?W.textureHalfFloatRender&&W.textureHalfFloatLinearFiltering?(g=!0,F.type=2):W.textureFloatRender&&W.textureFloatLinearFiltering&&(g=!0,F.type=1):g=!1:(g=!1,y=!0,B={}),g)v=new In("rgbdDecode","rgbdDecode",null,null,1,null,3,u,!1,void 0,F.type,void 0,null,!1),F._isRGBD=!1,F.invertY=!1,w=u.createRenderTargetCubeTexture(F.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:F.type,format:5});else if(F._isRGBD=!0,F.invertY=!0,y){const fe=F._lodGenerationScale,Re=F._lodGenerationOffset;for(let _e=0;_e<3;_e++){const tt=1-_e/2,$e=Re,Et=(c-1)*fe+Re,ft=$e+(Et-$e)*tt,dt=Math.round(Math.min(Math.max(ft,0),Et)),ut=new a0(u,hn.Temp);ut.isCube=!0,ut.invertY=!0,ut.generateMipMaps=!1,u.updateTextureSamplingMode(2,ut);const Mt=new Un(null);switch(Mt._isCube=!0,Mt._texture=ut,B[dt]=Mt,_e){case 0:F._lodTextureLow=Mt;break;case 1:F._lodTextureMid=Mt;break;case 2:F._lodTextureHigh=Mt;break}}}const ae=[];for(let ue=0;ue<a.length;ue++)for(let fe=0;fe<6;fe++){const Re=a[ue][fe],_e=new Blob([Re],{type:x}),Be=URL.createObjectURL(_e);let tt;if(u._features.forceBitmapOverHTMLImageElement)tt=u.createImageBitmap(_e,{premultiplyAlpha:"none"}).then($e=>jw($e,u,g,v,Be,fe,ue,y,B,w,F));else{const $e=new Image;$e.src=Be,tt=new Promise((Et,ft)=>{$e.onload=()=>{jw($e,u,g,v,Be,fe,ue,y,B,w,F).then(()=>Et()).catch(dt=>{ft(dt)})},$e.onerror=dt=>{ft(dt)}})}ae.push(tt)}if(a.length<c){let ue;const fe=Math.pow(2,c-1-a.length),Re=fe*fe*4;switch(F.type){case 0:{ue=new Uint8Array(Re);break}case 2:{ue=new Uint16Array(Re);break}case 1:{ue=new Float32Array(Re);break}}for(let _e=a.length;_e<c;_e++)for(let Be=0;Be<6;Be++)u._uploadArrayBufferViewToTexture(F,ue,Be,_e)}return Promise.all(ae).then(()=>{w&&(u._releaseTexture(F),w._swapAndDie(F)),v&&v.dispose(),y&&(F._lodTextureHigh&&F._lodTextureHigh._texture&&(F._lodTextureHigh._texture.isReady=!0),F._lodTextureMid&&F._lodTextureMid._texture&&(F._lodTextureMid._texture.isReady=!0),F._lodTextureLow&&F._lodTextureLow._texture&&(F._lodTextureLow._texture.isReady=!0))})}function Yw(F,a){a=Ug(a);const x=a.irradiance;if(!x)return;const c=new Wu;Ee.FromArrayToRef(x.x,0,c.x),Ee.FromArrayToRef(x.y,0,c.y),Ee.FromArrayToRef(x.z,0,c.z),Ee.FromArrayToRef(x.xx,0,c.xx),Ee.FromArrayToRef(x.yy,0,c.yy),Ee.FromArrayToRef(x.zz,0,c.zz),Ee.FromArrayToRef(x.yz,0,c.yz),Ee.FromArrayToRef(x.zx,0,c.zx),Ee.FromArrayToRef(x.xy,0,c.xy),F._sphericalPolynomial=c}function yF(F,a,x,c,u){const g=F.getEngine().createRawCubeTexture(null,F.width,F.format,F.type,F.generateMipMaps,F.invertY,F.samplingMode,F._compression),y=Vg(g,a).then(()=>F);return F.onRebuildCallback=v=>({proxy:y,isReady:!0,isAsync:!0}),F._source=hn.CubeRawRGBD,F._bufferViewArrayArray=a,F._lodGenerationScale=c,F._lodGenerationOffset=u,F._sphericalPolynomial=x,Vg(F,a).then(()=>(F.isReady=!0,F))}const U9={GetEnvInfo:Ww,CreateEnvTextureAsync:gF,CreateImageDataArrayBufferViews:Hw,UploadEnvLevelsAsync:Xw,UploadLevelsAsync:Vg,UploadEnvSpherical:Yw};Es.prototype._createDepthStencilCubeTexture=function(F,a){const x=new a0(this,hn.DepthStencil);if(x.isCube=!0,this.webGLVersion===1)return Qt.Error("Depth cube texture is not supported by WebGL 1."),x;const c={bilinearFiltering:!1,comparisonFunction:0,generateStencil:!1,...a},u=this._gl;this._bindTextureDirectly(u.TEXTURE_CUBE_MAP,x,!0),this._setupDepthStencilTexture(x,F,c.generateStencil,c.bilinearFiltering,c.comparisonFunction);for(let g=0;g<6;g++)c.generateStencil?u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X+g,0,u.DEPTH24_STENCIL8,F,F,0,u.DEPTH_STENCIL,u.UNSIGNED_INT_24_8,null):u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X+g,0,u.DEPTH_COMPONENT24,F,F,0,u.DEPTH_COMPONENT,u.UNSIGNED_INT,null);return this._bindTextureDirectly(u.TEXTURE_CUBE_MAP,null),this._internalTexturesCache.push(x),x},Es.prototype._partialLoadFile=function(F,a,x,c,u=null){const g=v=>{x[a]=v,x._internalCount++,x._internalCount===6&&c(x)},y=(v,w)=>{u&&v&&u(v.status+" "+v.statusText,w)};this._loadFile(F,g,void 0,void 0,!0,y)},Es.prototype._cascadeLoadFiles=function(F,a,x,c=null){const u=[];u._internalCount=0;for(let g=0;g<6;g++)this._partialLoadFile(x[g],g,u,a,c)},Es.prototype._cascadeLoadImgs=function(F,a,x,c,u=null,g){const y=[];y._internalCount=0;for(let v=0;v<6;v++)this._partialLoadImg(c[v],v,y,F,a,x,u,g)},Es.prototype._partialLoadImg=function(F,a,x,c,u,g,y=null,v){const w=v0();f2(F,ae=>{x[a]=ae,x._internalCount++,c&&c.removePendingData(w),x._internalCount===6&&g&&g(u,x)},(ae,ue)=>{c&&c.removePendingData(w),y&&y(ae,ue)},c?c.offlineProvider:null,v),c&&c.addPendingData(w)},Es.prototype._setCubeMapTextureParams=function(F,a,x){const c=this._gl;c.texParameteri(c.TEXTURE_CUBE_MAP,c.TEXTURE_MAG_FILTER,c.LINEAR),c.texParameteri(c.TEXTURE_CUBE_MAP,c.TEXTURE_MIN_FILTER,a?c.LINEAR_MIPMAP_LINEAR:c.LINEAR),c.texParameteri(c.TEXTURE_CUBE_MAP,c.TEXTURE_WRAP_S,c.CLAMP_TO_EDGE),c.texParameteri(c.TEXTURE_CUBE_MAP,c.TEXTURE_WRAP_T,c.CLAMP_TO_EDGE),F.samplingMode=a?3:2,a&&this.getCaps().textureMaxLevel&&x!==void 0&&x>0&&(c.texParameteri(c.TEXTURE_CUBE_MAP,c.TEXTURE_MAX_LEVEL,x),F._maxLodLevel=x),this._bindTextureDirectly(c.TEXTURE_CUBE_MAP,null)},Es.prototype.createCubeTextureBase=function(F,a,x,c,u=null,g=null,y,v=null,w=!1,B=0,W=0,ae=null,ue=null,fe=null,Re=!1){const _e=ae||new a0(this,hn.Cube);_e.isCube=!0,_e.url=F,_e.generateMipMaps=!c,_e._lodGenerationScale=B,_e._lodGenerationOffset=W,_e._useSRGBBuffer=!!Re&&this._caps.supportSRGBBuffers&&(this.webGLVersion>1||this.isWebGPU||!!c),_e!==ae&&(_e.label=F.substring(0,60)),this._doNotHandleContextLost||(_e._extension=v,_e._files=x);const Be=F;this._transformTextureUrl&&!ae&&(F=this._transformTextureUrl(F));const tt=F.split("?")[0],$e=tt.lastIndexOf("."),Et=v||($e>-1?tt.substring($e).toLowerCase():"");let ft=null;for(const ut of Es._TextureLoaders)if(ut.canLoad(Et)){ft=ut;break}const dt=(ut,Mt)=>{F===Be?g&&ut&&g(ut.status+" "+ut.statusText,Mt):(Qt.Warn(`Failed to load ${F}, falling back to the ${Be}`),this.createCubeTextureBase(Be,a,x,!!c,u,g,y,v,w,B,W,_e,ue,fe,Re))};if(ft){const ut=Mt=>{ue&&ue(_e,Mt),ft.loadCubeData(Mt,_e,w,u,g)};x&&x.length===6?ft.supportCascades?this._cascadeLoadFiles(a,Mt=>ut(Mt.map(ai=>new Uint8Array(ai))),x,g):g?g("Textures type does not support cascades."):Qt.Warn("Texture loader does not support cascades."):this._loadFile(F,Mt=>ut(new Uint8Array(Mt)),void 0,void 0,!0,dt)}else{if(!x||x.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(a,_e,(ut,Mt)=>{fe&&fe(ut,Mt)},x,g)}return this._internalTexturesCache.push(_e),_e},Es.prototype.createCubeTexture=function(F,a,x,c,u=null,g=null,y,v=null,w=!1,B=0,W=0,ae=null,ue,fe=!1){const Re=this._gl;return this.createCubeTextureBase(F,a,x,!!c,u,g,y,v,w,B,W,ae,_e=>this._bindTextureDirectly(Re.TEXTURE_CUBE_MAP,_e,!0),(_e,Be)=>{const tt=this.needPOTTextures?Es.GetExponentOfTwo(Be[0].width,this._caps.maxCubemapTextureSize):Be[0].width,$e=tt,Et=[Re.TEXTURE_CUBE_MAP_POSITIVE_X,Re.TEXTURE_CUBE_MAP_POSITIVE_Y,Re.TEXTURE_CUBE_MAP_POSITIVE_Z,Re.TEXTURE_CUBE_MAP_NEGATIVE_X,Re.TEXTURE_CUBE_MAP_NEGATIVE_Y,Re.TEXTURE_CUBE_MAP_NEGATIVE_Z];this._bindTextureDirectly(Re.TEXTURE_CUBE_MAP,_e,!0),this._unpackFlipY(!1);const ft=y?this._getInternalFormat(y,_e._useSRGBBuffer):_e._useSRGBBuffer?this._glSRGBExtensionValues.SRGB8_ALPHA8:Re.RGBA;let dt=y?this._getInternalFormat(y):Re.RGBA;_e._useSRGBBuffer&&this.webGLVersion===1&&(dt=ft);for(let ut=0;ut<Et.length;ut++)if(Be[ut].width!==tt||Be[ut].height!==$e){if(this._prepareWorkingCanvas(),!this._workingCanvas||!this._workingContext){Qt.Warn("Cannot create canvas to resize texture.");return}this._workingCanvas.width=tt,this._workingCanvas.height=$e,this._workingContext.drawImage(Be[ut],0,0,Be[ut].width,Be[ut].height,0,0,tt,$e),Re.texImage2D(Et[ut],0,ft,dt,Re.UNSIGNED_BYTE,this._workingCanvas)}else Re.texImage2D(Et[ut],0,ft,dt,Re.UNSIGNED_BYTE,Be[ut]);c||Re.generateMipmap(Re.TEXTURE_CUBE_MAP),this._setCubeMapTextureParams(_e,!c),_e.width=tt,_e.height=$e,_e.isReady=!0,y&&(_e.format=y),_e.onLoadedObservable.notifyObservers(_e),_e.onLoadedObservable.clear(),u&&u()},!!fe)};class vo extends Un{set boundingBoxSize(a){if(this._boundingBoxSize&&this._boundingBoxSize.equals(a))return;this._boundingBoxSize=a;const x=this.getScene();x&&x.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}set rotationY(a){this._rotationY=a,this.setReflectionTextureMatrix(vt.RotationY(this._rotationY))}get rotationY(){return this._rotationY}get noMipmap(){return this._noMipmap}get forcedExtension(){return this._forcedExtension}static CreateFromImages(a,x,c){let u="";return a.forEach(g=>u+=g),new vo(u,x,null,c,a)}static CreateFromPrefilteredData(a,x,c=null,u=!0){const g=x.useDelayedTextureLoading;x.useDelayedTextureLoading=!1;const y=new vo(a,x,null,!1,null,null,null,void 0,!0,c,u);return x.useDelayedTextureLoading=g,y}constructor(a,x,c=null,u=!1,g=null,y=null,v=null,w=5,B=!1,W=null,ae=!1,ue=.8,fe=0,Re,_e){super(x),this._lodScale=.8,this._lodOffset=0,this.onLoadObservable=new Jt,this.boundingBoxPosition=Ee.Zero(),this._rotationY=0,this._files=null,this._forcedExtension=null,this._extensions=null,this._textureMatrixRefraction=new vt,this.name=a,this.url=a,this._noMipmap=u,this.hasAlpha=!1,this._format=w,this.isCube=!0,this._textureMatrix=vt.Identity(),this._createPolynomials=ae,this.coordinatesMode=fi.CUBIC_MODE,this._extensions=c,this._files=g,this._forcedExtension=W,this._loaderOptions=Re,this._useSRGBBuffer=_e,this._lodScale=ue,this._lodOffset=fe,!(!a&&!g)&&this.updateURL(a,W,y,B,v,c,this.getScene()?.useDelayedTextureLoading,g)}getClassName(){return"CubeTexture"}updateURL(a,x,c=null,u=!1,g=null,y=null,v=!1,w=null){(!this.name||this.name.startsWith("data:"))&&(this.name=a),this.url=a,x&&(this._forcedExtension=x);const B=a.lastIndexOf("."),W=x||(B>-1?a.substring(B).toLowerCase():""),ae=W.indexOf(".dds")===0,ue=W.indexOf(".env")===0,fe=W.indexOf(".basis")===0;if(ue?(this.gammaSpace=!1,this._prefiltered=!1,this.anisotropicFilteringLevel=1):(this._prefiltered=u,u&&(this.gammaSpace=!1,this.anisotropicFilteringLevel=1)),w)this._files=w;else if(!fe&&!ue&&!ae&&!y&&(y=["_px.jpg","_py.jpg","_pz.jpg","_nx.jpg","_ny.jpg","_nz.jpg"]),this._files=this._files||[],this._files.length=0,y){for(let Re=0;Re<y.length;Re++)this._files.push(a+y[Re]);this._extensions=y}v?(this.delayLoadState=4,this._delayedOnLoad=c,this._delayedOnError=g):this._loadTexture(c,g)}delayLoad(a){this.delayLoadState===4&&(a&&(this._forcedExtension=a),this.delayLoadState=1,this._loadTexture(this._delayedOnLoad,this._delayedOnError))}getReflectionTextureMatrix(){return this._textureMatrix}setReflectionTextureMatrix(a){if(a.updateFlag===this._textureMatrix.updateFlag||(a.isIdentity()!==this._textureMatrix.isIdentity()&&this.getScene()?.markAllMaterialsAsDirty(1,g=>g.getActiveTextures().indexOf(this)!==-1),this._textureMatrix=a,!this.getScene()?.useRightHandedSystem))return;const x=Yt.Vector3[0],c=Yt.Quaternion[0],u=Yt.Vector3[1];this._textureMatrix.decompose(x,c,u),c.z*=-1,c.w*=-1,vt.ComposeToRef(x,c,u,this._textureMatrixRefraction)}getRefractionTextureMatrix(){return this.getScene()?.useRightHandedSystem?this._textureMatrixRefraction:this._textureMatrix}_loadTexture(a=null,x=null){const c=this.getScene(),u=this._texture;this._texture=this._getFromCache(this.url,this._noMipmap,void 0,void 0,this._useSRGBBuffer,this.isCube);const g=()=>{this.onLoadObservable.notifyObservers(this),u&&(u.dispose(),this.getScene()?.markAllMaterialsAsDirty(1)),a&&a()},y=(v,w)=>{this._loadingError=!0,this._errorObject={message:v,exception:w},x&&x(v,w),fi.OnTextureLoadErrorObservable.notifyObservers(this)};this._texture?this._texture.isReady?_t.SetImmediate(()=>g()):this._texture.onLoadedObservable.add(()=>g()):(this._prefiltered?this._texture=this._getEngine().createPrefilteredCubeTexture(this.url,c,this._lodScale,this._lodOffset,a,y,this._format,this._forcedExtension,this._createPolynomials):this._texture=this._getEngine().createCubeTexture(this.url,c,this._files,this._noMipmap,a,y,this._format,this._forcedExtension,!1,this._lodScale,this._lodOffset,null,this._loaderOptions,!!this._useSRGBBuffer),this._texture?.onLoadedObservable.add(()=>this.onLoadObservable.notifyObservers(this)))}static Parse(a,x,c){const u=hr.Parse(()=>{let g=!1;return a.prefiltered&&(g=a.prefiltered),new vo(c+(a.url??a.name),x,a.extensions,!1,a.files||null,null,null,void 0,g,a.forcedExtension)},a,x);if(a.boundingBoxPosition&&(u.boundingBoxPosition=Ee.FromArray(a.boundingBoxPosition)),a.boundingBoxSize&&(u.boundingBoxSize=Ee.FromArray(a.boundingBoxSize)),a.animations)for(let g=0;g<a.animations.length;g++){const y=a.animations[g],v=Ua("BABYLON.Animation");v&&u.animations.push(v.Parse(y))}return u}clone(){let a=0;const x=hr.Clone(()=>{const c=new vo(this.url,this.getScene()||this._getEngine(),this._extensions,this._noMipmap,this._files);return a=c.uniqueId,c},this);return x.uniqueId=a,x}}Ye([ht()],vo.prototype,"url",void 0),Ye([En()],vo.prototype,"boundingBoxPosition",void 0),Ye([En()],vo.prototype,"boundingBoxSize",null),Ye([ht("rotationY")],vo.prototype,"rotationY",null),Ye([ht("files")],vo.prototype,"_files",void 0),Ye([ht("forcedExtension")],vo.prototype,"_forcedExtension",void 0),Ye([ht("extensions")],vo.prototype,"_extensions",void 0),Ye([Jy("textureMatrix")],vo.prototype,"_textureMatrix",void 0),Ye([Jy("textureMatrixRefraction")],vo.prototype,"_textureMatrixRefraction",void 0),fi._CubeTextureParser=vo.Parse,as("BABYLON.CubeTexture",vo);class O_ extends vo{constructor(a,x,c,u=5,g=0,y=!1,v=!1,w=3,B=null){super("",a),this._texture=a.getEngine().createRawCubeTexture(x,c,u,g,y,v,w,B)}update(a,x,c,u,g=null){this._texture.getEngine().updateRawCubeTexture(this._texture,a,x,c,u,g)}updateRGBDAsync(a,x=null,c=.8,u=0){return yF(this._texture,a,x,c,u).then(()=>{})}clone(){return hr.Clone(()=>{const a=this.getScene(),x=this._texture,c=new O_(a,x._bufferViewArray,x.width,x.format,x.type,x.generateMipMaps,x.invertY,x.samplingMode,x._compression);return x.source===hn.CubeRawRGBD&&c.updateRGBDAsync(x._bufferViewArrayArray,x._sphericalPolynomial,x._lodGenerationScale,x._lodGenerationOffset),c},this)}}const D_="EXT_lights_image_based";class bF{constructor(a){this.name=D_,this._loader=a,this.enabled=this._loader.isExtensionUsed(D_)}dispose(){this._loader=null,delete this._lights}onLoading(){const a=this._loader.gltf.extensions;if(a&&a[this.name]){const x=a[this.name];this._lights=x.lights}}loadSceneAsync(a,x){return _s.LoadExtensionAsync(a,x,this.name,(c,u)=>{this._loader._allMaterialsDirtyRequired=!0;const g=new Array;g.push(this._loader.loadSceneAsync(a,x)),this._loader.logOpen(`${c}`);const y=lr.Get(`${c}/light`,this._lights,u.light);return g.push(this._loadLightAsync(`/extensions/${this.name}/lights/${u.light}`,y).then(v=>{this._loader.babylonScene.environmentTexture=v})),this._loader.logClose(),Promise.all(g).then(()=>{})})}_loadLightAsync(a,x){if(!x._loaded){const c=new Array;this._loader.logOpen(`${a}`);const u=new Array(x.specularImages.length);for(let g=0;g<x.specularImages.length;g++){const y=x.specularImages[g];u[g]=new Array(y.length);for(let v=0;v<y.length;v++){const w=`${a}/specularImages/${g}/${v}`;this._loader.logOpen(`${w}`);const B=y[v],W=lr.Get(w,this._loader.gltf.images,B);c.push(this._loader.loadImageAsync(`/images/${B}`,W).then(ae=>{u[g][v]=ae})),this._loader.logClose()}}this._loader.logClose(),x._loaded=Promise.all(c).then(()=>{const g=new O_(this._loader.babylonScene,null,x.specularImageSize);if(g.name=x.name||"environment",x._babylonTexture=g,x.intensity!=null&&(g.level=x.intensity),x.rotation){let B=Wi.FromArray(x.rotation);this._loader.babylonScene.useRightHandedSystem||(B=Wi.Inverse(B)),vt.FromQuaternionToRef(B,g.getReflectionTextureMatrix())}if(!x.irradianceCoefficients)throw new Error(`${a}: Irradiance coefficients are missing`);const y=Vu.FromArray(x.irradianceCoefficients);y.scaleInPlace(x.intensity),y.convertIrradianceToLambertianRadiance();const v=Wu.FromHarmonics(y),w=(u.length-1)/_n.Log2(x.specularImageSize);return g.updateRGBDAsync(u,v,w)})}return x._loaded.then(()=>x._babylonTexture)}}_s.RegisterExtension(D_,F=>new bF(F)),sr.prototype.thinInstanceAdd=function(F,a=!0){if(!this.getScene().getEngine().getCaps().instancedArrays)return Qt.Error("Thin Instances are not supported on this device as Instanced Array extension not supported"),-1;this._thinInstanceUpdateBufferSize("matrix",Array.isArray(F)?F.length:1);const x=this._thinInstanceDataStorage.instancesCount;if(Array.isArray(F))for(let c=0;c<F.length;++c)this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,F[c],c===F.length-1&&a);else this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++,F,a);return x},sr.prototype.thinInstanceAddSelf=function(F=!0){return this.thinInstanceAdd(vt.IdentityReadOnly,F)},sr.prototype.thinInstanceRegisterAttribute=function(F,a){F===Ve.ColorKind&&(F=Ve.ColorInstanceKind),this.removeVerticesData(F),this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.strides[F]=a,this._userThinInstanceBuffersStorage.sizes[F]=a*Math.max(32,this._thinInstanceDataStorage.instancesCount),this._userThinInstanceBuffersStorage.data[F]=new Float32Array(this._userThinInstanceBuffersStorage.sizes[F]),this._userThinInstanceBuffersStorage.vertexBuffers[F]=new Ve(this.getEngine(),this._userThinInstanceBuffersStorage.data[F],F,!0,!1,a,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[F])},sr.prototype.thinInstanceSetMatrixAt=function(F,a,x=!0){if(!this._thinInstanceDataStorage.matrixData||F>=this._thinInstanceDataStorage.instancesCount)return!1;const c=this._thinInstanceDataStorage.matrixData;return a.copyToArray(c,F*16),this._thinInstanceDataStorage.worldMatrices&&(this._thinInstanceDataStorage.worldMatrices[F]=a),x&&(this.thinInstanceBufferUpdated("matrix"),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)),!0},sr.prototype.thinInstanceSetAttributeAt=function(F,a,x,c=!0){return F===Ve.ColorKind&&(F=Ve.ColorInstanceKind),!this._userThinInstanceBuffersStorage||!this._userThinInstanceBuffersStorage.data[F]||a>=this._thinInstanceDataStorage.instancesCount?!1:(this._thinInstanceUpdateBufferSize(F,0),this._userThinInstanceBuffersStorage.data[F].set(x,a*this._userThinInstanceBuffersStorage.strides[F]),c&&this.thinInstanceBufferUpdated(F),!0)},Object.defineProperty(sr.prototype,"thinInstanceCount",{get:function(){return this._thinInstanceDataStorage.instancesCount},set:function(F){const a=this._thinInstanceDataStorage.matrixData??this.source?._thinInstanceDataStorage.matrixData,x=a?a.length/16:0;F<=x&&(this._thinInstanceDataStorage.instancesCount=F)},enumerable:!0,configurable:!0}),sr.prototype._thinInstanceCreateMatrixBuffer=function(F,a,x=!0){const c=new mu(this.getEngine(),a,!x,16,!1,!0);for(let u=0;u<4;u++)this.setVerticesBuffer(c.createVertexBuffer(F+u,u*4,4));return c},sr.prototype.thinInstanceSetBuffer=function(F,a,x=0,c=!0){x=x||16,F==="matrix"?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=null,this._thinInstanceDataStorage.matrixBufferSize=a?a.length:32*x,this._thinInstanceDataStorage.matrixData=a,this._thinInstanceDataStorage.worldMatrices=null,a!==null?(this._thinInstanceDataStorage.instancesCount=a.length/x,this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",a,c),this.doNotSyncBoundingInfo||this.thinInstanceRefreshBoundingInfo(!1)):(this._thinInstanceDataStorage.instancesCount=0,this.doNotSyncBoundingInfo||this.refreshBoundingInfo())):F==="previousMatrix"?(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=null,this._thinInstanceDataStorage.previousMatrixData=a,a!==null&&(this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",a,c))):(F===Ve.ColorKind&&(F=Ve.ColorInstanceKind),a===null?this._userThinInstanceBuffersStorage?.data[F]&&(this.removeVerticesData(F),delete this._userThinInstanceBuffersStorage.data[F],delete this._userThinInstanceBuffersStorage.strides[F],delete this._userThinInstanceBuffersStorage.sizes[F],delete this._userThinInstanceBuffersStorage.vertexBuffers[F]):(this._thinInstanceInitializeUserStorage(),this._userThinInstanceBuffersStorage.data[F]=a,this._userThinInstanceBuffersStorage.strides[F]=x,this._userThinInstanceBuffersStorage.sizes[F]=a.length,this._userThinInstanceBuffersStorage.vertexBuffers[F]=new Ve(this.getEngine(),a,F,!c,!1,x,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[F])))},sr.prototype.thinInstanceBufferUpdated=function(F){F==="matrix"?(this.thinInstanceAllowAutomaticStaticBufferRecreation&&this._thinInstanceDataStorage.matrixBuffer&&!this._thinInstanceDataStorage.matrixBuffer.isUpdatable()&&this._thinInstanceRecreateBuffer(F),this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData,0,this._thinInstanceDataStorage.instancesCount)):F==="previousMatrix"?(this.thinInstanceAllowAutomaticStaticBufferRecreation&&this._thinInstanceDataStorage.previousMatrixBuffer&&!this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()&&this._thinInstanceRecreateBuffer(F),this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData,0,this._thinInstanceDataStorage.instancesCount)):(F===Ve.ColorKind&&(F=Ve.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[F]&&(this.thinInstanceAllowAutomaticStaticBufferRecreation&&!this._userThinInstanceBuffersStorage.vertexBuffers[F].isUpdatable()&&this._thinInstanceRecreateBuffer(F),this._userThinInstanceBuffersStorage.vertexBuffers[F].updateDirectly(this._userThinInstanceBuffersStorage.data[F],0)))},sr.prototype.thinInstancePartialBufferUpdate=function(F,a,x){F==="matrix"?this._thinInstanceDataStorage.matrixBuffer&&this._thinInstanceDataStorage.matrixBuffer.updateDirectly(a,x):(F===Ve.ColorKind&&(F=Ve.ColorInstanceKind),this._userThinInstanceBuffersStorage?.vertexBuffers[F]&&this._userThinInstanceBuffersStorage.vertexBuffers[F].updateDirectly(a,x))},sr.prototype.thinInstanceGetWorldMatrices=function(){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return[];const F=this._thinInstanceDataStorage.matrixData;if(!this._thinInstanceDataStorage.worldMatrices){this._thinInstanceDataStorage.worldMatrices=[];for(let a=0;a<this._thinInstanceDataStorage.instancesCount;++a)this._thinInstanceDataStorage.worldMatrices[a]=vt.FromArray(F,a*16)}return this._thinInstanceDataStorage.worldMatrices},sr.prototype.thinInstanceRefreshBoundingInfo=function(F=!1,a=!1,x=!1){if(!this._thinInstanceDataStorage.matrixData||!this._thinInstanceDataStorage.matrixBuffer)return;const c=this._thinInstanceDataStorage.boundingVectors;if(F||!this.rawBoundingInfo){c.length=0,this.refreshBoundingInfo(a,x);const y=this.getBoundingInfo();this.rawBoundingInfo=new tx(y.minimum,y.maximum)}const u=this.getBoundingInfo(),g=this._thinInstanceDataStorage.matrixData;if(c.length===0)for(let y=0;y<u.boundingBox.vectors.length;++y)c.push(u.boundingBox.vectors[y].clone());Yt.Vector3[0].setAll(Number.POSITIVE_INFINITY),Yt.Vector3[1].setAll(Number.NEGATIVE_INFINITY);for(let y=0;y<this._thinInstanceDataStorage.instancesCount;++y){vt.FromArrayToRef(g,y*16,Yt.Matrix[0]);for(let v=0;v<c.length;++v)Ee.TransformCoordinatesToRef(c[v],Yt.Matrix[0],Yt.Vector3[2]),Yt.Vector3[0].minimizeInPlace(Yt.Vector3[2]),Yt.Vector3[1].maximizeInPlace(Yt.Vector3[2])}u.reConstruct(Yt.Vector3[0],Yt.Vector3[1]),this._updateBoundingInfo()},sr.prototype._thinInstanceRecreateBuffer=function(F,a=!0){F==="matrix"?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",this._thinInstanceDataStorage.matrixData,a)):F==="previousMatrix"?this._scene.needsPreviousWorldMatrices&&(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",this._thinInstanceDataStorage.previousMatrixData??this._thinInstanceDataStorage.matrixData,a)):(F===Ve.ColorKind&&(F=Ve.ColorInstanceKind),this._userThinInstanceBuffersStorage.vertexBuffers[F]?.dispose(),this._userThinInstanceBuffersStorage.vertexBuffers[F]=new Ve(this.getEngine(),this._userThinInstanceBuffersStorage.data[F],F,!a,!1,this._userThinInstanceBuffersStorage.strides[F],!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[F]))},sr.prototype._thinInstanceUpdateBufferSize=function(F,a=1){F===Ve.ColorKind&&(F=Ve.ColorInstanceKind);const x=F==="matrix";if(!x&&(!this._userThinInstanceBuffersStorage||!this._userThinInstanceBuffersStorage.strides[F]))return;const c=x?16:this._userThinInstanceBuffersStorage.strides[F],u=x?this._thinInstanceDataStorage.matrixBufferSize:this._userThinInstanceBuffersStorage.sizes[F];let g=x?this._thinInstanceDataStorage.matrixData:this._userThinInstanceBuffersStorage.data[F];const y=(this._thinInstanceDataStorage.instancesCount+a)*c;let v=u;for(;v<y;)v*=2;if(!g||u!=v){if(!g)g=new Float32Array(v);else{const w=new Float32Array(v);w.set(g,0),g=w}x?(this._thinInstanceDataStorage.matrixBuffer?.dispose(),this._thinInstanceDataStorage.matrixBuffer=this._thinInstanceCreateMatrixBuffer("world",g,!1),this._thinInstanceDataStorage.matrixData=g,this._thinInstanceDataStorage.matrixBufferSize=v,this._scene.needsPreviousWorldMatrices&&!this._thinInstanceDataStorage.previousMatrixData&&(this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),this._thinInstanceDataStorage.previousMatrixBuffer=this._thinInstanceCreateMatrixBuffer("previousWorld",g,!1))):(this._userThinInstanceBuffersStorage.vertexBuffers[F]?.dispose(),this._userThinInstanceBuffersStorage.data[F]=g,this._userThinInstanceBuffersStorage.sizes[F]=v,this._userThinInstanceBuffersStorage.vertexBuffers[F]=new Ve(this.getEngine(),g,F,!0,!1,c,!0),this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[F]))}},sr.prototype._thinInstanceInitializeUserStorage=function(){this._userThinInstanceBuffersStorage||(this._userThinInstanceBuffersStorage={data:{},sizes:{},vertexBuffers:{},strides:{}})},sr.prototype._disposeThinInstanceSpecificData=function(){this._thinInstanceDataStorage?.matrixBuffer&&(this._thinInstanceDataStorage.matrixBuffer.dispose(),this._thinInstanceDataStorage.matrixBuffer=null)};const N_="EXT_mesh_gpu_instancing";class EF{constructor(a){this.name=N_,this._loader=a,this.enabled=this._loader.isExtensionUsed(N_)}dispose(){this._loader=null}loadNodeAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{this._loader._disableInstancedMesh++;const y=this._loader.loadNodeAsync(`/nodes/${x.index}`,x,c);if(this._loader._disableInstancedMesh--,!x._primitiveBabylonMeshes)return y;const v=new Array;let w=0;const B=W=>{if(g.attributes[W]==null){v.push(Promise.resolve(null));return}const ae=lr.Get(`${u}/attributes/${W}`,this._loader.gltf.accessors,g.attributes[W]);if(v.push(this._loader._loadFloatAccessorAsync(`/accessors/${ae.bufferView}`,ae)),w===0)w=ae.count;else if(w!==ae.count)throw new Error(`${u}/attributes: Instance buffer accessors do not have the same count.`)};return B("TRANSLATION"),B("ROTATION"),B("SCALE"),y.then(W=>Promise.all(v).then(([ae,ue,fe])=>{const Re=new Float32Array(w*16);Yt.Vector3[0].copyFromFloats(0,0,0),Yt.Quaternion[0].copyFromFloats(0,0,0,1),Yt.Vector3[1].copyFromFloats(1,1,1);for(let _e=0;_e<w;++_e)ae&&Ee.FromArrayToRef(ae,_e*3,Yt.Vector3[0]),ue&&Wi.FromArrayToRef(ue,_e*4,Yt.Quaternion[0]),fe&&Ee.FromArrayToRef(fe,_e*3,Yt.Vector3[1]),vt.ComposeToRef(Yt.Vector3[1],Yt.Quaternion[0],Yt.Vector3[0],Yt.Matrix[0]),Yt.Matrix[0].copyToArray(Re,_e*16);for(const _e of x._primitiveBabylonMeshes)_e.thinInstanceSetBuffer("matrix",Re,16,!0);return W}))})}}_s.RegisterExtension(N_,F=>new EF(F));class uc{static get Default(){return uc._Default||(uc._Default=new uc),uc._Default}constructor(){const a=uc.Configuration.decoder;this._decoderModulePromise=_t.LoadBabylonScriptAsync(a.url).then(()=>MeshoptDecoder.ready)}dispose(){delete this._decoderModulePromise}decodeGltfBufferAsync(a,x,c,u,g){return this._decoderModulePromise.then(()=>{const y=new Uint8Array(x*c);return MeshoptDecoder.decodeGltfBuffer(y,x,c,a,u,g),y})}}uc.Configuration={decoder:{url:`${_t._DefaultCdnUrl}/meshopt_decoder.js`}},uc._Default=null;const L_="EXT_meshopt_compression";class vF{constructor(a){this.name=L_,this.enabled=a.isExtensionUsed(L_),this._loader=a}dispose(){this._loader=null}loadBufferViewAsync(a,x){return _s.LoadExtensionAsync(a,x,this.name,(c,u)=>{const g=x;if(g._meshOptData)return g._meshOptData;const y=lr.Get(`${a}/buffer`,this._loader.gltf.buffers,u.buffer);return g._meshOptData=this._loader.loadBufferAsync(`/buffers/${y.index}`,y,u.byteOffset||0,u.byteLength).then(v=>uc.Default.decodeGltfBufferAsync(v,u.count,u.byteStride,u.mode,u.filter)),g._meshOptData})}}_s.RegisterExtension(L_,F=>new vF(F));const F_="EXT_texture_webp";class IF{constructor(a){this.name=F_,this._loader=a,this.enabled=a.isExtensionUsed(F_)}dispose(){this._loader=null}_loadTextureAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=x.sampler==null?_s.DefaultSampler:lr.Get(`${a}/sampler`,this._loader.gltf.samplers,x.sampler),v=lr.Get(`${u}/source`,this._loader.gltf.images,g.source);return this._loader._createTextureAsync(a,y,v,w=>{c(w)},void 0,!x._textureInfo.nonColorData)})}}_s.RegisterExtension(F_,F=>new IF(F));class RF{constructor(a){this._pendingActions=new Array,this._workerInfos=a.map(x=>({workerPromise:Promise.resolve(x),idle:!0}))}dispose(){for(const a of this._workerInfos)a.workerPromise.then(x=>{x.terminate()});this._workerInfos.length=0,this._pendingActions.length=0}push(a){this._executeOnIdleWorker(a)||this._pendingActions.push(a)}_executeOnIdleWorker(a){for(const x of this._workerInfos)if(x.idle)return this._execute(x,a),!0;return!1}_execute(a,x){a.idle=!1,a.workerPromise.then(c=>{x(c,()=>{const u=this._pendingActions.shift();u?this._execute(a,u):a.idle=!0})})}}class Wg extends RF{constructor(a,x,c=Wg.DefaultOptions){super([]),this._maxWorkers=a,this._createWorkerAsync=x,this._options=c}push(a){if(!this._executeOnIdleWorker(a))if(this._workerInfos.length<this._maxWorkers){const x={workerPromise:this._createWorkerAsync(),idle:!1};this._workerInfos.push(x),this._execute(x,a)}else this._pendingActions.push(a)}_execute(a,x){a.timeoutId&&(clearTimeout(a.timeoutId),delete a.timeoutId),super._execute(a,(c,u)=>{x(c,()=>{u(),a.idle&&(a.timeoutId=setTimeout(()=>{a.workerPromise.then(y=>{y.terminate()});const g=this._workerInfos.indexOf(a);g!==-1&&this._workerInfos.splice(g,1)},this._options.idleTimeElapsedBeforeRelease))})})}}Wg.DefaultOptions={idleTimeElapsedBeforeRelease:1e3};function k_(F,a,x,c,u){let g=null,y=null,v=null;try{g=new F.Decoder,y=new F.DecoderBuffer,y.Init(a,a.byteLength);let w;const B=g.GetEncodedGeometryType(y);switch(B){case F.TRIANGULAR_MESH:{const ue=new F.Mesh;if(w=g.DecodeBufferToMesh(y,ue),!w.ok()||ue.ptr===0)throw new Error(w.error_msg());const Re=ue.num_faces()*3,_e=Re*4,Be=F._malloc(_e);try{g.GetTrianglesUInt32Array(ue,_e,Be);const tt=new Uint32Array(Re);tt.set(new Uint32Array(F.HEAPF32.buffer,Be,Re)),c(tt)}finally{F._free(Be)}v=ue;break}case F.POINT_CLOUD:{const ue=new F.PointCloud;if(w=g.DecodeBufferToPointCloud(y,ue),!w.ok()||!ue.ptr)throw new Error(w.error_msg());v=ue;break}default:throw new Error(`Invalid geometry type ${B}`)}const W=v.num_points(),ae=(ue,fe,Re,_e)=>{const Be=_e.data_type(),tt=_e.num_components(),$e=_e.normalized(),Et=_e.byte_stride(),ft=_e.byte_offset(),ut={[F.DT_FLOAT32]:{typedArrayConstructor:Float32Array,heap:F.HEAPF32},[F.DT_INT8]:{typedArrayConstructor:Int8Array,heap:F.HEAP8},[F.DT_INT16]:{typedArrayConstructor:Int16Array,heap:F.HEAP16},[F.DT_INT32]:{typedArrayConstructor:Int32Array,heap:F.HEAP32},[F.DT_UINT8]:{typedArrayConstructor:Uint8Array,heap:F.HEAPU8},[F.DT_UINT16]:{typedArrayConstructor:Uint16Array,heap:F.HEAPU16},[F.DT_UINT32]:{typedArrayConstructor:Uint32Array,heap:F.HEAPU32}}[Be];if(!ut)throw new Error(`Invalid data type ${Be}`);const Mt=W*tt,ai=Mt*ut.typedArrayConstructor.BYTES_PER_ELEMENT,Yi=F._malloc(ai);try{ue.GetAttributeDataArrayForAllPoints(fe,_e,Be,ai,Yi);const Vi=new ut.typedArrayConstructor(ut.heap.buffer,Yi,Mt);u(Re,Vi.slice(),tt,ft,Et,$e)}finally{F._free(Yi)}};if(x)for(const ue in x){const fe=x[ue],Re=g.GetAttributeByUniqueId(v,fe);ae(g,v,ue,Re)}else{const ue={position:F.POSITION,normal:F.NORMAL,color:F.COLOR,uv:F.TEX_COORD};for(const fe in ue){const Re=g.GetAttributeId(v,ue[fe]);if(Re!==-1){const _e=g.GetAttribute(v,Re);ae(g,v,fe,_e)}}}return W}finally{v&&F.destroy(v),y&&F.destroy(y),g&&F.destroy(g)}}function MF(){let F;onmessage=a=>{const x=a.data;switch(x.id){case"init":{const c=x.decoder;c.url&&importScripts(c.url),F=DracoDecoderModule({wasmBinary:c.wasmBinary}),postMessage({id:"initDone"});break}case"decodeMesh":{if(!F)throw new Error("Draco decoder module is not available");F.then(c=>{const u=k_(c,x.dataView,x.attributes,g=>{postMessage({id:"indices",data:g},[g.buffer])},(g,y,v,w,B,W)=>{postMessage({id:"attribute",kind:g,data:y,size:v,byteOffset:w,byteStride:B,normalized:W},[y.buffer])});postMessage({id:"decodeMeshDone",totalVertices:u})});break}}}}function BF(F,a,x){return new Promise((c,u)=>{const g=w=>{F.removeEventListener("error",g),F.removeEventListener("message",y),u(w)},y=w=>{w.data.id==="initDone"&&(F.removeEventListener("error",g),F.removeEventListener("message",y),c(F))};F.addEventListener("error",g),F.addEventListener("message",y);const v=a.slice(0);F.postMessage({id:"init",decoder:{url:x,wasmBinary:v}},[v])})}function UF(F,a){return new Promise(x=>{(a||DracoDecoderModule)({wasmBinary:F}).then(c=>{x({module:c})})})}class yx{static get DecoderAvailable(){const a=yx.Configuration.decoder;return!!(a.wasmUrl&&a.wasmBinaryUrl&&typeof WebAssembly=="object"||a.fallbackUrl)}static GetDefaultNumWorkers(){return typeof navigator!="object"||!navigator.hardwareConcurrency?1:Math.min(Math.floor(navigator.hardwareConcurrency*.5),4)}static get Default(){return yx._Default||(yx._Default=new yx),yx._Default}constructor(a=yx.DefaultNumWorkers){const x=yx.Configuration.decoder;if(x.workerPool||typeof a=="object"&&a.workerPool)this._workerPoolPromise=Promise.resolve(x.workerPool||a.workerPool);else{const c=x.wasmBinary||typeof a=="object"&&a.wasmBinary,u=typeof a=="number"?a:a.numWorkers,g=u&&typeof Worker=="function"&&typeof URL=="function",y=g||!g&&!x.jsModule,v=x.wasmUrl&&x.wasmBinaryUrl&&typeof WebAssembly=="object"?{url:y?_t.GetBabylonScriptURL(x.wasmUrl,!0):"",wasmBinaryPromise:c?Promise.resolve(c):_t.LoadFileAsync(_t.GetBabylonScriptURL(x.wasmBinaryUrl,!0))}:{url:y?_t.GetBabylonScriptURL(x.fallbackUrl):"",wasmBinaryPromise:Promise.resolve(void 0)};g?this._workerPoolPromise=v.wasmBinaryPromise.then(w=>{const B=`${k_}(${MF})()`,W=URL.createObjectURL(new Blob([B],{type:"application/javascript"}));return new Wg(u,()=>{const ae=new Worker(W);return BF(ae,w,v.url)})}):this._decoderModulePromise=v.wasmBinaryPromise.then(async w=>{if(typeof DracoDecoderModule>"u"&&!x.jsModule){if(!v.url)throw new Error("Draco decoder module is not available");await _t.LoadBabylonScriptAsync(v.url)}return await UF(w,x.jsModule)})}}dispose(){this._workerPoolPromise&&this._workerPoolPromise.then(a=>{a.dispose()}),delete this._workerPoolPromise,delete this._decoderModulePromise}async whenReadyAsync(){if(this._workerPoolPromise){await this._workerPoolPromise;return}if(this._decoderModulePromise){await this._decoderModulePromise;return}}_decodeMeshAsync(a,x,c){const u=a instanceof ArrayBuffer?new Int8Array(a):new Int8Array(a.buffer,a.byteOffset,a.byteLength),g=(y,v)=>c&&c[y]!==void 0?(v!==c[y]&&Qt.Warn(`Normalized flag from Draco data (${v}) does not match normalized flag from glTF accessor (${c[y]}). Using flag from glTF accessor.`),c[y]):v;if(this._workerPoolPromise)return this._workerPoolPromise.then(y=>new Promise((v,w)=>{y.push((B,W)=>{let ae=null;const ue=[],fe=Be=>{B.removeEventListener("error",fe),B.removeEventListener("message",Re),w(Be),W()},Re=Be=>{const tt=Be.data;switch(tt.id){case"decodeMeshDone":{B.removeEventListener("error",fe),B.removeEventListener("message",Re),v({indices:ae,attributes:ue,totalVertices:tt.totalVertices}),W();break}case"indices":{ae=tt.data;break}case"attribute":{ue.push({kind:tt.kind,data:tt.data,size:tt.size,byteOffset:tt.byteOffset,byteStride:tt.byteStride,normalized:g(tt.kind,tt.normalized)});break}}};B.addEventListener("error",fe),B.addEventListener("message",Re);const _e=u.slice();B.postMessage({id:"decodeMesh",dataView:_e,attributes:x},[_e.buffer])})}));if(this._decoderModulePromise)return this._decoderModulePromise.then(y=>{let v=null;const w=[],B=k_(y.module,u,x,W=>{v=W},(W,ae,ue,fe,Re,_e)=>{w.push({kind:W,data:ae,size:ue,byteOffset:fe,byteStride:Re,normalized:_e})});return{indices:v,attributes:w,totalVertices:B}});throw new Error("Draco decoder module is not available")}async decodeMeshToGeometryAsync(a,x,c,u){const g=await this._decodeMeshAsync(c,u),y=new go(a,x);g.indices&&y.setIndices(g.indices);for(const v of g.attributes)y.setVerticesBuffer(new Ve(x.getEngine(),v.data,v.kind,!1,void 0,v.byteStride,void 0,v.byteOffset,v.size,void 0,v.normalized,!0),g.totalVertices);return y}async _decodeMeshToGeometryForGltfAsync(a,x,c,u,g){const y=await this._decodeMeshAsync(c,u,g),v=new go(a,x);y.indices&&v.setIndices(y.indices);for(const w of y.attributes)v.setVerticesBuffer(new Ve(x.getEngine(),w.data,w.kind,!1,void 0,w.byteStride,void 0,w.byteOffset,w.size,void 0,w.normalized,!0),y.totalVertices);return v}async decodeMeshAsync(a,x){const c=await this._decodeMeshAsync(a,x),u=new fr;c.indices&&(u.indices=c.indices);for(const g of c.attributes){const y=Ve.GetFloatData(g.data,g.size,Ve.GetDataType(g.data),g.byteOffset,g.byteStride,g.normalized,c.totalVertices);u.set(y,g.kind)}return u}}yx.Configuration={decoder:{wasmUrl:`${_t._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,wasmBinaryUrl:`${_t._DefaultCdnUrl}/draco_decoder_gltf.wasm`,fallbackUrl:`${_t._DefaultCdnUrl}/draco_decoder_gltf.js`}},yx.DefaultNumWorkers=yx.GetDefaultNumWorkers(),yx._Default=null;const B_="KHR_draco_mesh_compression";class VF{constructor(a){this.name=B_,this.useNormalizedFlagFromAccessor=!0,this._loader=a,this.enabled=yx.DecoderAvailable&&this._loader.isExtensionUsed(B_)}dispose(){delete this.dracoCompression,this._loader=null}_loadVertexDataAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{if(x.mode!=null&&x.mode!==4&&x.mode!==5)throw new Error(`${a}: Unsupported mode ${x.mode}`);const y={},v={},w=(W,ae)=>{const ue=g.attributes[W];if(ue!=null&&(c._delayInfo=c._delayInfo||[],c._delayInfo.indexOf(ae)===-1&&c._delayInfo.push(ae),y[ae]=ue,this.useNormalizedFlagFromAccessor)){const fe=lr.TryGet(this._loader.gltf.accessors,x.attributes[W]);fe&&(v[ae]=fe.normalized||!1)}};w("POSITION",Ve.PositionKind),w("NORMAL",Ve.NormalKind),w("TANGENT",Ve.TangentKind),w("TEXCOORD_0",Ve.UVKind),w("TEXCOORD_1",Ve.UV2Kind),w("TEXCOORD_2",Ve.UV3Kind),w("TEXCOORD_3",Ve.UV4Kind),w("TEXCOORD_4",Ve.UV5Kind),w("TEXCOORD_5",Ve.UV6Kind),w("JOINTS_0",Ve.MatricesIndicesKind),w("WEIGHTS_0",Ve.MatricesWeightsKind),w("COLOR_0",Ve.ColorKind);const B=lr.Get(u,this._loader.gltf.bufferViews,g.bufferView);return B._dracoBabylonGeometry||(B._dracoBabylonGeometry=this._loader.loadBufferViewAsync(`/bufferViews/${B.index}`,B).then(W=>(this.dracoCompression||yx.Default)._decodeMeshToGeometryForGltfAsync(c.name,this._loader.babylonScene,W,y,v).catch(ue=>{throw new Error(`${a}: ${ue.message}`)}))),B._dracoBabylonGeometry})}}_s.RegisterExtension(B_,F=>new VF(F)),fa.AddNodeConstructor("Light_Type_2",(F,a)=>()=>new Wx(F,Ee.Zero(),Ee.Zero(),0,0,a));class Wx extends jc{get angle(){return this._angle}set angle(a){this._angle=a,this._cosHalfAngle=Math.cos(a*.5),this._projectionTextureProjectionLightDirty=!0,this.forceProjectionMatrixCompute(),this._computeAngleValues()}get innerAngle(){return this._innerAngle}set innerAngle(a){this._innerAngle=a,this._computeAngleValues()}get shadowAngleScale(){return this._shadowAngleScale}set shadowAngleScale(a){this._shadowAngleScale=a,this.forceProjectionMatrixCompute()}get projectionTextureMatrix(){return this._projectionTextureMatrix}get projectionTextureLightNear(){return this._projectionTextureLightNear}set projectionTextureLightNear(a){this._projectionTextureLightNear=a,this._projectionTextureProjectionLightDirty=!0}get projectionTextureLightFar(){return this._projectionTextureLightFar}set projectionTextureLightFar(a){this._projectionTextureLightFar=a,this._projectionTextureProjectionLightDirty=!0}get projectionTextureUpDirection(){return this._projectionTextureUpDirection}set projectionTextureUpDirection(a){this._projectionTextureUpDirection=a,this._projectionTextureProjectionLightDirty=!0}get projectionTexture(){return this._projectionTexture}set projectionTexture(a){this._projectionTexture!==a&&(this._projectionTexture=a,this._projectionTextureDirty=!0,this._projectionTexture&&!this._projectionTexture.isReady()&&(Wx._IsProceduralTexture(this._projectionTexture)?this._projectionTexture.getEffect().executeWhenCompiled(()=>{this._markMeshesAsLightDirty()}):Wx._IsTexture(this._projectionTexture)&&this._projectionTexture.onLoadObservable.addOnce(()=>{this._markMeshesAsLightDirty()})))}static _IsProceduralTexture(a){return a.onGeneratedObservable!==void 0}static _IsTexture(a){return a.onLoadObservable!==void 0}get projectionTextureProjectionLightMatrix(){return this._projectionTextureProjectionLightMatrix}set projectionTextureProjectionLightMatrix(a){this._projectionTextureProjectionLightMatrix=a,this._projectionTextureProjectionLightDirty=!1,this._projectionTextureDirty=!0}constructor(a,x,c,u,g,y){super(a,y),this._innerAngle=0,this._projectionTextureMatrix=vt.Zero(),this._projectionTextureLightNear=1e-6,this._projectionTextureLightFar=1e3,this._projectionTextureUpDirection=Ee.Up(),this._projectionTextureViewLightDirty=!0,this._projectionTextureProjectionLightDirty=!0,this._projectionTextureDirty=!0,this._projectionTextureViewTargetVector=Ee.Zero(),this._projectionTextureViewLightMatrix=vt.Zero(),this._projectionTextureProjectionLightMatrix=vt.Zero(),this._projectionTextureScalingMatrix=vt.FromValues(.5,0,0,0,0,.5,0,0,0,0,.5,0,.5,.5,.5,1),this.position=x,this.direction=c,this.angle=u,this.exponent=g}getClassName(){return"SpotLight"}getTypeID(){return Wr.LIGHTTYPEID_SPOTLIGHT}_setDirection(a){super._setDirection(a),this._projectionTextureViewLightDirty=!0}_setPosition(a){super._setPosition(a),this._projectionTextureViewLightDirty=!0}_setDefaultShadowProjectionMatrix(a,x,c){const u=this.getScene().activeCamera;if(!u)return;this._shadowAngleScale=this._shadowAngleScale||1;const g=this._shadowAngleScale*this._angle,y=this.shadowMinZ!==void 0?this.shadowMinZ:u.minZ,v=this.shadowMaxZ!==void 0?this.shadowMaxZ:u.maxZ,w=this.getScene().getEngine().useReverseDepthBuffer;vt.PerspectiveFovLHToRef(g,1,w?v:y,w?y:v,a,!0,this._scene.getEngine().isNDCHalfZRange,void 0,w)}_computeProjectionTextureViewLightMatrix(){this._projectionTextureViewLightDirty=!1,this._projectionTextureDirty=!0,this.getAbsolutePosition().addToRef(this.getShadowDirection(),this._projectionTextureViewTargetVector),vt.LookAtLHToRef(this.getAbsolutePosition(),this._projectionTextureViewTargetVector,this._projectionTextureUpDirection,this._projectionTextureViewLightMatrix)}_computeProjectionTextureProjectionLightMatrix(){this._projectionTextureProjectionLightDirty=!1,this._projectionTextureDirty=!0;const a=this.projectionTextureLightFar,x=this.projectionTextureLightNear,c=a/(a-x),u=-c*x,g=1/Math.tan(this._angle/2);vt.FromValuesToRef(g/1,0,0,0,0,g,0,0,0,0,c,1,0,0,u,0,this._projectionTextureProjectionLightMatrix)}_computeProjectionTextureMatrix(){if(this._projectionTextureDirty=!1,this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix,this._projectionTextureMatrix),this._projectionTexture instanceof fi){const a=this._projectionTexture.uScale/2,x=this._projectionTexture.vScale/2;vt.FromValuesToRef(a,0,0,0,0,x,0,0,0,0,.5,0,.5,.5,.5,1,this._projectionTextureScalingMatrix)}this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix,this._projectionTextureMatrix)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightDirection",3),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}_computeAngleValues(){this._lightAngleScale=1/Math.max(.001,Math.cos(this._innerAngle*.5)-this._cosHalfAngle),this._lightAngleOffset=-this._cosHalfAngle*this._lightAngleScale}transferTexturesToEffect(a,x){return this.projectionTexture&&this.projectionTexture.isReady()&&(this._projectionTextureViewLightDirty&&this._computeProjectionTextureViewLightMatrix(),this._projectionTextureProjectionLightDirty&&this._computeProjectionTextureProjectionLightMatrix(),this._projectionTextureDirty&&this._computeProjectionTextureMatrix(),a.setMatrix("textureProjectionMatrix"+x,this._projectionTextureMatrix),a.setTexture("projectionLightSampler"+x,this.projectionTexture)),this}transferToEffect(a,x){let c;return this.computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x,this.transformedPosition.y,this.transformedPosition.z,this.exponent,x),c=Ee.Normalize(this.transformedDirection)):(this._uniformBuffer.updateFloat4("vLightData",this.position.x,this.position.y,this.position.z,this.exponent,x),c=Ee.Normalize(this.direction)),this._uniformBuffer.updateFloat4("vLightDirection",c.x,c.y,c.z,this._cosHalfAngle,x),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,this._lightAngleScale,this._lightAngleOffset,x),this}transferToNodeMaterialEffect(a,x){let c;return this.computeTransformedInformation()?c=Ee.Normalize(this.transformedDirection):c=Ee.Normalize(this.direction),this.getScene().useRightHandedSystem?a.setFloat3(x,-c.x,-c.y,-c.z):a.setFloat3(x,c.x,c.y,c.z),this}dispose(){super.dispose(),this._projectionTexture&&this._projectionTexture.dispose()}getDepthMinZ(a){const x=this._scene.getEngine(),c=this.shadowMinZ!==void 0?this.shadowMinZ:a.minZ;return x.useReverseDepthBuffer&&x.isNDCHalfZRange?c:this._scene.getEngine().isNDCHalfZRange?0:c}getDepthMaxZ(a){const x=this._scene.getEngine(),c=this.shadowMaxZ!==void 0?this.shadowMaxZ:a.maxZ;return x.useReverseDepthBuffer&&x.isNDCHalfZRange?0:c}prepareLightSpecificDefines(a,x){a["SPOTLIGHT"+x]=!0,a["PROJECTEDLIGHTTEXTURE"+x]=!!(this.projectionTexture&&this.projectionTexture.isReady())}}Ye([ht()],Wx.prototype,"angle",null),Ye([ht()],Wx.prototype,"innerAngle",null),Ye([ht()],Wx.prototype,"shadowAngleScale",null),Ye([ht()],Wx.prototype,"exponent",void 0),Ye([ht()],Wx.prototype,"projectionTextureLightNear",null),Ye([ht()],Wx.prototype,"projectionTextureLightFar",null),Ye([ht()],Wx.prototype,"projectionTextureUpDirection",null),Ye([gn("projectedLightTexture")],Wx.prototype,"_projectionTexture",void 0);const U_="KHR_lights_punctual";class WF{constructor(a){this.name=U_,this._loader=a,this.enabled=this._loader.isExtensionUsed(U_)}dispose(){this._loader=null,delete this._lights}onLoading(){const a=this._loader.gltf.extensions;if(a&&a[this.name]){const x=a[this.name];this._lights=x.lights,lr.Assign(this._lights)}}loadNodeAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>(this._loader._allMaterialsDirtyRequired=!0,this._loader.loadNodeAsync(a,x,y=>{let v;const w=lr.Get(u,this._lights,g.light),B=w.name||y.name;switch(this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer,w.type){case"directional":{const W=new Hl(B,Ee.Backward(),this._loader.babylonScene);W.position.setAll(0),v=W;break}case"point":{v=new yg(B,Ee.Zero(),this._loader.babylonScene);break}case"spot":{const W=new Wx(B,Ee.Zero(),Ee.Backward(),0,1,this._loader.babylonScene);W.angle=(w.spot&&w.spot.outerConeAngle||Math.PI/4)*2,W.innerAngle=(w.spot&&w.spot.innerConeAngle||0)*2,v=W;break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${u}: Invalid light type (${w.type})`)}v._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,w._babylonLight=v,v.falloffType=Wr.FALLOFF_GLTF,v.diffuse=w.color?Bs.FromArray(w.color):Bs.White(),v.intensity=w.intensity==null?1:w.intensity,v.range=w.range==null?Number.MAX_VALUE:w.range,v.parent=y,this._loader._babylonLights.push(v),_s.AddPointerMetadata(v,u),c(y)})))}}_s.RegisterExtension(U_,F=>new WF(F));const V_="KHR_materials_pbrSpecularGlossiness";class HF{constructor(a){this.name=V_,this.order=200,this._loader=a,this.enabled=this._loader.isExtensionUsed(V_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialBasePropertiesAsync(a,x,c)),y.push(this._loadSpecularGlossinessPropertiesAsync(u,g,c)),this._loader.loadMaterialAlphaProperties(a,x,c),Promise.all(y).then(()=>{})})}_loadSpecularGlossinessPropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const u=new Array;return c.metallic=null,c.roughness=null,x.diffuseFactor?(c.albedoColor=Bs.FromArray(x.diffuseFactor),c.alpha=x.diffuseFactor[3]):c.albedoColor=Bs.White(),c.reflectivityColor=x.specularFactor?Bs.FromArray(x.specularFactor):Bs.White(),c.microSurface=x.glossinessFactor==null?1:x.glossinessFactor,x.diffuseTexture&&u.push(this._loader.loadTextureInfoAsync(`${a}/diffuseTexture`,x.diffuseTexture,g=>{g.name=`${c.name} (Diffuse)`,c.albedoTexture=g})),x.specularGlossinessTexture&&(u.push(this._loader.loadTextureInfoAsync(`${a}/specularGlossinessTexture`,x.specularGlossinessTexture,g=>{g.name=`${c.name} (Specular Glossiness)`,c.reflectivityTexture=g,c.reflectivityTexture.hasAlpha=!0})),c.useMicroSurfaceFromReflectivityMapAlpha=!0),Promise.all(u).then(()=>{})}}_s.RegisterExtension(V_,F=>new HF(F));const G_="KHR_materials_unlit";class XF{constructor(a){this.name=G_,this.order=210,this._loader=a,this.enabled=this._loader.isExtensionUsed(G_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,()=>this._loadUnlitPropertiesAsync(a,x,c))}_loadUnlitPropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const u=new Array;c.unlit=!0;const g=x.pbrMetallicRoughness;return g&&(g.baseColorFactor?(c.albedoColor=Bs.FromArray(g.baseColorFactor),c.alpha=g.baseColorFactor[3]):c.albedoColor=Bs.White(),g.baseColorTexture&&u.push(this._loader.loadTextureInfoAsync(`${a}/baseColorTexture`,g.baseColorTexture,y=>{y.name=`${c.name} (Base Color)`,c.albedoTexture=y}))),x.doubleSided&&(c.backFaceCulling=!1,c.twoSidedLighting=!0),this._loader.loadMaterialAlphaProperties(a,x,c),Promise.all(u).then(()=>{})}}_s.RegisterExtension(G_,F=>new XF(F));const z_="KHR_materials_clearcoat";class jF{constructor(a){this.name=z_,this.order=190,this._loader=a,this.enabled=this._loader.isExtensionUsed(z_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadClearCoatPropertiesAsync(u,g,c)),Promise.all(y).then(()=>{})})}_loadClearCoatPropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const u=new Array;return c.clearCoat.isEnabled=!0,c.clearCoat.useRoughnessFromMainTexture=!1,c.clearCoat.remapF0OnInterfaceChange=!1,x.clearcoatFactor!=null?c.clearCoat.intensity=x.clearcoatFactor:c.clearCoat.intensity=0,x.clearcoatTexture&&u.push(this._loader.loadTextureInfoAsync(`${a}/clearcoatTexture`,x.clearcoatTexture,g=>{g.name=`${c.name} (ClearCoat Intensity)`,c.clearCoat.texture=g})),x.clearcoatRoughnessFactor!=null?c.clearCoat.roughness=x.clearcoatRoughnessFactor:c.clearCoat.roughness=0,x.clearcoatRoughnessTexture&&(x.clearcoatRoughnessTexture.nonColorData=!0,u.push(this._loader.loadTextureInfoAsync(`${a}/clearcoatRoughnessTexture`,x.clearcoatRoughnessTexture,g=>{g.name=`${c.name} (ClearCoat Roughness)`,c.clearCoat.textureRoughness=g}))),x.clearcoatNormalTexture&&(x.clearcoatNormalTexture.nonColorData=!0,u.push(this._loader.loadTextureInfoAsync(`${a}/clearcoatNormalTexture`,x.clearcoatNormalTexture,g=>{g.name=`${c.name} (ClearCoat Normal)`,c.clearCoat.bumpTexture=g})),c.invertNormalMapX=!c.getScene().useRightHandedSystem,c.invertNormalMapY=c.getScene().useRightHandedSystem,x.clearcoatNormalTexture.scale!=null&&(c.clearCoat.bumpTexture.level=x.clearcoatNormalTexture.scale)),Promise.all(u).then(()=>{})}}_s.RegisterExtension(z_,F=>new jF(F));const W_="KHR_materials_iridescence";class YF{constructor(a){this.name=W_,this.order=195,this._loader=a,this.enabled=this._loader.isExtensionUsed(W_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadIridescencePropertiesAsync(u,g,c)),Promise.all(y).then(()=>{})})}_loadIridescencePropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const u=new Array;return c.iridescence.isEnabled=!0,c.iridescence.intensity=x.iridescenceFactor??0,c.iridescence.indexOfRefraction=x.iridescenceIor??x.iridescenceIOR??1.3,c.iridescence.minimumThickness=x.iridescenceThicknessMinimum??100,c.iridescence.maximumThickness=x.iridescenceThicknessMaximum??400,x.iridescenceTexture&&u.push(this._loader.loadTextureInfoAsync(`${a}/iridescenceTexture`,x.iridescenceTexture,g=>{g.name=`${c.name} (Iridescence Intensity)`,c.iridescence.texture=g})),x.iridescenceThicknessTexture&&u.push(this._loader.loadTextureInfoAsync(`${a}/iridescenceThicknessTexture`,x.iridescenceThicknessTexture,g=>{g.name=`${c.name} (Iridescence Thickness)`,c.iridescence.thicknessTexture=g})),Promise.all(u).then(()=>{})}}_s.RegisterExtension(W_,F=>new YF(F));const H_="KHR_materials_anisotropy";class $F{constructor(a){this.name=H_,this.order=195,this._loader=a,this.enabled=this._loader.isExtensionUsed(H_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadIridescencePropertiesAsync(u,g,c)),Promise.all(y).then(()=>{})})}_loadIridescencePropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const u=new Array;return c.anisotropy.isEnabled=!0,c.anisotropy.intensity=x.anisotropyStrength??0,c.anisotropy.angle=x.anisotropyRotation??0,x.anisotropyTexture&&u.push(this._loader.loadTextureInfoAsync(`${a}/anisotropyTexture`,x.anisotropyTexture,g=>{g.name=`${c.name} (Anisotropy Intensity)`,c.anisotropy.texture=g})),Promise.all(u).then(()=>{})}}_s.RegisterExtension(H_,F=>new $F(F));const X_="KHR_materials_emissive_strength";class JF{constructor(a){this.name=X_,this.order=170,this._loader=a,this.enabled=this._loader.isExtensionUsed(X_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>this._loader.loadMaterialPropertiesAsync(a,x,c).then(()=>{this._loadEmissiveProperties(u,g,c)}))}_loadEmissiveProperties(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);x.emissiveStrength!==void 0&&(c.emissiveIntensity=x.emissiveStrength)}}_s.RegisterExtension(X_,F=>new JF(F));const K_="KHR_materials_sheen";class tk{constructor(a){this.name=K_,this.order=190,this._loader=a,this.enabled=this._loader.isExtensionUsed(K_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadSheenPropertiesAsync(u,g,c)),Promise.all(y).then(()=>{})})}_loadSheenPropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const u=new Array;return c.sheen.isEnabled=!0,c.sheen.intensity=1,x.sheenColorFactor!=null?c.sheen.color=Bs.FromArray(x.sheenColorFactor):c.sheen.color=Bs.Black(),x.sheenColorTexture&&u.push(this._loader.loadTextureInfoAsync(`${a}/sheenColorTexture`,x.sheenColorTexture,g=>{g.name=`${c.name} (Sheen Color)`,c.sheen.texture=g})),x.sheenRoughnessFactor!==void 0?c.sheen.roughness=x.sheenRoughnessFactor:c.sheen.roughness=0,x.sheenRoughnessTexture&&(x.sheenRoughnessTexture.nonColorData=!0,u.push(this._loader.loadTextureInfoAsync(`${a}/sheenRoughnessTexture`,x.sheenRoughnessTexture,g=>{g.name=`${c.name} (Sheen Roughness)`,c.sheen.textureRoughness=g}))),c.sheen.albedoScaling=!0,c.sheen.useRoughnessFromMainTexture=!1,Promise.all(u).then(()=>{})}}_s.RegisterExtension(K_,F=>new tk(F));const j_="KHR_materials_specular";class ak{constructor(a){this.name=j_,this.order=190,this._loader=a,this.enabled=this._loader.isExtensionUsed(j_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadSpecularPropertiesAsync(u,g,c)),Promise.all(y).then(()=>{})})}_loadSpecularPropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const u=new Array;return x.specularFactor!==void 0&&(c.metallicF0Factor=x.specularFactor),x.specularColorFactor!==void 0&&(c.metallicReflectanceColor=Bs.FromArray(x.specularColorFactor)),x.specularTexture&&(x.specularTexture.nonColorData=!0,u.push(this._loader.loadTextureInfoAsync(`${a}/specularTexture`,x.specularTexture,g=>{g.name=`${c.name} (Specular F0 Strength)`,c.metallicReflectanceTexture=g,c.useOnlyMetallicFromMetallicReflectanceTexture=!0}))),x.specularColorTexture&&u.push(this._loader.loadTextureInfoAsync(`${a}/specularColorTexture`,x.specularColorTexture,g=>{g.name=`${c.name} (Specular F0 Color)`,c.reflectanceTexture=g})),Promise.all(u).then(()=>{})}}_s.RegisterExtension(j_,F=>new ak(F));const Y_="KHR_materials_ior";class Hg{constructor(a){this.name=Y_,this.order=180,this._loader=a,this.enabled=this._loader.isExtensionUsed(Y_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadIorPropertiesAsync(u,g,c)),Promise.all(y).then(()=>{})})}_loadIorPropertiesAsync(a,x,c){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);return x.ior!==void 0?c.indexOfRefraction=x.ior:c.indexOfRefraction=Hg._DEFAULT_IOR,Promise.resolve()}}Hg._DEFAULT_IOR=1.5,_s.RegisterExtension(Y_,F=>new Hg(F));const xx="KHR_materials_variants";class hh{constructor(a){this.name=xx,this._loader=a,this.enabled=this._loader.isExtensionUsed(xx)}dispose(){this._loader=null}static GetAvailableVariants(a){const x=this._GetExtensionMetadata(a);return x?Object.keys(x.variants):[]}getAvailableVariants(a){return hh.GetAvailableVariants(a)}static SelectVariant(a,x){const c=this._GetExtensionMetadata(a);if(!c)throw new Error(`Cannot select variant on a glTF mesh that does not have the ${xx} extension`);const u=g=>{const y=c.variants[g];if(y)for(const v of y)v.mesh.material=v.material};if(x instanceof Array)for(const g of x)u(g);else u(x);c.lastSelected=x}selectVariant(a,x){hh.SelectVariant(a,x)}static Reset(a){const x=this._GetExtensionMetadata(a);if(!x)throw new Error(`Cannot reset on a glTF mesh that does not have the ${xx} extension`);for(const c of x.original)c.mesh.material=c.material;x.lastSelected=null}reset(a){hh.Reset(a)}static GetLastSelectedVariant(a){const x=this._GetExtensionMetadata(a);if(!x)throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${xx} extension`);return x.lastSelected}getLastSelectedVariant(a){return hh.GetLastSelectedVariant(a)}static _GetExtensionMetadata(a){return a?._internalMetadata?.gltf?.[xx]||null}onLoading(){const a=this._loader.gltf.extensions;if(a&&a[this.name]){const x=a[this.name];this._variants=x.variants}}_loadMeshPrimitiveAsync(a,x,c,u,g,y){return _s.LoadExtensionAsync(a,g,this.name,(v,w)=>{const B=new Array;return B.push(this._loader._loadMeshPrimitiveAsync(a,x,c,u,g,W=>{if(y(W),W instanceof sr){const ae=_s._GetDrawMode(a,g.mode),ue=this._loader.rootBabylonMesh,fe=ue?ue._internalMetadata=ue._internalMetadata||{}:{},Re=fe.gltf=fe.gltf||{},_e=Re[xx]=Re[xx]||{lastSelected:null,original:[],variants:{}};_e.original.push({mesh:W,material:W.material});for(let Be=0;Be<w.mappings.length;++Be){const tt=w.mappings[Be],$e=lr.Get(`${v}/mappings/${Be}/material`,this._loader.gltf.materials,tt.material);B.push(this._loader._loadMaterialAsync(`#/materials/${tt.material}`,$e,W,ae,Et=>{for(let ft=0;ft<tt.variants.length;++ft){const dt=tt.variants[ft],ut=lr.Get(`/extensions/${xx}/variants/${dt}`,this._variants,dt);_e.variants[ut.name]=_e.variants[ut.name]||[],_e.variants[ut.name].push({mesh:W,material:Et}),W.onClonedObservable.add(Mt=>{const ai=Mt;let Yi=null,Vi=ai;do{if(Vi=Vi.parent,!Vi)return;Yi=hh._GetExtensionMetadata(Vi)}while(Yi===null);if(ue&&Yi===hh._GetExtensionMetadata(ue)){Vi._internalMetadata={};for(const Js in ue._internalMetadata)Vi._internalMetadata[Js]=ue._internalMetadata[Js];Vi._internalMetadata.gltf=[];for(const Js in ue._internalMetadata.gltf)Vi._internalMetadata.gltf[Js]=ue._internalMetadata.gltf[Js];Vi._internalMetadata.gltf[xx]={lastSelected:null,original:[],variants:{}};for(const Js of Yi.original)Vi._internalMetadata.gltf[xx].original.push({mesh:Js.mesh,material:Js.material});for(const Js in Yi.variants)if(Object.prototype.hasOwnProperty.call(Yi.variants,Js)){Vi._internalMetadata.gltf[xx].variants[Js]=[];for(const Rr of Yi.variants[Js])Vi._internalMetadata.gltf[xx].variants[Js].push({mesh:Rr.mesh,material:Rr.material})}Yi=Vi._internalMetadata.gltf[xx]}for(const Js of Yi.original)Js.mesh===W&&(Js.mesh=ai);for(const Js of Yi.variants[ut.name])Js.mesh===W&&(Js.mesh=ai)})}}))}}})),Promise.all(B).then(([W])=>W)})}}_s.RegisterExtension(xx,F=>new hh(F));class It{}It.ALPHA_DISABLE=0,It.ALPHA_ADD=1,It.ALPHA_COMBINE=2,It.ALPHA_SUBTRACT=3,It.ALPHA_MULTIPLY=4,It.ALPHA_MAXIMIZED=5,It.ALPHA_ONEONE=6,It.ALPHA_PREMULTIPLIED=7,It.ALPHA_PREMULTIPLIED_PORTERDUFF=8,It.ALPHA_INTERPOLATE=9,It.ALPHA_SCREENMODE=10,It.ALPHA_ONEONE_ONEONE=11,It.ALPHA_ALPHATOCOLOR=12,It.ALPHA_REVERSEONEMINUS=13,It.ALPHA_SRC_DSTONEMINUSSRCALPHA=14,It.ALPHA_ONEONE_ONEZERO=15,It.ALPHA_EXCLUSION=16,It.ALPHA_LAYER_ACCUMULATE=17,It.ALPHA_EQUATION_ADD=0,It.ALPHA_EQUATION_SUBSTRACT=1,It.ALPHA_EQUATION_REVERSE_SUBTRACT=2,It.ALPHA_EQUATION_MAX=3,It.ALPHA_EQUATION_MIN=4,It.ALPHA_EQUATION_DARKEN=5,It.DELAYLOADSTATE_NONE=0,It.DELAYLOADSTATE_LOADED=1,It.DELAYLOADSTATE_LOADING=2,It.DELAYLOADSTATE_NOTLOADED=4,It.NEVER=512,It.ALWAYS=519,It.LESS=513,It.EQUAL=514,It.LEQUAL=515,It.GREATER=516,It.GEQUAL=518,It.NOTEQUAL=517,It.KEEP=7680,It.ZERO=0,It.REPLACE=7681,It.INCR=7682,It.DECR=7683,It.INVERT=5386,It.INCR_WRAP=34055,It.DECR_WRAP=34056,It.TEXTURE_CLAMP_ADDRESSMODE=0,It.TEXTURE_WRAP_ADDRESSMODE=1,It.TEXTURE_MIRROR_ADDRESSMODE=2,It.TEXTURE_CREATIONFLAG_STORAGE=1,It.TEXTUREFORMAT_ALPHA=0,It.TEXTUREFORMAT_LUMINANCE=1,It.TEXTUREFORMAT_LUMINANCE_ALPHA=2,It.TEXTUREFORMAT_RGB=4,It.TEXTUREFORMAT_RGBA=5,It.TEXTUREFORMAT_RED=6,It.TEXTUREFORMAT_R=6,It.TEXTUREFORMAT_RG=7,It.TEXTUREFORMAT_RED_INTEGER=8,It.TEXTUREFORMAT_R_INTEGER=8,It.TEXTUREFORMAT_RG_INTEGER=9,It.TEXTUREFORMAT_RGB_INTEGER=10,It.TEXTUREFORMAT_RGBA_INTEGER=11,It.TEXTUREFORMAT_BGRA=12,It.TEXTUREFORMAT_DEPTH24_STENCIL8=13,It.TEXTUREFORMAT_DEPTH32_FLOAT=14,It.TEXTUREFORMAT_DEPTH16=15,It.TEXTUREFORMAT_DEPTH24=16,It.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8=17,It.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8=18,It.TEXTUREFORMAT_STENCIL8=19,It.TEXTUREFORMAT_UNDEFINED=4294967295,It.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM=36492,It.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM=36493,It.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT=36495,It.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT=36494,It.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5=33779,It.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT=35919,It.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3=33778,It.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT=35918,It.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1=33777,It.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1=33776,It.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT=35917,It.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT=35916,It.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4=37808,It.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR=37840,It.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL=36196,It.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2=37492,It.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2=37493,It.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2=37494,It.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2=37495,It.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC=37496,It.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC=37497,It.TEXTURETYPE_UNSIGNED_BYTE=0,It.TEXTURETYPE_UNSIGNED_INT=0,It.TEXTURETYPE_FLOAT=1,It.TEXTURETYPE_HALF_FLOAT=2,It.TEXTURETYPE_BYTE=3,It.TEXTURETYPE_SHORT=4,It.TEXTURETYPE_UNSIGNED_SHORT=5,It.TEXTURETYPE_INT=6,It.TEXTURETYPE_UNSIGNED_INTEGER=7,It.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4=8,It.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1=9,It.TEXTURETYPE_UNSIGNED_SHORT_5_6_5=10,It.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV=11,It.TEXTURETYPE_UNSIGNED_INT_24_8=12,It.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV=13,It.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV=14,It.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV=15,It.TEXTURETYPE_UNDEFINED=16,It.TEXTURE_2D=3553,It.TEXTURE_2D_ARRAY=35866,It.TEXTURE_CUBE_MAP=34067,It.TEXTURE_CUBE_MAP_ARRAY=3735928559,It.TEXTURE_3D=32879,It.TEXTURE_NEAREST_SAMPLINGMODE=1,It.TEXTURE_NEAREST_NEAREST=1,It.TEXTURE_BILINEAR_SAMPLINGMODE=2,It.TEXTURE_LINEAR_LINEAR=2,It.TEXTURE_TRILINEAR_SAMPLINGMODE=3,It.TEXTURE_LINEAR_LINEAR_MIPLINEAR=3,It.TEXTURE_NEAREST_NEAREST_MIPNEAREST=4,It.TEXTURE_NEAREST_LINEAR_MIPNEAREST=5,It.TEXTURE_NEAREST_LINEAR_MIPLINEAR=6,It.TEXTURE_NEAREST_LINEAR=7,It.TEXTURE_NEAREST_NEAREST_MIPLINEAR=8,It.TEXTURE_LINEAR_NEAREST_MIPNEAREST=9,It.TEXTURE_LINEAR_NEAREST_MIPLINEAR=10,It.TEXTURE_LINEAR_LINEAR_MIPNEAREST=11,It.TEXTURE_LINEAR_NEAREST=12,It.TEXTURE_EXPLICIT_MODE=0,It.TEXTURE_SPHERICAL_MODE=1,It.TEXTURE_PLANAR_MODE=2,It.TEXTURE_CUBIC_MODE=3,It.TEXTURE_PROJECTION_MODE=4,It.TEXTURE_SKYBOX_MODE=5,It.TEXTURE_INVCUBIC_MODE=6,It.TEXTURE_EQUIRECTANGULAR_MODE=7,It.TEXTURE_FIXED_EQUIRECTANGULAR_MODE=8,It.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE=9,It.TEXTURE_FILTERING_QUALITY_OFFLINE=4096,It.TEXTURE_FILTERING_QUALITY_HIGH=64,It.TEXTURE_FILTERING_QUALITY_MEDIUM=16,It.TEXTURE_FILTERING_QUALITY_LOW=8,It.SCALEMODE_FLOOR=1,It.SCALEMODE_NEAREST=2,It.SCALEMODE_CEILING=3,It.MATERIAL_TextureDirtyFlag=1,It.MATERIAL_LightDirtyFlag=2,It.MATERIAL_FresnelDirtyFlag=4,It.MATERIAL_AttributesDirtyFlag=8,It.MATERIAL_MiscDirtyFlag=16,It.MATERIAL_PrePassDirtyFlag=32,It.MATERIAL_AllDirtyFlag=63,It.MATERIAL_TriangleFillMode=0,It.MATERIAL_WireFrameFillMode=1,It.MATERIAL_PointFillMode=2,It.MATERIAL_PointListDrawMode=3,It.MATERIAL_LineListDrawMode=4,It.MATERIAL_LineLoopDrawMode=5,It.MATERIAL_LineStripDrawMode=6,It.MATERIAL_TriangleStripDrawMode=7,It.MATERIAL_TriangleFanDrawMode=8,It.MATERIAL_ClockWiseSideOrientation=0,It.MATERIAL_CounterClockWiseSideOrientation=1,It.ACTION_NothingTrigger=0,It.ACTION_OnPickTrigger=1,It.ACTION_OnLeftPickTrigger=2,It.ACTION_OnRightPickTrigger=3,It.ACTION_OnCenterPickTrigger=4,It.ACTION_OnPickDownTrigger=5,It.ACTION_OnDoublePickTrigger=6,It.ACTION_OnPickUpTrigger=7,It.ACTION_OnPickOutTrigger=16,It.ACTION_OnLongPressTrigger=8,It.ACTION_OnPointerOverTrigger=9,It.ACTION_OnPointerOutTrigger=10,It.ACTION_OnEveryFrameTrigger=11,It.ACTION_OnIntersectionEnterTrigger=12,It.ACTION_OnIntersectionExitTrigger=13,It.ACTION_OnKeyDownTrigger=14,It.ACTION_OnKeyUpTrigger=15,It.PARTICLES_BILLBOARDMODE_Y=2,It.PARTICLES_BILLBOARDMODE_ALL=7,It.PARTICLES_BILLBOARDMODE_STRETCHED=8,It.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL=9,It.MESHES_CULLINGSTRATEGY_STANDARD=0,It.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY=1,It.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION=2,It.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY=3,It.SCENELOADER_NO_LOGGING=0,It.SCENELOADER_MINIMAL_LOGGING=1,It.SCENELOADER_SUMMARY_LOGGING=2,It.SCENELOADER_DETAILED_LOGGING=3,It.PREPASS_IRRADIANCE_TEXTURE_TYPE=0,It.PREPASS_POSITION_TEXTURE_TYPE=1,It.PREPASS_VELOCITY_TEXTURE_TYPE=2,It.PREPASS_REFLECTIVITY_TEXTURE_TYPE=3,It.PREPASS_COLOR_TEXTURE_TYPE=4,It.PREPASS_DEPTH_TEXTURE_TYPE=5,It.PREPASS_NORMAL_TEXTURE_TYPE=6,It.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE=7,It.BUFFER_CREATIONFLAG_READ=1,It.BUFFER_CREATIONFLAG_WRITE=2,It.BUFFER_CREATIONFLAG_READWRITE=3,It.BUFFER_CREATIONFLAG_UNIFORM=4,It.BUFFER_CREATIONFLAG_VERTEX=8,It.BUFFER_CREATIONFLAG_INDEX=16,It.BUFFER_CREATIONFLAG_STORAGE=32,It.RENDERPASS_MAIN=0,It.INPUT_ALT_KEY=18,It.INPUT_CTRL_KEY=17,It.INPUT_META_KEY1=91,It.INPUT_META_KEY2=92,It.INPUT_META_KEY3=93,It.INPUT_SHIFT_KEY=16,It.SNAPSHOTRENDERING_STANDARD=0,It.SNAPSHOTRENDERING_FAST=1,It.PERSPECTIVE_CAMERA=0,It.ORTHOGRAPHIC_CAMERA=1,It.FOVMODE_VERTICAL_FIXED=0,It.FOVMODE_HORIZONTAL_FIXED=1,It.RIG_MODE_NONE=0,It.RIG_MODE_STEREOSCOPIC_ANAGLYPH=10,It.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL=11,It.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED=12,It.RIG_MODE_STEREOSCOPIC_OVERUNDER=13,It.RIG_MODE_STEREOSCOPIC_INTERLACED=14,It.RIG_MODE_VR=20,It.RIG_MODE_CUSTOM=22,It.MAX_SUPPORTED_UV_SETS=6,It.GL_ALPHA_EQUATION_ADD=32774,It.GL_ALPHA_EQUATION_MIN=32775,It.GL_ALPHA_EQUATION_MAX=32776,It.GL_ALPHA_EQUATION_SUBTRACT=32778,It.GL_ALPHA_EQUATION_REVERSE_SUBTRACT=32779,It.GL_ALPHA_FUNCTION_SRC=768,It.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR=769,It.GL_ALPHA_FUNCTION_SRC_ALPHA=770,It.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA=771,It.GL_ALPHA_FUNCTION_DST_ALPHA=772,It.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA=773,It.GL_ALPHA_FUNCTION_DST_COLOR=774,It.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR=775,It.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED=776,It.GL_ALPHA_FUNCTION_CONSTANT_COLOR=32769,It.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR=32770,It.GL_ALPHA_FUNCTION_CONSTANT_ALPHA=32771,It.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA=32772,It.SnippetUrl="https://snippet.babylonjs.com",It.FOGMODE_NONE=0,It.FOGMODE_EXP=1,It.FOGMODE_EXP2=2,It.FOGMODE_LINEAR=3,It.BYTE=5120,It.UNSIGNED_BYTE=5121,It.SHORT=5122,It.UNSIGNED_SHORT=5123,It.INT=5124,It.UNSIGNED_INT=5125,It.FLOAT=5126,It.PositionKind="position",It.NormalKind="normal",It.TangentKind="tangent",It.UVKind="uv",It.UV2Kind="uv2",It.UV3Kind="uv3",It.UV4Kind="uv4",It.UV5Kind="uv5",It.UV6Kind="uv6",It.ColorKind="color",It.ColorInstanceKind="instanceColor",It.MatricesIndicesKind="matricesIndices",It.MatricesWeightsKind="matricesWeights",It.MatricesIndicesExtraKind="matricesIndicesExtra",It.MatricesWeightsExtraKind="matricesWeightsExtra";class q_{static _GetDefaultOptions(){return{renderSize:1024,samples:4,lodGenerationScale:1,lodGenerationOffset:-4,renderTargetTextureType:It.TEXTURETYPE_HALF_FLOAT,generateMipmaps:!0}}constructor(a,x){this._opaqueRenderTarget=null,this._opaqueMeshesCache=[],this._transparentMeshesCache=[],this._materialObservers={},this._options={...q_._GetDefaultOptions(),...a},this._scene=x,this._scene._transmissionHelper=this,this.onErrorObservable=new Jt,this._scene.onDisposeObservable.addOnce(()=>{this.dispose()}),this._parseScene(),this._setupRenderTargets()}updateOptions(a){if(!Object.keys(a).filter(g=>this._options[g]!==a[g]).length)return;const c={...this._options,...a},u=this._options;this._options=c,c.renderSize!==u.renderSize||c.renderTargetTextureType!==u.renderTargetTextureType||c.generateMipmaps!==u.generateMipmaps||!this._opaqueRenderTarget?this._setupRenderTargets():(this._opaqueRenderTarget.samples=c.samples,this._opaqueRenderTarget.lodGenerationScale=c.lodGenerationScale,this._opaqueRenderTarget.lodGenerationOffset=c.lodGenerationOffset)}getOpaqueTarget(){return this._opaqueRenderTarget}_shouldRenderAsTransmission(a){return a?!!(a instanceof fs&&a.subSurface.isRefractionEnabled):!1}_addMesh(a){this._materialObservers[a.uniqueId]=a.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this)),_t.SetImmediate(()=>{this._shouldRenderAsTransmission(a.material)?(a.material.refractionTexture=this._opaqueRenderTarget,this._transparentMeshesCache.indexOf(a)===-1&&this._transparentMeshesCache.push(a)):this._opaqueMeshesCache.indexOf(a)===-1&&this._opaqueMeshesCache.push(a)})}_removeMesh(a){a.onMaterialChangedObservable.remove(this._materialObservers[a.uniqueId]),delete this._materialObservers[a.uniqueId];let x=this._transparentMeshesCache.indexOf(a);x!==-1&&this._transparentMeshesCache.splice(x,1),x=this._opaqueMeshesCache.indexOf(a),x!==-1&&this._opaqueMeshesCache.splice(x,1)}_parseScene(){this._scene.meshes.forEach(this._addMesh.bind(this)),this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this)),this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this))}_onMeshMaterialChanged(a){const x=this._transparentMeshesCache.indexOf(a),c=this._opaqueMeshesCache.indexOf(a);this._shouldRenderAsTransmission(a.material)?(a.material instanceof fs&&(a.material.subSurface.refractionTexture=this._opaqueRenderTarget),c!==-1?(this._opaqueMeshesCache.splice(c,1),this._transparentMeshesCache.push(a)):x===-1&&this._transparentMeshesCache.push(a)):x!==-1?(this._transparentMeshesCache.splice(x,1),this._opaqueMeshesCache.push(a)):c===-1&&this._opaqueMeshesCache.push(a)}_isRenderTargetValid(){return this._opaqueRenderTarget?.getInternalTexture()!==null}_setupRenderTargets(){this._opaqueRenderTarget&&this._opaqueRenderTarget.dispose(),this._opaqueRenderTarget=new Bo("opaqueSceneTexture",this._options.renderSize,this._scene,this._options.generateMipmaps,void 0,this._options.renderTargetTextureType),this._opaqueRenderTarget.ignoreCameraViewport=!0,this._opaqueRenderTarget.renderList=this._opaqueMeshesCache,this._opaqueRenderTarget.clearColor=this._options.clearColor?.clone()??this._scene.clearColor.clone(),this._opaqueRenderTarget.gammaSpace=!1,this._opaqueRenderTarget.lodGenerationScale=this._options.lodGenerationScale,this._opaqueRenderTarget.lodGenerationOffset=this._options.lodGenerationOffset,this._opaqueRenderTarget.samples=this._options.samples,this._opaqueRenderTarget.renderSprites=!0,this._opaqueRenderTarget.renderParticles=!0;let a,x;this._opaqueRenderTarget.onBeforeBindObservable.add(c=>{x=this._scene.environmentIntensity,this._scene.environmentIntensity=1,a=this._scene.imageProcessingConfiguration.applyByPostProcess,this._options.clearColor?c.clearColor.copyFrom(this._options.clearColor):this._scene.clearColor.toLinearSpaceToRef(c.clearColor,this._scene.getEngine().useExactSrgbConversions),this._scene.imageProcessingConfiguration._applyByPostProcess=!0}),this._opaqueRenderTarget.onAfterUnbindObservable.add(()=>{this._scene.environmentIntensity=x,this._scene.imageProcessingConfiguration._applyByPostProcess=a}),this._transparentMeshesCache.forEach(c=>{this._shouldRenderAsTransmission(c.material)&&(c.material.refractionTexture=this._opaqueRenderTarget)})}dispose(){this._scene._transmissionHelper=void 0,this._opaqueRenderTarget&&(this._opaqueRenderTarget.dispose(),this._opaqueRenderTarget=null),this._transparentMeshesCache=[],this._opaqueMeshesCache=[]}}const Q_="KHR_materials_transmission";class xk{constructor(a){this.name=Q_,this.order=175,this._loader=a,this.enabled=this._loader.isExtensionUsed(Q_),this.enabled&&(a.parent.transparencyAsCoverage=!0)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialBasePropertiesAsync(a,x,c)),y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadTransparentPropertiesAsync(u,x,c,g)),Promise.all(y).then(()=>{})})}_loadTransparentPropertiesAsync(a,x,c,u){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const g=c;if(g.subSurface.isRefractionEnabled=!0,g.subSurface.volumeIndexOfRefraction=1,g.subSurface.useAlbedoToTintRefraction=!0,u.transmissionFactor!==void 0){g.subSurface.refractionIntensity=u.transmissionFactor;const y=g.getScene();g.subSurface.refractionIntensity&&!y._transmissionHelper?new q_({},g.getScene()):g.subSurface.refractionIntensity&&!y._transmissionHelper?._isRenderTargetValid()&&y._transmissionHelper?._setupRenderTargets()}else return g.subSurface.refractionIntensity=0,g.subSurface.isRefractionEnabled=!1,Promise.resolve();return g.subSurface.minimumThickness=0,g.subSurface.maximumThickness=0,u.transmissionTexture?(u.transmissionTexture.nonColorData=!0,this._loader.loadTextureInfoAsync(`${a}/transmissionTexture`,u.transmissionTexture,void 0).then(y=>{g.subSurface.refractionIntensityTexture=y,g.subSurface.useGltfStyleTextures=!0})):Promise.resolve()}}_s.RegisterExtension(Q_,F=>new xk(F));const Z_="KHR_materials_translucency";class lk{constructor(a){this.name=Z_,this.order=174,this._loader=a,this.enabled=this._loader.isExtensionUsed(Z_),this.enabled&&(a.parent.transparencyAsCoverage=!0)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialBasePropertiesAsync(a,x,c)),y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadTranslucentPropertiesAsync(u,x,c,g)),Promise.all(y).then(()=>{})})}_loadTranslucentPropertiesAsync(a,x,c,u){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);const g=c;if(g.subSurface.isTranslucencyEnabled=!0,g.subSurface.volumeIndexOfRefraction=1,g.subSurface.minimumThickness=0,g.subSurface.maximumThickness=0,g.subSurface.useAlbedoToTintTranslucency=!0,u.translucencyFactor!==void 0)g.subSurface.translucencyIntensity=u.translucencyFactor;else return g.subSurface.translucencyIntensity=0,g.subSurface.isTranslucencyEnabled=!1,Promise.resolve();return u.translucencyTexture?(u.translucencyTexture.nonColorData=!0,this._loader.loadTextureInfoAsync(`${a}/translucencyTexture`,u.translucencyTexture).then(y=>{g.subSurface.translucencyIntensityTexture=y})):Promise.resolve()}}_s.RegisterExtension(Z_,F=>new lk(F));const $_="KHR_materials_volume";class hk{constructor(a){this.name=$_,this.order=173,this._loader=a,this.enabled=this._loader.isExtensionUsed($_),this.enabled&&this._loader._disableInstancedMesh++}dispose(){this.enabled&&this._loader._disableInstancedMesh--,this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialBasePropertiesAsync(a,x,c)),y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadVolumePropertiesAsync(u,x,c,g)),Promise.all(y).then(()=>{})})}_loadVolumePropertiesAsync(a,x,c,u){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);if(!c.subSurface.isRefractionEnabled&&!c.subSurface.isTranslucencyEnabled||!u.thicknessFactor)return Promise.resolve();c.subSurface.volumeIndexOfRefraction=c.indexOfRefraction;const g=u.attenuationDistance!==void 0?u.attenuationDistance:Number.MAX_VALUE;return c.subSurface.tintColorAtDistance=g,u.attenuationColor!==void 0&&u.attenuationColor.length==3&&c.subSurface.tintColor.copyFromFloats(u.attenuationColor[0],u.attenuationColor[1],u.attenuationColor[2]),c.subSurface.minimumThickness=0,c.subSurface.maximumThickness=u.thicknessFactor,c.subSurface.useThicknessAsDepth=!0,u.thicknessTexture?(u.thicknessTexture.nonColorData=!0,this._loader.loadTextureInfoAsync(`${a}/thicknessTexture`,u.thicknessTexture).then(y=>{c.subSurface.thicknessTexture=y,c.subSurface.useGltfStyleTextures=!0})):Promise.resolve()}}_s.RegisterExtension($_,F=>new hk(F));const J_="KHR_materials_dispersion";class uk{constructor(a){this.name=J_,this.order=174,this._loader=a,this.enabled=this._loader.isExtensionUsed(J_)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return y.push(this._loader.loadMaterialBasePropertiesAsync(a,x,c)),y.push(this._loader.loadMaterialPropertiesAsync(a,x,c)),y.push(this._loadDispersionPropertiesAsync(u,x,c,g)),Promise.all(y).then(()=>{})})}_loadDispersionPropertiesAsync(a,x,c,u){if(!(c instanceof fs))throw new Error(`${a}: Material type not supported`);return!c.subSurface.isRefractionEnabled||!u.dispersion||(c.subSurface.isDispersionEnabled=!0,c.subSurface.dispersion=u.dispersion),Promise.resolve()}}_s.RegisterExtension(J_,F=>new uk(F));const ty="KHR_mesh_quantization";class dk{constructor(a){this.name=ty,this.enabled=a.isExtensionUsed(ty)}dispose(){}}_s.RegisterExtension(ty,F=>new dk(F));const ay="KHR_texture_basisu";class fk{constructor(a){this.name=ay,this._loader=a,this.enabled=a.isExtensionUsed(ay)}dispose(){this._loader=null}_loadTextureAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=x.sampler==null?_s.DefaultSampler:lr.Get(`${a}/sampler`,this._loader.gltf.samplers,x.sampler),v=lr.Get(`${u}/source`,this._loader.gltf.images,g.source);return this._loader._createTextureAsync(a,y,v,w=>{c(w)},x._textureInfo.nonColorData?{useRGBAIfASTCBC7NotAvailableWhenUASTC:!0}:void 0,!x._textureInfo.nonColorData)})}}_s.RegisterExtension(ay,F=>new fk(F));const xy="KHR_texture_transform";class mk{constructor(a){this.name=xy,this._loader=a,this.enabled=this._loader.isExtensionUsed(xy)}dispose(){this._loader=null}loadTextureInfoAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>this._loader.loadTextureInfoAsync(a,x,y=>{if(!(y instanceof fi))throw new Error(`${u}: Texture type not supported`);g.offset&&(y.uOffset=g.offset[0],y.vOffset=g.offset[1]),y.uRotationCenter=0,y.vRotationCenter=0,g.rotation&&(y.wAng=-g.rotation),g.scale&&(y.uScale=g.scale[0],y.vScale=g.scale[1]),g.texCoord!=null&&(y.coordinatesIndex=g.texCoord),c(y)}))}}_s.RegisterExtension(xy,F=>new mk(F));const ly="KHR_xmp_json_ld";class gk{constructor(a){this.name=ly,this.order=100,this._loader=a,this.enabled=this._loader.isExtensionUsed(ly)}dispose(){this._loader=null}onLoading(){if(this._loader.rootBabylonMesh===null)return;const a=this._loader.gltf.extensions?.KHR_xmp_json_ld,x=this._loader.gltf.asset?.extensions?.KHR_xmp_json_ld;if(a&&x){const c=+x.packet;a.packets&&c<a.packets.length&&(this._loader.rootBabylonMesh.metadata=this._loader.rootBabylonMesh.metadata||{},this._loader.rootBabylonMesh.metadata.xmp=a.packets[c])}}}_s.RegisterExtension(ly,F=>new gk(F));function Ju(F,a,x,c){return Bs.FromArray(a,x).scale(c)}function _k(F,a,x,c){return a[x+3]*c}function Jn(F,a,x,c){return a[x]*c}function hy(F,a,x,c){return-a[x]*c}function Xg(F,a,x,c){return a[x+1]*c}function $w(F,a,x,c){return a[x]*c*2}function lx(F){return{scale:[new jn(xi.ANIMATIONTYPE_FLOAT,`${F}.uScale`,Jn,()=>2),new jn(xi.ANIMATIONTYPE_FLOAT,`${F}.vScale`,Xg,()=>2)],offset:[new jn(xi.ANIMATIONTYPE_FLOAT,`${F}.uOffset`,Jn,()=>2),new jn(xi.ANIMATIONTYPE_FLOAT,`${F}.vOffset`,Xg,()=>2)],rotation:[new jn(xi.ANIMATIONTYPE_FLOAT,`${F}.wAng`,hy,()=>1)]}}class dc extends gm{buildAnimations(a,x,c,u,g){g(a._babylonCamera,this._buildAnimation(x,c,u))}}class jn extends gm{buildAnimations(a,x,c,u,g){for(const y in a._data)g(a._data[y].babylonMaterial,this._buildAnimation(x,c,u))}}class bm extends gm{buildAnimations(a,x,c,u,g){g(a._babylonLight,this._buildAnimation(x,c,u))}}const yk={__array__:{__target__:!0,..._m}},bk={__array__:{__target__:!0,orthographic:{xmag:[new dc(xi.ANIMATIONTYPE_FLOAT,"orthoLeft",hy,()=>1),new dc(xi.ANIMATIONTYPE_FLOAT,"orthoRight",Xg,()=>1)],ymag:[new dc(xi.ANIMATIONTYPE_FLOAT,"orthoBottom",hy,()=>1),new dc(xi.ANIMATIONTYPE_FLOAT,"orthoTop",Xg,()=>1)],zfar:[new dc(xi.ANIMATIONTYPE_FLOAT,"maxZ",Jn,()=>1)],znear:[new dc(xi.ANIMATIONTYPE_FLOAT,"minZ",Jn,()=>1)]},perspective:{yfov:[new dc(xi.ANIMATIONTYPE_FLOAT,"fov",Jn,()=>1)],zfar:[new dc(xi.ANIMATIONTYPE_FLOAT,"maxZ",Jn,()=>1)],znear:[new dc(xi.ANIMATIONTYPE_FLOAT,"minZ",Jn,()=>1)]}}},Ek={__array__:{__target__:!0,pbrMetallicRoughness:{baseColorFactor:[new jn(xi.ANIMATIONTYPE_COLOR3,"albedoColor",Ju,()=>4),new jn(xi.ANIMATIONTYPE_FLOAT,"alpha",_k,()=>4)],metallicFactor:[new jn(xi.ANIMATIONTYPE_FLOAT,"metallic",Jn,()=>1)],roughnessFactor:[new jn(xi.ANIMATIONTYPE_FLOAT,"roughness",Jn,()=>1)],baseColorTexture:{extensions:{KHR_texture_transform:lx("albedoTexture")}},metallicRoughnessTexture:{extensions:{KHR_texture_transform:lx("metallicRoughnessTexture")}}},emissiveFactor:[new jn(xi.ANIMATIONTYPE_COLOR3,"emissiveColor",Ju,()=>3)],normalTexture:{scale:[new jn(xi.ANIMATIONTYPE_FLOAT,"bumpTexture.level",Jn,()=>1)],extensions:{KHR_texture_transform:lx("bumpTexture")}},occlusionTexture:{strength:[new jn(xi.ANIMATIONTYPE_FLOAT,"ambientTextureStrength",Jn,()=>1)],extensions:{KHR_texture_transform:lx("ambientTexture")}},emissiveTexture:{extensions:{KHR_texture_transform:lx("emissiveTexture")}},extensions:{KHR_materials_anisotropy:{anisotropyStrength:[new jn(xi.ANIMATIONTYPE_FLOAT,"anisotropy.intensity",Jn,()=>1)],anisotropyRotation:[new jn(xi.ANIMATIONTYPE_FLOAT,"anisotropy.angle",Jn,()=>1)],anisotropyTexture:{extensions:{KHR_texture_transform:lx("emissiveTexture")}}},KHR_materials_clearcoat:{clearcoatFactor:[new jn(xi.ANIMATIONTYPE_FLOAT,"clearCoat.intensity",Jn,()=>1)],clearcoatRoughnessFactor:[new jn(xi.ANIMATIONTYPE_FLOAT,"clearCoat.roughness",Jn,()=>1)],clearcoatTexture:{extensions:{KHR_texture_transform:lx("clearCoat.texture")}},clearcoatNormalTexture:{scale:[new jn(xi.ANIMATIONTYPE_FLOAT,"clearCoat.bumpTexture.level",Jn,()=>1)],extensions:{KHR_texture_transform:lx("clearCoat.bumpTexture")}},clearcoatRoughnessTexture:{extensions:{KHR_texture_transform:lx("clearCoat.textureRoughness")}}},KHR_materials_dispersion:{dispersion:[new jn(xi.ANIMATIONTYPE_FLOAT,"subSurface.dispersion",Jn,()=>1)]},KHR_materials_emissive_strength:{emissiveStrength:[new jn(xi.ANIMATIONTYPE_FLOAT,"emissiveIntensity",Jn,()=>1)]},KHR_materials_ior:{ior:[new jn(xi.ANIMATIONTYPE_FLOAT,"indexOfRefraction",Jn,()=>1)]},KHR_materials_iridescence:{iridescenceFactor:[new jn(xi.ANIMATIONTYPE_FLOAT,"iridescence.intensity",Jn,()=>1)],iridescenceIor:[new jn(xi.ANIMATIONTYPE_FLOAT,"iridescence.indexOfRefraction",Jn,()=>1)],iridescenceThicknessMinimum:[new jn(xi.ANIMATIONTYPE_FLOAT,"iridescence.minimumThickness",Jn,()=>1)],iridescenceThicknessMaximum:[new jn(xi.ANIMATIONTYPE_FLOAT,"iridescence.maximumThickness",Jn,()=>1)]},KHR_materials_sheen:{sheenColorFactor:[new jn(xi.ANIMATIONTYPE_COLOR3,"sheen.color",Ju,()=>3)],sheenRoughnessFactor:[new jn(xi.ANIMATIONTYPE_FLOAT,"sheen.roughness",Jn,()=>1)],sheenColorTexture:{extensions:{KHR_texture_transform:lx("sheen.texture")}},sheenRoughnessTexture:{extensions:{KHR_texture_transform:lx("sheen.textureRoughness")}}},KHR_materials_specular:{specularFactor:[new jn(xi.ANIMATIONTYPE_FLOAT,"metallicF0Factor",Jn,()=>1)],specularColorFactor:[new jn(xi.ANIMATIONTYPE_COLOR3,"metallicReflectanceColor",Ju,()=>3)],specularTexture:{extensions:{KHR_texture_transform:lx("metallicReflectanceTexture")}},specularColorTexture:{extensions:{KHR_texture_transform:lx("reflectanceTexture")}}},KHR_materials_transmission:{transmissionFactor:[new jn(xi.ANIMATIONTYPE_FLOAT,"subSurface.refractionIntensity",Jn,()=>1)],transmissionTexture:{extensions:{KHR_texture_transform:lx("subSurface.refractionIntensityTexture")}}},KHR_materials_volume:{attenuationColor:[new jn(xi.ANIMATIONTYPE_COLOR3,"subSurface.tintColor",Ju,()=>3)],attenuationDistance:[new jn(xi.ANIMATIONTYPE_FLOAT,"subSurface.tintColorAtDistance",Jn,()=>1)],thicknessFactor:[new jn(xi.ANIMATIONTYPE_FLOAT,"subSurface.maximumThickness",Jn,()=>1)],thicknessTexture:{extensions:{KHR_texture_transform:lx("subSurface.thicknessTexture")}}}}}},vk={KHR_lights_punctual:{lights:{__array__:{__target__:!0,color:[new bm(xi.ANIMATIONTYPE_COLOR3,"diffuse",Ju,()=>3)],intensity:[new bm(xi.ANIMATIONTYPE_FLOAT,"intensity",Jn,()=>1)],range:[new bm(xi.ANIMATIONTYPE_FLOAT,"range",Jn,()=>1)],spot:{innerConeAngle:[new bm(xi.ANIMATIONTYPE_FLOAT,"innerAngle",$w,()=>1)],outerConeAngle:[new bm(xi.ANIMATIONTYPE_FLOAT,"angle",$w,()=>1)]}}}}},Ik={nodes:yk,materials:Ek,cameras:bk,extensions:vk};class Jw{constructor(a,x){this._gltf=a,this._infoTree=x}convert(a){let x=this._gltf,c=this._infoTree,u;if(!a.startsWith("/"))throw new Error("Path must start with a /");const g=a.split("/");g.shift();for(const y of g){if(c.__array__)c=c.__array__;else if(c=c[y],!c)throw new Error(`Path ${a} is invalid`);if(x===void 0)throw new Error(`Path ${a} is invalid`);x=x[y],c.__target__&&(u=x)}return{object:u,info:c}}}const uy="KHR_animation_pointer";class Rk extends Jw{constructor(a){super(a,Ik)}}class Mk{constructor(a){this.name=uy,this._loader=a,this._pathToObjectConverter=new Rk(this._loader.gltf)}get enabled(){return this._loader.isExtensionUsed(uy)}dispose(){this._loader=null,delete this._pathToObjectConverter}_loadAnimationChannelAsync(a,x,c,u,g){const y=u.target.extensions?.KHR_animation_pointer;if(!y||!this._pathToObjectConverter)return null;u.target.path!=="pointer"&&Qt.Warn(`${a}/target/path: Value (${u.target.path}) must be (pointer) when using the ${this.name} extension`),u.target.node!=null&&Qt.Warn(`${a}/target/node: Value (${u.target.node}) must not be present when using the ${this.name} extension`);const v=`${a}/extensions/${this.name}`,w=y.pointer;if(!w)throw new Error(`${v}: Pointer is missing`);try{const B=this._pathToObjectConverter.convert(w);return this._loader._loadAnimationChannelFromTargetInfoAsync(a,x,c,u,B,g)}catch{return Qt.Warn(`${v}/pointer: Invalid pointer (${w}) skipped`),null}}}_s.RegisterExtension(uy,F=>new Mk(F));class dy{constructor(a,x,c){this.frame=a,this.action=x,this.onlyOnce=c,this.isDone=!1}_clone(){return new dy(this.frame,this.action,this.onlyOnce)}}class tu{get loop(){return this._loop}set loop(a){a!==this._loop&&(this._loop=a,this.updateOptions({loop:a}))}get currentTime(){if(this._htmlAudioElement)return this._htmlAudioElement.currentTime;if(Bt.audioEngine?.audioContext&&(this.isPlaying||this.isPaused)){const a=this.isPaused?0:Bt.audioEngine.audioContext.currentTime-this._startTime;return this._currentTime+a}return 0}get spatialSound(){return this._spatialSound}set spatialSound(a){if(a==this._spatialSound)return;const x=this.isPlaying;this.pause(),a?(this._spatialSound=a,this._updateSpatialParameters()):this._disableSpatialSound(),x&&this.play()}constructor(a,x,c,u=null,g){if(this.autoplay=!1,this._loop=!1,this.useCustomAttenuation=!1,this.isPlaying=!1,this.isPaused=!1,this.refDistance=1,this.rolloffFactor=1,this.maxDistance=100,this.distanceModel="linear",this.metadata=null,this.onEndedObservable=new Jt,this._spatialSound=!1,this._panningModel="equalpower",this._playbackRate=1,this._streaming=!1,this._startTime=0,this._currentTime=0,this._position=Ee.Zero(),this._localDirection=new Ee(1,0,0),this._volume=1,this._isReadyToPlay=!1,this._isDirectional=!1,this._coneInnerAngle=360,this._coneOuterAngle=360,this._coneOuterGain=0,this._isOutputConnected=!1,this._urlType="Unknown",this.name=a,c=c||tr.LastCreatedScene,!!c)if(this._scene=c,tu._SceneComponentInitialization(c),this._readyToPlayCallback=u,this._customAttenuationFunction=(y,v,w,B,W)=>v<w?y*(1-v/w):0,g&&(this.autoplay=g.autoplay||!1,this._loop=g.loop||!1,g.volume!==void 0&&(this._volume=g.volume),this._spatialSound=g.spatialSound??!1,this.maxDistance=g.maxDistance??100,this.useCustomAttenuation=g.useCustomAttenuation??!1,this.rolloffFactor=g.rolloffFactor||1,this.refDistance=g.refDistance||1,this.distanceModel=g.distanceModel||"linear",this._playbackRate=g.playbackRate||1,this._streaming=g.streaming??!1,this._length=g.length,this._offset=g.offset),Bt.audioEngine?.canUseWebAudio&&Bt.audioEngine.audioContext){this._soundGain=Bt.audioEngine.audioContext.createGain(),this._soundGain.gain.value=this._volume,this._inputAudioNode=this._soundGain,this._outputAudioNode=this._soundGain,this._spatialSound&&this._createSpatialParameters(),this._scene.mainSoundTrack.addSound(this);let y=!0;if(x)try{typeof x=="string"?(this._urlType="String",this._url=x):x instanceof ArrayBuffer?this._urlType="ArrayBuffer":x instanceof HTMLMediaElement?this._urlType="MediaElement":x instanceof MediaStream?this._urlType="MediaStream":x instanceof AudioBuffer?this._urlType="AudioBuffer":Array.isArray(x)&&(this._urlType="Array");let v=[],w=!1;switch(this._urlType){case"MediaElement":this._streaming=!0,this._isReadyToPlay=!0,this._streamingSource=Bt.audioEngine.audioContext.createMediaElementSource(x),this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback();break;case"MediaStream":this._streaming=!0,this._isReadyToPlay=!0,this._streamingSource=Bt.audioEngine.audioContext.createMediaStreamSource(x),this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback();break;case"ArrayBuffer":x.byteLength>0&&(w=!0,this._soundLoaded(x));break;case"AudioBuffer":this._audioBufferLoaded(x);break;case"String":v.push(x);case"Array":v.length===0&&(v=x);for(let B=0;B<v.length;B++){const W=v[B];if(w=g&&g.skipCodecCheck||W.indexOf(".mp3",W.length-4)!==-1&&Bt.audioEngine.isMP3supported||W.indexOf(".ogg",W.length-4)!==-1&&Bt.audioEngine.isOGGsupported||W.indexOf(".wav",W.length-4)!==-1||W.indexOf(".m4a",W.length-4)!==-1||W.indexOf(".mp4",W.length-4)!==-1||W.indexOf("blob:")!==-1,w){this._streaming?(this._htmlAudioElement=new Audio(W),this._htmlAudioElement.controls=!1,this._htmlAudioElement.loop=this.loop,_t.SetCorsBehavior(W,this._htmlAudioElement),this._htmlAudioElement.preload="auto",this._htmlAudioElement.addEventListener("canplaythrough",()=>{this._isReadyToPlay=!0,this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback()}),document.body.appendChild(this._htmlAudioElement),this._htmlAudioElement.load()):this._scene._loadFile(W,ae=>{this._soundLoaded(ae)},void 0,!0,!0,ae=>{ae&&Qt.Error("XHR "+ae.status+" error on: "+W+"."),Qt.Error("Sound creation aborted."),this._scene.mainSoundTrack.removeSound(this)});break}}break;default:y=!1;break}y?w||(this._isReadyToPlay=!0,this._readyToPlayCallback&&setTimeout(()=>{this._readyToPlayCallback&&this._readyToPlayCallback()},1e3)):Qt.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.")}catch{Qt.Error("Unexpected error. Sound creation aborted."),this._scene.mainSoundTrack.removeSound(this)}}else this._scene.mainSoundTrack.addSound(this),Bt.audioEngine&&!Bt.audioEngine.WarnedWebAudioUnsupported&&(Qt.Error("Web Audio is not supported by your browser."),Bt.audioEngine.WarnedWebAudioUnsupported=!0),this._readyToPlayCallback&&setTimeout(()=>{this._readyToPlayCallback&&this._readyToPlayCallback()},1e3)}dispose(){Bt.audioEngine?.canUseWebAudio&&(this.isPlaying&&this.stop(),this._isReadyToPlay=!1,this.soundTrackId===-1?this._scene.mainSoundTrack.removeSound(this):this._scene.soundTracks&&this._scene.soundTracks[this.soundTrackId].removeSound(this),this._soundGain&&(this._soundGain.disconnect(),this._soundGain=null),this._soundPanner&&(this._soundPanner.disconnect(),this._soundPanner=null),this._soundSource&&(this._soundSource.disconnect(),this._soundSource=null),this._audioBuffer=null,this._htmlAudioElement&&(this._htmlAudioElement.pause(),this._htmlAudioElement.src="",document.body.removeChild(this._htmlAudioElement)),this._streamingSource&&this._streamingSource.disconnect(),this._connectedTransformNode&&this._registerFunc&&(this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc),this._connectedTransformNode=null),this._clearTimeoutsAndObservers())}isReady(){return this._isReadyToPlay}getClassName(){return"Sound"}_audioBufferLoaded(a){Bt.audioEngine?.audioContext&&(this._audioBuffer=a,this._isReadyToPlay=!0,this.autoplay&&this.play(0,this._offset,this._length),this._readyToPlayCallback&&this._readyToPlayCallback())}_soundLoaded(a){Bt.audioEngine?.audioContext&&Bt.audioEngine.audioContext.decodeAudioData(a,x=>{this._audioBufferLoaded(x)},x=>{Qt.Error("Error while decoding audio data for: "+this.name+" / Error: "+x)})}setAudioBuffer(a){Bt.audioEngine?.canUseWebAudio&&(this._audioBuffer=a,this._isReadyToPlay=!0)}updateOptions(a){a&&(this.loop=a.loop??this.loop,this.maxDistance=a.maxDistance??this.maxDistance,this.useCustomAttenuation=a.useCustomAttenuation??this.useCustomAttenuation,this.rolloffFactor=a.rolloffFactor??this.rolloffFactor,this.refDistance=a.refDistance??this.refDistance,this.distanceModel=a.distanceModel??this.distanceModel,this._playbackRate=a.playbackRate??this._playbackRate,this._length=a.length??void 0,this.spatialSound=a.spatialSound??this._spatialSound,this._setOffset(a.offset??void 0),this.setVolume(a.volume??this._volume),this._updateSpatialParameters(),this.isPlaying&&(this._streaming&&this._htmlAudioElement?(this._htmlAudioElement.playbackRate=this._playbackRate,this._htmlAudioElement.loop!==this.loop&&(this._htmlAudioElement.loop=this.loop)):this._soundSource&&(this._soundSource.playbackRate.value=this._playbackRate,this._soundSource.loop!==this.loop&&(this._soundSource.loop=this.loop),this._offset!==void 0&&this._soundSource.loopStart!==this._offset&&(this._soundSource.loopStart=this._offset),this._length!==void 0&&this._length!==this._soundSource.loopEnd&&(this._soundSource.loopEnd=(this._offset|0)+this._length))))}_createSpatialParameters(){Bt.audioEngine?.canUseWebAudio&&Bt.audioEngine.audioContext&&(this._scene.headphone&&(this._panningModel="HRTF"),this._soundPanner=this._soundPanner??Bt.audioEngine.audioContext.createPanner(),this._soundPanner&&this._outputAudioNode&&(this._updateSpatialParameters(),this._soundPanner.connect(this._outputAudioNode),this._inputAudioNode=this._soundPanner))}_disableSpatialSound(){this._spatialSound&&(this._inputAudioNode=this._soundGain,this._soundPanner?.disconnect(),this._soundPanner=null,this._spatialSound=!1)}_updateSpatialParameters(){this._spatialSound&&(this._soundPanner?this.useCustomAttenuation?(this._soundPanner.distanceModel="linear",this._soundPanner.maxDistance=Number.MAX_VALUE,this._soundPanner.refDistance=1,this._soundPanner.rolloffFactor=1,this._soundPanner.panningModel=this._panningModel):(this._soundPanner.distanceModel=this.distanceModel,this._soundPanner.maxDistance=this.maxDistance,this._soundPanner.refDistance=this.refDistance,this._soundPanner.rolloffFactor=this.rolloffFactor,this._soundPanner.panningModel=this._panningModel):this._createSpatialParameters())}switchPanningModelToHRTF(){this._panningModel="HRTF",this._switchPanningModel()}switchPanningModelToEqualPower(){this._panningModel="equalpower",this._switchPanningModel()}_switchPanningModel(){Bt.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&(this._soundPanner.panningModel=this._panningModel)}connectToSoundTrackAudioNode(a){Bt.audioEngine?.canUseWebAudio&&this._outputAudioNode&&(this._isOutputConnected&&this._outputAudioNode.disconnect(),this._outputAudioNode.connect(a),this._isOutputConnected=!0)}setDirectionalCone(a,x,c){if(x<a){Qt.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=a,this._coneOuterAngle=x,this._coneOuterGain=c,this._isDirectional=!0,this.isPlaying&&this.loop&&(this.stop(),this.play(0,this._offset,this._length))}get directionalConeInnerAngle(){return this._coneInnerAngle}set directionalConeInnerAngle(a){if(a!=this._coneInnerAngle){if(this._coneOuterAngle<a){Qt.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=a,Bt.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&(this._soundPanner.coneInnerAngle=this._coneInnerAngle)}}get directionalConeOuterAngle(){return this._coneOuterAngle}set directionalConeOuterAngle(a){if(a!=this._coneOuterAngle){if(a<this._coneInnerAngle){Qt.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneOuterAngle=a,Bt.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&(this._soundPanner.coneOuterAngle=this._coneOuterAngle)}}setPosition(a){a.equals(this._position)||(this._position.copyFrom(a),Bt.audioEngine?.canUseWebAudio&&this._spatialSound&&this._soundPanner&&!isNaN(this._position.x)&&!isNaN(this._position.y)&&!isNaN(this._position.z)&&(this._soundPanner.positionX.value=this._position.x,this._soundPanner.positionY.value=this._position.y,this._soundPanner.positionZ.value=this._position.z))}setLocalDirectionToMesh(a){this._localDirection=a,Bt.audioEngine?.canUseWebAudio&&this._connectedTransformNode&&this.isPlaying&&this._updateDirection()}_updateDirection(){if(!this._connectedTransformNode||!this._soundPanner)return;const a=this._connectedTransformNode.getWorldMatrix(),x=Ee.TransformNormal(this._localDirection,a);x.normalize(),this._soundPanner.orientationX.value=x.x,this._soundPanner.orientationY.value=x.y,this._soundPanner.orientationZ.value=x.z}updateDistanceFromListener(){if(Bt.audioEngine?.canUseWebAudio&&this._connectedTransformNode&&this.useCustomAttenuation&&this._soundGain&&this._scene.activeCamera){const a=this._scene.audioListenerPositionProvider?this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length():this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);this._soundGain.gain.value=this._customAttenuationFunction(this._volume,a,this.maxDistance,this.refDistance,this.rolloffFactor)}}setAttenuationFunction(a){this._customAttenuationFunction=a}play(a,x,c){if(this._isReadyToPlay&&this._scene.audioEnabled&&Bt.audioEngine?.audioContext)try{this._clearTimeoutsAndObservers();let u=a?Bt.audioEngine?.audioContext.currentTime+a:Bt.audioEngine?.audioContext.currentTime;if((!this._soundSource||!this._streamingSource)&&this._spatialSound&&this._soundPanner&&(!isNaN(this._position.x)&&!isNaN(this._position.y)&&!isNaN(this._position.z)&&(this._soundPanner.positionX.value=this._position.x,this._soundPanner.positionY.value=this._position.y,this._soundPanner.positionZ.value=this._position.z),this._isDirectional&&(this._soundPanner.coneInnerAngle=this._coneInnerAngle,this._soundPanner.coneOuterAngle=this._coneOuterAngle,this._soundPanner.coneOuterGain=this._coneOuterGain,this._connectedTransformNode?this._updateDirection():this._soundPanner.setOrientation(this._localDirection.x,this._localDirection.y,this._localDirection.z))),this._streaming){if(this._streamingSource||(this._streamingSource=Bt.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement),this._htmlAudioElement.onended=()=>{this._onended()},this._htmlAudioElement.playbackRate=this._playbackRate),this._streamingSource.disconnect(),this._inputAudioNode&&this._streamingSource.connect(this._inputAudioNode),this._htmlAudioElement){const g=()=>{if(Bt.audioEngine?.unlocked){const y=this._htmlAudioElement.play();y!==void 0&&y.catch(()=>{Bt.audioEngine?.lock(),(this.loop||this.autoplay)&&(this._audioUnlockedObserver=Bt.audioEngine?.onAudioUnlockedObservable.addOnce(()=>{g()}))})}else(this.loop||this.autoplay)&&(this._audioUnlockedObserver=Bt.audioEngine?.onAudioUnlockedObservable.addOnce(()=>{g()}))};g()}}else{const g=()=>{if(Bt.audioEngine?.audioContext){if(c=c||this._length,x!==void 0&&this._setOffset(x),this._soundSource){const y=this._soundSource;y.onended=()=>{y.disconnect()}}if(this._soundSource=Bt.audioEngine?.audioContext.createBufferSource(),this._soundSource&&this._inputAudioNode){this._soundSource.buffer=this._audioBuffer,this._soundSource.connect(this._inputAudioNode),this._soundSource.loop=this.loop,x!==void 0&&(this._soundSource.loopStart=x),c!==void 0&&(this._soundSource.loopEnd=(x|0)+c),this._soundSource.playbackRate.value=this._playbackRate,this._soundSource.onended=()=>{this._onended()},u=a?Bt.audioEngine?.audioContext.currentTime+a:Bt.audioEngine.audioContext.currentTime;const y=((this.isPaused?this.currentTime:0)+(this._offset??0))%this._soundSource.buffer.duration;this._soundSource.start(u,y,this.loop?void 0:c)}}};Bt.audioEngine?.audioContext.state==="suspended"?this._tryToPlayTimeout=setTimeout(()=>{Bt.audioEngine?.audioContext.state==="suspended"?(Bt.audioEngine.lock(),(this.loop||this.autoplay)&&(this._audioUnlockedObserver=Bt.audioEngine.onAudioUnlockedObservable.addOnce(()=>{g()}))):g()},500):g()}this._startTime=u,this.isPlaying=!0,this.isPaused=!1}catch(u){Qt.Error("Error while trying to play audio: "+this.name+", "+u.message)}}_onended(){this.isPlaying=!1,this._startTime=0,this._currentTime=0,this.onended&&this.onended(),this.onEndedObservable.notifyObservers(this)}stop(a){if(this.isPlaying)if(this._clearTimeoutsAndObservers(),this._streaming)this._htmlAudioElement?(this._htmlAudioElement.pause(),this._htmlAudioElement.currentTime>0&&(this._htmlAudioElement.currentTime=0)):this._streamingSource.disconnect(),this.isPlaying=!1;else if(Bt.audioEngine?.audioContext&&this._soundSource){const x=a?Bt.audioEngine.audioContext.currentTime+a:void 0;this._soundSource.onended=()=>{this.isPlaying=!1,this.isPaused=!1,this._startTime=0,this._currentTime=0,this._soundSource&&(this._soundSource.onended=()=>{}),this._onended()},this._soundSource.stop(x)}else this.isPlaying=!1;else this.isPaused&&(this.isPaused=!1,this._startTime=0,this._currentTime=0)}pause(){this.isPlaying&&(this._clearTimeoutsAndObservers(),this._streaming?(this._htmlAudioElement?this._htmlAudioElement.pause():this._streamingSource.disconnect(),this.isPlaying=!1,this.isPaused=!0):Bt.audioEngine?.audioContext&&this._soundSource&&(this._soundSource.onended=()=>{},this._soundSource.stop(),this.isPlaying=!1,this.isPaused=!0,this._currentTime+=Bt.audioEngine.audioContext.currentTime-this._startTime))}setVolume(a,x){Bt.audioEngine?.canUseWebAudio&&this._soundGain&&(x&&Bt.audioEngine.audioContext?(this._soundGain.gain.cancelScheduledValues(Bt.audioEngine.audioContext.currentTime),this._soundGain.gain.setValueAtTime(this._soundGain.gain.value,Bt.audioEngine.audioContext.currentTime),this._soundGain.gain.linearRampToValueAtTime(a,Bt.audioEngine.audioContext.currentTime+x)):this._soundGain.gain.value=a),this._volume=a}setPlaybackRate(a){this._playbackRate=a,this.isPlaying&&(this._streaming&&this._htmlAudioElement?this._htmlAudioElement.playbackRate=this._playbackRate:this._soundSource&&(this._soundSource.playbackRate.value=this._playbackRate))}getPlaybackRate(){return this._playbackRate}getVolume(){return this._volume}attachToMesh(a){this._connectedTransformNode&&this._registerFunc&&(this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc),this._registerFunc=null),this._connectedTransformNode=a,this._spatialSound||(this._spatialSound=!0,this._createSpatialParameters(),this.isPlaying&&this.loop&&(this.stop(),this.play(0,this._offset,this._length))),this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode),this._registerFunc=x=>this._onRegisterAfterWorldMatrixUpdate(x),this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc)}detachFromMesh(){this._connectedTransformNode&&this._registerFunc&&(this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc),this._registerFunc=null,this._connectedTransformNode=null)}_onRegisterAfterWorldMatrixUpdate(a){if(!a.getBoundingInfo)this.setPosition(a.absolutePosition);else{const c=a.getBoundingInfo();this.setPosition(c.boundingSphere.centerWorld)}Bt.audioEngine?.canUseWebAudio&&this._isDirectional&&this.isPlaying&&this._updateDirection()}clone(){if(this._streaming)return null;{const a=()=>{this._isReadyToPlay?(c._audioBuffer=this.getAudioBuffer(),c._isReadyToPlay=!0,c.autoplay&&c.play(0,this._offset,this._length)):setTimeout(a,300)},x={autoplay:this.autoplay,loop:this.loop,volume:this._volume,spatialSound:this._spatialSound,maxDistance:this.maxDistance,useCustomAttenuation:this.useCustomAttenuation,rolloffFactor:this.rolloffFactor,refDistance:this.refDistance,distanceModel:this.distanceModel},c=new tu(this.name+"_cloned",new ArrayBuffer(0),this._scene,null,x);return this.useCustomAttenuation&&c.setAttenuationFunction(this._customAttenuationFunction),c.setPosition(this._position),c.setPlaybackRate(this._playbackRate),a(),c}}getAudioBuffer(){return this._audioBuffer}getSoundSource(){return this._soundSource}getSoundGain(){return this._soundGain}serialize(){const a={name:this.name,url:this._url,autoplay:this.autoplay,loop:this.loop,volume:this._volume,spatialSound:this._spatialSound,maxDistance:this.maxDistance,rolloffFactor:this.rolloffFactor,refDistance:this.refDistance,distanceModel:this.distanceModel,playbackRate:this._playbackRate,panningModel:this._panningModel,soundTrackId:this.soundTrackId,metadata:this.metadata};return this._spatialSound&&(this._connectedTransformNode&&(a.connectedMeshId=this._connectedTransformNode.id),a.position=this._position.asArray(),a.refDistance=this.refDistance,a.distanceModel=this.distanceModel,a.isDirectional=this._isDirectional,a.localDirectionToMesh=this._localDirection.asArray(),a.coneInnerAngle=this._coneInnerAngle,a.coneOuterAngle=this._coneOuterAngle,a.coneOuterGain=this._coneOuterGain),a}static Parse(a,x,c,u){const g=a.name;let y;a.url?y=c+a.url:y=c+g;const v={autoplay:a.autoplay,loop:a.loop,volume:a.volume,spatialSound:a.spatialSound,maxDistance:a.maxDistance,rolloffFactor:a.rolloffFactor,refDistance:a.refDistance,distanceModel:a.distanceModel,playbackRate:a.playbackRate};let w;if(!u)w=new tu(g,y,x,()=>{x.removePendingData(w)},v),x.addPendingData(w);else{const B=()=>{u._isReadyToPlay?(w._audioBuffer=u.getAudioBuffer(),w._isReadyToPlay=!0,w.autoplay&&w.play(0,w._offset,w._length)):setTimeout(B,300)};w=new tu(g,new ArrayBuffer(0),x,null,v),B()}if(a.position){const B=Ee.FromArray(a.position);w.setPosition(B)}if(a.isDirectional&&(w.setDirectionalCone(a.coneInnerAngle||360,a.coneOuterAngle||360,a.coneOuterGain||0),a.localDirectionToMesh)){const B=Ee.FromArray(a.localDirectionToMesh);w.setLocalDirectionToMesh(B)}if(a.connectedMeshId){const B=x.getMeshById(a.connectedMeshId);B&&w.attachToMesh(B)}return a.metadata&&(w.metadata=a.metadata),w}_setOffset(a){this._offset!==a&&(this.isPaused&&(this.stop(),this.isPaused=!1),this._offset=a)}_clearTimeoutsAndObservers(){this._tryToPlayTimeout&&(clearTimeout(this._tryToPlayTimeout),this._tryToPlayTimeout=null),this._audioUnlockedObserver&&(Bt.audioEngine?.onAudioUnlockedObservable.remove(this._audioUnlockedObserver),this._audioUnlockedObserver=null)}}tu._SceneComponentInitialization=F=>{throw js("AudioSceneComponent")};class Bk{constructor(a,x,c){if(this.loop=!1,this._coneInnerAngle=360,this._coneOuterAngle=360,this._volume=1,this.isPlaying=!1,this.isPaused=!1,this._sounds=[],this._weights=[],x.length!==c.length)throw new Error("Sounds length does not equal weights length");this.loop=a,this._weights=c;let u=0;for(const y of c)u+=y;const g=u>0?1/u:0;for(let y=0;y<this._weights.length;y++)this._weights[y]*=g;this._sounds=x;for(const y of this._sounds)y.onEndedObservable.add(()=>{this._onended()})}get directionalConeInnerAngle(){return this._coneInnerAngle}set directionalConeInnerAngle(a){if(a!==this._coneInnerAngle){if(this._coneOuterAngle<a){Qt.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneInnerAngle=a;for(const x of this._sounds)x.directionalConeInnerAngle=a}}get directionalConeOuterAngle(){return this._coneOuterAngle}set directionalConeOuterAngle(a){if(a!==this._coneOuterAngle){if(a<this._coneInnerAngle){Qt.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");return}this._coneOuterAngle=a;for(const x of this._sounds)x.directionalConeOuterAngle=a}}get volume(){return this._volume}set volume(a){if(a!==this._volume)for(const x of this._sounds)x.setVolume(a)}_onended(){this._currentIndex!==void 0&&(this._sounds[this._currentIndex].autoplay=!1),this.loop&&this.isPlaying?this.play():this.isPlaying=!1}pause(){this.isPaused=!0,this._currentIndex!==void 0&&this._sounds[this._currentIndex].pause()}stop(){this.isPlaying=!1,this._currentIndex!==void 0&&this._sounds[this._currentIndex].stop()}play(a){if(!this.isPaused){this.stop();const c=Math.random();let u=0;for(let g=0;g<this._weights.length;g++)if(u+=this._weights[g],c<=u){this._currentIndex=g;break}}const x=this._sounds[this._currentIndex];x.isReady()?x.play(0,this.isPaused?void 0:a):x.autoplay=!0,this.isPlaying=!0,this.isPaused=!1}}const fy="MSFT_audio_emitter";class Uk{constructor(a){this.name=fy,this._loader=a,this.enabled=this._loader.isExtensionUsed(fy)}dispose(){this._loader=null,this._clips=null,this._emitters=null}onLoading(){const a=this._loader.gltf.extensions;if(a&&a[this.name]){const x=a[this.name];this._clips=x.clips,this._emitters=x.emitters,lr.Assign(this._clips),lr.Assign(this._emitters)}}loadSceneAsync(a,x){return _s.LoadExtensionAsync(a,x,this.name,(c,u)=>{const g=new Array;g.push(this._loader.loadSceneAsync(a,x));for(const y of u.emitters){const v=lr.Get(`${c}/emitters`,this._emitters,y);if(v.refDistance!=null||v.maxDistance!=null||v.rolloffFactor!=null||v.distanceModel!=null||v.innerAngle!=null||v.outerAngle!=null)throw new Error(`${c}: Direction or Distance properties are not allowed on emitters attached to a scene`);g.push(this._loadEmitterAsync(`${c}/emitters/${v.index}`,v))}return Promise.all(g).then(()=>{})})}loadNodeAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{const y=new Array;return this._loader.loadNodeAsync(u,x,v=>{for(const w of g.emitters){const B=lr.Get(`${u}/emitters`,this._emitters,w);y.push(this._loadEmitterAsync(`${u}/emitters/${B.index}`,B).then(()=>{for(const W of B._babylonSounds)W.attachToMesh(v),(B.innerAngle!=null||B.outerAngle!=null)&&(W.setLocalDirectionToMesh(Ee.Forward()),W.setDirectionalCone(2*_t.ToDegrees(B.innerAngle==null?Math.PI:B.innerAngle),2*_t.ToDegrees(B.outerAngle==null?Math.PI:B.outerAngle),0))}))}c(v)}).then(v=>Promise.all(y).then(()=>v))})}loadAnimationAsync(a,x){return _s.LoadExtensionAsync(a,x,this.name,(c,u)=>this._loader.loadAnimationAsync(a,x).then(g=>{const y=new Array;lr.Assign(u.events);for(const v of u.events)y.push(this._loadAnimationEventAsync(`${c}/events/${v.index}`,a,x,v,g));return Promise.all(y).then(()=>g)}))}_loadClipAsync(a,x){if(x._objectURL)return x._objectURL;let c;if(x.uri)c=this._loader.loadUriAsync(a,x,x.uri);else{const u=lr.Get(`${a}/bufferView`,this._loader.gltf.bufferViews,x.bufferView);c=this._loader.loadBufferViewAsync(`/bufferViews/${u.index}`,u)}return x._objectURL=c.then(u=>URL.createObjectURL(new Blob([u],{type:x.mimeType}))),x._objectURL}_loadEmitterAsync(a,x){if(x._babylonSounds=x._babylonSounds||[],!x._babylonData){const c=new Array,u=x.name||`emitter${x.index}`,g={loop:!1,autoplay:!1,volume:x.volume==null?1:x.volume};for(let v=0;v<x.clips.length;v++){const w=`/extensions/${this.name}/clips`,B=lr.Get(w,this._clips,x.clips[v].clip);c.push(this._loadClipAsync(`${w}/${x.clips[v].clip}`,B).then(W=>{const ae=x._babylonSounds[v]=new tu(u,W,this._loader.babylonScene,null,g);ae.refDistance=x.refDistance||1,ae.maxDistance=x.maxDistance||256,ae.rolloffFactor=x.rolloffFactor||1,ae.distanceModel=x.distanceModel||"exponential"}))}const y=Promise.all(c).then(()=>{const v=x.clips.map(B=>B.weight||1),w=new Bk(x.loop||!1,x._babylonSounds,v);x.innerAngle&&(w.directionalConeInnerAngle=2*_t.ToDegrees(x.innerAngle)),x.outerAngle&&(w.directionalConeOuterAngle=2*_t.ToDegrees(x.outerAngle)),x.volume&&(w.volume=x.volume),x._babylonData.sound=w});x._babylonData={loaded:y}}return x._babylonData.loaded}_getEventAction(a,x,c,u,g){switch(c){case"play":return y=>{const v=(g||0)+(y-u);x.play(v)};case"stop":return()=>{x.stop()};case"pause":return()=>{x.pause()};default:throw new Error(`${a}: Unsupported action ${c}`)}}_loadAnimationEventAsync(a,x,c,u,g){if(g.targetedAnimations.length==0)return Promise.resolve();const y=g.targetedAnimations[0],v=u.emitter,w=lr.Get(`/extensions/${this.name}/emitters`,this._emitters,v);return this._loadEmitterAsync(a,w).then(()=>{const B=w._babylonData.sound;if(B){const W=new dy(u.time,this._getEventAction(a,B,u.action,u.time,u.startOffset));y.animation.addEvent(W),g.onAnimationGroupEndObservable.add(()=>{B.stop()}),g.onAnimationGroupPauseObservable.add(()=>{B.pause()})}})}}_s.RegisterExtension(fy,F=>new Uk(F));const my="MSFT_lod";class Vk{constructor(a){this.name=my,this.order=100,this.maxLODsToLoad=10,this.onNodeLODsLoadedObservable=new Jt,this.onMaterialLODsLoadedObservable=new Jt,this._bufferLODs=new Array,this._nodeIndexLOD=null,this._nodeSignalLODs=new Array,this._nodePromiseLODs=new Array,this._nodeBufferLODs=new Array,this._materialIndexLOD=null,this._materialSignalLODs=new Array,this._materialPromiseLODs=new Array,this._materialBufferLODs=new Array,this._loader=a,this.enabled=this._loader.isExtensionUsed(my)}dispose(){this._loader=null,this._nodeIndexLOD=null,this._nodeSignalLODs.length=0,this._nodePromiseLODs.length=0,this._nodeBufferLODs.length=0,this._materialIndexLOD=null,this._materialSignalLODs.length=0,this._materialPromiseLODs.length=0,this._materialBufferLODs.length=0,this.onMaterialLODsLoadedObservable.clear(),this.onNodeLODsLoadedObservable.clear()}onReady(){for(let a=0;a<this._nodePromiseLODs.length;a++){const x=Promise.all(this._nodePromiseLODs[a]).then(()=>{a!==0&&(this._loader.endPerformanceCounter(`Node LOD ${a}`),this._loader.log(`Loaded node LOD ${a}`)),this.onNodeLODsLoadedObservable.notifyObservers(a),a!==this._nodePromiseLODs.length-1&&(this._loader.startPerformanceCounter(`Node LOD ${a+1}`),this._loadBufferLOD(this._nodeBufferLODs,a+1),this._nodeSignalLODs[a]&&this._nodeSignalLODs[a].resolve())});this._loader._completePromises.push(x)}for(let a=0;a<this._materialPromiseLODs.length;a++){const x=Promise.all(this._materialPromiseLODs[a]).then(()=>{a!==0&&(this._loader.endPerformanceCounter(`Material LOD ${a}`),this._loader.log(`Loaded material LOD ${a}`)),this.onMaterialLODsLoadedObservable.notifyObservers(a),a!==this._materialPromiseLODs.length-1&&(this._loader.startPerformanceCounter(`Material LOD ${a+1}`),this._loadBufferLOD(this._materialBufferLODs,a+1),this._materialSignalLODs[a]&&this._materialSignalLODs[a].resolve())});this._loader._completePromises.push(x)}}loadSceneAsync(a,x){const c=this._loader.loadSceneAsync(a,x);return this._loadBufferLOD(this._bufferLODs,0),c}loadNodeAsync(a,x,c){return _s.LoadExtensionAsync(a,x,this.name,(u,g)=>{let y;const v=this._getLODs(u,x,this._loader.gltf.nodes,g.ids);this._loader.logOpen(`${u}`);for(let w=0;w<v.length;w++){const B=v[w];w!==0&&(this._nodeIndexLOD=w,this._nodeSignalLODs[w]=this._nodeSignalLODs[w]||new dm);const W=ue=>{c(ue),ue.setEnabled(!1)},ae=this._loader.loadNodeAsync(`/nodes/${B.index}`,B,W).then(ue=>{if(w!==0){const fe=v[w-1];fe._babylonTransformNode&&(this._disposeTransformNode(fe._babylonTransformNode),delete fe._babylonTransformNode)}return ue.setEnabled(!0),ue});this._nodePromiseLODs[w]=this._nodePromiseLODs[w]||[],w===0?y=ae:(this._nodeIndexLOD=null,this._nodePromiseLODs[w].push(ae))}return this._loader.logClose(),y})}_loadMaterialAsync(a,x,c,u,g){return this._nodeIndexLOD?null:_s.LoadExtensionAsync(a,x,this.name,(y,v)=>{let w;const B=this._getLODs(y,x,this._loader.gltf.materials,v.ids);this._loader.logOpen(`${y}`);for(let W=0;W<B.length;W++){const ae=B[W];W!==0&&(this._materialIndexLOD=W);const ue=this._loader._loadMaterialAsync(`/materials/${ae.index}`,ae,c,u,fe=>{W===0&&g(fe)}).then(fe=>{if(W!==0){g(fe);const Re=B[W-1]._data;Re[u]&&(this._disposeMaterials([Re[u].babylonMaterial]),delete Re[u])}return fe});this._materialPromiseLODs[W]=this._materialPromiseLODs[W]||[],W===0?w=ue:(this._materialIndexLOD=null,this._materialPromiseLODs[W].push(ue))}return this._loader.logClose(),w})}_loadUriAsync(a,x,c){if(this._nodeIndexLOD!==null){this._loader.log("deferred");const u=this._nodeIndexLOD-1;return this._nodeSignalLODs[u]=this._nodeSignalLODs[u]||new dm,this._nodeSignalLODs[this._nodeIndexLOD-1].promise.then(()=>this._loader.loadUriAsync(a,x,c))}else if(this._materialIndexLOD!==null){this._loader.log("deferred");const u=this._materialIndexLOD-1;return this._materialSignalLODs[u]=this._materialSignalLODs[u]||new dm,this._materialSignalLODs[u].promise.then(()=>this._loader.loadUriAsync(a,x,c))}return null}loadBufferAsync(a,x,c,u){if(this._loader.parent.useRangeRequests&&!x.uri){if(!this._loader.bin)throw new Error(`${a}: Uri is missing or the binary glTF is missing its binary chunk`);const g=(y,v)=>{const w=c,B=w+u-1;let W=y[v];return W?(W.start=Math.min(W.start,w),W.end=Math.max(W.end,B)):(W={start:w,end:B,loaded:new dm},y[v]=W),W.loaded.promise.then(ae=>new Uint8Array(ae.buffer,ae.byteOffset+c-W.start,u))};return this._loader.log("deferred"),this._nodeIndexLOD!==null?g(this._nodeBufferLODs,this._nodeIndexLOD):this._materialIndexLOD!==null?g(this._materialBufferLODs,this._materialIndexLOD):g(this._bufferLODs,0)}return null}_loadBufferLOD(a,x){const c=a[x];c&&(this._loader.log(`Loading buffer range [${c.start}-${c.end}]`),this._loader.bin.readAsync(c.start,c.end-c.start+1).then(u=>{c.loaded.resolve(u)},u=>{c.loaded.reject(u)}))}_getLODs(a,x,c,u){if(this.maxLODsToLoad<=0)throw new Error("maxLODsToLoad must be greater than zero");const g=[];for(let y=u.length-1;y>=0;y--)if(g.push(lr.Get(`${a}/ids/${u[y]}`,c,u[y])),g.length===this.maxLODsToLoad)return g;return g.push(x),g}_disposeTransformNode(a){const x=[],c=a.material;c&&x.push(c);for(const g of a.getChildMeshes())g.material&&x.push(g.material);a.dispose();const u=x.filter(g=>this._loader.babylonScene.meshes.every(y=>y.material!=g));this._disposeMaterials(u)}_disposeMaterials(a){const x={};for(const c of a){for(const u of c.getActiveTextures())x[u.uniqueId]=u;c.dispose()}for(const c in x)for(const u of this._loader.babylonScene.materials)u.hasTexture(x[c])&&delete x[c];for(const c in x)x[c].dispose()}}_s.RegisterExtension(my,F=>new Vk(F));const gy="MSFT_minecraftMesh";class Wk{constructor(a){this.name=gy,this._loader=a,this.enabled=this._loader.isExtensionUsed(gy)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtraAsync(a,x,this.name,(u,g)=>{if(g){if(!(c instanceof fs))throw new Error(`${u}: Material type not supported`);const y=this._loader.loadMaterialPropertiesAsync(a,x,c);return c.needAlphaBlending()&&(c.forceDepthWrite=!0,c.separateCullingPass=!0),c.backFaceCulling=c.forceDepthWrite,c.twoSidedLighting=!0,y}return null})}}_s.RegisterExtension(gy,F=>new Wk(F));const _y="MSFT_sRGBFactors";class Hk{constructor(a){this.name=_y,this._loader=a,this.enabled=this._loader.isExtensionUsed(_y)}dispose(){this._loader=null}loadMaterialPropertiesAsync(a,x,c){return _s.LoadExtraAsync(a,x,this.name,(u,g)=>{if(g){if(!(c instanceof fs))throw new Error(`${u}: Material type not supported`);const y=this._loader.loadMaterialPropertiesAsync(a,x,c),v=c.getScene().getEngine().useExactSrgbConversions;return c.albedoTexture||c.albedoColor.toLinearSpaceToRef(c.albedoColor,v),c.reflectivityTexture||c.reflectivityColor.toLinearSpaceToRef(c.reflectivityColor,v),y}return null})}}_s.RegisterExtension(_y,F=>new Hk(F));var bx;(function(F){F[F.Input=0]="Input",F[F.Output=1]="Output"})(bx||(bx={}));class yy{constructor(a,x,c){this._ownerBlock=c,this._connectedPoint=[],this.uniqueId=v0(),this.connectedPointIds=[],this.name=a,this._connectionType=x}get connectionType(){return this._connectionType}_isSingularConnection(){return!0}isConnected(){return this._connectedPoint.length>0}connectTo(a){if(this._connectionType===a._connectionType)throw new Error(`Cannot connect two points of type ${this.connectionType}`);if(this._isSingularConnection()&&this._connectedPoint.length>0||a._isSingularConnection()&&a._connectedPoint.length>0)throw new Error("Max number of connections for point reached");this._connectedPoint.push(a),a._connectedPoint.push(this)}serialize(a={}){a.uniqueId=this.uniqueId,a.name=this.name,a._connectionType=this._connectionType,a.connectedPointIds=[],a.className=this.getClassName();for(const x of this._connectedPoint)a.connectedPointIds.push(x.uniqueId)}getClassName(){return"FGConnection"}deserialize(a){this.uniqueId=a.uniqueId,this.name=a.name,this._connectionType=a._connectionType,this.connectedPointIds=a.connectedPointIds}static Parse(a={},x){const c=_t.Instantiate(a.className),u=new c(a.name,a._connectionType,x);return u.deserialize(a),u}}class Ma{constructor(a){this.value=this._toInt(a)}_toInt(a){return a|0}add(a){return new Ma(this.value+a.value)}subtract(a){return new Ma(this.value-a.value)}multiply(a){return new Ma(Math.imul(this.value,a.value))}divide(a){return new Ma(this.value/a.value)}getClassName(){return Ma.ClassName}equals(a){return this.value===a.value}static Parse(a){return new Ma(a.value)}}Ma.ClassName="FlowGraphInteger",as("FlowGraphInteger",Ma);class hx{constructor(a,x){this.typeName=a,this.defaultValue=x}serialize(a){a.typeName=this.typeName,a.defaultValue=this.defaultValue}static Parse(a){return new hx(a.typeName,a.defaultValue)}}const ls=new hx("any",void 0),Xk=new hx("string",""),g0=new hx("number",0),fc=new hx("boolean",!1),by=new hx("Vector2",mr.Zero()),au=new hx("Vector3",Ee.Zero()),jk=new hx("Vector4",an.Zero()),uh=new hx("Matrix",vt.Identity()),Yk=new hx("Color3",Bs.Black()),$k=new hx("Color4",new Yr(0,0,0,0)),Jk=new hx("Quaternion",Wi.Identity()),Ea=new hx("FlowGraphInteger",new Ma(0));function V9(F){switch(typeof F){case"string":return Xk;case"number":return g0;case"boolean":return fc;case"object":return F instanceof Vector2?by:F instanceof Vector3?au:F instanceof Vector4?jk:F instanceof Color3?Yk:F instanceof Color4?$k:F instanceof Quaternion?Jk:F instanceof FlowGraphInteger?Ea:ls;default:return ls}}class Ey extends yy{constructor(a,x,c,u){super(a,x,c),this.richType=u}_isSingularConnection(){return this.connectionType===bx.Input}setValue(a,x){x._setConnectionValue(this,a)}connectTo(a){super.connectTo(a)}_getValueOrDefault(a){return a._hasConnectionValue(this)?a._getConnectionValue(this):this.richType.defaultValue}getValue(a){return this.connectionType===bx.Output?(a._notifyExecuteNode(this._ownerBlock),this._ownerBlock._updateOutputs(a),this._getValueOrDefault(a)):this.isConnected()?this._connectedPoint[0].getValue(a):this._getValueOrDefault(a)}getClassName(){return"FGDataConnection"}serialize(a={}){super.serialize(a),a.richType={},this.richType.serialize(a.richType)}static Parse(a,x){const c=yy.Parse(a,x);return c.richType=hx.Parse(a.richType),c}}as("FGDataConnection",Ey);function tP(F){return F==="Mesh"||F==="AbstractMesh"||F==="GroundMesh"||F==="InstanceMesh"||F==="LinesMesh"||F==="GoldbergMesh"||F==="GreasedLineMesh"||F==="TrailMesh"}function aP(F){return F==="Vector2"||F==="Vector3"||F==="Vector4"||F==="Quaternion"||F==="Color3"||F==="Color4"}function t3(F,a){if(F==="Vector2")return mr.FromArray(a);if(F==="Vector3")return Ee.FromArray(a);if(F==="Vector4")return an.FromArray(a);if(F==="Quaternion")return Wi.FromArray(a);if(F==="Color3")return new Bs(a[0],a[1],a[2]);if(F==="Color4")return new Yr(a[0],a[1],a[2],a[3]);throw new Error(`Unknown vector class name ${F}`)}function xP(F,a,x){const c=a?.getClassName?.()??"";tP(c)?x[F]={name:a.name,className:c}:aP(c)?x[F]={value:a.asArray(),className:c}:x[F]=a}function jg(F,a,x){const c=a[F];let u;const g=c?.className;return tP(g)?u=x.getMeshByName(c.name):aP(g)?u=t3(g,c.value):g==="Matrix"?u=vt.FromArray(c.value):g===Ma.ClassName?u=Ma.Parse(c):c&&c.value!==void 0?u=c.value:u=c,u}function a3(F){return F==="FGSetPropertyBlock"||F==="FGGetPropertyBlock"||F==="FGPlayAnimationBlock"||F==="FGMeshPickEventBlock"}class Em{constructor(a){this.config=a,this.uniqueId=v0(),this.name=this.config?.name??this.getClassName(),this.dataInputs=[],this.dataOutputs=[]}_updateOutputs(a){}registerDataInput(a,x){const c=new Ey(a,bx.Input,this,x);return this.dataInputs.push(c),c}registerDataOutput(a,x){const c=new Ey(a,bx.Output,this,x);return this.dataOutputs.push(c),c}getDataInput(a){return this.dataInputs.find(x=>x.name===a)}getDataOutput(a){return this.dataOutputs.find(x=>x.name===a)}serialize(a={},x=xP){a.uniqueId=this.uniqueId,a.config={},this.config&&(a.config.name=this.config.name),a.dataInputs=[],a.dataOutputs=[],a.className=this.getClassName();for(const c of this.dataInputs){const u={};c.serialize(u),a.dataInputs.push(u)}for(const c of this.dataOutputs){const u={};c.serialize(u),a.dataOutputs.push(u)}}getClassName(){return"FGBlock"}static Parse(a,x){const c=_t.Instantiate(a.className),u={},g=x.valueParseFunction??jg;if(a.config)for(const v in a.config)u[v]=g(v,a.config,x.scene);a3(a.className)&&(u.pathConverter=x.pathConverter);const y=new c(u);y.uniqueId=a.uniqueId;for(let v=0;v<a.dataInputs.length;v++){const w=y.getDataInput(a.dataInputs[v].name);if(w)w.deserialize(a.dataInputs[v]);else throw new Error("Could not find data input with name "+a.dataInputs[v].name+" in block "+a.className)}for(let v=0;v<a.dataOutputs.length;v++){const w=y.getDataOutput(a.dataOutputs[v].name);if(w)w.deserialize(a.dataOutputs[v]);else throw new Error("Could not find data output with name "+a.dataOutputs[v].name+" in block "+a.className)}return y.metadata=a.metadata,y.deserialize&&y.deserialize(a),y}}class vy extends yy{_isSingularConnection(){return this.connectionType===bx.Output}_activateSignal(a){this.connectionType===bx.Input?(a._notifyExecuteNode(this._ownerBlock),this._ownerBlock._execute(a,this),a._increaseExecutionId()):this._connectedPoint[0]?._activateSignal(a)}}as("FlowGraphSignalConnection",vy);class td extends Em{constructor(a){super(a),this.signalInputs=[],this.signalOutputs=[],this.in=this._registerSignalInput("in")}_registerSignalInput(a){const x=new vy(a,bx.Input,this);return this.signalInputs.push(x),x}_registerSignalOutput(a){const x=new vy(a,bx.Output,this);return this.signalOutputs.push(x),x}getSignalInput(a){return this.signalInputs.find(x=>x.name===a)}getSignalOutput(a){return this.signalOutputs.find(x=>x.name===a)}serialize(a={}){super.serialize(a),a.signalInputs=[],a.signalOutputs=[];for(const x of this.signalInputs){const c={};x.serialize(c),a.signalInputs.push(c)}for(const x of this.signalOutputs){const c={};x.serialize(c),a.signalOutputs.push(c)}}deserialize(a){for(let x=0;x<a.signalInputs.length;x++){const c=this.getSignalInput(a.signalInputs[x].name);if(c)c.deserialize(a.signalInputs[x]);else throw new Error("Could not find signal input with name "+a.signalInputs[x].name+" in block "+a.className)}for(let x=0;x<a.signalOutputs.length;x++){const c=this.getSignalOutput(a.signalOutputs[x].name);if(c)c.deserialize(a.signalOutputs[x]);else throw new Error("Could not find signal output with name "+a.signalOutputs[x].name+" in block "+a.className)}}getClassName(){return"FGExecutionBlock"}}class lP extends td{constructor(a){super(a),this.out=this._registerSignalOutput("out"),this.done=this._registerSignalOutput("done")}_startPendingTasks(a){this._preparePendingTasks(a),a._addPendingBlock(this)}}class vm extends lP{_execute(a){a._notifyExecuteNode(this),this.out._activateSignal(a)}}class Iy{constructor(a){this.uniqueId=v0(),this._userVariables={},this._executionVariables={},this._connectionValues={},this._pendingBlocks=[],this._executionId=0,this.onNodeExecutedObservable=new Jt,this._configuration=a}hasVariable(a){return a in this._userVariables}setVariable(a,x){this._userVariables[a]=x}getVariable(a){return this._userVariables[a]}get userVariables(){return this._userVariables}_getUniqueIdPrefixedName(a,x){return`${a.uniqueId}_${x}`}_setExecutionVariable(a,x,c){this._executionVariables[this._getUniqueIdPrefixedName(a,x)]=c}_getExecutionVariable(a,x,c){return this._hasExecutionVariable(a,x)?this._executionVariables[this._getUniqueIdPrefixedName(a,x)]:c}_deleteExecutionVariable(a,x){delete this._executionVariables[this._getUniqueIdPrefixedName(a,x)]}_hasExecutionVariable(a,x){return this._getUniqueIdPrefixedName(a,x)in this._executionVariables}_hasConnectionValue(a){return a.uniqueId in this._connectionValues}_setConnectionValue(a,x){this._connectionValues[a.uniqueId]=x}_getConnectionValue(a){return this._connectionValues[a.uniqueId]}get configuration(){return this._configuration}_addPendingBlock(a){this._pendingBlocks.push(a)}_removePendingBlock(a){const x=this._pendingBlocks.indexOf(a);x!==-1&&this._pendingBlocks.splice(x,1)}_clearPendingBlocks(){for(const a of this._pendingBlocks)a._cancelPendingTasks(this);this._pendingBlocks.length=0}_notifyExecuteNode(a){this.onNodeExecutedObservable.notifyObservers(a)}_increaseExecutionId(){this._executionId++}get executionId(){return this._executionId}serialize(a={},x=xP){a.uniqueId=this.uniqueId,a._userVariables={};for(const c in this._userVariables)x(c,this._userVariables[c],a._userVariables);a._connectionValues={};for(const c in this._connectionValues)x(c,this._connectionValues[c],a._connectionValues)}getClassName(){return"FGContext"}static Parse(a,x){const c=x.graph.createContext(),u=x.valueParseFunction??jg;c.uniqueId=a.uniqueId;for(const g in a._userVariables){const y=u(g,a._userVariables,c._configuration.scene);c._userVariables[g]=y}for(const g in a._connectionValues){const y=u(g,a._connectionValues,c._configuration.scene);c._connectionValues[g]=y}return c}}Ye([ht()],Iy.prototype,"uniqueId",void 0);function Ry(F,a){return!!(F.parent&&(F.parent===a||Ry(F.parent,a)))}class ad extends vm{constructor(a){super(a),this.config=a}_getReferencedMesh(){const a=this.config.pathConverter.convert(this.config.path),x=a.info.getObject(a.object);if(!x||!(x instanceof mo))throw new Error("Mesh pick event block requires a valid mesh");return x}_preparePendingTasks(a){let x=a._getExecutionVariable(this,"meshPickObserver");if(!x){const c=this._getReferencedMesh();a._setExecutionVariable(this,"mesh",c),x=c.getScene().onPointerObservable.add(g=>{g.type===dr.POINTERPICK&&g.pickInfo?.pickedMesh&&(g.pickInfo?.pickedMesh===c||Ry(g.pickInfo?.pickedMesh,c))&&this._execute(a)});const u=c.onDisposeObservable.add(()=>this._onDispose);a._setExecutionVariable(this,"meshPickObserver",x),a._setExecutionVariable(this,"meshDisposeObserver",u)}}_onDispose(a){this._cancelPendingTasks(a),a._removePendingBlock(this)}_cancelPendingTasks(a){const x=a._getExecutionVariable(this,"mesh"),c=a._getExecutionVariable(this,"meshPickObserver"),u=a._getExecutionVariable(this,"meshDisposeObserver");x.getScene().onPointerObservable.remove(c),x.onDisposeObservable.remove(u),a._deleteExecutionVariable(this,"mesh"),a._deleteExecutionVariable(this,"meshPickObserver"),a._deleteExecutionVariable(this,"meshDisposeObserver")}getClassName(){return ad.ClassName}serialize(a){super.serialize(a),a.config.path=this.config.path}}ad.ClassName="FGMeshPickEventBlock",as(ad.ClassName,ad);var xu;(function(F){F[F.Stopped=0]="Stopped",F[F.Started=1]="Started"})(xu||(xu={}));class xd{constructor(a){this._eventBlocks=[],this._executionContexts=[],this.state=xu.Stopped,this._scene=a.scene,this._coordinator=a.coordinator,this._sceneDisposeObserver=this._scene.onDisposeObservable.add(()=>this.dispose())}createContext(){const a=new Iy({scene:this._scene,coordinator:this._coordinator});return this._executionContexts.push(a),a}getContext(a){return this._executionContexts[a]}addEventBlock(a){this._eventBlocks.push(a)}start(){if(this.state!==xu.Started){this.state=xu.Started,this._executionContexts.length===0&&this.createContext();for(const a of this._executionContexts){const x=this._getContextualOrder();for(const c of x)c._startPendingTasks(a)}}}_getContextualOrder(){const a=[];for(const x of this._eventBlocks)if(x.getClassName()===ad.ClassName){const c=x._getReferencedMesh();let u=0;for(;u<a.length;u++){const y=a[u]._getReferencedMesh();if(c&&y&&Ry(c,y))break}a.splice(u,0,x)}else a.push(x);return a}dispose(){if(this.state!==xu.Stopped){this.state=xu.Stopped;for(const a of this._executionContexts)a._clearPendingBlocks();this._executionContexts.length=0,this._eventBlocks.length=0,this._scene.onDisposeObservable.remove(this._sceneDisposeObserver),this._sceneDisposeObserver=null}}visitAllBlocks(a){const x=[],c=new Set;for(const u of this._eventBlocks)x.push(u),c.add(u.uniqueId);for(;x.length>0;){const u=x.pop();a(u);for(const g of u.dataInputs)for(const y of g._connectedPoint)c.has(y._ownerBlock.uniqueId)||(x.push(y._ownerBlock),c.add(y._ownerBlock.uniqueId));if(u instanceof td)for(const g of u.signalOutputs)for(const y of g._connectedPoint)c.has(y._ownerBlock.uniqueId)||(x.push(y._ownerBlock),c.add(y._ownerBlock.uniqueId))}}serialize(a={},x){a.allBlocks=[],this.visitAllBlocks(c=>{const u={};c.serialize(u),a.allBlocks.push(u)}),a.executionContexts=[];for(const c of this._executionContexts){const u={};c.serialize(u,x),a.executionContexts.push(u)}}static GetDataOutConnectionByUniqueId(a,x){for(const c of a)for(const u of c.dataOutputs)if(u.uniqueId===x)return u;throw new Error("Could not find data out connection with unique id "+x)}static GetSignalInConnectionByUniqueId(a,x){for(const c of a)if(c instanceof td){for(const u of c.signalInputs)if(u.uniqueId===x)return u}throw new Error("Could not find signal in connection with unique id "+x)}static Parse(a,x){const c=x.coordinator.createGraph(),u=[],g=x.valueParseFunction??jg;for(const y of a.allBlocks){const v=Em.Parse(y,{scene:x.coordinator.config.scene,pathConverter:x.pathConverter,valueParseFunction:g});u.push(v),v instanceof vm&&c.addEventBlock(v)}for(const y of u){for(const v of y.dataInputs)for(const w of v.connectedPointIds){const B=xd.GetDataOutConnectionByUniqueId(u,w);v.connectTo(B)}if(y instanceof td)for(const v of y.signalOutputs)for(const w of v.connectedPointIds){const B=xd.GetSignalInConnectionByUniqueId(u,w);v.connectTo(B)}}for(const y of a.executionContexts)Iy.Parse(y,{graph:c,valueParseFunction:g});return c}}class ld{constructor(a){this.config=a,this._flowGraphs=[],this._customEventsMap=new Map,this.config.scene.onDisposeObservable.add(()=>{this.dispose()}),(ld.SceneCoordinators.get(this.config.scene)??[]).push(this)}createGraph(){const a=new xd({scene:this.config.scene,coordinator:this});return this._flowGraphs.push(a),a}removeGraph(a){const x=this._flowGraphs.indexOf(a);x!==-1&&(a.dispose(),this._flowGraphs.splice(x,1))}start(){this._flowGraphs.forEach(a=>a.start())}dispose(){this._flowGraphs.forEach(c=>c.dispose()),this._flowGraphs.length=0;const a=ld.SceneCoordinators.get(this.config.scene)??[],x=a.indexOf(this);x!==-1&&a.splice(x,1)}serialize(a,x){a._flowGraphs=[],this._flowGraphs.forEach(c=>{const u={};c.serialize(u,x),a._flowGraphs.push(u)})}static Parse(a,x){const c=x.valueParseFunction??jg,u=new ld({scene:x.scene});return a._flowGraphs?.forEach(g=>{xd.Parse(g,{coordinator:u,valueParseFunction:c,pathConverter:x.pathConverter})}),u}get flowGraphs(){return this._flowGraphs}getCustomEventObservable(a){let x=this._customEventsMap.get(a);return x||(x=new Jt,this._customEventsMap.set(a,x)),x}notifyCustomEvent(a,x){const c=this._customEventsMap.get(a);c&&c.notifyObservers(x)}}ld.SceneCoordinators=new Map;class Im extends vm{_preparePendingTasks(a){if(!a._getExecutionVariable(this,"sceneReadyObserver")){const c=a.configuration.scene.onReadyObservable.add(()=>{this._execute(a)});a._setExecutionVariable(this,"sceneReadyObserver",c)}}_cancelPendingTasks(a){const x=a._getExecutionVariable(this,"sceneReadyObserver");a.configuration.scene.onReadyObservable.remove(x),a._deleteExecutionVariable(this,"sceneReadyObserver")}getClassName(){return Im.ClassName}}Im.ClassName="FGSceneReadyEventBlock",as("FGSceneReadyEventBlock",Im);class hd extends vm{_preparePendingTasks(a){if(!a._getExecutionVariable(this,"sceneBeforeRender")){const c=a.configuration.scene.onBeforeRenderObservable.add(()=>{this._execute(a)});a._setExecutionVariable(this,"sceneBeforeRender",c)}}_cancelPendingTasks(a){const x=a._getExecutionVariable(this,"sceneBeforeRender");a.configuration.scene.onBeforeRenderObservable.remove(x),a._deleteExecutionVariable(this,"sceneBeforeRender")}getClassName(){return hd.ClassName}}hd.ClassName="FGSceneTickEventBlock",as(hd.ClassName,hd);class ud extends td{constructor(a){super(a),this.out=this._registerSignalOutput("out")}}class dd extends ud{constructor(a){super(a),this.message=this.registerDataInput("message",ls)}_execute(a){const x=this.message.getValue(a);Qt.Log(x),this.out._activateSignal(a)}getClassName(){return dd.ClassName}}dd.ClassName="FGConsoleLogBlock",as(dd.ClassName,dd);var lu;(function(F){F[F.INIT=0]="INIT",F[F.STARTED=1]="STARTED",F[F.ENDED=2]="ENDED"})(lu||(lu={}));function W9(F){let a=0;const x=Date.now();F.observableParameters=F.observableParameters??{};const c=F.contextObservable.add(u=>{const g=Date.now();a=g-x;const y={startTime:x,currentTime:g,deltaTime:a,completeRate:a/F.timeout,payload:u};F.onTick&&F.onTick(y),F.breakCondition&&F.breakCondition()&&(F.contextObservable.remove(c),F.onAborted&&F.onAborted(y)),a>=F.timeout&&(F.contextObservable.remove(c),F.onEnded&&F.onEnded(y))},F.observableParameters.mask,F.observableParameters.insertFirst,F.observableParameters.scope);return c}class x3{constructor(a){this.onEachCountObservable=new Jt,this.onTimerAbortedObservable=new Jt,this.onTimerEndedObservable=new Jt,this.onStateChangedObservable=new Jt,this._observer=null,this._breakOnNextTick=!1,this._tick=x=>{const c=Date.now();this._timer=c-this._startTime;const u={startTime:this._startTime,currentTime:c,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:x},g=this._breakOnNextTick||this._breakCondition(u);g||this._timer>=this._timeToEnd?this._stop(u,g):this.onEachCountObservable.notifyObservers(u)},this._setState(lu.INIT),this._contextObservable=a.contextObservable,this._observableParameters=a.observableParameters??{},this._breakCondition=a.breakCondition??(()=>!1),this._timeToEnd=a.timeout,a.onEnded&&this.onTimerEndedObservable.add(a.onEnded),a.onTick&&this.onEachCountObservable.add(a.onTick),a.onAborted&&this.onTimerAbortedObservable.add(a.onAborted)}set breakCondition(a){this._breakCondition=a}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(a=this._timeToEnd){if(this._state===lu.STARTED)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=a,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(lu.STARTED)}stop(){this._state===lu.STARTED&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(a){this._state=a,this.onStateChangedObservable.notifyObservers(this._state)}_stop(a,x=!1){this._contextObservable.remove(this._observer),this._setState(lu.ENDED),x?this.onTimerAbortedObservable.notifyObservers(a):this.onTimerEndedObservable.notifyObservers(a)}}class Rm extends lP{constructor(a){super(a),this.timeout=this.registerDataInput("timeout",g0)}_preparePendingTasks(a){const x=this.timeout.getValue(a);if(x!==void 0&&x>=0){const c=a._getExecutionVariable(this,"runningTimers")||[],u=a.configuration.scene,g=new x3({timeout:x,contextObservable:u.onBeforeRenderObservable,onEnded:()=>this._onEnded(g,a)});g.start(),c.push(g),a._setExecutionVariable(this,"runningTimers",c)}}_execute(a){this._startPendingTasks(a),this.out._activateSignal(a)}_onEnded(a,x){const c=x._getExecutionVariable(this,"runningTimers")||[],u=c.indexOf(a);u!==-1?c.splice(u,1):_t.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),x._removePendingBlock(this),this.done._activateSignal(x)}_cancelPendingTasks(a){const x=a._getExecutionVariable(this,"runningTimers")||[];for(const c of x)c.dispose();a._deleteExecutionVariable(this,"runningTimers")}getClassName(){return Rm.ClassName}}Rm.ClassName="FGTimerBlock",as("FGTimerBlock",Rm);class Mm extends ud{constructor(a){super(a),this.config=a;for(let x=0;x<this.config.eventData.length;x++){const c=this.config.eventData[x];this.registerDataInput(c,ls)}}_execute(a){const x=this.config.eventId,c=this.dataInputs.map(u=>u.getValue(a));a.configuration.coordinator.notifyCustomEvent(x,c),this.out._activateSignal(a)}getClassName(){return Mm.ClassName}}Mm.ClassName="FGSendCustomEventBlock",as("FGSendCustomEventBlock",Mm);class fd extends vm{constructor(a){super(a),this.config=a;for(let x=0;x<this.config.eventData.length;x++){const c=this.config.eventData[x];this.registerDataOutput(c,ls)}}_preparePendingTasks(a){const x=a.configuration.coordinator.getCustomEventObservable(this.config.eventId);this._eventObserver=x.add(c=>{for(let u=0;u<c.length;u++)this.dataOutputs[u].setValue(c[u],a);this._execute(a)})}_cancelPendingTasks(a){const x=a.configuration.coordinator.getCustomEventObservable(this.config.eventId);x?x.remove(this._eventObserver):_t.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`)}getClassName(){return fd.ClassName}serialize(a){super.serialize(a),a.eventId=this.config.eventId,a.eventData=this.config.eventData}}fd.ClassName="FGReceiveCustomEventBlock",as(fd.ClassName,fd);class md extends td{constructor(a){super(a),this.config=a,this.outFlows=[];for(let x=0;x<this.config.numberOutputFlows;x++)this.outFlows.push(this._registerSignalOutput(`${x}`))}_execute(a){for(let x=0;x<this.config.numberOutputFlows;x++)this.outFlows[x]._activateSignal(a)}getClassName(){return md.ClassName}}md.ClassName="FGSequenceBlock",as(md.ClassName,md);const hP=new RegExp(/\{(\w+)\}/g);class uP{constructor(a,x){this.path=a,this.ownerBlock=x,this.templatedInputs=[];let c=hP.exec(a);for(;c;){const[,u]=c;this.templatedInputs.push(x.registerDataInput(u,Ea)),c=hP.exec(a)}}getAccessor(a,x){let c=this.path;for(const u of this.templatedInputs){const g=u.getValue(x).value;c=c.replace(`{${u.name}}`,g.toString())}return a.convert(c)}}class gd extends Em{constructor(a){super(a),this.config=a,this.value=this.registerDataOutput("value",ls),this.templateComponent=new uP(a.path,this)}_updateOutputs(a){const x=this.templateComponent.getAccessor(this.config.pathConverter,a),c=x.info.get(x.object);this.value.setValue(c,a)}getClassName(){return gd.ClassName}serialize(a={}){super.serialize(a),a.config.path=this.config.path}}gd.ClassName="FGGetPropertyBlock",as(gd.ClassName,gd);class Bm extends ud{constructor(a){super(a),this.config=a,this.a=this.registerDataInput("a",ls),this.templateComponent=new uP(a.path,this)}_execute(a){const x=this.a.getValue(a),c=this.templateComponent.getAccessor(this.config.pathConverter,a);c.info.set(x,c.object),this.out._activateSignal(a)}serialize(a={}){super.serialize(a),a.config.path=this.config.path}getClassName(){return Bm.ClassName}}Bm.ClassName="FGSetPropertyBlock",as("FGSetPropertyBlock",Bm);const dP="cachedOperationValue",fP="cachedExecutionId";class Yg extends Em{constructor(a,x){super(x),this.value=this.registerDataOutput("value",a)}_updateOutputs(a){const x=a._getExecutionVariable(this,fP),c=a._getExecutionVariable(this,dP);if(c!==void 0&&x===a.executionId)this.value.setValue(c,a);else{const u=this._doOperation(a);a._setExecutionVariable(this,dP,u),a._setExecutionVariable(this,fP,a.executionId),this.value.setValue(u,a)}}}class _0 extends Yg{constructor(a,x,c,u,g,y){super(c,y),this._operation=u,this._className=g,this.a=this.registerDataInput("a",a),this.b=this.registerDataInput("b",x)}_doOperation(a){return this._operation(this.a.getValue(a),this.b.getValue(a))}getClassName(){return this._className}}class Um extends Yg{constructor(a,x,c,u){super(a,u),this._operation=x,this._className=c}_doOperation(a){return this._operation()}getClassName(){return this._className}}class yn extends Yg{constructor(a,x,c,u,g){super(x,g),this._operation=c,this._className=u,this.a=this.registerDataInput("a",a)}_doOperation(a){return this._operation(this.a.getValue(a))}getClassName(){return this._className}}class My extends Yg{constructor(a,x,c,u,g,y,v){super(u,v),this._operation=g,this._className=y,this.a=this.registerDataInput("a",a),this.b=this.registerDataInput("b",x),this.c=this.registerDataInput("c",c)}_doOperation(a){return this._operation(this.a.getValue(a),this.b.getValue(a),this.c.getValue(a))}getClassName(){return this._className}}function lo(F){return F.getClassName?F.getClassName():""}function Vm(F,a){return F==="Vector2"&&a==="Vector2"||F==="Vector3"&&a==="Vector3"||F==="Vector4"&&a==="Vector4"}function Wm(F,a){return F==="Matrix"&&a==="Matrix"}function Hm(F,a){return F==="FlowGraphInteger"&&a==="FlowGraphInteger"}class _d extends _0{constructor(a){super(ls,ls,ls,(x,c)=>this._polymorphicAdd(x,c),_d.ClassName,a)}_polymorphicAdd(a,x){const c=lo(a),u=lo(x);return Vm(c,u)||Wm(c,u)||Hm(c,u)?a.add(x):a+x}}_d.ClassName="FGAddBlock",as(_d.ClassName,_d);class yd extends _0{constructor(a){super(ls,ls,ls,(x,c)=>this._polymorphicAdd(x,c),yd.ClassName,a)}_polymorphicAdd(a,x){const c=lo(a),u=lo(x);return Vm(c,u)||Hm(c,u)?a.subtract(x):Wm(c,u)?a.add(x.scale(-1)):a-x}}yd.ClassName="FGSubBlock",as(yd.ClassName,yd);class bd extends _0{constructor(a){super(ls,ls,ls,(x,c)=>this._polymorphicMultiply(x,c),bd.ClassName,a)}_polymorphicMultiply(a,x){const c=lo(a),u=lo(x);return Vm(c,u)||Hm(c,u)?a.multiply(x):Wm(c,u)?vt.FromValues(a.m[0]*x.m[0],a.m[4]*x.m[4],a.m[8]*x.m[8],a.m[12]*x.m[12],a.m[1]*x.m[1],a.m[5]*x.m[5],a.m[9]*x.m[9],a.m[13]*x.m[13],a.m[2]*x.m[2],a.m[6]*x.m[6],a.m[10]*x.m[10],a.m[14]*x.m[14],a.m[3]*x.m[3],a.m[7]*x.m[7],a.m[11]*x.m[11],a.m[15]*x.m[15]):a*x}}bd.ClassName="FGMultiplyBlock",as(bd.ClassName,bd);class Ed extends _0{constructor(a){super(ls,ls,ls,(x,c)=>this._polymorphicDivide(x,c),Ed.ClassName,a)}_polymorphicDivide(a,x){const c=lo(a),u=lo(x);return Vm(c,u)||Hm(c,u)?a.divide(x):Wm(c,u)?vt.FromValues(a.m[0]/x.m[0],a.m[4]/x.m[4],a.m[8]/x.m[8],a.m[12]/x.m[12],a.m[1]/x.m[1],a.m[5]/x.m[5],a.m[9]/x.m[9],a.m[13]/x.m[13],a.m[2]/x.m[2],a.m[6]/x.m[6],a.m[10]/x.m[10],a.m[14]/x.m[14],a.m[3]/x.m[3],a.m[7]/x.m[7],a.m[11]/x.m[11],a.m[15]/x.m[15]):a/x}}Ed.ClassName="FGDivideBlock",as(Ed.ClassName,Ed);class vd extends Um{constructor(a){super(g0,()=>Math.random(),vd.ClassName,a)}}vd.ClassName="FGRandomBlock",as(vd.ClassName,vd);class Id extends _0{constructor(a){super(ls,ls,g0,(x,c)=>this._polymorphicDot(x,c),Id.ClassName,a)}_polymorphicDot(a,x){switch(lo(a)){case"Vector2":return mr.Dot(a,x);case"Vector3":return Ee.Dot(a,x);case"Vector4":return an.Dot(a,x);default:throw new Error(`Cannot get dot product of ${a} and ${x}`)}}}Id.ClassName="FGDotBlock",as(Id.ClassName,Id);class Rd extends Um{constructor(a){super(g0,()=>Math.E,Rd.ClassName,a)}}Rd.ClassName="FGEBlock",as(Rd.ClassName,Rd);class Md extends Um{constructor(a){super(g0,()=>Math.PI,Md.ClassName,a)}}Md.ClassName="FGPIBlock",as(Md.ClassName,Md);class Bd extends Um{constructor(a){super(g0,()=>Number.POSITIVE_INFINITY,Bd.ClassName,a)}}Bd.ClassName="FGInfBlock",as(Bd.ClassName,Bd);class Ud extends Um{constructor(a){super(g0,()=>Number.NaN,Ud.ClassName,a)}}Ud.ClassName="FGNaNBlock",as(Ud.ClassName,Ud);function ga(F,a){switch(lo(F)){case"FlowGraphInteger":return new Ma(a(F.value));case"Vector2":return new mr(a(F.x),a(F.y));case"Vector3":return new Ee(a(F.x),a(F.y),a(F.z));case"Vector4":return new an(a(F.x),a(F.y),a(F.z),a(F.w));case"Matrix":return vt.FromValues(a(F.m[0]),a(F.m[4]),a(F.m[8]),a(F.m[12]),a(F.m[1]),a(F.m[5]),a(F.m[9]),a(F.m[13]),a(F.m[2]),a(F.m[6]),a(F.m[10]),a(F.m[14]),a(F.m[3]),a(F.m[7]),a(F.m[11]),a(F.m[15]));default:return a(F)}}class Vd extends yn{constructor(a){super(ls,ls,x=>this._polymorphicAbs(x),Vd.ClassName,a)}_polymorphicAbs(a){return ga(a,Math.abs)}}Vd.ClassName="FGAbsBlock",as(Vd.ClassName,Vd);class Wd extends yn{constructor(a){super(ls,ls,x=>this._polymorphicSign(x),Wd.ClassName,a)}_polymorphicSign(a){return ga(a,Math.sign)}}Wd.ClassName="FGSignBlock",as(Wd.ClassName,Wd);class Hd extends yn{constructor(a){super(ls,ls,x=>this._polymorphicTrunc(x),Hd.ClassName,a)}_polymorphicTrunc(a){return ga(a,Math.trunc)}}Hd.ClassName="FGTruncBlock",as(Hd.ClassName,Hd);class Xd extends yn{constructor(a){super(ls,ls,x=>this._polymorphicFloor(x),Xd.ClassName,a)}_polymorphicFloor(a){return ga(a,Math.floor)}}Xd.ClassName="FGFloorBlock",as(Xd.ClassName,Xd);class jd extends yn{constructor(a){super(ls,ls,x=>this._polymorphicCeiling(x),jd.ClassName,a)}_polymorphicCeiling(a){return ga(a,Math.ceil)}}jd.ClassName="FGCeilBlock",as(jd.ClassName,jd);class Yd extends yn{constructor(a){super(ls,ls,x=>this._polymorphicFract(x),Yd.ClassName,a)}_polymorphicFract(a){return ga(a,x=>x-Math.floor(x))}}Yd.ClassName="FGFractBlock",as(Yd.ClassName,Yd);class $d extends yn{constructor(a){super(ls,ls,x=>this._polymorphicNeg(x),$d.ClassName,a)}_polymorphicNeg(a){return ga(a,x=>-x)}}$d.ClassName="FGNegBlock",as($d.ClassName,$d);function Xm(F,a,x){switch(lo(F)){case"FlowGraphInteger":return new Ma(x(F.value,a.value));case"Vector2":return new mr(x(F.x,a.x),x(F.y,a.y));case"Vector3":return new Ee(x(F.x,a.x),x(F.y,a.y),x(F.z,a.z));case"Vector4":return new an(x(F.x,a.x),x(F.y,a.y),x(F.z,a.z),x(F.w,a.w));case"Matrix":return vt.FromValues(x(F.m[0],a.m[0]),x(F.m[4],a.m[4]),x(F.m[8],a.m[8]),x(F.m[12],a.m[12]),x(F.m[1],a.m[1]),x(F.m[5],a.m[5]),x(F.m[9],a.m[9]),x(F.m[13],a.m[13]),x(F.m[2],a.m[2]),x(F.m[6],a.m[6]),x(F.m[10],a.m[10]),x(F.m[14],a.m[14]),x(F.m[3],a.m[3]),x(F.m[7],a.m[7]),x(F.m[11],a.m[11]),x(F.m[15],a.m[15]));default:return x(F,a)}}class Jd extends _0{constructor(a){super(ls,ls,ls,(x,c)=>this._polymorphicRemainder(x,c),Jd.ClassName,a)}_polymorphicRemainder(a,x){return Xm(a,x,(c,u)=>c%u)}}Jd.ClassName="FGRemainderBlock",as(Jd.ClassName,Jd);class tf extends _0{constructor(a){super(ls,ls,ls,(x,c)=>this._polymorphicMin(x,c),tf.ClassName,a)}_polymorphicMin(a,x){return Xm(a,x,Math.min)}}tf.ClassName="FGMinBlock",as(tf.ClassName,tf);class af extends _0{constructor(a){super(ls,ls,ls,(x,c)=>this._polymorphicMax(x,c),af.ClassName,a)}_polymorphicMax(a,x){return Xm(a,x,Math.max)}}af.ClassName="FGMaxBlock",as(af.ClassName,af);function l3(F,a,x){return Math.min(Math.max(F,Math.min(a,x)),Math.max(a,x))}function mP(F,a,x,c){switch(lo(F)){case"FlowGraphInteger":return new Ma(c(F.value,a.value,x.value));case"Vector2":return new mr(c(F.x,a.x,x.x),c(F.y,a.y,x.y));case"Vector3":return new Ee(c(F.x,a.x,x.x),c(F.y,a.y,x.y),c(F.z,a.z,x.z));case"Vector4":return new an(c(F.x,a.x,x.x),c(F.y,a.y,x.y),c(F.z,a.z,x.z),c(F.w,a.w,x.w));case"Matrix":return vt.FromValues(c(F.m[0],a.m[0],x.m[0]),c(F.m[4],a.m[4],x.m[4]),c(F.m[8],a.m[8],x.m[8]),c(F.m[12],a.m[12],x.m[12]),c(F.m[1],a.m[1],x.m[1]),c(F.m[5],a.m[5],x.m[5]),c(F.m[9],a.m[9],x.m[9]),c(F.m[13],a.m[13],x.m[13]),c(F.m[2],a.m[2],x.m[2]),c(F.m[6],a.m[6],x.m[6]),c(F.m[10],a.m[10],x.m[10]),c(F.m[14],a.m[14],x.m[14]),c(F.m[3],a.m[3],x.m[3]),c(F.m[7],a.m[7],x.m[7]),c(F.m[11],a.m[11],x.m[11]),c(F.m[15],a.m[15],x.m[15]));default:return c(F,a,x)}}class xf extends My{constructor(a){super(ls,ls,ls,ls,(x,c,u)=>this._polymorphicClamp(x,c,u),xf.ClassName,a)}_polymorphicClamp(a,x,c){return mP(a,x,c,l3)}}xf.ClassName="FGClampBlock",as(xf.ClassName,xf);function h3(F){return Math.min(Math.max(F,0),1)}class lf extends yn{constructor(a){super(ls,ls,x=>this._polymorphicSaturate(x),lf.ClassName,a)}_polymorphicSaturate(a){return ga(a,h3)}}lf.ClassName="FGSaturateBlock",as(lf.ClassName,lf);class hf extends My{constructor(a){super(ls,ls,ls,ls,(x,c,u)=>this._polymorphicInterpolate(x,c,u),hf.ClassName,a)}_interpolate(a,x,c){return(1-c)*a+c*x}_polymorphicInterpolate(a,x,c){return mP(a,x,c,this._interpolate)}}hf.ClassName="FGInterpolateBlock",as(hf.ClassName,hf);class uf extends _0{constructor(a){super(ls,ls,fc,(x,c)=>this._polymorphicEq(x,c),uf.ClassName,a)}_polymorphicEq(a,x){const c=lo(a),u=lo(x);return Vm(c,u)||Wm(c,u)||Hm(c,u)?a.equals(x):a===x}}uf.ClassName="FGEqBlock",as(uf.ClassName,uf);function $g(F,a,x){const c=lo(F),u=lo(a);if(c===u){if(c==="")return x(F,a);if(c==="FlowGraphInteger")return x(F.value,a.value);throw new Error(`Cannot compare ${F} and ${a}`)}throw new Error(`${F} and ${a} are of different types.`)}class df extends _0{constructor(a){super(ls,ls,fc,(x,c)=>this._polymorphicLessThan(x,c),df.ClassName,a)}_polymorphicLessThan(a,x){return $g(a,x,(c,u)=>c<u)}}df.ClassName="FGLessThanBlock",as(df.ClassName,df);class Jg extends _0{constructor(a){super(ls,ls,fc,(x,c)=>this._polymorphicLessThanOrEqual(x,c),Jg.ClassName,a)}_polymorphicLessThanOrEqual(a,x){return $g(a,x,(c,u)=>c<=u)}}Jg.ClassName="FGLessThanOrEqualBlock";class ff extends _0{constructor(a){super(ls,ls,fc,(x,c)=>this._polymorphicGreaterThan(x,c),ff.ClassName,a)}_polymorphicGreaterThan(a,x){return $g(a,x,(c,u)=>c>u)}}ff.ClassName="FGGreaterThanBlock",as(ff.ClassName,ff);class mf extends _0{constructor(a){super(ls,ls,fc,(x,c)=>this._polymorphicGreaterThanOrEqual(x,c),mf.ClassName,a)}_polymorphicGreaterThanOrEqual(a,x){return $g(a,x,(c,u)=>c>=u)}}mf.ClassName="FGGreaterThanOrEqualBlock",as(mf.ClassName,mf);class gf extends yn{constructor(a){super(ls,fc,x=>this._polymorphicIsNan(x),gf.ClassName,a)}_polymorphicIsNan(a){const x=lo(a);if(x==="")return isNaN(a);if(x==="FlowGraphInteger")return isNaN(a.value);throw new Error(`Cannot get NaN of ${a}`)}}gf.ClassName="FGIsNanBlock",as(gf.ClassName,gf);class e_ extends yn{constructor(a){super(ls,fc,x=>this._polymorphicIsInf(x),e_.ClassName,a)}_polymorphicIsInf(a){const x=lo(a);if(x==="")return!isFinite(a);if(x==="FlowGraphInteger")return!isFinite(a.value);throw new Error(`Cannot get isInf of ${a}`)}}e_.ClassName="FGIsInfBlock";class _f extends yn{constructor(a){super(ls,ls,x=>this._polymorphicDegToRad(x),_f.ClassName,a)}_degToRad(a){return a*Math.PI/180}_polymorphicDegToRad(a){return ga(a,this._degToRad)}}_f.ClassName="FGDegToRadBlock",as(_f.ClassName,_f);class yf extends yn{constructor(a){super(ls,ls,x=>this._polymorphicRadToDeg(x),yf.ClassName,a)}_radToDeg(a){return a*180/Math.PI}_polymorphicRadToDeg(a){return ga(a,this._radToDeg)}}yf.ClassName="FGRadToDegBlock",as(yf.ClassName,yf);class bf extends yn{constructor(a){super(ls,ls,x=>this._polymorphicSin(x),bf.ClassName,a)}_polymorphicSin(a){return ga(a,Math.sin)}}bf.ClassName="FGSinBlock",as(bf.ClassName,bf);class Ef extends yn{constructor(a){super(ls,ls,x=>this._polymorphicCos(x),Ef.ClassName,a)}_polymorphicCos(a){return ga(a,Math.cos)}}Ef.ClassName="FGCosBlock",as(Ef.ClassName,Ef);class vf extends yn{constructor(a){super(ls,ls,x=>this._polymorphicTan(x),vf.ClassName,a)}_polymorphicTan(a){return ga(a,Math.tan)}}vf.ClassName="FGTanBlock",as(vf.ClassName,vf);class If extends yn{constructor(a){super(ls,ls,x=>this._polymorphicAsin(x),If.ClassName,a)}_polymorphicAsin(a){return ga(a,Math.asin)}}If.ClassName="FGAsinBlock",as(If.ClassName,If);class Rf extends yn{constructor(a){super(ls,ls,x=>this._polymorphicAcos(x),Rf.ClassName,a)}_polymorphicAcos(a){return ga(a,Math.acos)}}Rf.ClassName="FGAcosBlock",as(Rf.ClassName,Rf);class Mf extends yn{constructor(a){super(ls,ls,x=>this._polymorphicAtan(x),Mf.ClassName,a)}_polymorphicAtan(a){return ga(a,Math.atan)}}Mf.ClassName="FGAtanBlock",as(Mf.ClassName,Mf);class Bf extends _0{constructor(a){super(ls,ls,ls,(x,c)=>this._polymorphicAtan2(x,c),Bf.ClassName,a)}_polymorphicAtan2(a,x){return Xm(a,x,Math.atan2)}}Bf.ClassName="FGAtan2Block",as(Bf.ClassName,Bf);class Uf extends yn{constructor(a){super(ls,ls,x=>this._polymorphicSinh(x),Uf.ClassName,a)}_polymorphicSinh(a){return ga(a,Math.sinh)}}Uf.ClassName="FGSinhBlock",as(Uf.ClassName,Uf);class Vf extends yn{constructor(a){super(ls,ls,x=>this._polymorphicCosh(x),Vf.ClassName,a)}_polymorphicCosh(a){return ga(a,Math.cosh)}}Vf.ClassName="FGCoshBlock",as(Vf.ClassName,Vf);class Wf extends yn{constructor(a){super(ls,ls,x=>this._polymorphicTanh(x),Wf.ClassName,a)}_polymorphicTanh(a){return ga(a,Math.tanh)}}Wf.ClassName="FGTanhBlock",as(Wf.ClassName,Wf);class Hf extends yn{constructor(a){super(ls,g0,x=>this._polymorphicAsinh(x),Hf.ClassName,a)}_polymorphicAsinh(a){return ga(a,Math.asinh)}}Hf.ClassName="FGAsinhBlock",as(Hf.ClassName,Hf);class Xf extends yn{constructor(a){super(ls,g0,x=>this._polymorphicAcosh(x),Xf.ClassName,a)}_polymorphicAcosh(a){return ga(a,Math.acosh)}}Xf.ClassName="FGAcoshBlock",as(Xf.ClassName,Xf);class jf extends yn{constructor(a){super(ls,g0,x=>this._polymorphicAtanh(x),jf.ClassName,a)}_polymorphicAtanh(a){return ga(a,Math.atanh)}}jf.ClassName="FGAtanhBlock",as(jf.ClassName,jf);class Yf extends yn{constructor(a){super(ls,g0,x=>this._polymorphicExp(x),Yf.ClassName,a)}_polymorphicExp(a){return ga(a,Math.exp)}}Yf.ClassName="FGExpBlock",as(Yf.ClassName,Yf);class $f extends yn{constructor(a){super(ls,g0,x=>this._polymorphicLog(x),$f.ClassName,a)}_polymorphicLog(a){return ga(a,Math.log)}}$f.ClassName="FGLogBlock",as($f.ClassName,$f);class Jf extends yn{constructor(a){super(ls,g0,x=>this._polymorphicLog2(x),Jf.ClassName,a)}_polymorphicLog2(a){return ga(a,Math.log2)}}Jf.ClassName="FGLog2Block",as(Jf.ClassName,Jf);class tp extends yn{constructor(a){super(ls,g0,x=>this._polymorphicLog10(x),tp.ClassName,a)}_polymorphicLog10(a){return ga(a,Math.log10)}}tp.ClassName="FGLog10Block",as(tp.ClassName,tp);class ap extends yn{constructor(a){super(ls,g0,x=>this._polymorphicSqrt(x),ap.ClassName,a)}_polymorphicSqrt(a){return ga(a,Math.sqrt)}}ap.ClassName="FGSqrtBlock",as(ap.ClassName,ap);class op extends yn{constructor(a){super(ls,g0,x=>this._polymorphicCubeRoot(x),op.ClassName,a)}_polymorphicCubeRoot(a){return ga(a,Math.cbrt)}}op.ClassName="FGCubeRootBlock",as(op.ClassName,op);class xp extends _0{constructor(a){super(ls,g0,g0,(x,c)=>this._polymorphicPow(x,c),xp.ClassName,a)}_polymorphicPow(a,x){return Xm(a,x,Math.pow)}}xp.ClassName="FGPowBlock",as(xp.ClassName,xp);class lp extends yn{constructor(a){super(ls,g0,x=>this._polymorphicLength(x),lp.ClassName,a)}_polymorphicLength(a){switch(lo(a)){case"Vector2":case"Vector3":case"Vector4":return a.length();default:throw new Error(`Cannot compute length of value ${a}`)}}}lp.ClassName="FGLengthBlock",as(lp.ClassName,lp);class hp extends yn{constructor(a){super(ls,ls,x=>this._polymorphicNormalize(x),hp.ClassName,a)}_polymorphicNormalize(a){switch(lo(a)){case"Vector2":case"Vector3":case"Vector4":return a.normalize();default:throw new Error(`Cannot normalize value ${a}`)}}}hp.ClassName="FGNormalizeBlock",as(hp.ClassName,hp);class up extends _0{constructor(a){super(au,au,au,(x,c)=>Ee.Cross(x,c),up.ClassName,a)}}up.ClassName="FGCrossBlock",as(up.ClassName,up);class dp extends _0{constructor(a){super(by,g0,by,(x,c)=>mr.Transform(x,vt.RotationZ(c)),dp.ClassName,a)}}dp.ClassName="FGRotate2DBlock",as(dp.ClassName,dp);class fp extends My{constructor(a){super(au,au,g0,au,(x,c,u)=>Ee.TransformCoordinates(x,vt.RotationAxis(c,u)),fp.ClassName,a)}}fp.ClassName="FGRotate3DBlock",as(fp.ClassName,fp);class mp extends yn{constructor(a){super(uh,uh,x=>vt.Transpose(x),mp.ClassName,a)}}mp.ClassName="FGTransposeBlock",as(mp.ClassName,mp);class gp extends yn{constructor(a){super(uh,g0,x=>x.determinant(),gp.ClassName,a)}}gp.ClassName="FGDeterminantBlock",as(gp.ClassName,gp);class _p extends yn{constructor(a){super(uh,uh,x=>vt.Invert(x),_p.ClassName,a)}}_p.ClassName="FGInvertMatrixBlock",as(_p.ClassName,_p);class yp extends _0{constructor(a){super(uh,uh,uh,(x,c)=>c.multiply(x),yp.ClassName,a)}}yp.ClassName="FGMatMulBlock",as(yp.ClassName,yp);class bp extends yn{constructor(a){super(Ea,Ea,x=>new Ma(~x.value),bp.ClassName,a)}}bp.ClassName="FGBitwiseNotBlock",as(bp.ClassName,bp);class Ep extends _0{constructor(a){super(Ea,Ea,Ea,(x,c)=>new Ma(x.value&c.value),Ep.ClassName,a)}}Ep.ClassName="FGBitwiseAndBlock",as(Ep.ClassName,Ep);class vp extends _0{constructor(a){super(Ea,Ea,Ea,(x,c)=>new Ma(x.value|c.value),vp.ClassName,a)}}vp.ClassName="FGBitwiseOrBlock",as(vp.ClassName,vp);class Ip extends _0{constructor(a){super(Ea,Ea,Ea,(x,c)=>new Ma(x.value^c.value),Ip.ClassName,a)}}Ip.ClassName="FGBitwiseXorBlock",as(Ip.ClassName,Ip);class Rp extends _0{constructor(a){super(Ea,Ea,Ea,(x,c)=>new Ma(x.value<<c.value),Rp.ClassName,a)}}Rp.ClassName="FGBitwiseLeftShiftBlock",as(Rp.ClassName,Rp);class Mp extends _0{constructor(a){super(Ea,Ea,Ea,(x,c)=>new Ma(x.value>>c.value),Mp.ClassName,a)}}Mp.ClassName="FGBitwiseRightShiftBlock",as(Mp.ClassName,Mp);class Bp extends yn{constructor(a){super(Ea,Ea,x=>new Ma(Math.clz32(x.value)),Bp.ClassName,a)}}Bp.ClassName="FGCountLeadingZerosBlock",as(Bp.ClassName,Bp);class Up extends yn{constructor(a){super(Ea,Ea,x=>new Ma(x.value?31-Math.clz32(x.value&-x.value):32),Up.ClassName,a)}}Up.ClassName="FGCountTrailingZerosBlock",as(Up.ClassName,Up);function u3(F){let a=0;for(;F;)a+=F&1,F>>=1;return a}class Vp extends yn{constructor(a){super(Ea,Ea,x=>new Ma(u3(x.value)),Vp.ClassName,a)}}Vp.ClassName="FGCountOneBitsBlock",as(Vp.ClassName,Vp);class Wp extends ud{constructor(a={startIndex:new Ma(0)}){super(a),this.config=a,this.reset=this._registerSignalInput("reset"),this.n=this.registerDataInput("n",Ea),this.value=this.registerDataOutput("value",Ea)}_execute(a,x){if(x===this.reset)this.value.setValue(this.config.startIndex,a);else{const c=this.value.getValue(a);c.value<this.n.getValue(a).value&&(this.value.setValue(new Ma(c.value+1),a),this.out._activateSignal(a))}}getClassName(){return Wp.ClassName}}Wp.ClassName="FGDoNBlock",as(Wp.ClassName,Wp);class Hp extends Em{constructor(a){super(a),this.config=a,this.output=this.registerDataOutput(a.variableName,ls)}_updateOutputs(a){const x=this.config.variableName;a.hasVariable(x)&&this.output.setValue(a.getVariable(x),a)}getClassName(){return Hp.ClassName}serialize(a){super.serialize(a),a.config.variableName=this.config.variableName}}Hp.ClassName="FGGetVariableBlock",as(Hp.ClassName,Hp);class Xp extends ud{constructor(a){super(a),this.config=a,this.input=this.registerDataInput(a.variableName,ls)}_execute(a){const x=this.config.variableName,c=this.input.getValue(a);a.setVariable(x,c),this.out._activateSignal(a)}getClassName(){return Xp.ClassName}}Xp.ClassName="FGSetVariableBlock",as(Xp.ClassName,Xp);class jp extends ud{constructor(a){super(a),this.config=a,this.condition=this.registerDataInput("condition",fc),this.loopBody=this._registerSignalOutput("loopBody")}_execute(a,x){let c=this.condition.getValue(a);for(this.config?.isDo&&!c&&this.loopBody._activateSignal(a);c;)this.loopBody._activateSignal(a),c=this.condition.getValue(a);this.out._activateSignal(a)}getClassName(){return jp.ClassName}serialize(a){super.serialize(a),a.isDo=this.config?.isDo}}jp.ClassName="FGWhileLoopBlock",as(jp.ClassName,jp);const d3={"lifecycle/onStart":Im.ClassName,"lifecycle/onTick":hd.ClassName,log:dd.ClassName,"flow/delay":Rm.ClassName,"customEvent/send":Mm.ClassName,"customEvent/receive":fd.ClassName,"flow/sequence":md.ClassName,"world/get":gd.ClassName,"world/set":Bm.ClassName,"flow/doN":Wp.ClassName,"variable/get":Hp.ClassName,"variable/set":Xp.ClassName,"flow/whileLoop":jp.ClassName,"math/random":vd.ClassName,"math/e":Rd.ClassName,"math/pi":Md.ClassName,"math/inf":Bd.ClassName,"math/nan":Ud.ClassName,"math/abs":Vd.ClassName,"math/sign":Wd.ClassName,"math/trunc":Hd.ClassName,"math/floor":Xd.ClassName,"math/ceil":jd.ClassName,"math/fract":Yd.ClassName,"math/neg":$d.ClassName,"math/add":_d.ClassName,"math/sub":yd.ClassName,"math/mul":bd.ClassName,"math/div":Ed.ClassName,"math/rem":Jd.ClassName,"math/min":tf.ClassName,"math/max":af.ClassName,"math/clamp":xf.ClassName,"math/saturate":lf.ClassName,"math/mix":hf.ClassName,"math/eq":uf.ClassName,"math/lt":df.ClassName,"math/le":Jg.ClassName,"math/gt":ff.ClassName,"math/ge":mf.ClassName,"math/isnan":gf.ClassName,"math/isinf":e_.ClassName,"math/rad":_f.ClassName,"math/deg":yf.ClassName,"math/sin":bf.ClassName,"math/cos":Ef.ClassName,"math/tan":vf.ClassName,"math/asin":If.ClassName,"math/acos":Rf.ClassName,"math/atan":Mf.ClassName,"math/atan2":Bf.ClassName,"math/sinh":Uf.ClassName,"math/cosh":Vf.ClassName,"math/tanh":Wf.ClassName,"math/asinh":Hf.ClassName,"math/acosh":Xf.ClassName,"math/atanh":jf.ClassName,"math/exp":Yf.ClassName,"math/log":$f.ClassName,"math/log2":Jf.ClassName,"math/log10":tp.ClassName,"math/sqrt":ap.ClassName,"math/cbrt":op.ClassName,"math/pow":xp.ClassName,"math/length":lp.ClassName,"math/normalize":hp.ClassName,"math/dot":Id.ClassName,"math/cross":up.ClassName,"math/rotate2d":dp.ClassName,"math/rotate3d":fp.ClassName,"math/transpose":mp.ClassName,"math/determinant":gp.ClassName,"math/inverse":_p.ClassName,"math/matmul":yp.ClassName,"math/not":bp.ClassName,"math/and":Ep.ClassName,"math/or":vp.ClassName,"math/xor":Ip.ClassName,"math/asr":Mp.ClassName,"math/lsl":Rp.ClassName,"math/clz":Bp.ClassName,"math/ctz":Up.ClassName,"math/popcnt":Vp.ClassName},f3={float2:"Vector2",float3:"Vector3",float4:"Vector4",float4x4:"Matrix",int:"FlowGraphInteger"};function By(F,a,x){if(F.type!==void 0){const c=a.types&&a.types[F.type];if(!c)throw new Error(`${x}: Unknown type: ${F.type}`);const u=c.signature;if(!u)throw new Error(`${x}: Type ${F.type} has no signature`);const g=f3[u];return{value:F.value,className:g}}else return F.value}function m3(F,a,x){const c={},u=F.configuration??[];for(const g of u)if(g.id==="customEvent"){const y=a.customEvents&&a.customEvents[g.value];if(!y)throw new Error(`/extensions/KHR_interactivity/nodes/${x}: Unknown custom event: ${g.value}`);c.eventId=y.id,c.eventData=y.values.map(v=>v.id)}else if(g.id==="variable"){const y=a.variables&&a.variables[g.value];if(!y)throw new Error(`/extensions/KHR_interactivity/nodes/${x}: Unknown variable: ${g.value}`);c.variableName=y.id}else if(g.id==="path"){const y=g.value;c.path=y}else c[g.id]=By(g,a,`/extensions/KHR_interactivity/nodes/${x}`);return c}function g3(F,a,x){const c=d3[a.type];if(!c)throw new Error(`/extensions/KHR_interactivity/nodes/${F}: Unknown block type: ${a.type}`);const u=F.toString(),g=m3(a,x,u),y=a.metadata;return{className:c,config:g,uniqueId:u,metadata:y,dataInputs:[],dataOutputs:[],signalInputs:[],signalOutputs:[]}}function _3(F){const a={uniqueId:v0(),_userVariables:{},_connectionValues:{}},x=[a],c=[];for(let g=0;g<F.nodes.length;g++){const y=F.nodes[g],v=g3(g,y,F);c.push(v)}for(let g=0;g<F.nodes.length;g++){const y=F.nodes[g],v=c[g],w=y.flows??[];for(const W of w){const ae=W.id,ue={uniqueId:v0(),name:ae,_connectionType:bx.Output,connectedPointIds:[]};v.signalOutputs.push(ue);const fe=W.node,Re=W.socket,_e=c[fe];if(!_e)throw new Error(`/extensions/KHR_interactivity/nodes/${g}: Could not find node with id ${fe} that connects its input with with node ${g}'s output ${ae}`);let Be=_e.signalInputs.find(tt=>tt.name===Re);Be||(Be={uniqueId:v0(),name:Re,_connectionType:bx.Input,connectedPointIds:[]},_e.signalInputs.push(Be)),Be.connectedPointIds.push(ue.uniqueId),ue.connectedPointIds.push(Be.uniqueId)}const B=y.values??[];for(const W of B){const ae=W.id,ue={uniqueId:v0(),name:ae,_connectionType:bx.Input,connectedPointIds:[]};if(v.dataInputs.push(ue),W.value!==void 0){const fe=By(W,F,`/extensions/KHR_interactivity/nodes/${g}`);a._connectionValues[ue.uniqueId]=fe}else if(W.node!==void 0&&W.socket!==void 0){const fe=W.node,Re=W.socket,_e=c[fe];if(!_e)throw new Error(`/extensions/KHR_interactivity/nodes/${g}: Could not find node with id ${fe} that connects its output with node${g}'s input ${ae}`);let Be=_e.dataOutputs.find(tt=>tt.name===Re);Be||(Be={uniqueId:v0(),name:Re,_connectionType:bx.Output,connectedPointIds:[]},_e.dataOutputs.push(Be)),ue.connectedPointIds.push(Be.uniqueId),Be.connectedPointIds.push(ue.uniqueId)}else throw new Error(`/extensions/KHR_interactivity/nodes/${g}: Invalid socket ${ae} in node ${g}`)}}const u=F.variables??[];for(let g=0;g<u.length;g++){const y=u[g],v=y.id;a._userVariables[v]=By(y,F,`/extensions/KHR_interactivity/variables/${g}`)}return{allBlocks:c,executionContexts:x}}class y3 extends Jw{constructor(a){super(a,b3)}}const b3={nodes:{__array__:{__target__:!0,translation:{type:"Vector3",get:F=>F._babylonTransformNode.position,set:(F,a)=>{const x=a._babylonTransformNode;x.position=F},getObject(F){return F._babylonTransformNode}}}}},Uy="KHR_interactivity";class E3{constructor(a){this._loader=a,this.name=Uy,this.enabled=this._loader.isExtensionUsed(Uy),this._pathConverter=new y3(this._loader.gltf)}dispose(){this._loader=null,delete this._pathConverter}onReady(){if(!this._loader.babylonScene||!this._pathConverter)return;const a=this._loader.babylonScene,x=this._loader.gltf.extensions?.KHR_interactivity,c=_3(x),u=new ld({scene:a});xd.Parse(c,{coordinator:u,pathConverter:this._pathConverter}),u.start()}}_s.RegisterExtension(Uy,F=>new E3(F));const gP="ExtrasAsMetadata";class v3{_assignExtras(a,x){if(x.extras&&Object.keys(x.extras).length>0){const c=a.metadata=a.metadata||{},u=c.gltf=c.gltf||{};u.extras=x.extras}}constructor(a){this.name=gP,this.enabled=!0,this._loader=a}dispose(){this._loader=null}loadNodeAsync(a,x,c){return this._loader.loadNodeAsync(a,x,u=>{this._assignExtras(u,x),c(u)})}loadCameraAsync(a,x,c){return this._loader.loadCameraAsync(a,x,u=>{this._assignExtras(u,x),c(u)})}createMaterial(a,x,c){const u=this._loader.createMaterial(a,x,c);return this._assignExtras(u,x),u}}_s.RegisterExtension(gP,F=>new v3(F));class R3{constructor(){this.supportCascades=!1}canLoad(a){return a.endsWith(".env")}loadCubeData(a,x,c,u,g){if(Array.isArray(a))return;const y=Ww(a);if(y){x.width=y.width,x.height=y.width;try{Yw(x,y),Xw(x,a,y).then(()=>{x.isReady=!0,x.onLoadedObservable.notifyObservers(x),x.onLoadedObservable.clear(),u&&u()},v=>{g?.("Can not upload environment levels",v)})}catch(v){g?.("Can not upload environment file",v)}}else g&&g("Can not parse the environment file",null)}loadData(){throw".env not supported in 2d."}}Bt._TextureLoaders.push(new R3);class M3 extends ID{constructor(a,x,c,u){super(a,x,c),this.url=u,this.aligner=new $D(void 0,{shouldersD:void 0}),this.shadowers=[],this.addPlugin(this.aligner);const g=new dD;this.addPlugin(g),this.patcher=new VN,this.addPlugin(this.patcher),this.occluderMaskPlugin=new jN,this.addPlugin(this.occluderMaskPlugin)}async load(){this.loaded||!this.scene||(await super.load(),this.setupLight(),await this.setupScene())}setupLight(){this.light=new Hl("DirectLightUp",new Ee(.5,-1,-1),this.scene),this.light.position.set(0,4,10),this.light.intensity=2,[this.light].forEach(x=>{if(!(x instanceof jc))return;const c=new Hs(2048,x,!0);c.useBlurCloseExponentialShadowMap=!0,c.usePercentageCloserFiltering=!0,c.blurBoxOffset=1,c.bias=.005,c.normalBias=1e-4,x.autoCalcShadowZBounds=!0,this.shadowers.push(c)});const a=new yg("PointLight",new Ee(-2,1,2),this.scene);a.intensity=20}async setupScene(){if(!this.scene)throw new Error("Scene is not initialized");const a=vo.CreateFromPrefilteredData("https://labs-custom-projects.s3.eu-central-1.amazonaws.com/assets/environments/city_blender.env",this.scene);this.scene.clearColor=new Yr(0,0,0,0),this.scene.ambientColor=new Bs(1,1,1),this.scene.imageProcessingConfiguration.contrast=1.2,this.scene.environmentTexture=a,this.scene.environmentIntensity=.8,await this.setModel(this.url)}async setModel(a){if(this.scene==null)return;if(this.outfit){const v=this.outfit;this.aligner.setNode(),this.patcher?.setParts(),this.shadowers.forEach(w=>w.removeShadowCaster(v)),this.scene?.removeMesh(v,!0),this.outfit.dispose(!1,!0)}delete this.outfit,this.aligner?.setNode(void 0);const x=await ln.LoadAssetContainerAsync(a,"",this.scene,void 0,".glb"),c=x.meshes.find(v=>v.id==="__root__");if(c==null)throw new Error("Couldn't get the root node");x.addAllToScene(),this.outfit=c;const u=this.aligner,g=c.getChildMeshes();this.patcher.setParts(g.filter(v=>v.name.toLowerCase().includes("cloth")),g.filter(v=>v.name.includes("body"))),c.getChildMeshes().forEach(v=>{v.receiveShadows=!0}),this.shadowers.forEach(v=>v.addShadowCaster(c)),this.scene.meshes.filter(v=>v.name.toLowerCase().includes("body")).forEach(v=>{v!=null&&this.scene!=null&&(v.material=this.occluderMaskPlugin.createMaterial())}),u.setNode(c)}}const Yp=new aa,B3=location.hostname==="localhost"?"OesY-n98plQwoJsS2aJEs4n6OnAT4NNE":"6w1GqK4hriTZ2Z96QsEfKLI5FvKCHOf-";let $p=new URLSearchParams(window.location.search).has("rear");async function U3(){var F="hoodie.glb";const a=document.getElementById("root");if(!a)return;const x=new M3(a,"pad",!$p,F);var c="female";const u=document.getElementById("women"),g=document.getElementById("men");u&&(console.log("Women found"),u.onclick=async()=>{c="female",console.log("Women Clicked"),y(),v([w,B,W,fe,_e,Be,tt])}),g&&(console.log("Men found"),g.onclick=async()=>{c="male",console.log("Men Clicked"),y(),v([ae,ue,Re])});function y(){const Et=[w,B,W,ae,ue,fe,Re,_e,Be,tt];for(const ft of Et)ft&&(ft.style.display="none")}function v(Et){for(const ft of Et)ft&&(ft.style.display="flex")}const w=document.getElementById("coat"),B=document.getElementById("shein"),W=document.getElementById("bomber-shein"),ae=document.getElementById("adidas-jacket"),ue=document.getElementById("adidas-hoodie"),fe=document.getElementById("bag"),Re=document.getElementById("classic-outfit"),_e=document.getElementById("hogwarts-uniform"),Be=document.getElementById("macys-outfit"),tt=document.getElementById("vest-puffer");w?(console.log("coat found"),w.onclick=async()=>{F="coat.glb",x.setModel(F),console.log("coat")}):console.log("coat not found"),B?(console.log("shein found"),B.onclick=async()=>{F="shein.glb",x.setModel(F),console.log("shein")}):console.log("shein not found"),W?(console.log("bomber_shein found"),W.onclick=async()=>{F="bomber_shein_m.glb",x.setModel(F),console.log("bomber_shein")}):console.log("bomber_shein not found"),ae?(console.log("adidas_jacket found"),ae.onclick=async()=>{F="adidas_jacket_m.glb",x.setModel(F),console.log("adidas_jacket")}):console.log("adidas_jacket not found"),ue?(console.log("adidas_hoodie found"),ue.onclick=async()=>{ue.dataset.hasSizes==="true"&&console.log("Adidas Hoodie has size"),F="adidas_hoodie_m.glb",x.setModel(F),console.log("adidas_hoodie")}):console.log("adidas_hoodie not found"),fe?(console.log("bag found"),fe.onclick=async()=>{F="bag.glb",x.setModel(F),console.log("bag")}):console.log("bag not found"),Re?(console.log("classic_outfit found"),Re.onclick=async()=>{Re.dataset.hasSizes==="true"&&console.log("Classic Outfit has size"),F="classic_outfit_M.glb",x.setModel(F),console.log("classic_outfit")}):console.log("classic_outfit not found"),_e?(console.log("hogwarts_uniform found"),_e.onclick=async()=>{F="hogwarts_uniform_girl.glb",x.setModel(F),console.log("hogwarts_uniform_girl")}):console.log("hogwarts_uniform not found"),Be?(console.log("macys_outfit found"),Be.onclick=async()=>{F="MacysOutfit_m.glb",x.setModel(F),console.log("macys_outfit")}):console.log("macys_outfit not found"),tt?(console.log("vest_puffer found"),tt.onclick=async()=>{F="Vest_Puffer_Blue.glb",x.setModel(F),console.log("vest_puffer")}):console.log("vest_puffer not found");const $e=document.getElementById("camera-switch");$e&&($e.onclick=async()=>{$e.disabled=!0,$p=!$p,await Yp.setup({size:{width:1920,height:1080},rear:$p}),await Yp.start(),x.setMirror(!$p),$e.disabled=!1,console.log("camera switched")}),await Promise.all([Yp.addRenderer(x),Yp.init({token:B3,mask:!0})]),await Yp.setup({size:{width:1920,height:1080},rear:$p}),await Yp.start(),document.getElementById("dots")?.remove()}U3()})()})();
